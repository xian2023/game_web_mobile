System.register(['./instantiated-b4706e79.js'], function (exports) {
    'use strict';
    var Pool, RecyclePool, CachedArray, assertsArrayIndex, DescriptorSet, Buffer, CommandBuffer, ObjectType, Status, API, SurfaceTransform, Feature, Format, FormatType, Type$1, BufferUsageBit, BufferFlagBit, MemoryAccessBit, MemoryUsageBit, TextureType, TextureUsageBit, TextureFlagBit, FormatFeatureBit, SampleCount, VsyncMode, Filter, Address, ComparisonFunc, StencilOp, BlendFactor, BlendOp, ColorMask, ShaderStageFlagBit, LoadOp, StoreOp, AccessFlagBit, ResolveMode, PipelineBindPoint, PrimitiveMode, PolygonMode, ShadeModel, CullMode, DynamicStateFlagBit, StencilFace, DescriptorType, QueueType, QueryType, CommandBufferType, ClearFlagBit, BarrierType, PassType, Size, DeviceCaps, DeviceOptions, Offset, Rect, Extent, TextureSubresLayers, TextureSubresRange, TextureCopy, TextureBlit, BufferTextureCopy, Viewport, Color, BindingMappingInfo, SwapchainInfo, DeviceInfo, BufferInfo, BufferViewInfo, DrawInfo, DispatchInfo, IndirectBuffer, TextureInfo, TextureViewInfo, SamplerInfo, Uniform, UniformBlock, UniformSamplerTexture, UniformSampler, UniformTexture, UniformStorageImage, UniformStorageBuffer, UniformInputAttachment, ShaderStage, Attribute, ShaderInfo, InputAssemblerInfo, ColorAttachment, DepthStencilAttachment, SubpassInfo, SubpassDependency, RenderPassInfo, GeneralBarrierInfo, TextureBarrierInfo, BufferBarrierInfo, FramebufferInfo, DescriptorSetLayoutBinding, DescriptorSetLayoutInfo, DescriptorSetInfo, PipelineLayoutInfo, InputState, CommandBufferInfo, QueueInfo, QueryPoolInfo, FormatInfo, MemoryStatus, DynamicStencilStates, DynamicStates, GFXObject, AttributeName, FormatInfos, DESCRIPTOR_BUFFER_TYPE, DESCRIPTOR_SAMPLER_TYPE, DESCRIPTOR_DYNAMIC_TYPE, DRAW_INFO_SIZE, IsPowerOf2, FormatSize, FormatSurfaceSize, GetTypeSize, getTypedArrayConstructor, formatAlignment, alignTo, Device, DefaultResource, Swapchain, Framebuffer, InputAssembler, DescriptorSetLayout, PipelineLayout, RasterizerState, DepthStencilState, BlendTarget, BlendState$1, PipelineStateInfo, PipelineState, Queue, RenderPass, Sampler, Shader, Texture, GeneralBarrier, TextureBarrier, LegacyRenderMode, RenderType, DeviceManager, deviceManager, Mat4, clamp$1, Color$1, _inheritsLoose, PixelFormat, Texture2D, legacyCC, CameraFOVAxis, CameraProjection, CameraAperture, CameraISO, CameraShutter, CameraType, TrackingType, CameraUsage, SKYBOX_FLAG, Camera$1, ModelType, Model, SubModel, Ambient, EnvironmentLightingType, Skybox, ShadowSize, ShadowType, PCFType, CSMLevel, CSMOptimizationMode, Shadows, FogType, Fog, Octree, ColorTemperatureToRGB, LightType, nt2lm, Light$1, DirectionalLight$1, SphereLight$1, SpotLight$1, ProbeClearFlag, ProbeType, ReflectionProbe$1, LODData, LODGroup$1, _createForOfIteratorHelperLoose, RenderQueue, PassStage, genHandle, getTypeFromHandle, getBindingFromHandle, getCountFromHandle, getOffsetFromHandle, customizeType, type2reader, type2writer, type2validator, getDefaultFromType, getStringFromType, overrideMacros, BatchingSchemes, Pass, flattenShaderLocation, getDeviceShaderVersion, programLib, nearestPOT, TextureBufferPool, MaterialInstance, PassInstance, PoolType, NULL_HANDLE, Render2dView, Render2dPool, NodeView, NodePool$1, PassView, PassPool, AABBView, AABBPool, RenderScene, macro, Filter$1, fastRemove, _createClass, director, System, readBuffer, Vec3, writeBuffer, Mesh, BufferBlob, find, mapBuffer, ccclass$p, errorID, ccwindow, Rect$1, Vec2, Size$1, Asset, ImageAsset, Vec4, warnID, createMap, getClassId, applyDecoratedInitializer, serializable$j, _applyDecoratedDescriptor, override$1, string, extname, type$8, warn, mixin, Pool$1, Director, assertIsTrue, getError, sys, assertID, murmurhash2_32_gc, disallowMultiple, NodeEventType, approx, EPSILON$2, AABB, executionOrder, visibleRect, Component, ccenum, Material, uiRendererManager, assert, builtinResMgr, Renderer, requireComponent, TextureBase, RenderingSubMesh, _assertThisInitialized, RenderTexture, _extends, NodeEventProcessor, deprecateModuleExportedName, Enum, Layers, TransformBit, Ray, toRadian, CAMERA_DEFAULT_MASK, Orientation, settings, Settings, screenAdapter, screen, Eventify, Triangle$1, ERaycastMode, intersect, Prefab, ModelLocalBindings, ModelRenderer, Node, CCObject, RenderPriority, clampf, addon, WrapMode$1, logID, Input, EventDispatcherPriority, input, DispatcherEventType, remove, InputEventType, removeAt, UBOLocal, downloader, factory, game, Game, MeshRenderer, CCString, CCBoolean, CCFloat, property$2, formerlySerializedAs$3, Quat, UBOSkinningAnimation, UBOSkinning, UNIFORM_REALTIME_JOINT_TEXTURE_BINDING, MorphModel, UBOSkinningTexture, UNIFORM_JOINT_TEXTURE_BINDING, INST_JOINT_ANIM_INFO, CCInteger, equals$1, ReflectionProbeManager, EditorExtendable, WrapModeMask, debug, getClassByName, getClassName, uniquelyReferenced, RealCurve, _initializerDefineProperty, _float, QuatCurve, ObjectCurve, _wrapNativeSuper, isCCObject, value, isCCClassOrFastDefined, ValueType, editorExtrasTag, assertIsNonNullable, removeIf, easing, bezierByTime, binarySearchEpsilon, lerp, EasingMethod, RealInterpolationMode, TangentWeightMode, QuatInterpolationMode, MutableForwardIterator, clamp01, contains, setClassAlias, EventTarget, systemInfo, OS, BrowserType, fastRemoveAt, log, error, _throw, debug$1, join, mainFileName, basename, dirname, changeExtname, changeBasename, _normalize, stripSep, getSeperator, buildForwardPass, buildGBufferPass, buildLightingPass, buildPostprocessPass, buildUIPass, Scheduler, CCClass, nextPow2, WECHAT_MINI_PROGRAM, EDITOR, BufferBarrier, Mat3, toDegree, constructLegacyCurveAndConvert, AnimationCurve, repeat$2, random, randomRange, randomRangeInt, sign$1, pseudoRandom, pingPong, INT_MAX, degreesToRadians, radiansToDegrees, assetManager, bt, Sphere, absMax, EBulletType, EBulletTriangleRaycastFlag, absMaxComponent, preTransforms, MobilityMode, EffectAsset, isValid, PipelineEventType, engineVersion, Event, EventHandler, contains$1, KeyCode, MINIGAME, JSB, RUNTIME_BASED, EventTouch, SystemEventType, EventGamepad, EventHandle, editorOnly, Scene;
    return {
        setters: [function (module) {
            Pool = module.P;
            RecyclePool = module.R;
            CachedArray = module.C;
            assertsArrayIndex = module.a;
            DescriptorSet = module.D;
            Buffer = module.B;
            CommandBuffer = module.b;
            ObjectType = module.O;
            Status = module.S;
            API = module.A;
            SurfaceTransform = module.c;
            Feature = module.F;
            Format = module.d;
            FormatType = module.e;
            Type$1 = module.T;
            BufferUsageBit = module.f;
            BufferFlagBit = module.g;
            MemoryAccessBit = module.M;
            MemoryUsageBit = module.h;
            TextureType = module.i;
            TextureUsageBit = module.j;
            TextureFlagBit = module.k;
            FormatFeatureBit = module.l;
            SampleCount = module.m;
            VsyncMode = module.V;
            Filter = module.n;
            Address = module.o;
            ComparisonFunc = module.p;
            StencilOp = module.q;
            BlendFactor = module.r;
            BlendOp = module.s;
            ColorMask = module.t;
            ShaderStageFlagBit = module.u;
            LoadOp = module.L;
            StoreOp = module.v;
            AccessFlagBit = module.w;
            ResolveMode = module.x;
            PipelineBindPoint = module.y;
            PrimitiveMode = module.z;
            PolygonMode = module.E;
            ShadeModel = module.G;
            CullMode = module.H;
            DynamicStateFlagBit = module.I;
            StencilFace = module.J;
            DescriptorType = module.K;
            QueueType = module.Q;
            QueryType = module.N;
            CommandBufferType = module.U;
            ClearFlagBit = module.W;
            BarrierType = module.X;
            PassType = module.Y;
            Size = module.Z;
            DeviceCaps = module._;
            DeviceOptions = module.$;
            Offset = module.a0;
            Rect = module.a1;
            Extent = module.a2;
            TextureSubresLayers = module.a3;
            TextureSubresRange = module.a4;
            TextureCopy = module.a5;
            TextureBlit = module.a6;
            BufferTextureCopy = module.a7;
            Viewport = module.a8;
            Color = module.a9;
            BindingMappingInfo = module.aa;
            SwapchainInfo = module.ab;
            DeviceInfo = module.ac;
            BufferInfo = module.ad;
            BufferViewInfo = module.ae;
            DrawInfo = module.af;
            DispatchInfo = module.ag;
            IndirectBuffer = module.ah;
            TextureInfo = module.ai;
            TextureViewInfo = module.aj;
            SamplerInfo = module.ak;
            Uniform = module.al;
            UniformBlock = module.am;
            UniformSamplerTexture = module.an;
            UniformSampler = module.ao;
            UniformTexture = module.ap;
            UniformStorageImage = module.aq;
            UniformStorageBuffer = module.ar;
            UniformInputAttachment = module.as;
            ShaderStage = module.at;
            Attribute = module.au;
            ShaderInfo = module.av;
            InputAssemblerInfo = module.aw;
            ColorAttachment = module.ax;
            DepthStencilAttachment = module.ay;
            SubpassInfo = module.az;
            SubpassDependency = module.aA;
            RenderPassInfo = module.aB;
            GeneralBarrierInfo = module.aC;
            TextureBarrierInfo = module.aD;
            BufferBarrierInfo = module.aE;
            FramebufferInfo = module.aF;
            DescriptorSetLayoutBinding = module.aG;
            DescriptorSetLayoutInfo = module.aH;
            DescriptorSetInfo = module.aI;
            PipelineLayoutInfo = module.aJ;
            InputState = module.aK;
            CommandBufferInfo = module.aL;
            QueueInfo = module.aM;
            QueryPoolInfo = module.aN;
            FormatInfo = module.aO;
            MemoryStatus = module.aP;
            DynamicStencilStates = module.aQ;
            DynamicStates = module.aR;
            GFXObject = module.aS;
            AttributeName = module.aT;
            FormatInfos = module.aU;
            DESCRIPTOR_BUFFER_TYPE = module.aV;
            DESCRIPTOR_SAMPLER_TYPE = module.aW;
            DESCRIPTOR_DYNAMIC_TYPE = module.aX;
            DRAW_INFO_SIZE = module.aY;
            IsPowerOf2 = module.aZ;
            FormatSize = module.a_;
            FormatSurfaceSize = module.a$;
            GetTypeSize = module.b0;
            getTypedArrayConstructor = module.b1;
            formatAlignment = module.b2;
            alignTo = module.b3;
            Device = module.b4;
            DefaultResource = module.b5;
            Swapchain = module.b6;
            Framebuffer = module.b7;
            InputAssembler = module.b8;
            DescriptorSetLayout = module.b9;
            PipelineLayout = module.ba;
            RasterizerState = module.bb;
            DepthStencilState = module.bc;
            BlendTarget = module.bd;
            BlendState$1 = module.be;
            PipelineStateInfo = module.bf;
            PipelineState = module.bg;
            Queue = module.bh;
            RenderPass = module.bi;
            Sampler = module.bj;
            Shader = module.bk;
            Texture = module.bl;
            GeneralBarrier = module.bm;
            TextureBarrier = module.bn;
            LegacyRenderMode = module.bo;
            RenderType = module.bp;
            DeviceManager = module.bq;
            deviceManager = module.br;
            Mat4 = module.bs;
            clamp$1 = module.bt;
            Color$1 = module.bu;
            _inheritsLoose = module.bv;
            PixelFormat = module.bw;
            Texture2D = module.bx;
            legacyCC = module.by;
            CameraFOVAxis = module.bz;
            CameraProjection = module.bA;
            CameraAperture = module.bB;
            CameraISO = module.bC;
            CameraShutter = module.bD;
            CameraType = module.bE;
            TrackingType = module.bF;
            CameraUsage = module.bG;
            SKYBOX_FLAG = module.bH;
            Camera$1 = module.bI;
            ModelType = module.bJ;
            Model = module.bK;
            SubModel = module.bL;
            Ambient = module.bM;
            EnvironmentLightingType = module.bN;
            Skybox = module.bO;
            ShadowSize = module.bP;
            ShadowType = module.bQ;
            PCFType = module.bR;
            CSMLevel = module.bS;
            CSMOptimizationMode = module.bT;
            Shadows = module.bU;
            FogType = module.bV;
            Fog = module.bW;
            Octree = module.bX;
            ColorTemperatureToRGB = module.bY;
            LightType = module.bZ;
            nt2lm = module.b_;
            Light$1 = module.b$;
            DirectionalLight$1 = module.c0;
            SphereLight$1 = module.c1;
            SpotLight$1 = module.c2;
            ProbeClearFlag = module.c3;
            ProbeType = module.c4;
            ReflectionProbe$1 = module.c5;
            LODData = module.c6;
            LODGroup$1 = module.c7;
            _createForOfIteratorHelperLoose = module.c8;
            RenderQueue = module.c9;
            PassStage = module.ca;
            genHandle = module.cb;
            getTypeFromHandle = module.cc;
            getBindingFromHandle = module.cd;
            getCountFromHandle = module.ce;
            getOffsetFromHandle = module.cf;
            customizeType = module.cg;
            type2reader = module.ch;
            type2writer = module.ci;
            type2validator = module.cj;
            getDefaultFromType = module.ck;
            getStringFromType = module.cl;
            overrideMacros = module.cm;
            BatchingSchemes = module.cn;
            Pass = module.co;
            flattenShaderLocation = module.cp;
            getDeviceShaderVersion = module.cq;
            programLib = module.cr;
            nearestPOT = module.cs;
            TextureBufferPool = module.ct;
            MaterialInstance = module.cu;
            PassInstance = module.cv;
            PoolType = module.cw;
            NULL_HANDLE = module.cx;
            Render2dView = module.cy;
            Render2dPool = module.cz;
            NodeView = module.cA;
            NodePool$1 = module.cB;
            PassView = module.cC;
            PassPool = module.cD;
            AABBView = module.cE;
            AABBPool = module.cF;
            RenderScene = module.cG;
            macro = module.cH;
            Filter$1 = module.cI;
            fastRemove = module.cJ;
            _createClass = module.cK;
            director = module.cL;
            System = module.cM;
            readBuffer = module.cN;
            Vec3 = module.cO;
            writeBuffer = module.cP;
            Mesh = module.cQ;
            BufferBlob = module.cR;
            find = module.cS;
            mapBuffer = module.cT;
            ccclass$p = module.cU;
            errorID = module.cV;
            ccwindow = module.cW;
            Rect$1 = module.cX;
            Vec2 = module.cY;
            Size$1 = module.cZ;
            Asset = module.c_;
            ImageAsset = module.c$;
            Vec4 = module.d0;
            warnID = module.d1;
            createMap = module.d2;
            getClassId = module.d3;
            applyDecoratedInitializer = module.d4;
            serializable$j = module.d5;
            _applyDecoratedDescriptor = module.d6;
            override$1 = module.d7;
            string = module.d8;
            extname = module.d9;
            type$8 = module.da;
            warn = module.db;
            mixin = module.dc;
            Pool$1 = module.dd;
            Director = module.de;
            assertIsTrue = module.df;
            getError = module.dg;
            sys = module.dh;
            assertID = module.di;
            murmurhash2_32_gc = module.dj;
            disallowMultiple = module.dk;
            NodeEventType = module.dl;
            approx = module.dm;
            EPSILON$2 = module.dn;
            AABB = module.dp;
            executionOrder = module.dq;
            visibleRect = module.dr;
            Component = module.ds;
            ccenum = module.dt;
            Material = module.du;
            uiRendererManager = module.dv;
            assert = module.dw;
            builtinResMgr = module.dx;
            Renderer = module.dy;
            requireComponent = module.dz;
            TextureBase = module.dA;
            RenderingSubMesh = module.dB;
            _assertThisInitialized = module.dC;
            RenderTexture = module.dD;
            _extends = module.dE;
            NodeEventProcessor = module.dF;
            deprecateModuleExportedName = module.dG;
            Enum = module.dH;
            Layers = module.dI;
            TransformBit = module.dJ;
            Ray = module.dK;
            toRadian = module.dL;
            CAMERA_DEFAULT_MASK = module.dM;
            Orientation = module.dN;
            settings = module.dO;
            Settings = module.dP;
            screenAdapter = module.dQ;
            screen = module.dR;
            Eventify = module.dS;
            Triangle$1 = module.dT;
            ERaycastMode = module.dU;
            intersect = module.dV;
            Prefab = module.dW;
            ModelLocalBindings = module.dX;
            ModelRenderer = module.dY;
            Node = module.dZ;
            CCObject = module.d_;
            RenderPriority = module.d$;
            clampf = module.e0;
            addon = module.e1;
            WrapMode$1 = module.e2;
            logID = module.e3;
            Input = module.e4;
            EventDispatcherPriority = module.e5;
            input = module.e6;
            DispatcherEventType = module.e7;
            remove = module.e8;
            InputEventType = module.e9;
            removeAt = module.ea;
            UBOLocal = module.eb;
            downloader = module.ec;
            factory = module.ed;
            game = module.ee;
            Game = module.ef;
            MeshRenderer = module.eg;
            CCString = module.eh;
            CCBoolean = module.ei;
            CCFloat = module.ej;
            property$2 = module.ek;
            formerlySerializedAs$3 = module.el;
            Quat = module.em;
            UBOSkinningAnimation = module.en;
            UBOSkinning = module.eo;
            UNIFORM_REALTIME_JOINT_TEXTURE_BINDING = module.ep;
            MorphModel = module.eq;
            UBOSkinningTexture = module.er;
            UNIFORM_JOINT_TEXTURE_BINDING = module.es;
            INST_JOINT_ANIM_INFO = module.et;
            CCInteger = module.eu;
            equals$1 = module.ev;
            ReflectionProbeManager = module.ew;
            EditorExtendable = module.ex;
            WrapModeMask = module.ey;
            debug = module.ez;
            getClassByName = module.eA;
            getClassName = module.eB;
            uniquelyReferenced = module.eC;
            RealCurve = module.eD;
            _initializerDefineProperty = module.eE;
            _float = module.eF;
            QuatCurve = module.eG;
            ObjectCurve = module.eH;
            _wrapNativeSuper = module.eI;
            isCCObject = module.eJ;
            value = module.eK;
            isCCClassOrFastDefined = module.eL;
            ValueType = module.eM;
            editorExtrasTag = module.eN;
            assertIsNonNullable = module.eO;
            removeIf = module.eP;
            easing = module.eQ;
            bezierByTime = module.eR;
            binarySearchEpsilon = module.eS;
            lerp = module.eT;
            EasingMethod = module.eU;
            RealInterpolationMode = module.eV;
            TangentWeightMode = module.eW;
            QuatInterpolationMode = module.eX;
            MutableForwardIterator = module.eY;
            clamp01 = module.eZ;
            contains = module.e_;
            setClassAlias = module.e$;
            EventTarget = module.f0;
            systemInfo = module.f1;
            OS = module.f2;
            BrowserType = module.f3;
            fastRemoveAt = module.f4;
            log = module.f5;
            error = module.f6;
            _throw = module.f7;
            debug$1 = module.f8;
            join = module.f9;
            mainFileName = module.fa;
            basename = module.fb;
            dirname = module.fc;
            changeExtname = module.fd;
            changeBasename = module.fe;
            _normalize = module.ff;
            stripSep = module.fg;
            getSeperator = module.fh;
            buildForwardPass = module.fi;
            buildGBufferPass = module.fj;
            buildLightingPass = module.fk;
            buildPostprocessPass = module.fl;
            buildUIPass = module.fm;
            Scheduler = module.fn;
            CCClass = module.fo;
            nextPow2 = module.fp;
            WECHAT_MINI_PROGRAM = module.fq;
            EDITOR = module.fr;
            BufferBarrier = module.fs;
            Mat3 = module.ft;
            toDegree = module.fu;
            constructLegacyCurveAndConvert = module.fv;
            AnimationCurve = module.fw;
            repeat$2 = module.fx;
            random = module.fy;
            randomRange = module.fz;
            randomRangeInt = module.fA;
            sign$1 = module.fB;
            pseudoRandom = module.fC;
            pingPong = module.fD;
            INT_MAX = module.fE;
            degreesToRadians = module.fF;
            radiansToDegrees = module.fG;
            assetManager = module.fH;
            bt = module.fI;
            Sphere = module.fJ;
            absMax = module.fK;
            EBulletType = module.fL;
            EBulletTriangleRaycastFlag = module.fM;
            absMaxComponent = module.fN;
            preTransforms = module.fO;
            MobilityMode = module.fP;
            EffectAsset = module.fQ;
            isValid = module.fR;
            PipelineEventType = module.fS;
            engineVersion = module.fT;
            Event = module.fU;
            EventHandler = module.fV;
            contains$1 = module.fW;
            KeyCode = module.fX;
            MINIGAME = module.fY;
            JSB = module.fZ;
            RUNTIME_BASED = module.f_;
            EventTouch = module.f$;
            SystemEventType = module.g0;
            EventGamepad = module.g1;
            EventHandle = module.g2;
            editorOnly = module.g3;
            Scene = module.g4;
            var _setter = {};
            _setter.Acceleration = module.hY;
            _setter.AffineTransform = module.gf;
            _setter.AmbientInfo = module.hw;
            _setter.Asset = module.c_;
            _setter.AssetManager = module.hR;
            _setter.AsyncDelegate = module.gJ;
            _setter.BITMASK_TAG = module.h0;
            _setter.BaseNode = module.dZ;
            _setter.BitMask = module.gr;
            _setter.BloomStage = module.hj;
            _setter.BufferAsset = module.hJ;
            _setter.CCBoolean = module.ei;
            _setter.CCClass = module.fo;
            _setter.CCFloat = module.ej;
            _setter.CCInteger = module.eu;
            _setter.CCObject = module.d_;
            _setter.CCString = module.eh;
            _setter.CachedArray = module.C;
            _setter.CallbacksInvoker = module.h1;
            _setter.Color = module.bu;
            _setter.CompactValueTypeArray = module.gF;
            _setter.Component = module.ds;
            _setter.DEFAULT_OCTREE_DEPTH = module.hC;
            _setter.DEFAULT_WORLD_MAX_POS = module.hB;
            _setter.DEFAULT_WORLD_MIN_POS = module.hA;
            _setter.DebugMode = module.gM;
            _setter.DebugView = module.hq;
            _setter.DeferredPipeline = module.hf;
            _setter.Details = module.hI;
            _setter.Director = module.de;
            _setter.ENUM_TAG = module.g$;
            _setter.EPSILON = module.dn;
            _setter.EasingMethod = module.eU;
            _setter.EditorExtendable = module.ex;
            _setter.EffectAsset = module.fQ;
            _setter.Enum = module.dH;
            _setter.Event = module.fU;
            _setter.EventAcceleration = module.hT;
            _setter.EventGamepad = module.g1;
            _setter.EventHMD = module.hW;
            _setter.EventHandheld = module.hX;
            _setter.EventHandle = module.g2;
            _setter.EventHandler = module.fV;
            _setter.EventKeyboard = module.hU;
            _setter.EventMouse = module.hV;
            _setter.EventTarget = module.f0;
            _setter.EventTouch = module.f$;
            _setter.Eventify = module.dS;
            _setter.ExtrapolationMode = module.gN;
            _setter.FogInfo = module.hy;
            _setter.ForwardFlow = module.hd;
            _setter.ForwardPipeline = module.hc;
            _setter.ForwardStage = module.he;
            _setter.GCObject = module.g_;
            _setter.Game = module.ef;
            _setter.GbufferStage = module.hh;
            _setter.HALF_PI = module.gj;
            _setter.ImageAsset = module.c$;
            _setter.Input = module.e4;
            _setter.InstancedBuffer = module.hn;
            _setter.JavaScript = module.hP;
            _setter.JsonAsset = module.hM;
            _setter.KeyCode = module.fX;
            _setter.Layers = module.dI;
            _setter.LightProbeInfo = module.hE;
            _setter.LightingStage = module.hi;
            _setter.MATH_FLOAT_ARRAY = module.gp;
            _setter.MainFlow = module.hg;
            _setter.Mat3 = module.ft;
            _setter.Mat4 = module.bs;
            _setter.Material = module.du;
            _setter.MathBase = module.gq;
            _setter.Mesh = module.cQ;
            _setter.MeshRenderer = module.eg;
            _setter.MissingScript = module.hG;
            _setter.MobilityMode = module.fP;
            _setter.ModelRenderer = module.dY;
            _setter.Node = module.dZ;
            _setter.NodeActivator = module.hu;
            _setter.NodeEventType = module.dl;
            _setter.NodeSpace = module.hv;
            _setter.ObjectCurve = module.eH;
            _setter.OctreeInfo = module.hD;
            _setter.PipelineEventProcessor = module.hp;
            _setter.PipelineEventType = module.fS;
            _setter.PipelineSceneData = module.hb;
            _setter.PipelineStateManager = module.ho;
            _setter.Pool = module.P;
            _setter.PostProcessStage = module.hk;
            _setter.Prefab = module.dW;
            _setter.Quat = module.em;
            _setter.QuatCurve = module.eG;
            _setter.QuatInterpolationMode = module.eX;
            _setter.RealCurve = module.eD;
            _setter.RealInterpolationMode = module.eV;
            _setter.Rect = module.cX;
            _setter.RecyclePool = module.R;
            _setter.ReflectionProbeFlow = module.hr;
            _setter.ReflectionProbeManager = module.ew;
            _setter.ReflectionProbeStage = module.hs;
            _setter.ReflectionProbeType = module.g5;
            _setter.RenderFlow = module.h9;
            _setter.RenderPipeline = module.h8;
            _setter.RenderStage = module.ha;
            _setter.RenderTexture = module.dD;
            _setter.Renderer = module.dy;
            _setter.RenderingSubMesh = module.dB;
            _setter.Root = module.g6;
            _setter.Scene = module.g4;
            _setter.SceneAsset = module.hK;
            _setter.SceneGlobals = module.hF;
            _setter.Scheduler = module.fn;
            _setter.Script = module.hO;
            _setter.Settings = module.dP;
            _setter.ShadowFlow = module.hl;
            _setter.ShadowStage = module.hm;
            _setter.ShadowsInfo = module.hz;
            _setter.Size = module.cZ;
            _setter.SkyboxInfo = module.hx;
            _setter.System = module.cM;
            _setter.SystemEvent = module.h$;
            _setter.SystemEventType = module.g0;
            _setter.TWO_PI = module.gk;
            _setter.TangentWeightMode = module.eW;
            _setter.TextAsset = module.hL;
            _setter.Texture2D = module.bx;
            _setter.TextureCube = module.hN;
            _setter.Touch = module.hZ;
            _setter.TransformBit = module.dJ;
            _setter.TypeScript = module.hQ;
            _setter.VERSION = module.fT;
            _setter.ValueType = module.eM;
            _setter.Vec2 = module.cY;
            _setter.Vec3 = module.cO;
            _setter.Vec4 = module.d0;
            _setter.WorldNode3DToLocalNodeUI = module.gB;
            _setter.WorldNode3DToWorldNodeUI = module.gC;
            _setter.__checkObsoleteInNamespace__ = module.gA;
            _setter.__checkObsolete__ = module.gz;
            _setter._decorator = module.gE;
            _setter._resetDebugSetting = module.h2;
            _setter.absMax = module.fK;
            _setter.absMaxComponent = module.fN;
            _setter.approx = module.dm;
            _setter.assert = module.dw;
            _setter.assertID = module.di;
            _setter.assertIsNonNullable = module.eO;
            _setter.assertIsTrue = module.df;
            _setter.assertsArrayIndex = module.a;
            _setter.assetManager = module.fH;
            _setter.bezier = module.gO;
            _setter.bezierByTime = module.eR;
            _setter.binarySearch = module.h3;
            _setter.binarySearchBy = module.h4;
            _setter.binarySearchEpsilon = module.eS;
            _setter.bits = module.g9;
            _setter.builtinResMgr = module.dx;
            _setter.ccenum = module.dt;
            _setter.cclegacy = module.by;
            _setter.clamp = module.bt;
            _setter.clamp01 = module.eZ;
            _setter.color = module.gi;
            _setter.convertUtils = module.gD;
            _setter.createDefaultPipeline = module.h7;
            _setter.debug = module.ez;
            _setter.deprecateModuleExportedName = module.dG;
            _setter.deserialize = module.hH;
            _setter.deserializeTag = module.gG;
            _setter.director = module.cL;
            _setter.disallowAnimation = module.gY;
            _setter.displayName = module.gT;
            _setter.displayOrder = module.gU;
            _setter.easing = module.eQ;
            _setter.editable = module.gQ;
            _setter.editorExtrasTag = module.eN;
            _setter.enumerableProps = module.go;
            _setter.equals = module.ev;
            _setter.error = module.f6;
            _setter.errorID = module.cV;
            _setter.find = module.cS;
            _setter.flattenCodeArray = module.h5;
            _setter.formerlySerializedAs = module.el;
            _setter.game = module.ee;
            _setter.garbageCollectionManager = module.gZ;
            _setter.geometry = module.g8;
            _setter.getError = module.dg;
            _setter.getPhaseID = module.ht;
            _setter.getSerializationMetadata = module.gI;
            _setter.input = module.e6;
            _setter.inverseLerp = module.gn;
            _setter.isCCClassOrFastDefined = module.eL;
            _setter.isCCObject = module.eJ;
            _setter.isDisplayStats = module.gK;
            _setter.isValid = module.fR;
            _setter.js = module.gs;
            _setter.jsbUtils = module.gP;
            _setter.lerp = module.eT;
            _setter.log = module.f5;
            _setter.logID = module.e3;
            _setter.macro = module.cH;
            _setter.markAsWarning = module.gy;
            _setter.mat4 = module.ge;
            _setter.math = module.g7;
            _setter.misc = module.gt;
            _setter.murmurhash2_32_gc = module.dj;
            _setter.nextPow2 = module.fp;
            _setter.override = module.d7;
            _setter.path = module.gu;
            _setter.pingPong = module.fD;
            _setter.pipeline = module.h6;
            _setter.preTransforms = module.fO;
            _setter.pseudoRandom = module.fC;
            _setter.pseudoRandomRange = module.gl;
            _setter.pseudoRandomRangeInt = module.gm;
            _setter.quat = module.gd;
            _setter.random = module.fy;
            _setter.randomRange = module.fz;
            _setter.randomRangeInt = module.fA;
            _setter.range = module.gV;
            _setter.rangeStep = module.gW;
            _setter.rect = module.gh;
            _setter.removeProperty = module.gx;
            _setter.repeat = module.fx;
            _setter.replaceProperty = module.gw;
            _setter.resources = module.hS;
            _setter.screen = module.dR;
            _setter.serializable = module.d5;
            _setter.serializeTag = module.gH;
            _setter.setDefaultLogTimes = module.gv;
            _setter.setDisplayStats = module.gL;
            _setter.settings = module.dO;
            _setter.size = module.gg;
            _setter.slide = module.gX;
            _setter.sys = module.dh;
            _setter.systemEvent = module.h_;
            _setter.toDegree = module.fu;
            _setter.toRadian = module.dL;
            _setter.tooltip = module.gR;
            _setter.v2 = module.ga;
            _setter.v3 = module.gb;
            _setter.v4 = module.gc;
            _setter.visible = module.gS;
            _setter.visibleRect = module.dr;
            _setter.warn = module.db;
            _setter.warnID = module.d1;
            exports(_setter);
        }],
        execute: function () {

            exports({
                CacheMode: void 0,
                EAxisDirection: void 0,
                ERigidBodyType: void 0,
                HorizontalTextAlignment: void 0,
                InstanceMaterialType: void 0,
                Overflow: void 0,
                VerticalTextAlignment: void 0,
                applyMixins: applyMixins,
                computeRatioByType: computeRatioByType,
                fragmentText: fragmentText,
                getBaselineOffset: getBaselineOffset,
                getEnglishWordPartAtFirst: getEnglishWordPartAtFirst,
                getEnglishWordPartAtLast: getEnglishWordPartAtLast,
                getPathFromRoot: getPathFromRoot,
                getWorldTransformUntilRoot: getWorldTransformUntilRoot,
                instantiate: instantiate,
                isEnglishWordPartAtFirst: isEnglishWordPartAtFirst,
                isEnglishWordPartAtLast: isEnglishWordPartAtLast,
                isUnicodeCJK: isUnicodeCJK,
                isUnicodeSpace: isUnicodeSpace,
                safeMeasureText: safeMeasureText,
                sampleAnimationCurve: sampleAnimationCurve,
                shift: shift,
                tween: tween,
                tweenUtil: tweenUtil
            });

            var index = /*#__PURE__*/Object.freeze({
                __proto__: null,
                Pool: Pool,
                RecyclePool: RecyclePool,
                CachedArray: CachedArray
            });
            exports('memop', index);

            function shift(array, first, last) {
              assertsArrayIndex(array, first);
              assertsArrayIndex(array, last);

              if (first === last) {
                return array;
              }

              var element = array[first];

              if (first < last) {
                for (var iElement = first + 1; iElement <= last; ++iElement) {
                  array[iElement - 1] = array[iElement];
                }
              } else {
                for (var _iElement = first; _iElement !== last; --_iElement) {
                  array[_iElement] = array[_iElement - 1];
                }
              }

              array[last] = element;
              return array;
            }

            function applyMixins(derivedCtor, baseCtors) {
              baseCtors.forEach(function (baseCtor) {
                Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
                  if (name !== 'constructor') {
                    Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
                  }
                });
              });
            }

            var index$1 = /*#__PURE__*/Object.freeze({
                __proto__: null,
                DescriptorSet: DescriptorSet,
                Buffer: Buffer,
                CommandBuffer: CommandBuffer,
                get ObjectType () { return ObjectType; },
                get Status () { return Status; },
                get API () { return API; },
                get SurfaceTransform () { return SurfaceTransform; },
                get Feature () { return Feature; },
                get Format () { return Format; },
                get FormatType () { return FormatType; },
                get Type () { return Type$1; },
                get BufferUsageBit () { return BufferUsageBit; },
                get BufferFlagBit () { return BufferFlagBit; },
                get MemoryAccessBit () { return MemoryAccessBit; },
                get MemoryUsageBit () { return MemoryUsageBit; },
                get TextureType () { return TextureType; },
                get TextureUsageBit () { return TextureUsageBit; },
                get TextureFlagBit () { return TextureFlagBit; },
                get FormatFeatureBit () { return FormatFeatureBit; },
                get SampleCount () { return SampleCount; },
                get VsyncMode () { return VsyncMode; },
                get Filter () { return Filter; },
                get Address () { return Address; },
                get ComparisonFunc () { return ComparisonFunc; },
                get StencilOp () { return StencilOp; },
                get BlendFactor () { return BlendFactor; },
                get BlendOp () { return BlendOp; },
                get ColorMask () { return ColorMask; },
                get ShaderStageFlagBit () { return ShaderStageFlagBit; },
                get LoadOp () { return LoadOp; },
                get StoreOp () { return StoreOp; },
                get AccessFlagBit () { return AccessFlagBit; },
                get ResolveMode () { return ResolveMode; },
                get PipelineBindPoint () { return PipelineBindPoint; },
                get PrimitiveMode () { return PrimitiveMode; },
                get PolygonMode () { return PolygonMode; },
                get ShadeModel () { return ShadeModel; },
                get CullMode () { return CullMode; },
                get DynamicStateFlagBit () { return DynamicStateFlagBit; },
                get StencilFace () { return StencilFace; },
                get DescriptorType () { return DescriptorType; },
                get QueueType () { return QueueType; },
                get QueryType () { return QueryType; },
                get CommandBufferType () { return CommandBufferType; },
                get ClearFlagBit () { return ClearFlagBit; },
                get BarrierType () { return BarrierType; },
                get PassType () { return PassType; },
                Size: Size,
                DeviceCaps: DeviceCaps,
                DeviceOptions: DeviceOptions,
                Offset: Offset,
                Rect: Rect,
                Extent: Extent,
                TextureSubresLayers: TextureSubresLayers,
                TextureSubresRange: TextureSubresRange,
                TextureCopy: TextureCopy,
                TextureBlit: TextureBlit,
                BufferTextureCopy: BufferTextureCopy,
                Viewport: Viewport,
                Color: Color,
                BindingMappingInfo: BindingMappingInfo,
                SwapchainInfo: SwapchainInfo,
                DeviceInfo: DeviceInfo,
                BufferInfo: BufferInfo,
                BufferViewInfo: BufferViewInfo,
                DrawInfo: DrawInfo,
                DispatchInfo: DispatchInfo,
                IndirectBuffer: IndirectBuffer,
                TextureInfo: TextureInfo,
                TextureViewInfo: TextureViewInfo,
                SamplerInfo: SamplerInfo,
                Uniform: Uniform,
                UniformBlock: UniformBlock,
                UniformSamplerTexture: UniformSamplerTexture,
                UniformSampler: UniformSampler,
                UniformTexture: UniformTexture,
                UniformStorageImage: UniformStorageImage,
                UniformStorageBuffer: UniformStorageBuffer,
                UniformInputAttachment: UniformInputAttachment,
                ShaderStage: ShaderStage,
                Attribute: Attribute,
                ShaderInfo: ShaderInfo,
                InputAssemblerInfo: InputAssemblerInfo,
                ColorAttachment: ColorAttachment,
                DepthStencilAttachment: DepthStencilAttachment,
                SubpassInfo: SubpassInfo,
                SubpassDependency: SubpassDependency,
                RenderPassInfo: RenderPassInfo,
                GeneralBarrierInfo: GeneralBarrierInfo,
                TextureBarrierInfo: TextureBarrierInfo,
                BufferBarrierInfo: BufferBarrierInfo,
                FramebufferInfo: FramebufferInfo,
                DescriptorSetLayoutBinding: DescriptorSetLayoutBinding,
                DescriptorSetLayoutInfo: DescriptorSetLayoutInfo,
                DescriptorSetInfo: DescriptorSetInfo,
                PipelineLayoutInfo: PipelineLayoutInfo,
                InputState: InputState,
                CommandBufferInfo: CommandBufferInfo,
                QueueInfo: QueueInfo,
                QueryPoolInfo: QueryPoolInfo,
                FormatInfo: FormatInfo,
                MemoryStatus: MemoryStatus,
                DynamicStencilStates: DynamicStencilStates,
                DynamicStates: DynamicStates,
                GFXObject: GFXObject,
                get AttributeName () { return AttributeName; },
                FormatInfos: FormatInfos,
                DESCRIPTOR_BUFFER_TYPE: DESCRIPTOR_BUFFER_TYPE,
                DESCRIPTOR_SAMPLER_TYPE: DESCRIPTOR_SAMPLER_TYPE,
                DESCRIPTOR_DYNAMIC_TYPE: DESCRIPTOR_DYNAMIC_TYPE,
                DRAW_INFO_SIZE: DRAW_INFO_SIZE,
                IsPowerOf2: IsPowerOf2,
                FormatSize: FormatSize,
                FormatSurfaceSize: FormatSurfaceSize,
                GetTypeSize: GetTypeSize,
                getTypedArrayConstructor: getTypedArrayConstructor,
                formatAlignment: formatAlignment,
                alignTo: alignTo,
                Device: Device,
                DefaultResource: DefaultResource,
                Swapchain: Swapchain,
                Framebuffer: Framebuffer,
                InputAssembler: InputAssembler,
                DescriptorSetLayout: DescriptorSetLayout,
                PipelineLayout: PipelineLayout,
                RasterizerState: RasterizerState,
                DepthStencilState: DepthStencilState,
                BlendTarget: BlendTarget,
                BlendState: BlendState$1,
                PipelineStateInfo: PipelineStateInfo,
                PipelineState: PipelineState,
                Queue: Queue,
                RenderPass: RenderPass,
                Sampler: Sampler,
                Shader: Shader,
                Texture: Texture,
                GeneralBarrier: GeneralBarrier,
                TextureBarrier: TextureBarrier,
                get LegacyRenderMode () { return LegacyRenderMode; },
                get RenderType () { return RenderType; },
                DeviceManager: DeviceManager,
                deviceManager: deviceManager
            });
            exports('gfx', index$1);

            var m = new Mat4();
            function fillMeshVertices3D(node, renderer, renderData, color) {
              var chunk = renderData.chunk;
              var dataList = renderData.data;
              var vData = chunk.vb;
              var vertexCount = renderData.vertexCount;
              node.getWorldMatrix(m);
              var vertexOffset = 0;

              for (var i = 0; i < vertexCount; i++) {
                var vert = dataList[i];
                var x = vert.x;
                var y = vert.y;
                var rhw = m.m03 * x + m.m07 * y + m.m15;
                rhw = rhw ? Math.abs(1 / rhw) : 1;
                vData[vertexOffset + 0] = (m.m00 * x + m.m04 * y + m.m12) * rhw;
                vData[vertexOffset + 1] = (m.m01 * x + m.m05 * y + m.m13) * rhw;
                vData[vertexOffset + 2] = (m.m02 * x + m.m06 * y + m.m14) * rhw;
                Color$1.toArray(vData, color, vertexOffset + 5);
                vertexOffset += 9;
              }

              var bid = chunk.bufferId;
              var vid = chunk.vertexOffset;
              var meshBuffer = chunk.meshBuffer;
              var ib = chunk.meshBuffer.iData;
              var indexOffset = meshBuffer.indexOffset;

              for (var _i = 0, count = vertexCount / 4; _i < count; _i++) {
                var start = vid + _i * 4;
                ib[indexOffset++] = start;
                ib[indexOffset++] = start + 1;
                ib[indexOffset++] = start + 2;
                ib[indexOffset++] = start + 1;
                ib[indexOffset++] = start + 3;
                ib[indexOffset++] = start + 2;
              }

              meshBuffer.indexOffset += renderData.indexCount;
              meshBuffer.setDirty();
            }
            function updateOpacity(renderData, opacity) {
              var vfmt = renderData.vertexFormat;
              var vb = renderData.chunk.vb;
              var attr;
              var format;
              var stride;
              var offset = 0;

              for (var i = 0; i < vfmt.length; ++i) {
                attr = vfmt[i];
                format = FormatInfos[attr.format];

                if (format.hasAlpha) {
                  stride = renderData.floatStride;

                  if (format.size / format.count === 1) {
                    var alpha = ~~clamp$1(Math.round(opacity * 255), 0, 255);

                    for (var color = offset; color < vb.length; color += stride) {
                      vb[color] = (vb[color] & 0xffffff00 | alpha) >>> 0;
                    }
                  } else if (format.size / format.count === 4) {
                    for (var _alpha = offset + 3; _alpha < vb.length; _alpha += stride) {
                      vb[_alpha] = opacity;
                    }
                  }
                }

                offset += format.size >> 2;
              }
            }

            var minigame = {};

            var space = 2;
            var Atlas = function () {
              function Atlas(width, height) {
                this._texture = void 0;
                this._width = void 0;
                this._height = void 0;
                this._x = void 0;
                this._y = void 0;
                this._nexty = void 0;
                this._innerTextureInfos = {};
                this._innerSpriteFrames = void 0;
                this._count = void 0;
                var texture = new DynamicAtlasTexture();
                texture.initWithSize(width, height);
                this._texture = texture;
                this._width = width;
                this._height = height;
                this._x = space;
                this._y = space;
                this._nexty = space;
                this._innerTextureInfos = {};
                this._innerSpriteFrames = [];
                this._count = 0;
              }

              var _proto = Atlas.prototype;

              _proto.insertSpriteFrame = function insertSpriteFrame(spriteFrame) {
                var rect = spriteFrame.rect;
                var texture = spriteFrame.texture;

                var info = this._innerTextureInfos[texture.getId()];

                var sx = rect.x;
                var sy = rect.y;

                if (info) {
                  sx += info.x;
                  sy += info.y;
                } else {
                  var width = texture.width;
                  var height = texture.height;

                  if (this._x + width + space > this._width) {
                    this._x = space;
                    this._y = this._nexty;
                  }

                  if (this._y + height + space > this._nexty) {
                    this._nexty = this._y + height + space;
                  }

                  if (this._nexty > this._height) {
                    return null;
                  }

                  if (legacyCC.internal.dynamicAtlasManager.textureBleeding) {
                    if (width <= 8 || height <= 8) {
                      this._texture.drawTextureAt(texture.image, this._x - 1, this._y - 1);

                      this._texture.drawTextureAt(texture.image, this._x - 1, this._y + 1);

                      this._texture.drawTextureAt(texture.image, this._x + 1, this._y - 1);

                      this._texture.drawTextureAt(texture.image, this._x + 1, this._y + 1);
                    }

                    this._texture.drawTextureAt(texture.image, this._x - 1, this._y);

                    this._texture.drawTextureAt(texture.image, this._x + 1, this._y);

                    this._texture.drawTextureAt(texture.image, this._x, this._y - 1);

                    this._texture.drawTextureAt(texture.image, this._x, this._y + 1);
                  }

                  this._texture.drawTextureAt(texture.image, this._x, this._y);

                  this._innerTextureInfos[texture.getId()] = {
                    x: this._x,
                    y: this._y,
                    texture: texture
                  };
                  this._count++;
                  sx += this._x;
                  sy += this._y;
                  this._x += width + space;
                }

                var frame = {
                  x: sx,
                  y: sy,
                  texture: this._texture
                };

                this._innerSpriteFrames.push(spriteFrame);

                return frame;
              };

              _proto.deleteInnerTexture = function deleteInnerTexture(texture) {
                if (texture && this._innerTextureInfos[texture.getId()]) {
                  delete this._innerTextureInfos[texture.getId()];
                  this._count--;
                }
              };

              _proto.isEmpty = function isEmpty() {
                return this._count <= 0;
              };

              _proto.reset = function reset() {
                this._x = space;
                this._y = space;
                this._nexty = space;
                var frames = this._innerSpriteFrames;

                for (var i = 0, l = frames.length; i < l; i++) {
                  var frame = frames[i];

                  if (!frame.isValid) {
                    continue;
                  }

                  frame._resetDynamicAtlasFrame();
                }

                this._innerSpriteFrames.length = 0;
                this._innerTextureInfos = {};
              };

              _proto.destroy = function destroy() {
                this.reset();

                this._texture.destroy();
              };

              return Atlas;
            }();
            var DynamicAtlasTexture = function (_Texture2D) {
              _inheritsLoose(DynamicAtlasTexture, _Texture2D);

              function DynamicAtlasTexture() {
                return _Texture2D.apply(this, arguments) || this;
              }

              var _proto2 = DynamicAtlasTexture.prototype;

              _proto2.initWithSize = function initWithSize(width, height, format) {
                if (format === void 0) {
                  format = PixelFormat.RGBA8888;
                }

                this.reset({
                  width: width,
                  height: height,
                  format: format
                });
              };

              _proto2.drawTextureAt = function drawTextureAt(image, x, y) {
                var gfxTexture = this.getGFXTexture();

                if (!image || !gfxTexture) {
                  return;
                }

                var gfxDevice = this._getGFXDevice();

                if (!gfxDevice) {
                  console.warn('Unable to get device');
                  return;
                }

                var region = new BufferTextureCopy();
                region.texOffset.x = x;
                region.texOffset.y = y;
                region.texExtent.width = image.width;
                region.texExtent.height = image.height;
                gfxDevice.copyTexImagesToTexture([image.data], gfxTexture, [region]);
              };

              return DynamicAtlasTexture;
            }(Texture2D);

            var index$2 = /*#__PURE__*/Object.freeze({
                __proto__: null,
                get CameraFOVAxis () { return CameraFOVAxis; },
                get CameraProjection () { return CameraProjection; },
                get CameraAperture () { return CameraAperture; },
                get CameraISO () { return CameraISO; },
                get CameraShutter () { return CameraShutter; },
                get CameraType () { return CameraType; },
                get TrackingType () { return TrackingType; },
                get CameraUsage () { return CameraUsage; },
                SKYBOX_FLAG: SKYBOX_FLAG,
                Camera: Camera$1,
                get ModelType () { return ModelType; },
                Model: Model,
                SubModel: SubModel,
                Ambient: Ambient,
                EnvironmentLightingType: EnvironmentLightingType,
                Skybox: Skybox,
                ShadowSize: ShadowSize,
                ShadowType: ShadowType,
                PCFType: PCFType,
                CSMLevel: CSMLevel,
                CSMOptimizationMode: CSMOptimizationMode,
                Shadows: Shadows,
                FogType: FogType,
                Fog: Fog,
                Octree: Octree,
                ColorTemperatureToRGB: ColorTemperatureToRGB,
                get LightType () { return LightType; },
                nt2lm: nt2lm,
                Light: Light$1,
                DirectionalLight: DirectionalLight$1,
                SphereLight: SphereLight$1,
                SpotLight: SpotLight$1,
                get ProbeClearFlag () { return ProbeClearFlag; },
                get ProbeType () { return ProbeType; },
                ReflectionProbe: ReflectionProbe$1,
                LODData: LODData,
                LODGroup: LODGroup$1
            });

            var _stageOffset = 0;
            var _name2stageID = {};
            var config = {
              addStage: function addStage(name) {
                if (_name2stageID[name] !== undefined) {
                  return;
                }

                var stageID = 1 << _stageOffset;
                _name2stageID[name] = stageID;
                _stageOffset += 1;
              },
              stageID: function stageID(name) {
                var id = _name2stageID[name];

                if (id === undefined) {
                  return -1;
                }

                return id;
              },
              stageIDs: function stageIDs(nameList) {
                var key = 0;

                for (var _iterator = _createForOfIteratorHelperLoose(nameList), _step; !(_step = _iterator()).done;) {
                  var name = _step.value;
                  var id = _name2stageID[name];

                  if (id !== undefined) {
                    key |= id;
                  }
                }

                return key;
              }
            };

            function createIA(device, data) {
              if (!data.positions) {
                console.error('The data must have positions field');
                return null;
              }

              var verts = [];
              var vcount = data.positions.length / 3;

              for (var i = 0; i < vcount; ++i) {
                verts.push(data.positions[3 * i], data.positions[3 * i + 1], data.positions[3 * i + 2]);

                if (data.normals) {
                  verts.push(data.normals[3 * i], data.normals[3 * i + 1], data.normals[3 * i + 2]);
                }

                if (data.uvs) {
                  verts.push(data.uvs[2 * i], data.uvs[2 * i + 1]);
                }

                if (data.colors) {
                  verts.push(data.colors[3 * i], data.colors[3 * i + 1], data.colors[3 * i + 2]);
                }
              }

              var vfmt = [];
              vfmt.push(new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F));

              if (data.normals) {
                vfmt.push(new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F));
              }

              if (data.uvs) {
                vfmt.push(new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F));
              }

              if (data.colors) {
                vfmt.push(new Attribute(AttributeName.ATTR_COLOR, Format.RGB32F));
              }

              var vb = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, verts.length * 4, verts.length * 4 / vcount));
              vb.update(new Float32Array(verts));
              var ib = null;

              if (data.indices) {
                ib = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, data.indices.length * 2, 2));
                ib.update(new Uint16Array(data.indices));
              }

              return device.createInputAssembler(new InputAssemblerInfo(vfmt, [vb], ib));
            }

            var addStage = config.addStage;

            var renderer = /*#__PURE__*/Object.freeze({
                __proto__: null,
                addStage: addStage,
                scene: index$2,
                createIA: createIA,
                get RenderQueue () { return RenderQueue; },
                get PassStage () { return PassStage; },
                genHandle: genHandle,
                getTypeFromHandle: getTypeFromHandle,
                getBindingFromHandle: getBindingFromHandle,
                getCountFromHandle: getCountFromHandle,
                getOffsetFromHandle: getOffsetFromHandle,
                customizeType: customizeType,
                type2reader: type2reader,
                type2writer: type2writer,
                type2validator: type2validator,
                getDefaultFromType: getDefaultFromType,
                getStringFromType: getStringFromType,
                overrideMacros: overrideMacros,
                get BatchingSchemes () { return BatchingSchemes; },
                Pass: Pass,
                flattenShaderLocation: flattenShaderLocation,
                getDeviceShaderVersion: getDeviceShaderVersion,
                programLib: programLib,
                nearestPOT: nearestPOT,
                TextureBufferPool: TextureBufferPool,
                MaterialInstance: MaterialInstance,
                PassInstance: PassInstance,
                get PoolType () { return PoolType; },
                NULL_HANDLE: NULL_HANDLE,
                get Render2dView () { return Render2dView; },
                Render2dPool: Render2dPool,
                get NodeView () { return NodeView; },
                NodePool: NodePool$1,
                get PassView () { return PassView; },
                PassPool: PassPool,
                get AABBView () { return AABBView; },
                AABBPool: AABBPool,
                RenderScene: RenderScene
            });
            exports('renderer', renderer);

            var DynamicAtlasManager = exports('DynamicAtlasManager', function (_System) {
              _inheritsLoose(DynamicAtlasManager, _System);

              function DynamicAtlasManager() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _System.call.apply(_System, [this].concat(args)) || this;
                _this._atlases = [];
                _this._atlasIndex = -1;
                _this._maxAtlasCount = 5;
                _this._textureSize = 2048;
                _this._maxFrameSize = 512;
                _this._textureBleeding = true;
                _this._enabled = false;
                return _this;
              }

              var _proto = DynamicAtlasManager.prototype;

              _proto.newAtlas = function newAtlas() {
                var atlas = this._atlases[++this._atlasIndex];

                if (!atlas) {
                  atlas = new Atlas(this._textureSize, this._textureSize);

                  this._atlases.push(atlas);
                }

                return atlas;
              };

              _proto.beforeSceneLoad = function beforeSceneLoad() {
                this.reset();
              };

              _proto.init = function init() {
                this.enabled = !macro.CLEANUP_IMAGE_CACHE;
              };

              _proto.insertSpriteFrame = function insertSpriteFrame(spriteFrame) {
                if (!this._enabled || this._atlasIndex === this._maxAtlasCount || !spriteFrame || spriteFrame._original) return null;
                if (!spriteFrame.packable) return null;
                var sampler = spriteFrame.texture.getSamplerInfo();

                if (sampler.minFilter !== Filter$1.LINEAR || sampler.magFilter !== Filter$1.LINEAR || sampler.mipFilter !== Filter$1.NONE) {
                  return null;
                }

                var atlas = this._atlases[this._atlasIndex];

                if (!atlas) {
                  atlas = this.newAtlas();
                }

                var frame = atlas.insertSpriteFrame(spriteFrame);

                if (!frame && this._atlasIndex !== this._maxAtlasCount) {
                  atlas = this.newAtlas();
                  return atlas.insertSpriteFrame(spriteFrame);
                }

                return frame;
              };

              _proto.reset = function reset() {
                for (var i = 0, l = this._atlases.length; i < l; i++) {
                  this._atlases[i].destroy();
                }

                this._atlases.length = 0;
                this._atlasIndex = -1;
              };

              _proto.deleteAtlasSpriteFrame = function deleteAtlasSpriteFrame(spriteFrame) {
                if (!spriteFrame._original) return;
                var atlas;

                for (var i = this._atlases.length - 1; i >= 0; i--) {
                  atlas = this._atlases[i];
                  fastRemove(atlas._innerSpriteFrames, spriteFrame);
                }

                var texture = spriteFrame._original._texture;
                this.deleteAtlasTexture(texture);
              };

              _proto.deleteAtlasTexture = function deleteAtlasTexture(texture) {
                if (texture) {
                  for (var i = this._atlases.length - 1; i >= 0; i--) {
                    this._atlases[i].deleteInnerTexture(texture);

                    if (this._atlases[i].isEmpty()) {
                      this._atlases[i].destroy();

                      this._atlases.splice(i, 1);

                      this._atlasIndex--;
                    }
                  }
                }
              };

              _proto.packToDynamicAtlas = function packToDynamicAtlas(comp, frame) {
                if ( !this._enabled) return;

                if (frame && !frame._original && frame.packable && frame.texture && frame.texture.width > 0 && frame.texture.height > 0) {
                  var packedFrame = this.insertSpriteFrame(frame);

                  if (packedFrame) {
                    frame._setDynamicAtlasFrame(packedFrame);
                  }
                }
              };

              _createClass(DynamicAtlasManager, [{
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(value) {
                  if (this._enabled === value) return;

                  if (value) {
                    this.reset();
                    legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
                  } else {
                    this.reset();
                    legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
                  }

                  this._enabled = value;
                }
              }, {
                key: "maxAtlasCount",
                get: function get() {
                  return this._maxAtlasCount;
                },
                set: function set(value) {
                  this._maxAtlasCount = value;
                }
              }, {
                key: "atlasCount",
                get: function get() {
                  return this._atlases.length;
                }
              }, {
                key: "textureBleeding",
                get: function get() {
                  return this._textureBleeding;
                },
                set: function set(enable) {
                  this._textureBleeding = enable;
                }
              }, {
                key: "textureSize",
                get: function get() {
                  return this._textureSize;
                },
                set: function set(value) {
                  this._textureSize = value;
                }
              }, {
                key: "maxFrameSize",
                get: function get() {
                  return this._maxFrameSize;
                },
                set: function set(value) {
                  this._maxFrameSize = value;
                }
              }]);

              return DynamicAtlasManager;
            }(System));
            DynamicAtlasManager.instance = void 0;
            var dynamicAtlasManager = exports('dynamicAtlasManager', DynamicAtlasManager.instance = new DynamicAtlasManager());
            director.registerSystem('dynamicAtlasManager', dynamicAtlasManager, 0);
            legacyCC.internal.dynamicAtlasManager = dynamicAtlasManager;

            function toPPM(buffer, w, h) {
              return "P3 " + w + " " + h + " 255\n" + buffer.filter(function (e, i) {
                return i % 4 < 3;
              }).toString() + "\n";
            }

            var _keyMap;

            (function (_keyMap) {
              _keyMap[_keyMap["positions"] = AttributeName.ATTR_POSITION] = "positions";
              _keyMap[_keyMap["normals"] = AttributeName.ATTR_NORMAL] = "normals";
              _keyMap[_keyMap["uvs"] = AttributeName.ATTR_TEX_COORD] = "uvs";
              _keyMap[_keyMap["colors"] = AttributeName.ATTR_COLOR] = "colors";
            })(_keyMap || (_keyMap = {}));

            function readMesh(mesh, iPrimitive) {
              if (iPrimitive === void 0) {
                iPrimitive = 0;
              }

              var out = {
                positions: []
              };
              var dataView = new DataView(mesh.data.buffer, mesh.data.byteOffset, mesh.data.byteLength);
              var struct = mesh.struct;
              var primitive = struct.primitives[iPrimitive];

              for (var _iterator = _createForOfIteratorHelperLoose(primitive.vertexBundelIndices), _step; !(_step = _iterator()).done;) {
                var idx = _step.value;
                var bundle = struct.vertexBundles[idx];
                var offset = bundle.view.offset;
                var _bundle$view = bundle.view,
                    length = _bundle$view.length,
                    stride = _bundle$view.stride;

                for (var _iterator2 = _createForOfIteratorHelperLoose(bundle.attributes), _step2; !(_step2 = _iterator2()).done;) {
                  var attr = _step2.value;
                  var name = _keyMap[attr.name];

                  if (name) {
                    out[name] = (out[name] || []).concat(readBuffer(dataView, attr.format, offset, length, stride));
                  }

                  offset += FormatInfos[attr.format].size;
                }
              }

              var view = primitive.indexView;
              out.indices = readBuffer(dataView, Format["R" + view.stride * 8 + "UI"], view.offset, view.length);
              return out;
            }

            var _defAttrs = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_TANGENT, Format.RGBA32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
            var v3_1 = new Vec3();

            function _createMesh(geometry, out, options) {
              options = options || {};
              var attributes = [];
              var stride = 0;
              var channels = [];
              var vertCount = 0;
              var attr;
              var positions = geometry.positions.slice();

              if (positions.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (var _iterator = _createForOfIteratorHelperLoose(geometry.attributes), _step; !(_step = _iterator()).done;) {
                    var att = _step.value;

                    if (att.name === AttributeName.ATTR_POSITION) {
                      attr = att;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[0];
                }

                attributes.push(attr);
                var info = FormatInfos[attr.format];
                vertCount = Math.max(vertCount, Math.floor(positions.length / info.count));
                channels.push({
                  offset: stride,
                  data: positions,
                  attribute: attr
                });
                stride += info.size;
              }

              if (geometry.normals && geometry.normals.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (var _iterator2 = _createForOfIteratorHelperLoose(geometry.attributes), _step2; !(_step2 = _iterator2()).done;) {
                    var _att = _step2.value;

                    if (_att.name === AttributeName.ATTR_NORMAL) {
                      attr = _att;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[1];
                }

                var _info = FormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.normals.length / _info.count));
                channels.push({
                  offset: stride,
                  data: geometry.normals,
                  attribute: attr
                });
                stride += _info.size;
              }

              if (geometry.uvs && geometry.uvs.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (var _iterator3 = _createForOfIteratorHelperLoose(geometry.attributes), _step3; !(_step3 = _iterator3()).done;) {
                    var _att2 = _step3.value;

                    if (_att2.name === AttributeName.ATTR_TEX_COORD) {
                      attr = _att2;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[2];
                }

                var _info2 = FormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.uvs.length / _info2.count));
                channels.push({
                  offset: stride,
                  data: geometry.uvs,
                  attribute: attr
                });
                stride += _info2.size;
              }

              if (geometry.tangents && geometry.tangents.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (var _iterator4 = _createForOfIteratorHelperLoose(geometry.attributes), _step4; !(_step4 = _iterator4()).done;) {
                    var _att3 = _step4.value;

                    if (_att3.name === AttributeName.ATTR_TANGENT) {
                      attr = _att3;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[3];
                }

                var _info3 = FormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.tangents.length / _info3.count));
                channels.push({
                  offset: stride,
                  data: geometry.tangents,
                  attribute: attr
                });
                stride += _info3.size;
              }

              if (geometry.colors && geometry.colors.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (var _iterator5 = _createForOfIteratorHelperLoose(geometry.attributes), _step5; !(_step5 = _iterator5()).done;) {
                    var _att4 = _step5.value;

                    if (_att4.name === AttributeName.ATTR_COLOR) {
                      attr = _att4;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[4];
                }

                var _info4 = FormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.colors.length / _info4.count));
                channels.push({
                  offset: stride,
                  data: geometry.colors,
                  attribute: attr
                });
                stride += _info4.size;
              }

              if (geometry.customAttributes) {
                for (var k = 0; k < geometry.customAttributes.length; k++) {
                  var ca = geometry.customAttributes[k];
                  var _info5 = FormatInfos[ca.attr.format];
                  attributes.push(ca.attr);
                  vertCount = Math.max(vertCount, Math.floor(ca.values.length / _info5.count));
                  channels.push({
                    offset: stride,
                    data: ca.values,
                    attribute: ca.attr
                  });
                  stride += _info5.size;
                }
              }

              var bufferBlob = new BufferBlob();
              var vertexBuffer = new ArrayBuffer(vertCount * stride);
              var vertexBufferView = new DataView(vertexBuffer);

              for (var _i = 0, _channels = channels; _i < _channels.length; _i++) {
                var channel = _channels[_i];
                writeBuffer(vertexBufferView, channel.data, channel.attribute.format, channel.offset, stride);
              }

              bufferBlob.setNextAlignment(0);
              var vertexBundle = {
                attributes: attributes,
                view: {
                  offset: bufferBlob.getLength(),
                  length: vertexBuffer.byteLength,
                  count: vertCount,
                  stride: stride
                }
              };
              bufferBlob.addBuffer(vertexBuffer);
              var indexBuffer = null;
              var idxCount = 0;
              var idxStride = 2;

              if (geometry.indices) {
                var indices = geometry.indices;
                idxCount = indices.length;
                indexBuffer = new ArrayBuffer(idxStride * idxCount);
                var indexBufferView = new DataView(indexBuffer);
                writeBuffer(indexBufferView, indices, Format.R16UI);
              }

              var primitive = {
                primitiveMode: geometry.primitiveMode || PrimitiveMode.TRIANGLE_LIST,
                vertexBundelIndices: [0]
              };

              if (indexBuffer) {
                bufferBlob.setNextAlignment(idxStride);
                primitive.indexView = {
                  offset: bufferBlob.getLength(),
                  length: indexBuffer.byteLength,
                  count: idxCount,
                  stride: idxStride
                };
                bufferBlob.addBuffer(indexBuffer);
              }

              var minPosition = geometry.minPos;

              if (!minPosition && options.calculateBounds) {
                minPosition = Vec3.set(new Vec3(), Infinity, Infinity, Infinity);

                for (var iVertex = 0; iVertex < vertCount; ++iVertex) {
                  Vec3.set(v3_1, positions[iVertex * 3 + 0], positions[iVertex * 3 + 1], positions[iVertex * 3 + 2]);
                  Vec3.min(minPosition, minPosition, v3_1);
                }
              }

              var maxPosition = geometry.maxPos;

              if (!maxPosition && options.calculateBounds) {
                maxPosition = Vec3.set(new Vec3(), -Infinity, -Infinity, -Infinity);

                for (var _iVertex = 0; _iVertex < vertCount; ++_iVertex) {
                  Vec3.set(v3_1, positions[_iVertex * 3 + 0], positions[_iVertex * 3 + 1], positions[_iVertex * 3 + 2]);
                  Vec3.max(maxPosition, maxPosition, v3_1);
                }
              }

              var meshStruct = {
                vertexBundles: [vertexBundle],
                primitives: [primitive]
              };

              if (minPosition) {
                meshStruct.minPosition = new Vec3(minPosition.x, minPosition.y, minPosition.z);
              }

              if (maxPosition) {
                meshStruct.maxPosition = new Vec3(maxPosition.x, maxPosition.y, maxPosition.z);
              }

              if (!out) {
                out = new Mesh();
              }

              out.reset({
                struct: meshStruct,
                data: new Uint8Array(bufferBlob.getCombined())
              });
              return out;
            }

            function getPadding(length, align) {
              if (align > 0) {
                var remainder = length % align;

                if (remainder !== 0) {
                  var padding = align - remainder;
                  return padding;
                }
              }

              return 0;
            }

            function _createDynamicMesh(primitiveIndex, geometry, out, options) {
              options = options || {
                maxSubMeshes: 1,
                maxSubMeshVertices: 1024,
                maxSubMeshIndices: 1024
              };
              var attributes = [];
              var stream = 0;

              if (geometry.positions.length > 0) {
                attributes.push(new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F, false, stream++, false, 0));
              }

              if (geometry.normals && geometry.normals.length > 0) {
                attributes.push(new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F, false, stream++, false, 0));
              }

              if (geometry.uvs && geometry.uvs.length > 0) {
                attributes.push(new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F, false, stream++, false, 0));
              }

              if (geometry.tangents && geometry.tangents.length > 0) {
                attributes.push(new Attribute(AttributeName.ATTR_TANGENT, Format.RGBA32F, false, stream++, false, 0));
              }

              if (geometry.colors && geometry.colors.length > 0) {
                attributes.push(new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F, false, stream++, false, 0));
              }

              if (geometry.customAttributes) {
                for (var k = 0; k < geometry.customAttributes.length; k++) {
                  var ca = geometry.customAttributes[k];
                  var attr = new Attribute();
                  attr.copy(ca.attr);
                  attr.stream = stream++;
                  attributes.push(attr);
                }
              }

              var vertexBundles = [];
              var primitives = [];
              var dataSize = 0;

              for (var i = 0; i < options.maxSubMeshes; i++) {
                var primitive = {
                  vertexBundelIndices: [],
                  primitiveMode: geometry.primitiveMode || PrimitiveMode.TRIANGLE_LIST
                };

                for (var _iterator6 = _createForOfIteratorHelperLoose(attributes), _step6; !(_step6 = _iterator6()).done;) {
                  var _attr = _step6.value;
                  var formatInfo = FormatInfos[_attr.format];
                  var vertexBufferSize = options.maxSubMeshVertices * formatInfo.size;
                  var vertexView = {
                    offset: dataSize,
                    length: vertexBufferSize,
                    count: 0,
                    stride: formatInfo.size
                  };
                  var vertexBundle = {
                    view: vertexView,
                    attributes: [_attr]
                  };
                  var vertexBundleIndex = vertexBundles.length;
                  primitive.vertexBundelIndices.push(vertexBundleIndex);
                  vertexBundles.push(vertexBundle);
                  dataSize += vertexBufferSize;
                }

                var stride = 0;

                if (geometry.indices16 && geometry.indices16.length > 0) {
                  stride = 2;
                } else if (geometry.indices32 && geometry.indices32.length > 0) {
                  stride = 4;
                }

                if (stride > 0) {
                  dataSize += getPadding(dataSize, stride);
                  var indexBufferSize = options.maxSubMeshIndices * stride;
                  var indexView = {
                    offset: dataSize,
                    length: indexBufferSize,
                    count: 0,
                    stride: stride
                  };
                  primitive.indexView = indexView;
                  dataSize += indexBufferSize;
                }

                primitives.push(primitive);
              }

              var dynamicInfo = {
                maxSubMeshes: options.maxSubMeshes,
                maxSubMeshVertices: options.maxSubMeshVertices,
                maxSubMeshIndices: options.maxSubMeshIndices
              };
              var dynamicStruct = {
                info: dynamicInfo,
                bounds: []
              };
              dynamicStruct.bounds.length = options.maxSubMeshes;
              var meshStruct = {
                vertexBundles: vertexBundles,
                primitives: primitives,
                dynamic: dynamicStruct
              };
              var createInfo = {
                struct: meshStruct,
                data: new Uint8Array(dataSize)
              };

              if (!out) {
                out = new Mesh();
              }

              out.reset(createInfo);
              out.initialize();
              out.updateSubMesh(primitiveIndex, geometry);
              return out;
            }

            var MeshUtils = function () {
              function MeshUtils() {}

              MeshUtils.createMesh = function createMesh(geometry, out, options) {
                return _createMesh(geometry, out, options);
              };

              MeshUtils.createDynamicMesh = function createDynamicMesh(primitiveIndex, geometry, out, options) {
                return _createDynamicMesh(primitiveIndex, geometry, out, options);
              };

              return MeshUtils;
            }();

            var utils = /*#__PURE__*/Object.freeze({
                __proto__: null,
                find: find,
                toPPM: toPPM,
                readMesh: readMesh,
                createMesh: _createMesh,
                MeshUtils: MeshUtils,
                readBuffer: readBuffer,
                writeBuffer: writeBuffer,
                mapBuffer: mapBuffer
            });
            exports('utils', utils);

            var _dec, _class, _class2, _temp;
            var INSET_LEFT = 0;
            var INSET_TOP = 1;
            var INSET_RIGHT = 2;
            var INSET_BOTTOM = 3;
            var temp_vec3 = new Vec3();
            var temp_matrix = new Mat4();
            var MeshType;

            (function (MeshType) {
              MeshType[MeshType["RECT"] = 0] = "RECT";
              MeshType[MeshType["POLYGON"] = 1] = "POLYGON";
            })(MeshType || (MeshType = {}));

            var temp_uvs = [{
              u: 0,
              v: 0
            }, {
              u: 0,
              v: 0
            }, {
              u: 0,
              v: 0
            }, {
              u: 0,
              v: 0
            }];
            var SpriteFrame = exports('SpriteFrame', (_dec = ccclass$p('cc.SpriteFrame'), _dec(_class = (_temp = _class2 = function (_Asset) {
              _inheritsLoose(SpriteFrame, _Asset);

              SpriteFrame.createWithImage = function createWithImage(imageSourceOrImageAsset) {
                var img = imageSourceOrImageAsset instanceof ImageAsset ? imageSourceOrImageAsset : new ImageAsset(imageSourceOrImageAsset);
                var tex = new Texture2D();
                tex.image = img;
                var spf = new SpriteFrame();
                spf.texture = tex;
                return spf;
              };

              function SpriteFrame() {
                var _this;

                _this = _Asset.call(this) || this;
                _this.vertices = null;
                _this.uv = [];
                _this.unbiasUV = [];
                _this.uvSliced = [];
                _this._rect = new Rect$1();
                _this._trimmedBorder = new Vec4();
                _this._offset = new Vec2();
                _this._originalSize = new Size$1();
                _this._rotated = false;
                _this._capInsets = [0, 0, 0, 0];
                _this._atlasUuid = '';
                _this._texture = void 0;
                _this._isFlipUVY = false;
                _this._isFlipUVX = false;
                _this._original = null;
                _this._packable = true;
                _this._pixelsToUnit = 100;
                _this._pivot = new Vec2(0.5, 0.5);
                _this._meshType = MeshType.RECT;
                _this._extrude = 0;
                _this._customOutLine = [];
                _this._minPos = new Vec3();
                _this._maxPos = new Vec3();

                return _this;
              }

              var _proto = SpriteFrame.prototype;

              _proto.textureLoaded = function textureLoaded() {
                return !!this.texture;
              };

              _proto.isRotated = function isRotated() {
                return this._rotated;
              };

              _proto.setRotated = function setRotated(rotated) {
                this.rotated = rotated;
              };

              _proto.getRect = function getRect(out) {
                if (out) {
                  out.set(this._rect);
                  return out;
                }

                return this._rect.clone();
              };

              _proto.setRect = function setRect(rect) {
                this.rect = rect;
              };

              _proto.getOriginalSize = function getOriginalSize(out) {
                if (out) {
                  out.set(this._originalSize);
                  return out;
                }

                return this._originalSize.clone();
              };

              _proto.setOriginalSize = function setOriginalSize(size) {
                this.originalSize = size;
              };

              _proto.getOffset = function getOffset(out) {
                if (out) {
                  out.set(this._offset);
                  return out;
                }

                return this._offset.clone();
              };

              _proto.setOffset = function setOffset(offset) {
                this.offset = offset;
              };

              _proto.getGFXTexture = function getGFXTexture() {
                return this._texture.getGFXTexture();
              };

              _proto.getGFXSampler = function getGFXSampler() {
                return this._texture.getGFXSampler();
              };

              _proto.getHash = function getHash() {
                return this._texture.getHash();
              };

              _proto.getSamplerInfo = function getSamplerInfo() {
                return this._texture.getSamplerInfo();
              };

              _proto.reset = function reset(info, clearData) {
                if (clearData === void 0) {
                  clearData = false;
                }

                var calUV = false;

                if (clearData) {
                  this._originalSize.set(0, 0);

                  this._rect.set(0, 0, 0, 0);

                  this._offset.set(0, 0);

                  this._capInsets = [0, 0, 0, 0];
                  this._rotated = false;
                  calUV = true;
                }

                if (info) {
                  if (info.texture) {
                    this._rect.x = this._rect.y = 0;
                    this._rect.width = info.texture.width;
                    this._rect.height = info.texture.height;

                    this._refreshTexture(info.texture);

                    this.checkRect(this._texture);
                  }

                  if (info.originalSize) {
                    this._originalSize.set(info.originalSize);
                  }

                  if (info.rect) {
                    this._rect.set(info.rect);
                  }

                  if (info.offset) {
                    this._offset.set(info.offset);
                  }

                  if (info.borderTop !== undefined) {
                    this._capInsets[INSET_TOP] = info.borderTop;
                  }

                  if (info.borderBottom !== undefined) {
                    this._capInsets[INSET_BOTTOM] = info.borderBottom;
                  }

                  if (info.borderLeft !== undefined) {
                    this._capInsets[INSET_LEFT] = info.borderLeft;
                  }

                  if (info.borderRight !== undefined) {
                    this._capInsets[INSET_RIGHT] = info.borderRight;
                  }

                  if (info.isRotate !== undefined) {
                    this._rotated = !!info.isRotate;
                  }

                  if (info.isFlipUv !== undefined) {
                    this._isFlipUVY = !!info.isFlipUv;
                  }

                  calUV = true;
                }

                if (calUV && this.texture) {
                  this._calculateUV();
                }

                this._calcTrimmedBorder();
              };

              _proto.checkRect = function checkRect(texture) {
                var rect = this._rect;
                var maxX = rect.x;
                var maxY = rect.y;

                if (this._rotated) {
                  maxX += rect.height;
                  maxY += rect.width;
                } else {
                  maxX += rect.width;
                  maxY += rect.height;
                }

                if (maxX > texture.width) {
                  errorID(3300, this.name + "/" + texture.name, maxX, texture.width);
                  return false;
                }

                if (maxY > texture.height) {
                  errorID(3301, this.name + "/" + texture.name, maxY, texture.height);
                  return false;
                }

                return true;
              };

              _proto._calcTrimmedBorder = function _calcTrimmedBorder() {
                var ow = this._originalSize.width;
                var oh = this._originalSize.height;
                var rw = this._rect.width;
                var rh = this._rect.height;
                var halfTrimmedWidth = (ow - rw) * 0.5;
                var halfTrimmedHeight = (oh - rh) * 0.5;
                this._trimmedBorder.x = this._offset.x + halfTrimmedWidth;
                this._trimmedBorder.y = this._offset.x - halfTrimmedWidth;
                this._trimmedBorder.z = this._offset.y + halfTrimmedHeight;
                this._trimmedBorder.w = this._offset.y - halfTrimmedHeight;
              };

              _proto.ensureMeshData = function ensureMeshData() {
                if (this._mesh) return;

                this._initVertices();

                this._createMesh();
              };

              _proto.destroy = function destroy() {
                if (this._packable && dynamicAtlasManager) {
                  dynamicAtlasManager.deleteAtlasSpriteFrame(this);
                }

                return _Asset.prototype.destroy.call(this);
              };

              _proto._calculateSlicedUV = function _calculateSlicedUV() {
                var rect = this._rect;
                var tex = this.texture;
                var atlasWidth = tex.width;
                var atlasHeight = tex.height;
                var leftWidth = this._capInsets[INSET_LEFT];
                var rightWidth = this._capInsets[INSET_RIGHT];
                var centerWidth = rect.width - leftWidth - rightWidth;
                var topHeight = this._capInsets[INSET_TOP];
                var bottomHeight = this._capInsets[INSET_BOTTOM];
                var centerHeight = rect.height - topHeight - bottomHeight;
                var uvSliced = this.uvSliced;
                uvSliced.length = 0;

                if (this._rotated) {
                  temp_uvs[0].u = rect.x / atlasWidth;
                  temp_uvs[1].u = (rect.x + bottomHeight) / atlasWidth;
                  temp_uvs[2].u = (rect.x + bottomHeight + centerHeight) / atlasWidth;
                  temp_uvs[3].u = (rect.x + rect.height) / atlasWidth;
                  temp_uvs[3].v = rect.y / atlasHeight;
                  temp_uvs[2].v = (rect.y + leftWidth) / atlasHeight;
                  temp_uvs[1].v = (rect.y + leftWidth + centerWidth) / atlasHeight;
                  temp_uvs[0].v = (rect.y + rect.width) / atlasHeight;

                  for (var row = 0; row < 4; ++row) {
                    var rowD = temp_uvs[row];

                    for (var col = 0; col < 4; ++col) {
                      var colD = temp_uvs[3 - col];
                      uvSliced.push({
                        u: rowD.u,
                        v: colD.v
                      });
                    }
                  }
                } else {
                  temp_uvs[0].u = rect.x / atlasWidth;
                  temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth;
                  temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth;
                  temp_uvs[3].u = (rect.x + rect.width) / atlasWidth;
                  temp_uvs[3].v = rect.y / atlasHeight;
                  temp_uvs[2].v = (rect.y + topHeight) / atlasHeight;
                  temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight;
                  temp_uvs[0].v = (rect.y + rect.height) / atlasHeight;

                  for (var _row = 0; _row < 4; ++_row) {
                    var _rowD = temp_uvs[_row];

                    for (var _col = 0; _col < 4; ++_col) {
                      var _colD = temp_uvs[_col];
                      uvSliced.push({
                        u: _colD.u,
                        v: _rowD.v
                      });
                    }
                  }
                }

                this.emit(SpriteFrame.EVENT_UV_UPDATED, this);
              };

              _proto._calculateUV = function _calculateUV() {
                var rect = this._rect;
                var uv = this.uv;
                var unbiasUV = this.unbiasUV;
                var tex = this.texture;
                var texw = tex.width;
                var texh = tex.height;

                if (this._rotated) {
                  var l = texw === 0 ? 0 : rect.x / texw;
                  var r = texw === 0 ? 1 : (rect.x + rect.height) / texw;
                  var t = texh === 0 ? 0 : rect.y / texh;
                  var b = texh === 0 ? 1 : (rect.y + rect.width) / texh;

                  if (this._isFlipUVX && this._isFlipUVY) {
                    uv[0] = r;
                    uv[1] = b;
                    uv[2] = r;
                    uv[3] = t;
                    uv[4] = l;
                    uv[5] = b;
                    uv[6] = l;
                    uv[7] = t;
                  } else if (this._isFlipUVX) {
                    uv[0] = r;
                    uv[1] = t;
                    uv[2] = r;
                    uv[3] = b;
                    uv[4] = l;
                    uv[5] = t;
                    uv[6] = l;
                    uv[7] = b;
                  } else if (this._isFlipUVY) {
                    uv[0] = l;
                    uv[1] = b;
                    uv[2] = l;
                    uv[3] = t;
                    uv[4] = r;
                    uv[5] = b;
                    uv[6] = r;
                    uv[7] = t;
                  } else {
                    uv[0] = l;
                    uv[1] = t;
                    uv[2] = l;
                    uv[3] = b;
                    uv[4] = r;
                    uv[5] = t;
                    uv[6] = r;
                    uv[7] = b;
                  }

                  var ul = texw === 0 ? 0 : rect.x / texw;
                  var ur = texw === 0 ? 1 : (rect.x + rect.height) / texw;
                  var ut = texh === 0 ? 0 : rect.y / texh;
                  var ub = texh === 0 ? 1 : (rect.y + rect.width) / texh;

                  if (this._isFlipUVX && this._isFlipUVY) {
                    unbiasUV[0] = ur;
                    unbiasUV[1] = ub;
                    unbiasUV[2] = ur;
                    unbiasUV[3] = ut;
                    unbiasUV[4] = ul;
                    unbiasUV[5] = ub;
                    unbiasUV[6] = ul;
                    unbiasUV[7] = ut;
                  } else if (this._isFlipUVX) {
                    unbiasUV[0] = ur;
                    unbiasUV[1] = ut;
                    unbiasUV[2] = ur;
                    unbiasUV[3] = ub;
                    unbiasUV[4] = ul;
                    unbiasUV[5] = ut;
                    unbiasUV[6] = ul;
                    unbiasUV[7] = ub;
                  } else if (this._isFlipUVY) {
                    unbiasUV[0] = ul;
                    unbiasUV[1] = ub;
                    unbiasUV[2] = ul;
                    unbiasUV[3] = ut;
                    unbiasUV[4] = ur;
                    unbiasUV[5] = ub;
                    unbiasUV[6] = ur;
                    unbiasUV[7] = ut;
                  } else {
                    unbiasUV[0] = ul;
                    unbiasUV[1] = ut;
                    unbiasUV[2] = ul;
                    unbiasUV[3] = ub;
                    unbiasUV[4] = ur;
                    unbiasUV[5] = ut;
                    unbiasUV[6] = ur;
                    unbiasUV[7] = ub;
                  }
                } else {
                  var _l = texw === 0 ? 0 : rect.x / texw;

                  var _r = texw === 0 ? 1 : (rect.x + rect.width) / texw;

                  var _b = texh === 0 ? 1 : (rect.y + rect.height) / texh;

                  var _t = texh === 0 ? 0 : rect.y / texh;

                  if (this._isFlipUVX && this._isFlipUVY) {
                    uv[0] = _r;
                    uv[1] = _t;
                    uv[2] = _l;
                    uv[3] = _t;
                    uv[4] = _r;
                    uv[5] = _b;
                    uv[6] = _l;
                    uv[7] = _b;
                  } else if (this._isFlipUVX) {
                    uv[0] = _r;
                    uv[1] = _b;
                    uv[2] = _l;
                    uv[3] = _b;
                    uv[4] = _r;
                    uv[5] = _t;
                    uv[6] = _l;
                    uv[7] = _t;
                  } else if (this._isFlipUVY) {
                    uv[0] = _l;
                    uv[1] = _t;
                    uv[2] = _r;
                    uv[3] = _t;
                    uv[4] = _l;
                    uv[5] = _b;
                    uv[6] = _r;
                    uv[7] = _b;
                  } else {
                    uv[0] = _l;
                    uv[1] = _b;
                    uv[2] = _r;
                    uv[3] = _b;
                    uv[4] = _l;
                    uv[5] = _t;
                    uv[6] = _r;
                    uv[7] = _t;
                  }

                  var _ul = texw === 0 ? 0 : rect.x / texw;

                  var _ur = texw === 0 ? 1 : (rect.x + rect.width) / texw;

                  var _ub = texh === 0 ? 1 : (rect.y + rect.height) / texh;

                  var _ut = texh === 0 ? 0 : rect.y / texh;

                  if (this._isFlipUVX && this._isFlipUVY) {
                    unbiasUV[0] = _ur;
                    unbiasUV[1] = _ut;
                    unbiasUV[2] = _ul;
                    unbiasUV[3] = _ut;
                    unbiasUV[4] = _ur;
                    unbiasUV[5] = _ub;
                    unbiasUV[6] = _ul;
                    unbiasUV[7] = _ub;
                  } else if (this._isFlipUVX) {
                    unbiasUV[0] = _ur;
                    unbiasUV[1] = _ub;
                    unbiasUV[2] = _ul;
                    unbiasUV[3] = _ub;
                    unbiasUV[4] = _ur;
                    unbiasUV[5] = _ut;
                    unbiasUV[6] = _ul;
                    unbiasUV[7] = _ut;
                  } else if (this._isFlipUVY) {
                    unbiasUV[0] = _ul;
                    unbiasUV[1] = _ut;
                    unbiasUV[2] = _ur;
                    unbiasUV[3] = _ut;
                    unbiasUV[4] = _ul;
                    unbiasUV[5] = _ub;
                    unbiasUV[6] = _ur;
                    unbiasUV[7] = _ub;
                  } else {
                    unbiasUV[0] = _ul;
                    unbiasUV[1] = _ub;
                    unbiasUV[2] = _ur;
                    unbiasUV[3] = _ub;
                    unbiasUV[4] = _ul;
                    unbiasUV[5] = _ut;
                    unbiasUV[6] = _ur;
                    unbiasUV[7] = _ut;
                  }
                }

                this._calculateSlicedUV();
              };

              _proto._setDynamicAtlasFrame = function _setDynamicAtlasFrame(frame) {
                if (!frame) return;
                this._original = {
                  _texture: this._texture,
                  _x: this._rect.x,
                  _y: this._rect.y
                };
                this._texture = frame.texture;
                this._rect.x = frame.x;
                this._rect.y = frame.y;

                this._calculateUV();
              };

              _proto._resetDynamicAtlasFrame = function _resetDynamicAtlasFrame() {
                if (!this._original) return;
                this._rect.x = this._original._x;
                this._rect.y = this._original._y;
                this._texture = this._original._texture;
                this._original = null;

                this._calculateUV();
              };

              _proto._checkPackable = function _checkPackable() {
                var dynamicAtlas = dynamicAtlasManager;
                if (!dynamicAtlas) return;
                var texture = this._texture;

                if (!(texture instanceof Texture2D) || texture.isCompressed) {
                  this._packable = false;
                  return;
                }

                var w = this.width;
                var h = this.height;

                if (!texture.image || w > dynamicAtlas.maxFrameSize || h > dynamicAtlas.maxFrameSize) {
                  this._packable = false;
                  return;
                }

                var CanvasElement = ccwindow.HTMLCanvasElement;

                if (texture.image && texture.image instanceof CanvasElement) {
                  this._packable = true;
                }
              };

              _proto._serialize = function _serialize(ctxForExporting) {

                return null;
              };

              _proto._deserialize = function _deserialize(serializeData, handle) {
                var data = serializeData;
                var rect = data.rect;

                if (rect) {
                  this._rect = new Rect$1(rect.x, rect.y, rect.width, rect.height);
                }

                var offset = data.offset;

                if (data.offset) {
                  this._offset = new Vec2(offset.x, offset.y);
                }

                var originalSize = data.originalSize;

                if (data.originalSize) {
                  this._originalSize = new Size$1(originalSize.width, originalSize.height);
                }

                this._rotated = !!data.rotated;
                this._name = data.name;
                this._packable = !!data.packable;
                this._pixelsToUnit = data.pixelsToUnit;
                var pivot = data.pivot;

                if (pivot) {
                  this._pivot = new Vec2(pivot.x, pivot.y);
                }

                this._meshType = data.meshType;
                var capInsets = data.capInsets;

                if (capInsets) {
                  this._capInsets[INSET_LEFT] = capInsets[INSET_LEFT];
                  this._capInsets[INSET_TOP] = capInsets[INSET_TOP];
                  this._capInsets[INSET_RIGHT] = capInsets[INSET_RIGHT];
                  this._capInsets[INSET_BOTTOM] = capInsets[INSET_BOTTOM];
                }

                var vertices = data.vertices;

                if (vertices) {
                  if (!this.vertices) {
                    this.vertices = {
                      rawPosition: [],
                      positions: [],
                      indexes: vertices.indexes,
                      uv: vertices.uv,
                      nuv: vertices.nuv,
                      minPos: new Vec3(vertices.minPos.x, vertices.minPos.y, vertices.minPos.z),
                      maxPos: new Vec3(vertices.maxPos.x, vertices.maxPos.y, vertices.maxPos.z)
                    };
                  }

                  this.vertices.rawPosition.length = 0;
                  var rawPosition = vertices.rawPosition;

                  for (var i = 0; i < rawPosition.length; i += 3) {
                    this.vertices.rawPosition.push(new Vec3(rawPosition[i], rawPosition[i + 1], rawPosition[i + 2]));
                  }

                  this._updateMeshVertices();
                }
              };

              _proto.clone = function clone() {
                var _sp$uv, _sp$unbiasUV, _sp$uvSliced, _sp$_capInsets;

                var sp = new SpriteFrame();
                var v = this.vertices;
                sp.vertices = v ? {
                  rawPosition: v.rawPosition.slice(0),
                  positions: v.positions.slice(0),
                  indexes: v.indexes.slice(0),
                  uv: v.uv.slice(0),
                  nuv: v.nuv.slice(0),
                  minPos: v.minPos.clone(),
                  maxPos: v.minPos.clone()
                } : null;

                (_sp$uv = sp.uv).splice.apply(_sp$uv, [0, sp.uv.length].concat(this.uv));

                (_sp$unbiasUV = sp.unbiasUV).splice.apply(_sp$unbiasUV, [0, sp.unbiasUV.length].concat(this.unbiasUV));

                (_sp$uvSliced = sp.uvSliced).splice.apply(_sp$uvSliced, [0, sp.uvSliced.length].concat(this.uvSliced));

                sp._rect.set(this._rect);

                sp._offset.set(this._offset);

                sp._originalSize.set(this._originalSize);

                sp._rotated = this._rotated;

                (_sp$_capInsets = sp._capInsets).splice.apply(_sp$_capInsets, [0, sp._capInsets.length].concat(this._capInsets));

                sp._atlasUuid = this._atlasUuid;
                sp._texture = this._texture;
                sp._isFlipUVX = this._isFlipUVX;
                sp._isFlipUVY = this._isFlipUVY;
                sp._pixelsToUnit = this._pixelsToUnit;

                sp._pivot.set(this._pivot);

                sp._meshType = this._meshType;
                return sp;
              };

              _proto._refreshTexture = function _refreshTexture(texture) {
                this._texture = texture;
                var tex = this._texture;
                var config = {};
                var isReset = false;

                if (this._rect.width === 0 || this._rect.height === 0 || !this.checkRect(tex)) {
                  config.rect = new Rect$1(0, 0, tex.width, tex.height);
                  isReset = true;
                }

                if (this._originalSize.width === 0 || this._originalSize.height === 0 || isReset) {
                  config.originalSize = new Size$1(tex.width, tex.height);
                  isReset = true;
                }

                if (isReset) {
                  this.reset(config);
                }

                this._checkPackable();

                if (this._mesh) {
                  this._updateMesh();
                }
              };

              _proto.onLoaded = function onLoaded() {
                this._calcTrimmedBorder();
              };

              _proto.initDefault = function initDefault(uuid) {
                _Asset.prototype.initDefault.call(this, uuid);

                var texture = new Texture2D();
                texture.initDefault();

                this._refreshTexture(texture);

                this._calculateUV();
              };

              _proto.validate = function validate() {
                return this._texture && this._rect && this._rect.width !== 0 && this._rect.height !== 0;
              };

              _proto._initVertices = function _initVertices() {
                if (!this.vertices) {
                  this.vertices = {
                    rawPosition: [],
                    positions: [],
                    indexes: [],
                    uv: [],
                    nuv: [],
                    minPos: new Vec3(),
                    maxPos: new Vec3()
                  };
                } else {
                  this.vertices.rawPosition.length = 0;
                  this.vertices.positions.length = 0;
                  this.vertices.indexes.length = 0;
                  this.vertices.uv.length = 0;
                  this.vertices.nuv.length = 0;
                  this.vertices.minPos.set(0, 0, 0);
                  this.vertices.maxPos.set(0, 0, 0);
                }

                if (this._meshType === MeshType.POLYGON) ; else {
                  var tex = this.texture;
                  var texw = tex.width;
                  var texh = tex.height;
                  var rect = this.rect;
                  var width = rect.width;
                  var height = rect.height;
                  var rectX = rect.x;
                  var rectY = texh - rect.y - height;
                  var halfWidth = width / 2;
                  var halfHeight = height / 2;
                  var l = texw === 0 ? 0 : rectX / texw;
                  var r = texw === 0 ? 1 : (rectX + width) / texw;
                  var t = texh === 0 ? 1 : (rectY + height) / texh;
                  var b = texh === 0 ? 0 : rect.y / texh;
                  temp_vec3.set(-halfWidth, -halfHeight, 0);
                  this.vertices.rawPosition.push(temp_vec3.clone());
                  this.vertices.uv.push(rectX);
                  this.vertices.uv.push(rectY + height);
                  this.vertices.nuv.push(l);
                  this.vertices.nuv.push(b);
                  this.vertices.minPos.set(temp_vec3);
                  temp_vec3.set(halfWidth, -halfHeight, 0);
                  this.vertices.rawPosition.push(temp_vec3.clone());
                  this.vertices.uv.push(rectX + width);
                  this.vertices.uv.push(rectY + height);
                  this.vertices.nuv.push(r);
                  this.vertices.nuv.push(b);
                  temp_vec3.set(-halfWidth, halfHeight, 0);
                  this.vertices.rawPosition.push(temp_vec3.clone());
                  this.vertices.uv.push(rectX);
                  this.vertices.uv.push(rectY);
                  this.vertices.nuv.push(l);
                  this.vertices.nuv.push(t);
                  temp_vec3.set(halfWidth, halfHeight, 0);
                  this.vertices.rawPosition.push(temp_vec3.clone());
                  this.vertices.uv.push(rectX + width);
                  this.vertices.uv.push(rectY);
                  this.vertices.nuv.push(r);
                  this.vertices.nuv.push(t);
                  this.vertices.maxPos.set(temp_vec3);
                  this.vertices.indexes.push(0);
                  this.vertices.indexes.push(1);
                  this.vertices.indexes.push(2);
                  this.vertices.indexes.push(2);
                  this.vertices.indexes.push(1);
                  this.vertices.indexes.push(3);
                }

                this._updateMeshVertices();
              };

              _proto._updateMeshVertices = function _updateMeshVertices() {
                temp_matrix.identity();
                var units = 1 / this._pixelsToUnit;
                var temp_vec3 = new Vec3(units, units, 1);
                temp_matrix.scale(temp_vec3);
                var PosX = -(this._pivot.x - 0.5) * this.rect.width * units;
                var PosY = -(this._pivot.y - 0.5) * this.rect.height * units;
                temp_vec3.set(PosX, PosY, 0);
                temp_matrix.translate(temp_vec3);
                var vertices = this.vertices;

                for (var i = 0; i < vertices.rawPosition.length; i++) {
                  var pos = vertices.rawPosition[i];
                  Vec3.transformMat4(temp_vec3, pos, temp_matrix);
                  Vec3.toArray(vertices.positions, temp_vec3, 3 * i);
                }

                Vec3.transformMat4(this._minPos, vertices.minPos, temp_matrix);
                Vec3.transformMat4(this._maxPos, vertices.maxPos, temp_matrix);
              };

              _proto._createMesh = function _createMesh$1() {
                this._mesh = _createMesh({
                  primitiveMode: PrimitiveMode.TRIANGLE_LIST,
                  positions: this.vertices.positions,
                  uvs: this.vertices.nuv,
                  indices: this.vertices.indexes,
                  minPos: this._minPos,
                  maxPos: this._maxPos,
                  attributes: [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F)]
                });
              };

              _proto._updateMesh = function _updateMesh() {
                if (this._mesh) {
                  this._mesh.destroy();
                }

                this._initVertices();

                this._createMesh();
              };

              _createClass(SpriteFrame, [{
                key: "insetTop",
                get: function get() {
                  return this._capInsets[INSET_TOP];
                },
                set: function set(value) {
                  if (this._capInsets[INSET_TOP] === value) {
                    return;
                  }

                  this._capInsets[INSET_TOP] = value;

                  if (this._texture) {
                    this._calculateSlicedUV();
                  }
                }
              }, {
                key: "insetBottom",
                get: function get() {
                  return this._capInsets[INSET_BOTTOM];
                },
                set: function set(value) {
                  if (this._capInsets[INSET_BOTTOM] === value) {
                    return;
                  }

                  this._capInsets[INSET_BOTTOM] = value;

                  if (this._texture) {
                    this._calculateSlicedUV();
                  }
                }
              }, {
                key: "insetLeft",
                get: function get() {
                  return this._capInsets[INSET_LEFT];
                },
                set: function set(value) {
                  if (this._capInsets[INSET_LEFT] === value) {
                    return;
                  }

                  this._capInsets[INSET_LEFT] = value;

                  if (this._texture) {
                    this._calculateSlicedUV();
                  }
                }
              }, {
                key: "insetRight",
                get: function get() {
                  return this._capInsets[INSET_RIGHT];
                },
                set: function set(value) {
                  if (this._capInsets[INSET_RIGHT] === value) {
                    return;
                  }

                  this._capInsets[INSET_RIGHT] = value;

                  if (this._texture) {
                    this._calculateSlicedUV();
                  }
                }
              }, {
                key: "rect",
                get: function get() {
                  return this._rect;
                },
                set: function set(value) {
                  if (this._rect.equals(value)) {
                    return;
                  }

                  this._rect.set(value);

                  if (this._texture) {
                    this._calculateUV();
                  }

                  this._calcTrimmedBorder();
                }
              }, {
                key: "originalSize",
                get: function get() {
                  return this._originalSize;
                },
                set: function set(value) {
                  if (this._originalSize.equals(value)) {
                    return;
                  }

                  this._originalSize.set(value);

                  if (this._texture) {
                    this._calculateUV();
                  }

                  this._calcTrimmedBorder();
                }
              }, {
                key: "offset",
                get: function get() {
                  return this._offset;
                },
                set: function set(value) {
                  this._offset.set(value);

                  this._calcTrimmedBorder();
                }
              }, {
                key: "rotated",
                get: function get() {
                  return this._rotated;
                },
                set: function set(rotated) {
                  if (this._rotated === rotated) {
                    return;
                  }

                  this._rotated = rotated;

                  if (this._texture) {
                    this._calculateUV();
                  }
                }
              }, {
                key: "texture",
                get: function get() {
                  return this._texture;
                },
                set: function set(value) {
                  if (!value) {
                    warnID(3122, this.name);
                    return;
                  }

                  if (value === this._texture) {
                    return;
                  }

                  this.reset({
                    texture: value
                  }, true);
                }
              }, {
                key: "atlasUuid",
                get: function get() {
                  return this._atlasUuid;
                },
                set: function set(value) {
                  this._atlasUuid = value;
                }
              }, {
                key: "width",
                get: function get() {
                  return this._texture.width;
                }
              }, {
                key: "height",
                get: function get() {
                  return this._texture.height;
                }
              }, {
                key: "_textureSource",
                set: function set(value) {
                  if (globalThis.Build) {
                    this._texture = value;
                    return;
                  }

                  if (value) {
                    this._refreshTexture(value);

                    this._calculateUV();
                  }
                }
              }, {
                key: "flipUVX",
                get: function get() {
                  return this._isFlipUVX;
                },
                set: function set(value) {
                  this._isFlipUVX = value;

                  this._calculateUV();
                }
              }, {
                key: "flipUVY",
                get: function get() {
                  return this._isFlipUVY;
                },
                set: function set(value) {
                  this._isFlipUVY = value;

                  this._calculateUV();
                }
              }, {
                key: "packable",
                get: function get() {
                  return this._packable;
                },
                set: function set(value) {
                  this._packable = value;
                }
              }, {
                key: "original",
                get: function get() {
                  return this._original;
                }
              }, {
                key: "pixelsToUnit",
                get: function get() {
                  return this._pixelsToUnit;
                }
              }, {
                key: "pivot",
                get: function get() {
                  return this._pivot;
                }
              }, {
                key: "mesh",
                get: function get() {
                  return this._mesh;
                }
              }, {
                key: "trimmedBorder",
                get: function get() {
                  return this._trimmedBorder;
                }
              }]);

              return SpriteFrame;
            }(Asset), _class2.EVENT_UV_UPDATED = 'uv_updated', _class2.MeshType = MeshType, _temp)) || _class));
            legacyCC.SpriteFrame = SpriteFrame;

            var _dec$1, _class$1, _class2$1, _initializer;
            var SpriteAtlas = exports('SpriteAtlas', (_dec$1 = ccclass$p('cc.SpriteAtlas'), _dec$1(_class$1 = (_class2$1 = function (_Asset) {
              _inheritsLoose(SpriteAtlas, _Asset);

              function SpriteAtlas() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;
                _this.spriteFrames = _initializer && _initializer();
                return _this;
              }

              var _proto = SpriteAtlas.prototype;

              _proto.getTexture = function getTexture() {
                var keys = Object.keys(this.spriteFrames);

                if (keys.length > 0) {
                  var spriteFrame = this.spriteFrames[keys[0]];
                  return spriteFrame && spriteFrame.texture;
                } else {
                  return null;
                }
              };

              _proto.getSpriteFrame = function getSpriteFrame(key) {
                var sf = this.spriteFrames[key];

                if (!sf) {
                  return null;
                }

                if (!sf.name) {
                  sf.name = key;
                }

                return sf;
              };

              _proto.getSpriteFrames = function getSpriteFrames() {
                var frames = [];
                var spriteFrames = this.spriteFrames;

                for (var _i = 0, _Object$keys = Object.keys(spriteFrames); _i < _Object$keys.length; _i++) {
                  var _key2 = _Object$keys[_i];
                  frames.push(spriteFrames[_key2]);
                }

                return frames;
              };

              _proto._serialize = function _serialize(ctxForExporting) {
              };

              _proto._deserialize = function _deserialize(serializeData, handle) {
                var data = serializeData;
                this._name = data.name;
                var frames = data.spriteFrames;
                this.spriteFrames = createMap();

                for (var i = 0; i < frames.length; i += 2) {
                  handle.result.push(this.spriteFrames, frames[i], frames[i + 1], getClassId(SpriteFrame));
                }
              };

              return SpriteAtlas;
            }(Asset), (_initializer = applyDecoratedInitializer(_class2$1.prototype, "spriteFrames", [serializable$j], function () {
              return createMap();
            })), _class2$1)) || _class$1));
            legacyCC.SpriteAtlas = SpriteAtlas;

            var _dec$2, _class$2;
            var Font = exports('Font', (_dec$2 = ccclass$p('cc.Font'), _dec$2(_class$2 = function (_Asset) {
              _inheritsLoose(Font, _Asset);

              function Font() {
                return _Asset.apply(this, arguments) || this;
              }

              return Font;
            }(Asset)) || _class$2));
            legacyCC.Font = Font;

            var _dec$3, _class$3, _class2$2, _initializer$1;
            var TTFFont = exports('TTFFont', (_dec$3 = ccclass$p('cc.TTFFont'), _dec$3(_class$3 = (_class2$2 = function (_Font) {
              _inheritsLoose(TTFFont, _Font);

              function TTFFont() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Font.call.apply(_Font, [this].concat(args)) || this;
                _this._fontFamily = _initializer$1 && _initializer$1();
                return _this;
              }

              var _proto = TTFFont.prototype;

              _proto.initDefault = function initDefault(uuid) {
                this._fontFamily = 'Arial';

                _Font.prototype.initDefault.call(this, uuid);
              };

              _createClass(TTFFont, [{
                key: "_nativeAsset",
                get: function get() {
                  return this._fontFamily;
                },
                set: function set(value) {
                  this._fontFamily = value || 'Arial';
                }
              }, {
                key: "_nativeDep",
                get: function get() {
                  return {
                    uuid: this._uuid,
                    __nativeName__: this._native,
                    ext: extname(this._native),
                    __isNative__: true
                  };
                }
              }]);

              return TTFFont;
            }(Font), (_initializer$1 = applyDecoratedInitializer(_class2$2.prototype, "_fontFamily", [serializable$j], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$2.prototype, "_nativeAsset", [override$1, string], Object.getOwnPropertyDescriptor(_class2$2.prototype, "_nativeAsset"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "_nativeDep", [override$1], Object.getOwnPropertyDescriptor(_class2$2.prototype, "_nativeDep"), _class2$2.prototype)), _class2$2)) || _class$3));
            legacyCC.TTFFont = TTFFont;

            var _dec$4, _dec2, _class$4, _class2$3, _initializer$2, _initializer2, _initializer3, _initializer4;
            var FontLetterDefinition = function FontLetterDefinition() {
              this.u = 0;
              this.v = 0;
              this.w = 0;
              this.h = 0;
              this.offsetX = 0;
              this.offsetY = 0;
              this.textureID = 0;
              this.valid = false;
              this.xAdvance = 0;
            };
            var FontAtlas = function () {
              function FontAtlas(texture) {
                this.letterDefinitions = {};
                this.texture = texture;
              }

              var _proto = FontAtlas.prototype;

              _proto.addLetterDefinitions = function addLetterDefinitions(letter, letterDefinition) {
                this.letterDefinitions[letter] = letterDefinition;
              };

              _proto.cloneLetterDefinition = function cloneLetterDefinition() {
                var copyLetterDefinitions = {};

                for (var _i = 0, _Object$keys = Object.keys(this.letterDefinitions); _i < _Object$keys.length; _i++) {
                  var _key = _Object$keys[_i];
                  var value = new FontLetterDefinition();
                  mixin(value, this.letterDefinitions[_key]);
                  copyLetterDefinitions[_key] = value;
                }

                return copyLetterDefinitions;
              };

              _proto.getTexture = function getTexture() {
                return this.texture;
              };

              _proto.getLetter = function getLetter(key) {
                return this.letterDefinitions[key];
              };

              _proto.getLetterDefinitionForChar = function getLetterDefinitionForChar(_char, labelInfo) {
                var key = _char.charCodeAt(0);

                var hasKey = this.letterDefinitions.hasOwnProperty(key);
                var letter;

                if (hasKey) {
                  letter = this.letterDefinitions[key];
                } else {
                  letter = null;
                }

                return letter;
              };

              _proto.clear = function clear() {
                this.letterDefinitions = {};
              };

              return FontAtlas;
            }();
            var BitmapFont = exports('BitmapFont', (_dec$4 = ccclass$p('cc.BitmapFont'), _dec2 = type$8(SpriteFrame), _dec$4(_class$4 = (_class2$3 = function (_Font) {
              _inheritsLoose(BitmapFont, _Font);

              function BitmapFont() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
                  args[_key2] = arguments[_key2];
                }

                _this = _Font.call.apply(_Font, [this].concat(args)) || this;
                _this.fntDataStr = _initializer$2 && _initializer$2();
                _this.spriteFrame = _initializer2 && _initializer2();
                _this.fontSize = _initializer3 && _initializer3();
                _this.fntConfig = _initializer4 && _initializer4();
                return _this;
              }

              var _proto2 = BitmapFont.prototype;

              _proto2.onLoaded = function onLoaded() {
                var spriteFrame = this.spriteFrame;

                if (!this.fontDefDictionary && spriteFrame) {
                  this.fontDefDictionary = new FontAtlas(spriteFrame.texture);
                }

                var fntConfig = this.fntConfig;

                if (!fntConfig) {
                  warn('The fnt config is not exists!');
                  return;
                }

                var fontDict = fntConfig.fontDefDictionary;

                for (var fontDef in fontDict) {
                  var letter = new FontLetterDefinition();
                  var rect = fontDict[fontDef].rect;
                  letter.offsetX = fontDict[fontDef].xOffset;
                  letter.offsetY = fontDict[fontDef].yOffset;
                  letter.w = rect.width;
                  letter.h = rect.height;
                  letter.u = rect.x;
                  letter.v = rect.y;
                  letter.textureID = 0;
                  letter.valid = true;
                  letter.xAdvance = fontDict[fontDef].xAdvance;
                  this.fontDefDictionary.addLetterDefinitions(fontDef, letter);
                }
              };

              return BitmapFont;
            }(Font), (_initializer$2 = applyDecoratedInitializer(_class2$3.prototype, "fntDataStr", [serializable$j], function () {
              return '';
            }), _initializer2 = applyDecoratedInitializer(_class2$3.prototype, "spriteFrame", [_dec2], function () {
              return null;
            }), _initializer3 = applyDecoratedInitializer(_class2$3.prototype, "fontSize", [serializable$j], function () {
              return -1;
            }), _initializer4 = applyDecoratedInitializer(_class2$3.prototype, "fntConfig", [serializable$j], function () {
              return null;
            })), _class2$3)) || _class$4));
            legacyCC.BitmapFont = BitmapFont;

            var _dec$5, _class$5;
            var LabelAtlas = exports('LabelAtlas', (_dec$5 = ccclass$p('cc.LabelAtlas'), _dec$5(_class$5 = function (_BitmapFont) {
              _inheritsLoose(LabelAtlas, _BitmapFont);

              function LabelAtlas() {
                return _BitmapFont.apply(this, arguments) || this;
              }

              return LabelAtlas;
            }(BitmapFont)) || _class$5));
            legacyCC.LabelAtlas = LabelAtlas;

            var BASELINE_RATIO = exports('BASELINE_RATIO', 0.26);
            var _BASELINE_OFFSET = 0;

            var MIDDLE_RATIO = exports('MIDDLE_RATIO', (BASELINE_RATIO + 1) / 2 - BASELINE_RATIO);
            function getBaselineOffset() {
              return _BASELINE_OFFSET;
            }
            var MAX_CACHE_SIZE = 100;
            var pool = new Pool$1(2);

            pool.get = function () {
              return this._get() || {
                key: '',
                value: 0,
                prev: null,
                next: null
              };
            };

            var LRUCache = function () {
              function LRUCache(size) {
                this.count = 0;
                this.limit = 0;
                this.datas = {};
                this.limit = size;
              }

              var _proto = LRUCache.prototype;

              _proto.moveToHead = function moveToHead(node) {
                node.next = this.head;
                node.prev = null;
                if (this.head) this.head.prev = node;
                this.head = node;
                if (!this.tail) this.tail = node;
                this.count++;
                this.datas[node.key] = node;
              };

              _proto.put = function put(key, value) {
                var node = pool.get();
                node.key = key;
                node.value = value;

                if (this.count >= this.limit) {
                  var discard = this.tail;
                  delete this.datas[discard.key];
                  this.count--;
                  this.tail = discard.prev;
                  this.tail.next = null;
                  discard.prev = null;
                  discard.next = null;
                  pool.put(discard);
                }

                this.moveToHead(node);
              };

              _proto.remove = function remove(node) {
                if (node.prev) {
                  node.prev.next = node.next;
                } else {
                  this.head = node.next;
                }

                if (node.next) {
                  node.next.prev = node.prev;
                } else {
                  this.tail = node.prev;
                }

                delete this.datas[node.key];
                this.count--;
              };

              _proto.get = function get(key) {
                var node = this.datas[key];

                if (node) {
                  this.remove(node);
                  this.moveToHead(node);
                  return node.value;
                }

                return null;
              };

              _proto.clear = function clear() {
                this.count = 0;
                this.datas = {};
                this.head = null;
                this.tail = null;
              };

              _proto.has = function has(key) {
                return !!this.datas[key];
              };

              _proto["delete"] = function _delete(key) {
                var node = this.datas[key];
                this.remove(node);
              };

              return LRUCache;
            }();

            var measureCache = new LRUCache(MAX_CACHE_SIZE);
            var WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûа-яА-ЯЁё]+|\S)/;
            var SYMBOL_REG = /^[!,.:;'}\]%\?>、‘“》？。，！]/;
            var LAST_WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁёáàảạãăắằẳẵặâấầẩẫậéèẻẽẹêếềểễệiíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵđÁÀẢẠÃĂẮẰẲẴẶÂẤẦẨẪẬÉÈẺẼẸÊẾỀỂỄỆIÍÌỈĨỊÓÒỎÕỌÔỐỒỔỖỘƠỚỜỞỠỢÚÙỦŨỤƯỨỪỬỮỰÝỲỶỸỴĐ]+|\S)$/;
            var LAST_ENGLISH_REG = /[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁёáàảạãăắằẳẵặâấầẩẫậéèẻẽẹêếềểễệiíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵđÁÀẢẠÃĂẮẰẲẴẶÂẤẦẨẪẬÉÈẺẼẸÊẾỀỂỄỆIÍÌỈĨỊÓÒỎÕỌÔỐỒỔỖỘƠỚỜỞỠỢÚÙỦŨỤƯỨỪỬỮỰÝỲỶỸỴĐ]+$/;
            var FIRST_ENGLISH_REG = /^[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁёáàảạãăắằẳẵặâấầẩẫậéèẻẽẹêếềểễệiíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵđÁÀẢẠÃĂẮẰẲẴẶÂẤẦẨẪẬÉÈẺẼẸÊẾỀỂỄỆIÍÌỈĨỊÓÒỎÕỌÔỐỒỔỖỘƠỚỜỞỠỢÚÙỦŨỤƯỨỪỬỮỰÝỲỶỸỴĐ]/;
            function isUnicodeCJK(ch) {
              var __CHINESE_REG = /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/;
              var __JAPANESE_REG = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
              var __KOREAN_REG = /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/;
              return __CHINESE_REG.test(ch) || __JAPANESE_REG.test(ch) || __KOREAN_REG.test(ch);
            }
            function isUnicodeSpace(ch) {
              var chCode = ch.charCodeAt(0);
              return chCode >= 9 && chCode <= 13 || chCode === 32 || chCode === 133 || chCode === 160 || chCode === 5760 || chCode >= 8192 && chCode <= 8202 || chCode === 8232 || chCode === 8233 || chCode === 8239 || chCode === 8287 || chCode === 12288;
            }
            function safeMeasureText(ctx, string, desc) {
              var font = desc || ctx.font;
              var key = font + "\uD83C\uDFAE" + string;
              var cache = measureCache.get(key);

              if (cache !== null) {
                return cache;
              }

              var metric = ctx.measureText(string);
              var width = metric && metric.width || 0;
              measureCache.put(key, width);
              return width;
            }

            function _safeSubstring(targetString, startIndex, endIndex) {
              var newStartIndex = startIndex;
              var newEndIndex = endIndex;
              var startChar = targetString[startIndex];

              if (startChar >= "\uDC00" && startChar <= "\uDFFF") {
                newStartIndex--;
              }

              if (endIndex !== undefined) {
                if (endIndex - 1 !== startIndex) {
                  var endChar = targetString[endIndex - 1];

                  if (endChar >= "\uD800" && endChar <= "\uDBFF") {
                    newEndIndex--;
                  }
                } else if (startChar >= "\uD800" && startChar <= "\uDBFF") {
                  newEndIndex++;
                }
              }

              return targetString.substring(newStartIndex, newEndIndex);
            }

            function isEnglishWordPartAtFirst(stringToken) {
              return FIRST_ENGLISH_REG.test(stringToken);
            }
            function isEnglishWordPartAtLast(stringToken) {
              return LAST_ENGLISH_REG.test(stringToken);
            }
            function getEnglishWordPartAtFirst(stringToken) {
              var result = FIRST_ENGLISH_REG.exec(stringToken);
              return result;
            }
            function getEnglishWordPartAtLast(stringToken) {
              var result = LAST_ENGLISH_REG.exec(stringToken);
              return result;
            }
            function fragmentText(stringToken, allWidth, maxWidth, measureText) {
              var wrappedWords = [];

              if (stringToken.length === 0 || maxWidth < 0) {
                wrappedWords.push('');
                return wrappedWords;
              }

              var text = stringToken;

              while (allWidth > maxWidth && text.length > 1) {
                var fuzzyLen = text.length * (maxWidth / allWidth) | 0;

                var tmpText = _safeSubstring(text, fuzzyLen);

                var width = allWidth - measureText(tmpText);
                var sLine = tmpText;
                var pushNum = 0;
                var checkWhile = 0;
                var checkCount = 100;

                while (width > maxWidth && checkWhile++ < checkCount) {
                  fuzzyLen *= maxWidth / width;
                  fuzzyLen |= 0;
                  tmpText = _safeSubstring(text, fuzzyLen);
                  width = allWidth - measureText(tmpText);
                }

                checkWhile = 0;

                while (tmpText && width <= maxWidth && checkWhile++ < checkCount) {
                  var exec = WORD_REG.exec(tmpText);
                  pushNum = exec ? exec[0].length : 1;
                  sLine = tmpText;
                  fuzzyLen += pushNum;
                  tmpText = _safeSubstring(text, fuzzyLen);
                  width = allWidth - measureText(tmpText);
                }

                fuzzyLen -= pushNum;

                if (fuzzyLen === 0) {
                  fuzzyLen = 1;
                  sLine = _safeSubstring(text, 1);
                } else if (fuzzyLen === 1 && text[0] >= "\uD800" && text[0] <= "\uDBFF") {
                  fuzzyLen = 2;
                  sLine = _safeSubstring(text, 2);
                }

                var sText = _safeSubstring(text, 0, fuzzyLen);

                var result = void 0;

                {
                  if (SYMBOL_REG.test(sLine || tmpText)) {
                    result = LAST_WORD_REG.exec(sText);
                    fuzzyLen -= result ? result[0].length : 0;

                    if (fuzzyLen === 0) {
                      fuzzyLen = 1;
                    }

                    sLine = _safeSubstring(text, fuzzyLen);
                    sText = _safeSubstring(text, 0, fuzzyLen);
                  }
                }

                if (FIRST_ENGLISH_REG.test(sLine)) {
                  result = LAST_ENGLISH_REG.exec(sText);

                  if (result && sText !== result[0]) {
                    fuzzyLen -= result[0].length;
                    sLine = _safeSubstring(text, fuzzyLen);
                    sText = _safeSubstring(text, 0, fuzzyLen);
                  }
                }

                if (wrappedWords.length === 0) {
                  wrappedWords.push(sText);
                } else {
                  sText = sText.trim();

                  if (sText.length > 0) {
                    wrappedWords.push(sText);
                  }
                }

                text = sLine || tmpText;
                allWidth = measureText(text);
              }

              if (wrappedWords.length === 0) {
                wrappedWords.push(text);
              } else {
                text = text.trim();

                if (text.length > 0) {
                  wrappedWords.push(text);
                }
              }

              return wrappedWords;
            }

            var _canvasPool;

            var CanvasPool = function () {
              function CanvasPool() {
                this.pool = [];
              }

              CanvasPool.getInstance = function getInstance() {
                if (!_canvasPool) {
                  _canvasPool = new CanvasPool();
                }

                return _canvasPool;
              };

              var _proto = CanvasPool.prototype;

              _proto.get = function get() {
                var data = this.pool.pop();

                if (!data) {
                  var canvas = ccwindow.document.createElement('canvas');
                  var context = canvas.getContext('2d');
                  data = {
                    canvas: canvas,
                    context: context
                  };
                }

                return data;
              };

              _proto.put = function put(canvas) {
                if (this.pool.length >= macro.MAX_LABEL_CANVAS_POOL_SIZE) {
                  return;
                }

                this.pool.push(canvas);
              };

              return CanvasPool;
            }();
            var WHITE = Color$1.WHITE.clone();
            var space$1 = 0;
            var bleed = 2;

            var FontLetterDefinition$1 = function FontLetterDefinition() {
              this.u = 0;
              this.v = 0;
              this.w = 0;
              this.h = 0;
              this.texture = null;
              this.offsetX = 0;
              this.offsetY = 0;
              this.valid = false;
              this.xAdvance = 0;
            };

            var _backgroundStyle = "rgba(255, 255, 255, " + (1 / 255).toFixed(3) + ")";

            var BASELINE_OFFSET = getBaselineOffset();

            var LetterTexture = function () {
              function LetterTexture(_char, labelInfo) {
                this.image = null;
                this.labelInfo = void 0;
                this["char"] = void 0;
                this.data = null;
                this.canvas = null;
                this.context = null;
                this.width = 0;
                this.height = 0;
                this.offsetY = 0;
                this.hash = void 0;
                this["char"] = _char;
                this.labelInfo = labelInfo;
                this.hash = "" + _char.charCodeAt(0) + labelInfo.hash;
              }

              var _proto2 = LetterTexture.prototype;

              _proto2.updateRenderData = function updateRenderData() {
                this._updateProperties();

                this._updateTexture();
              };

              _proto2.destroy = function destroy() {
                this.image = null;
                CanvasPool.getInstance().put(this.data);
              };

              _proto2._updateProperties = function _updateProperties() {
                this.data = CanvasPool.getInstance().get();
                this.canvas = this.data.canvas;
                this.context = this.data.context;

                if (this.context) {
                  this.context.font = this.labelInfo.fontDesc;
                  var width = safeMeasureText(this.context, this["char"], this.labelInfo.fontDesc);
                  var blank = this.labelInfo.margin * 2 + bleed;
                  this.width = parseFloat(width.toFixed(2)) + blank;
                  this.height = (1 + BASELINE_RATIO) * this.labelInfo.fontSize + blank;
                  this.offsetY = -(this.labelInfo.fontSize * BASELINE_RATIO) / 2;
                }

                if (this.canvas.width !== this.width) {
                  this.canvas.width = this.width;
                }

                if (this.canvas.height !== this.height) {
                  this.canvas.height = this.height;
                }

                if (!this.image) {
                  this.image = new ImageAsset();
                }

                this.image.reset(this.canvas);
              };

              _proto2._updateTexture = function _updateTexture() {
                if (!this.context || !this.canvas) {
                  return;
                }

                var context = this.context;
                var labelInfo = this.labelInfo;
                var width = this.canvas.width;
                var height = this.canvas.height;
                context.textAlign = 'center';
                context.textBaseline = 'alphabetic';
                context.clearRect(0, 0, width, height);
                context.fillStyle = _backgroundStyle;
                context.fillRect(0, 0, width, height);
                context.font = labelInfo.fontDesc;
                var fontSize = labelInfo.fontSize;
                var startX = width / 2;
                var startY = height / 2 + fontSize * MIDDLE_RATIO + fontSize * BASELINE_OFFSET;
                var color = labelInfo.color;
                context.lineJoin = 'round';
                context.fillStyle = "rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + 1 + ")";

                if (labelInfo.isOutlined) {
                  var strokeColor = labelInfo.out || WHITE;
                  context.strokeStyle = "rgba(" + strokeColor.r + ", " + strokeColor.g + ", " + strokeColor.b + ", " + strokeColor.a / 255 + ")";
                  context.lineWidth = labelInfo.margin * 2;
                  context.strokeText(this["char"], startX, startY);
                }

                context.fillText(this["char"], startX, startY);
              };

              return LetterTexture;
            }();

            var LetterRenderTexture = function (_Texture2D) {
              _inheritsLoose(LetterRenderTexture, _Texture2D);

              function LetterRenderTexture() {
                return _Texture2D.apply(this, arguments) || this;
              }

              var _proto3 = LetterRenderTexture.prototype;

              _proto3.initWithSize = function initWithSize(width, height, format) {
                if (format === void 0) {
                  format = PixelFormat.RGBA8888;
                }

                this.reset({
                  width: width,
                  height: height,
                  format: format
                });
              };

              _proto3.drawTextureAt = function drawTextureAt(image, x, y) {
                var gfxTexture = this.getGFXTexture();

                if (!image || !gfxTexture) {
                  return;
                }

                var gfxDevice = this._getGFXDevice();

                if (!gfxDevice) {
                  console.warn('Unable to get device');
                  return;
                }

                var region = new BufferTextureCopy();
                region.texOffset.x = x;
                region.texOffset.y = y;
                region.texExtent.width = image.width;
                region.texExtent.height = image.height;
                gfxDevice.copyTexImagesToTexture([image.data], gfxTexture, [region]);
              };

              return LetterRenderTexture;
            }(Texture2D);
            var LetterAtlas = function () {
              function LetterAtlas(width, height) {
                this._x = space$1;
                this._y = space$1;
                this._nextY = space$1;
                this._width = 0;
                this._height = 0;
                this._halfBleed = 0;
                this._dirty = false;
                var texture = new LetterRenderTexture();
                texture.initWithSize(width, height);
                this.fontDefDictionary = new FontAtlas(texture);
                this._halfBleed = bleed / 2;
                this._width = width;
                this._height = height;
                director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
              }

              var _proto4 = LetterAtlas.prototype;

              _proto4.insertLetterTexture = function insertLetterTexture(letterTexture) {
                var texture = letterTexture.image;
                var device = director.root.device;

                if (!texture || !this.fontDefDictionary || !device) {
                  return null;
                }

                var width = texture.width;
                var height = texture.height;

                if (this._x + width + space$1 > this._width) {
                  this._x = space$1;
                  this._y = this._nextY;
                }

                if (this._y + height > this._nextY) {
                  this._nextY = this._y + height + space$1;
                }

                if (this._nextY > this._height) {
                  warnID(12100);
                  return null;
                }

                this.fontDefDictionary.texture.drawTextureAt(texture, this._x, this._y);
                this._dirty = true;
                var letterDefinition = new FontLetterDefinition$1();
                letterDefinition.u = this._x + this._halfBleed;
                letterDefinition.v = this._y + this._halfBleed;
                letterDefinition.texture = this.fontDefDictionary.texture;
                letterDefinition.valid = true;
                letterDefinition.w = letterTexture.width - bleed;
                letterDefinition.h = letterTexture.height - bleed;
                letterDefinition.xAdvance = letterDefinition.w;
                letterDefinition.offsetY = letterTexture.offsetY;
                this._x += width + space$1;
                this.fontDefDictionary.addLetterDefinitions(letterTexture.hash, letterDefinition);
                return letterDefinition;
              };

              _proto4.update = function update() {
                if (!this._dirty) {
                  return;
                }

                this._dirty = false;
              };

              _proto4.reset = function reset() {
                this._x = space$1;
                this._y = space$1;
                this._nextY = space$1;
                this.fontDefDictionary.clear();
              };

              _proto4.destroy = function destroy() {
                this.reset();

                if (this.fontDefDictionary) {
                  this.fontDefDictionary.texture.destroy();
                  this.fontDefDictionary.texture = null;
                }
              };

              _proto4.getTexture = function getTexture() {
                return this.fontDefDictionary.getTexture();
              };

              _proto4.beforeSceneLoad = function beforeSceneLoad() {
                this.clearAllCache();
              };

              _proto4.clearAllCache = function clearAllCache() {
                this.destroy();
                var texture = new LetterRenderTexture();
                texture.initWithSize(this._width, this._height);
                this.fontDefDictionary.texture = texture;
              };

              _proto4.getLetter = function getLetter(key) {
                return this.fontDefDictionary.letterDefinitions[key];
              };

              _proto4.getLetterDefinitionForChar = function getLetterDefinitionForChar(_char2, labelInfo) {
                var hash = _char2.charCodeAt(0) + labelInfo.hash;
                var letter = this.fontDefDictionary.letterDefinitions[hash];

                if (!letter) {
                  var temp = new LetterTexture(_char2, labelInfo);
                  temp.updateRenderData();
                  letter = this.insertLetterTexture(temp);
                  temp.destroy();
                }

                return letter;
              };

              _createClass(LetterAtlas, [{
                key: "width",
                get: function get() {
                  return this._width;
                }
              }, {
                key: "height",
                get: function get() {
                  return this._height;
                }
              }]);

              return LetterAtlas;
            }();
            var shareLabelInfo = {
              fontAtlas: null,
              fontSize: 0,
              lineHeight: 0,
              hAlign: 0,
              vAlign: 0,
              hash: '',
              fontFamily: '',
              fontDesc: 'Arial',
              color: Color$1.WHITE.clone(),
              isOutlined: false,
              out: Color$1.WHITE.clone(),
              margin: 0
            };
            function computeHash(labelInfo) {
              var hashData = '';
              var color = labelInfo.color.toHEX();
              var out = '';

              if (labelInfo.isOutlined && labelInfo.margin > 0) {
                out = out + labelInfo.margin + labelInfo.out.toHEX();
              }

              return hashData + labelInfo.fontSize + labelInfo.fontFamily + color + out;
            }

            var vfmt = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F)];
            var vfmtPosColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
            var vfmtPosUvColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
            var vfmtPosUvColor4B = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true)];
            var vfmtPosUvTwoColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F), new Attribute(AttributeName.ATTR_COLOR2, Format.RGBA32F)];
            var vfmtPosUvTwoColor4B = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true), new Attribute(AttributeName.ATTR_COLOR2, Format.RGBA8, true)];
            function getComponentPerVertex(attrs) {
              var count = 0;

              for (var i = 0; i < attrs.length; i++) {
                var attr = attrs[i];
                var info = FormatInfos[attr.format];
                count += info.count;
              }

              return count;
            }
            function getAttributeStride(attrs) {
              var count = 0;

              for (var i = 0; i < attrs.length; i++) {
                var attr = attrs[i];
                var info = FormatInfos[attr.format];
                count += info.size;
              }

              return count;
            }
            legacyCC.internal.vfmtPosUvColor = vfmtPosUvColor;
            legacyCC.internal.vfmtPosUvTwoColor = vfmtPosUvTwoColor;
            legacyCC.internal.vfmtPosUvColor4B = vfmtPosUvColor4B;
            legacyCC.internal.vfmtPosUvTwoColor4B = vfmtPosUvTwoColor4B;

            var MeshBufferSharedBufferView;

            (function (MeshBufferSharedBufferView) {
              MeshBufferSharedBufferView[MeshBufferSharedBufferView["byteOffset"] = 0] = "byteOffset";
              MeshBufferSharedBufferView[MeshBufferSharedBufferView["vertexOffset"] = 1] = "vertexOffset";
              MeshBufferSharedBufferView[MeshBufferSharedBufferView["indexOffset"] = 2] = "indexOffset";
              MeshBufferSharedBufferView[MeshBufferSharedBufferView["dirty"] = 3] = "dirty";
              MeshBufferSharedBufferView[MeshBufferSharedBufferView["count"] = 4] = "count";
            })(MeshBufferSharedBufferView || (MeshBufferSharedBufferView = {}));

            var IA_POOL_USED_SCALE = 1 / 2;
            var MeshBuffer = exports('MeshBuffer', function () {
              var _proto = MeshBuffer.prototype;

              _proto.initSharedBuffer = function initSharedBuffer() {
              };

              _proto.syncSharedBufferToNative = function syncSharedBufferToNative() {
              };

              function MeshBuffer() {
                this._byteOffset = 0;
                this._vertexOffset = 0;
                this._indexOffset = 0;
                this._dirty = false;
                this._floatsPerVertex = 0;
                this._vData = null;
                this._iData = null;
                this._vertexFormatBytes = 0;
                this._initVDataCount = 0;
                this._initIDataCount = 0;
                this._attributes = null;
                this._iaPool = [];
                this._iaInfo = null;
                this._nextFreeIAHandle = 0;

                this.initSharedBuffer();
                this.syncSharedBufferToNative();
              }

              _proto.initialize = function initialize(device, attrs, vFloatCount, iCount) {
                this._initVDataCount = vFloatCount;
                this._initIDataCount = iCount;
                this._attributes = attrs;
                this.floatsPerVertex = getAttributeStride(attrs) >> 2;
                assertIsTrue(this._initVDataCount / this._floatsPerVertex < 65536, getError(9005));

                if (!this.vData || !this.iData) {
                  this.vData = new Float32Array(this._initVDataCount);
                  this.iData = new Uint16Array(this._initIDataCount);
                }

                this._iaPool.push(this.createNewIA(device));
              };

              _proto.reset = function reset() {
                this._nextFreeIAHandle = 0;
                this.dirty = false;
              };

              _proto.destroy = function destroy() {
                this.reset();
                this._attributes = null;
                this._iaInfo = null;
                this.vData = null;
                this.iData = null;

                for (var i = 0; i < this._iaPool.length; ++i) {
                  var iaRef = this._iaPool[i];

                  if (iaRef.vertexBuffers[0]) {
                    iaRef.vertexBuffers[0].destroy();
                  }

                  if (iaRef.indexBuffer) {
                    iaRef.indexBuffer.destroy();
                  }

                  iaRef.ia.destroy();
                }

                this._iaPool.length = 0;
              };

              _proto.setDirty = function setDirty() {
                this.dirty = true;
              };

              _proto.request = function request(vertexCount, indexCount) {
                warnID(9002);
                return false;
              };

              _proto.requireFreeIA = function requireFreeIA(device) {
                if (this._iaPool.length <= this._nextFreeIAHandle) {
                  this._iaPool.push(this.createNewIA(device));
                }

                var ia = this._iaPool[this._nextFreeIAHandle++].ia;
                return ia;
              };

              _proto.recycleIA = function recycleIA(ia) {
                var pool = this._iaPool;

                for (var i = 0; i < this._nextFreeIAHandle; ++i) {
                  if (ia === pool[i].ia) {
                    var iaRef = pool[i];
                    pool[i] = pool[--this._nextFreeIAHandle];
                    pool[this._nextFreeIAHandle] = iaRef;
                    return;
                  }
                }
              };

              _proto.checkCapacity = function checkCapacity(vertexCount, indexCount) {
                var maxVertex = (this.vertexOffset + vertexCount) * this._floatsPerVertex;
                var maxIndex = this.indexOffset + indexCount;

                if (maxVertex > this._initVDataCount || maxIndex > this._initIDataCount) {
                  return false;
                }

                return true;
              };

              _proto.uploadBuffers = function uploadBuffers() {
                if (this.byteOffset === 0 || !this._dirty) {
                  return;
                }

                var iOS14 = sys.__isWebIOS14OrIPadOS14Env;
                var submitCount = iOS14 ? this._nextFreeIAHandle : 1;

                if (iOS14 && submitCount / this._iaPool.length < IA_POOL_USED_SCALE) {
                  var count = submitCount / IA_POOL_USED_SCALE;
                  var length = this._iaPool.length;

                  for (var i = length - 1; i >= count; i--) {
                    var iaRef = this._iaPool[i];

                    if (iaRef.vertexBuffers[0]) {
                      iaRef.vertexBuffers[0].destroy();
                    }

                    if (iaRef.indexBuffer) {
                      iaRef.indexBuffer.destroy();
                    }

                    iaRef.ia.destroy();
                  }

                  this._iaPool.length = count;
                }

                var byteCount = this.byteOffset;
                var indexCount = this.indexOffset;

                for (var _i = 0; _i < submitCount; ++_i) {
                  var _iaRef = this._iaPool[_i];
                  var verticesData = new Float32Array(this.vData.buffer, 0, byteCount >> 2);
                  var indicesData = new Uint16Array(this.iData.buffer, 0, indexCount);
                  var vertexBuffer = _iaRef.vertexBuffers[0];

                  if (byteCount > vertexBuffer.size) {
                    vertexBuffer.resize(byteCount);
                  }

                  vertexBuffer.update(verticesData);

                  if (indexCount * 2 > _iaRef.indexBuffer.size) {
                    _iaRef.indexBuffer.resize(indexCount * 2);
                  }

                  _iaRef.indexBuffer.update(indicesData);
                }

                this.dirty = false;
              };

              _proto.createNewIA = function createNewIA(device) {
                var ia;
                var vertexBuffers;
                var indexBuffer;

                if (sys.__isWebIOS14OrIPadOS14Env || !this._iaPool[0]) {
                  var vbStride = this._vertexFormatBytes = this._floatsPerVertex * Float32Array.BYTES_PER_ELEMENT;
                  var ibStride = Uint16Array.BYTES_PER_ELEMENT;
                  var vertexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, vbStride, vbStride));
                  indexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, ibStride, ibStride));
                  vertexBuffers = [vertexBuffer];
                  this._iaInfo = new InputAssemblerInfo(this._attributes, vertexBuffers, indexBuffer);
                  ia = device.createInputAssembler(this._iaInfo);
                } else {
                  ia = device.createInputAssembler(this._iaInfo);
                  vertexBuffers = this._iaInfo.vertexBuffers;
                  indexBuffer = this._iaInfo.indexBuffer;
                }

                return {
                  ia: ia,
                  vertexBuffers: vertexBuffers,
                  indexBuffer: indexBuffer
                };
              };

              _createClass(MeshBuffer, [{
                key: "attributes",
                get: function get() {
                  return this._attributes;
                }
              }, {
                key: "vertexFormatBytes",
                get: function get() {
                  return this._vertexFormatBytes;
                }
              }, {
                key: "byteOffset",
                get: function get() {
                  return this._byteOffset;
                },
                set: function set(val) {
                  this._byteOffset = val;
                }
              }, {
                key: "vertexOffset",
                get: function get() {
                  return this._vertexOffset;
                },
                set: function set(val) {
                  this._vertexOffset = val;
                }
              }, {
                key: "indexOffset",
                get: function get() {
                  return this._indexOffset;
                },
                set: function set(val) {
                  this._indexOffset = val;
                }
              }, {
                key: "dirty",
                get: function get() {
                  return this._dirty;
                },
                set: function set(val) {
                  this._dirty = val;
                }
              }, {
                key: "floatsPerVertex",
                get: function get() {
                  return this._floatsPerVertex;
                },
                set: function set(val) {
                  this._floatsPerVertex = val;
                }
              }, {
                key: "vData",
                get: function get() {
                  return this._vData;
                },
                set: function set(val) {
                  this._vData = val;
                }
              }, {
                key: "iData",
                get: function get() {
                  return this._iData;
                },
                set: function set(val) {
                  this._iData = val;
                }
              }, {
                key: "nativeObj",
                get: function get() {
                  return this._nativeObj;
                }
              }, {
                key: "sharedBuffer",
                get: function get() {
                  return this._sharedBuffer;
                }
              }]);

              return MeshBuffer;
            }());

            var BufferAccessor = function () {
              function BufferAccessor(device, attributes) {
                this._device = null;
                this._attributes = null;
                this._vertexFormatBytes = void 0;
                this._floatsPerVertex = void 0;
                this._buffers = [];
                this._device = device;
                this._attributes = attributes;
                this._floatsPerVertex = getAttributeStride(attributes) >> 2;
                this._vertexFormatBytes = this._floatsPerVertex * Float32Array.BYTES_PER_ELEMENT;
              }

              var _proto = BufferAccessor.prototype;

              _proto.initialize = function initialize() {};

              _proto.reset = function reset() {};

              _proto.request = function request(vertexCount, indexCount) {
              };

              _proto.appendBuffers = function appendBuffers(vertices, indices) {};

              _proto.uploadBuffers = function uploadBuffers() {};

              _proto.destroy = function destroy() {
                this._attributes.length = 0;
              };

              _createClass(BufferAccessor, [{
                key: "attributes",
                get: function get() {
                  return this._attributes;
                }
              }, {
                key: "vertexFormatBytes",
                get: function get() {
                  return this._vertexFormatBytes;
                }
              }, {
                key: "floatsPerVertex",
                get: function get() {
                  return this._floatsPerVertex;
                }
              }]);

              return BufferAccessor;
            }();

            var _entryPool = new Pool(function () {
              return {
                offset: 0,
                length: 0
              };
            }, 32);

            var StaticVBChunk = function () {
              function StaticVBChunk(vertexAccessor, bufferId, meshBuffer, vertexOffset, vb, indexCount) {
                this._ib = void 0;
                this.vertexAccessor = vertexAccessor;
                this.bufferId = bufferId;
                this.meshBuffer = meshBuffer;
                this.vertexOffset = vertexOffset;
                this.vb = vb;
                this.indexCount = indexCount;
                this._ib = new Uint16Array(indexCount);
                assertIsTrue(meshBuffer === vertexAccessor.getMeshBuffer(bufferId));
              }

              var _proto = StaticVBChunk.prototype;

              _proto.setIndexBuffer = function setIndexBuffer(indices) {
              };

              _createClass(StaticVBChunk, [{
                key: "ib",
                get: function get() {
                  return this._ib;
                }
              }]);

              return StaticVBChunk;
            }();
            var StaticVBAccessor = function (_BufferAccessor) {
              _inheritsLoose(StaticVBAccessor, _BufferAccessor);

              function StaticVBAccessor(device, attributes, vCount, iCount) {
                var _this;

                _this = _BufferAccessor.call(this, device, attributes) || this;
                _this._freeLists = [];
                _this._vCount = 0;
                _this._iCount = 0;
                _this._id = 0;
                _this._vCount = vCount || Math.floor(macro.BATCHER2D_MEM_INCREMENT * 1024 / _this._vertexFormatBytes);
                _this._iCount = iCount || _this._vCount * StaticVBAccessor.IB_SCALE;
                _this._id = StaticVBAccessor.generateID();

                _this._allocateBuffer();

                return _this;
              }

              var _proto2 = StaticVBAccessor.prototype;

              _proto2.destroy = function destroy() {
                for (var i = 0; i < this._buffers.length; ++i) {
                  this._buffers[i].destroy();

                  var freeList = this._freeLists[i];

                  for (var j = 0; j < freeList.length; ++j) {
                    _entryPool.free(freeList[j]);
                  }
                }

                this._buffers.length = 0;
                this._freeLists.length = 0;

                _BufferAccessor.prototype.destroy.call(this);
              };

              _proto2.reset = function reset() {
                for (var i = 0; i < this._buffers.length; ++i) {
                  var buffer = this._buffers[i];
                  buffer.indexOffset = 0;
                  buffer.reset();
                }
              };

              _proto2.getVertexBuffer = function getVertexBuffer(bid) {
                return this._buffers[bid].vData;
              };

              _proto2.getIndexBuffer = function getIndexBuffer(bid) {
                return this._buffers[bid].iData;
              };

              _proto2.getMeshBuffer = function getMeshBuffer(bid) {
                return this._buffers[bid];
              };

              _proto2.uploadBuffers = function uploadBuffers() {
                for (var i = 0; i < this._buffers.length; ++i) {
                  var firstEntry = this._freeLists[i][0];
                  var buffer = this._buffers[i];

                  if (!firstEntry || firstEntry.length < buffer.vData.byteLength) {
                    buffer.uploadBuffers();
                  }
                }
              };

              _proto2.appendIndices = function appendIndices(bufferId, indices) {
                var buf = this._buffers[bufferId];
                var iCount = indices.length;

                if (iCount) {
                  var needLength = buf.indexOffset + indices.length;

                  if (buf.iData.length < needLength) {
                    var expansionLength = Math.floor(1.25 * needLength);
                    var newIData = new Uint16Array(expansionLength);
                    newIData.set(buf.iData);
                    buf.iData = newIData;
                  }

                  buf.iData.set(indices, buf.indexOffset);
                  buf.indexOffset += indices.length;
                }
              };

              _proto2.allocateChunk = function allocateChunk(vertexCount, indexCount) {
                var byteLength = vertexCount * this.vertexFormatBytes;
                var buf = null;
                var freeList;
                var bid = 0;
                var eid = -1;
                var entry = null;

                for (var i = 0; i < this._buffers.length; ++i) {
                  buf = this._buffers[i];
                  freeList = this._freeLists[i];

                  for (var e = 0; e < freeList.length; ++e) {
                    if (freeList[e].length >= byteLength) {
                      entry = freeList[e];
                      bid = i;
                      eid = e;
                      break;
                    }
                  }

                  if (entry) break;
                }

                if (!entry) {
                  bid = this._allocateBuffer();
                  buf = this._buffers[bid];

                  if (buf && buf.checkCapacity(vertexCount, indexCount)) {
                    eid = 0;
                    entry = this._freeLists[bid][eid];
                  }
                }

                if (entry) {
                  var _vertexOffset = entry.offset / this.vertexFormatBytes;

                  assertIsTrue(Number.isInteger(_vertexOffset));

                  var _vb = new Float32Array(buf.vData.buffer, entry.offset, byteLength >> 2).fill(0);

                  this._allocateChunkFromEntry(bid, eid, entry, byteLength);

                  return new StaticVBChunk(this, bid, buf, _vertexOffset, _vb, indexCount);
                } else {
                  errorID(9004, byteLength);
                  return null;
                }
              };

              _proto2.recycleChunk = function recycleChunk(chunk) {
                var freeList = this._freeLists[chunk.bufferId];
                var buf = this._buffers[chunk.bufferId];
                var offset = chunk.vertexOffset * this.vertexFormatBytes;
                var bytes = chunk.vb.byteLength;
                if (bytes === 0) return;
                var recycled = false;
                var i = 0;
                var prevEntry = null;
                var nextEntry = freeList[i];

                while (nextEntry && nextEntry.offset < offset) {
                  prevEntry = nextEntry;
                  nextEntry = freeList[++i];
                }

                if (prevEntry) {
                  var distance = offset - (prevEntry.offset + prevEntry.length);
                  assertIsTrue(distance >= 0);

                  if (distance === 0) {
                    prevEntry.length += bytes;
                    offset = prevEntry.offset;
                    bytes = prevEntry.length;

                    if (nextEntry && nextEntry.offset - (offset + bytes) === 0) {
                      prevEntry.length += nextEntry.length;
                      freeList.splice(i, 1);

                      _entryPool.free(nextEntry);

                      nextEntry = null;
                    }

                    recycled = true;
                  }
                }

                if (!recycled && nextEntry) {
                  var _distance = nextEntry.offset - (offset + bytes);

                  assertIsTrue(_distance >= 0);

                  if (_distance === 0) {
                    nextEntry.offset = offset;
                    nextEntry.length += bytes;
                  } else {
                    var newEntry = _entryPool.alloc();

                    newEntry.offset = offset;
                    newEntry.length = bytes;
                    freeList.splice(i, 0, newEntry);
                  }

                  recycled = true;
                }

                if (recycled) {
                  if (offset + bytes === buf.byteOffset) {
                    buf.byteOffset = offset;
                  }
                } else {
                  var _newEntry = _entryPool.alloc();

                  _newEntry.offset = offset;
                  _newEntry.length = bytes;
                  freeList.push(_newEntry);
                }
              };

              _proto2._allocateChunkFromEntry = function _allocateChunkFromEntry(bid, eid, entry, bytes) {
                var remaining = entry.length - bytes;
                var offset = entry.offset + bytes;
                var buf = this._buffers[bid];

                if (buf.byteOffset < offset) {
                  buf.byteOffset = offset;
                }

                assertID(remaining >= 0, 9004, bid, entry.offset, entry.length);

                if (remaining === 0) {
                  this._freeLists[bid].splice(eid, 1);

                  _entryPool.free(entry);
                } else {
                  entry.offset += bytes;
                  entry.length = remaining;
                }
              };

              _proto2._allocateBuffer = function _allocateBuffer() {
                assertID(this._buffers.length === this._freeLists.length, 9003);
                var buffer = new MeshBuffer();
                var vFloatCount = this._vCount * this._floatsPerVertex;
                buffer.initialize(this._device, this._attributes, vFloatCount, this._iCount);

                this._buffers.push(buffer);

                var entry = _entryPool.alloc();

                entry.offset = 0;
                entry.length = buffer.vData.byteLength;
                var freeList = [entry];

                this._freeLists.push(freeList);

                var batcher = director.root.batcher2D;
                batcher.syncMeshBuffersToNative(this.id, this._buffers);
                return this._buffers.length - 1;
              };

              StaticVBAccessor.generateID = function generateID() {
                return StaticVBAccessor.ID_COUNT++;
              };

              _createClass(StaticVBAccessor, [{
                key: "id",
                get: function get() {
                  return this._id;
                }
              }]);

              return StaticVBAccessor;
            }(BufferAccessor);
            StaticVBAccessor.IB_SCALE = 4;
            StaticVBAccessor.ID_COUNT = 0;

            var AttrUInt8ArrayView;

            (function (AttrUInt8ArrayView) {
              AttrUInt8ArrayView[AttrUInt8ArrayView["DrawInfoType"] = 0] = "DrawInfoType";
              AttrUInt8ArrayView[AttrUInt8ArrayView["VertDirty"] = 1] = "VertDirty";
              AttrUInt8ArrayView[AttrUInt8ArrayView["IsMeshBuffer"] = 2] = "IsMeshBuffer";
              AttrUInt8ArrayView[AttrUInt8ArrayView["Stride"] = 3] = "Stride";
              AttrUInt8ArrayView[AttrUInt8ArrayView["Count"] = 4] = "Count";
            })(AttrUInt8ArrayView || (AttrUInt8ArrayView = {}));

            var AttrUInt16ArrayView;

            (function (AttrUInt16ArrayView) {
              AttrUInt16ArrayView[AttrUInt16ArrayView["BufferID"] = 0] = "BufferID";
              AttrUInt16ArrayView[AttrUInt16ArrayView["AccessorID"] = 1] = "AccessorID";
              AttrUInt16ArrayView[AttrUInt16ArrayView["Count"] = 2] = "Count";
            })(AttrUInt16ArrayView || (AttrUInt16ArrayView = {}));

            var AttrUInt32ArrayView;

            (function (AttrUInt32ArrayView) {
              AttrUInt32ArrayView[AttrUInt32ArrayView["VertexOffset"] = 0] = "VertexOffset";
              AttrUInt32ArrayView[AttrUInt32ArrayView["IndexOffset"] = 1] = "IndexOffset";
              AttrUInt32ArrayView[AttrUInt32ArrayView["VBCount"] = 2] = "VBCount";
              AttrUInt32ArrayView[AttrUInt32ArrayView["IBCount"] = 3] = "IBCount";
              AttrUInt32ArrayView[AttrUInt32ArrayView["DataHash"] = 4] = "DataHash";
              AttrUInt32ArrayView[AttrUInt32ArrayView["Count"] = 5] = "Count";
            })(AttrUInt32ArrayView || (AttrUInt32ArrayView = {}));

            var RenderDrawInfoType;

            (function (RenderDrawInfoType) {
              RenderDrawInfoType[RenderDrawInfoType["COMP"] = 0] = "COMP";
              RenderDrawInfoType[RenderDrawInfoType["MODEL"] = 1] = "MODEL";
              RenderDrawInfoType[RenderDrawInfoType["MIDDLEWARE"] = 2] = "MIDDLEWARE";
              RenderDrawInfoType[RenderDrawInfoType["SUB_NODE"] = 3] = "SUB_NODE";
            })(RenderDrawInfoType || (RenderDrawInfoType = {}));

            var RenderDrawInfo = function () {
              function RenderDrawInfo(nativeDrawInfo) {
                this._accId = -1;
                this._bufferId = -1;
                this._vertexOffset = 0;
                this._indexOffset = 0;
                this._vb = null;
                this._ib = null;
                this._vData = null;
                this._iData = null;
                this._vertDirty = false;
                this._vbCount = 0;
                this._ibCount = 0;
                this._dataHash = 0;
                this._isMeshBuffer = false;
                this._material = null;
                this._texture = null;
                this._sampler = null;
                this._stride = 0;
                this._useLocal = false;
                this._model = null;
                this._drawInfoType = RenderDrawInfoType.COMP;
                this._subNode = null;
                this._uint8SharedBuffer = void 0;
                this._uint16SharedBuffer = void 0;
                this._uint32SharedBuffer = void 0;
                this.init(nativeDrawInfo);

                var attrSharedBuffer = this._nativeObj.getAttrSharedBufferForJS();

                var offset = 0;
                this._uint8SharedBuffer = new Uint8Array(attrSharedBuffer, offset, AttrUInt8ArrayView.Count);
                offset += AttrUInt8ArrayView.Count * Uint8Array.BYTES_PER_ELEMENT;
                this._uint16SharedBuffer = new Uint16Array(attrSharedBuffer, offset, AttrUInt16ArrayView.Count);
                offset += AttrUInt16ArrayView.Count * Uint16Array.BYTES_PER_ELEMENT;
                this._uint32SharedBuffer = new Uint32Array(attrSharedBuffer, offset, AttrUInt32ArrayView.Count);
              }

              var _proto = RenderDrawInfo.prototype;

              _proto.init = function init(nativeDrawInfo) {
              };

              _proto.clear = function clear() {
                this._bufferId = 0;
                this._vertexOffset = 0;
                this._indexOffset = 0;
                this._vertDirty = false;
              };

              _proto.setAccId = function setAccId(accId) {

                this._accId = accId;
              };

              _proto.setBufferId = function setBufferId(bufferId) {

                this._bufferId = bufferId;
              };

              _proto.setAccAndBuffer = function setAccAndBuffer(accId, bufferId) {

                this._bufferId = bufferId;
                this._accId = accId;
              };

              _proto.setVertexOffset = function setVertexOffset(vertexOffset) {
                this._vertexOffset = vertexOffset;
              };

              _proto.setIndexOffset = function setIndexOffset(indexOffset) {
                this._indexOffset = indexOffset;
              };

              _proto.setVB = function setVB(vbBuffer) {
              };

              _proto.setIB = function setIB(ibBuffer) {
              };

              _proto.setVData = function setVData(vDataBuffer) {
              };

              _proto.setIData = function setIData(iDataBuffer) {
              };

              _proto.setVBCount = function setVBCount(vbCount) {

                this._vbCount = vbCount;
              };

              _proto.setIBCount = function setIBCount(ibCount) {
              };

              _proto.setVertDirty = function setVertDirty(val) {

                this._vertDirty = val;
              };

              _proto.setDataHash = function setDataHash(dataHash) {

                this._dataHash = dataHash;
              };

              _proto.setIsMeshBuffer = function setIsMeshBuffer(isMeshBuffer) {

                this._isMeshBuffer = isMeshBuffer;
              };

              _proto.setMaterial = function setMaterial(material) {

                this._material = material;
              };

              _proto.setTexture = function setTexture(texture) {

                this._texture = texture;
              };

              _proto.setSampler = function setSampler(sampler) {

                this._sampler = sampler;
              };

              _proto.setModel = function setModel(model) {
              };

              _proto.setDrawInfoType = function setDrawInfoType(drawInfoType) {

                this._drawInfoType = drawInfoType;
              };

              _proto.setSubNode = function setSubNode(node) {

                this._subNode = node;
              };

              _proto.setStride = function setStride(stride) {

                this._stride = stride;
              };

              _proto.initRender2dBuffer = function initRender2dBuffer() {
              };

              _proto.fillRender2dBuffer = function fillRender2dBuffer(vertexDataArr) {
              };

              _createClass(RenderDrawInfo, [{
                key: "nativeObj",
                get: function get() {
                  return this._nativeObj;
                }
              }, {
                key: "render2dBuffer",
                get: function get() {
                  return this._render2dBuffer;
                }
              }]);

              return RenderDrawInfo;
            }();

            var Stage;

            (function (Stage) {
              Stage[Stage["DISABLED"] = 0] = "DISABLED";
              Stage[Stage["CLEAR"] = 1] = "CLEAR";
              Stage[Stage["ENTER_LEVEL"] = 2] = "ENTER_LEVEL";
              Stage[Stage["ENABLED"] = 3] = "ENABLED";
              Stage[Stage["EXIT_LEVEL"] = 4] = "EXIT_LEVEL";
              Stage[Stage["CLEAR_INVERTED"] = 5] = "CLEAR_INVERTED";
              Stage[Stage["ENTER_LEVEL_INVERTED"] = 6] = "ENTER_LEVEL_INVERTED";
            })(Stage || (Stage = {}));

            var StencilSharedBufferView;

            (function (StencilSharedBufferView) {
              StencilSharedBufferView[StencilSharedBufferView["stencilTest"] = 0] = "stencilTest";
              StencilSharedBufferView[StencilSharedBufferView["func"] = 1] = "func";
              StencilSharedBufferView[StencilSharedBufferView["stencilMask"] = 2] = "stencilMask";
              StencilSharedBufferView[StencilSharedBufferView["writeMask"] = 3] = "writeMask";
              StencilSharedBufferView[StencilSharedBufferView["failOp"] = 4] = "failOp";
              StencilSharedBufferView[StencilSharedBufferView["zFailOp"] = 5] = "zFailOp";
              StencilSharedBufferView[StencilSharedBufferView["passOp"] = 6] = "passOp";
              StencilSharedBufferView[StencilSharedBufferView["ref"] = 7] = "ref";
              StencilSharedBufferView[StencilSharedBufferView["count"] = 8] = "count";
            })(StencilSharedBufferView || (StencilSharedBufferView = {}));

            var StencilManager = exports('StencilManager', function () {
              function StencilManager() {
                this._maskStack = [];
                this._stencilPattern = {
                  stencilTest: true,
                  func: ComparisonFunc.ALWAYS,
                  stencilMask: 0xffff,
                  writeMask: 0xffff,
                  failOp: StencilOp.KEEP,
                  zFailOp: StencilOp.KEEP,
                  passOp: StencilOp.KEEP,
                  ref: 1
                };
                this._stage = Stage.DISABLED;
                this.stencilStateMap = new Map();
                this.stencilStateMapWithDepth = new Map();
              }

              var _proto = StencilManager.prototype;

              _proto.pushMask = function pushMask(mask) {
                this._maskStack.push(mask);
              };

              _proto.clear = function clear(comp) {
                var isInverted = comp.stencilStage !== Stage.ENTER_LEVEL;
                return isInverted ? Stage.CLEAR_INVERTED : Stage.CLEAR;
              };

              _proto.enableMask = function enableMask() {
                this.stage = Stage.ENABLED;
              };

              _proto.exitMask = function exitMask() {
                if (this._maskStack.length === 0) {
                  return;
                }

                this._maskStack.pop();

                if (this._maskStack.length === 0) {
                  this.stage = Stage.DISABLED;
                } else {
                  this.stage = Stage.ENABLED;
                }
              };

              _proto.getWriteMask = function getWriteMask() {
                return 1 << this._maskStack.length - 1;
              };

              _proto.getExitWriteMask = function getExitWriteMask() {
                return 1 << this._maskStack.length;
              };

              _proto.getStencilRef = function getStencilRef() {
                var result = 0;

                for (var i = 0; i < this._maskStack.length; ++i) {
                  result += 0x00000001 << i;
                }

                return result;
              };

              _proto.getMaskStackSize = function getMaskStackSize() {
                return this._maskStack.length;
              };

              _proto.reset = function reset() {
                this._maskStack.length = 0;
                this.stage = Stage.DISABLED;
              };

              _proto.destroy = function destroy() {
                this.stencilStateMap.forEach(function (value, key) {
                  value.destroy();
                });
                this.stencilStateMap.clear();
              };

              _proto.getStencilStage = function getStencilStage(stage, mat) {
                var key = 0;
                var depthTest = false;
                var depthWrite = false;
                var depthFunc = ComparisonFunc.LESS;
                var cacheMap = this.stencilStateMap;

                if (mat && mat.passes[0]) {
                  var pass = mat.passes[0];
                  var dss = pass.depthStencilState;
                  var depthTestValue = 0;
                  var depthWriteValue = 0;
                  if (dss.depthTest) depthTestValue = 1;
                  if (dss.depthWrite) depthWriteValue = 1;
                  key = depthTestValue | depthWriteValue << 1 | dss.depthFunc << 2 | stage << 6 | this._maskStack.length << 9;
                  depthTest = dss.depthTest;
                  depthWrite = dss.depthWrite;
                  depthFunc = dss.depthFunc;
                  cacheMap = this.stencilStateMapWithDepth;
                } else {
                  key = stage << 16 | this._maskStack.length;
                }

                if (cacheMap && cacheMap.has(key)) {
                  return cacheMap.get(key);
                }

                this.setStateFromStage(stage);
                var depthStencilState = new DepthStencilState(depthTest, depthWrite, depthFunc, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref);
                cacheMap.set(key, depthStencilState);
                return depthStencilState;
              };

              _proto.getStencilHash = function getStencilHash(stage) {
                return stage << 8 | this._maskStack.length;
              };

              _proto.setStateFromStage = function setStateFromStage(stage) {
                var pattern = this._stencilPattern;

                if (stage === Stage.DISABLED) {
                  pattern.stencilTest = false;
                  pattern.func = ComparisonFunc.ALWAYS;
                  pattern.failOp = StencilOp.KEEP;
                  pattern.stencilMask = pattern.writeMask = 0xffff;
                  pattern.ref = 1;
                } else {
                  pattern.stencilTest = true;

                  if (stage === Stage.ENABLED) {
                    pattern.func = ComparisonFunc.EQUAL;
                    pattern.failOp = StencilOp.KEEP;
                    pattern.stencilMask = pattern.ref = this.getStencilRef();
                    pattern.writeMask = this.getWriteMask();
                  } else if (stage === Stage.CLEAR) {
                    pattern.func = ComparisonFunc.NEVER;
                    pattern.failOp = StencilOp.ZERO;
                    pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
                  } else if (stage === Stage.CLEAR_INVERTED) {
                    pattern.func = ComparisonFunc.NEVER;
                    pattern.failOp = StencilOp.REPLACE;
                    pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
                  } else if (stage === Stage.ENTER_LEVEL) {
                    pattern.func = ComparisonFunc.NEVER;
                    pattern.failOp = StencilOp.REPLACE;
                    pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
                  } else if (stage === Stage.ENTER_LEVEL_INVERTED) {
                    pattern.func = ComparisonFunc.NEVER;
                    pattern.failOp = StencilOp.ZERO;
                    pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
                  }
                }
              };

              _createClass(StencilManager, [{
                key: "stage",
                get: function get() {
                  return this._stage;
                },
                set: function set(val) {
                  this._stage = val;
                }
              }, {
                key: "pattern",
                get: function get() {
                  return this._stencilPattern;
                }
              }]);

              return StencilManager;
            }());
            StencilManager.sharedManager = null;
            StencilManager.sharedManager = new StencilManager();

            var RenderEntityType;

            (function (RenderEntityType) {
              RenderEntityType[RenderEntityType["STATIC"] = 0] = "STATIC";
              RenderEntityType[RenderEntityType["DYNAMIC"] = 1] = "DYNAMIC";
              RenderEntityType[RenderEntityType["CROSSED"] = 2] = "CROSSED";
            })(RenderEntityType || (RenderEntityType = {}));

            var RenderEntityFloatSharedBufferView;

            (function (RenderEntityFloatSharedBufferView) {
              RenderEntityFloatSharedBufferView[RenderEntityFloatSharedBufferView["localOpacity"] = 0] = "localOpacity";
              RenderEntityFloatSharedBufferView[RenderEntityFloatSharedBufferView["count"] = 1] = "count";
            })(RenderEntityFloatSharedBufferView || (RenderEntityFloatSharedBufferView = {}));

            var RenderEntityUInt8SharedBufferView;

            (function (RenderEntityUInt8SharedBufferView) {
              RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["colorR"] = 0] = "colorR";
              RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["colorG"] = 1] = "colorG";
              RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["colorB"] = 2] = "colorB";
              RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["colorA"] = 3] = "colorA";
              RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["maskMode"] = 4] = "maskMode";
              RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["count"] = 5] = "count";
            })(RenderEntityUInt8SharedBufferView || (RenderEntityUInt8SharedBufferView = {}));

            var RenderEntityBoolSharedBufferView;

            (function (RenderEntityBoolSharedBufferView) {
              RenderEntityBoolSharedBufferView[RenderEntityBoolSharedBufferView["colorDirty"] = 0] = "colorDirty";
              RenderEntityBoolSharedBufferView[RenderEntityBoolSharedBufferView["enabled"] = 1] = "enabled";
              RenderEntityBoolSharedBufferView[RenderEntityBoolSharedBufferView["useLocal"] = 2] = "useLocal";
              RenderEntityBoolSharedBufferView[RenderEntityBoolSharedBufferView["count"] = 3] = "count";
            })(RenderEntityBoolSharedBufferView || (RenderEntityBoolSharedBufferView = {}));

            var MaskMode;

            (function (MaskMode) {
              MaskMode[MaskMode["NONE"] = 0] = "NONE";
              MaskMode[MaskMode["MASK"] = 1] = "MASK";
              MaskMode[MaskMode["MASK_INVERTED"] = 2] = "MASK_INVERTED";
              MaskMode[MaskMode["MASK_NODE"] = 3] = "MASK_NODE";
              MaskMode[MaskMode["MASK_NODE_INVERTED"] = 4] = "MASK_NODE_INVERTED";
            })(MaskMode || (MaskMode = {}));

            var RenderEntity = function () {
              function RenderEntity(entityType) {
                this._renderEntityType = RenderEntityType.STATIC;
                this._dynamicDrawInfoArr = [];
                this._node = null;
                this._renderTransform = null;
                this._stencilStage = Stage.DISABLED;
                this._useLocal = false;
                this._maskMode = MaskMode.NONE;
                this._color = Color$1.WHITE;
                this._localOpacity = 255;
                this._colorDirty = true;
                this._enabled = false;
              }

              var _proto = RenderEntity.prototype;

              _proto.addDynamicRenderDrawInfo = function addDynamicRenderDrawInfo(renderDrawInfo) {
              };

              _proto.removeDynamicRenderDrawInfo = function removeDynamicRenderDrawInfo() {
              };

              _proto.clearDynamicRenderDrawInfos = function clearDynamicRenderDrawInfos() {
              };

              _proto.clearStaticRenderDrawInfos = function clearStaticRenderDrawInfos() {
              };

              _proto.setDynamicRenderDrawInfo = function setDynamicRenderDrawInfo(renderDrawInfo, index) {
              };

              _proto.setMaskMode = function setMaskMode(mode) {

                this._maskMode = mode;
              };

              _proto.getStaticRenderDrawInfo = function getStaticRenderDrawInfo() {

                return null;
              };

              _proto.setNode = function setNode(node) {

                this._node = node;
              };

              _proto.setRenderTransform = function setRenderTransform(renderTransform) {

                this._renderTransform = renderTransform;
              };

              _proto.setStencilStage = function setStencilStage(stage) {

                this._stencilStage = stage;
              };

              _proto.setUseLocal = function setUseLocal(useLocal) {

                this._useLocal = useLocal;
              };

              _proto.initSharedBuffer = function initSharedBuffer() {
              };

              _createClass(RenderEntity, [{
                key: "nativeObj",
                get: function get() {
                  return this._nativeObj;
                }
              }, {
                key: "renderDrawInfoArr",
                get: function get() {
                  return this._dynamicDrawInfoArr;
                }
              }, {
                key: "renderEntityType",
                get: function get() {
                  return this._renderEntityType;
                }
              }, {
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(val) {
                  this._color = val;
                }
              }, {
                key: "localOpacity",
                get: function get() {
                  return this._localOpacity;
                },
                set: function set(val) {
                  this._localOpacity = val;
                }
              }, {
                key: "colorDirty",
                get: function get() {
                  return this._colorDirty;
                },
                set: function set(val) {
                  this._colorDirty = val;
                }
              }, {
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  this._enabled = val;
                }
              }]);

              return RenderEntity;
            }();

            var DEFAULT_STRIDE = getAttributeStride(vfmtPosUvColor) >> 2;

            var _dataPool = new Pool(function () {
              return {
                x: 0,
                y: 0,
                z: 0,
                u: 0,
                v: 0,
                color: Color$1.WHITE.clone()
              };
            }, 128);
            var BaseRenderData = exports('BaseRenderData', function () {
              function BaseRenderData(vertexFormat) {
                if (vertexFormat === void 0) {
                  vertexFormat = vfmtPosUvColor;
                }

                this.chunk = null;
                this._renderDrawInfo = null;
                this._material = null;
                this._dataHash = 0;
                this._isMeshBuffer = false;
                this._vc = 0;
                this._ic = 0;
                this._floatStride = 0;
                this._vertexFormat = vfmtPosUvColor;
                this._drawInfoType = RenderDrawInfoType.COMP;
                this._multiOwner = false;
                this._batcher = null;
                this._floatStride = vertexFormat === vfmtPosUvColor ? DEFAULT_STRIDE : getAttributeStride(vertexFormat) >> 2;
                this._vertexFormat = vertexFormat;
              }

              var _proto = BaseRenderData.prototype;

              _proto.isValid = function isValid() {
                return this._ic > 0 && this.chunk.vertexAccessor;
              };

              _proto.initRenderDrawInfo = function initRenderDrawInfo(comp, drawInfoType) {
                if (drawInfoType === void 0) {
                  drawInfoType = RenderDrawInfoType.COMP;
                }
              };

              _proto.removeRenderDrawInfo = function removeRenderDrawInfo(comp) {
              };

              _proto.setRenderDrawInfoAttributes = function setRenderDrawInfoAttributes() {
              };

              _createClass(BaseRenderData, [{
                key: "vertexCount",
                get: function get() {
                  return this._vc;
                }
              }, {
                key: "indexCount",
                get: function get() {
                  return this._ic;
                }
              }, {
                key: "stride",
                get: function get() {
                  return this._floatStride << 2;
                }
              }, {
                key: "floatStride",
                get: function get() {
                  return this._floatStride;
                }
              }, {
                key: "vertexFormat",
                get: function get() {
                  return this._vertexFormat;
                }
              }, {
                key: "drawInfoType",
                get: function get() {
                  return this._drawInfoType;
                },
                set: function set(type) {
                  this._drawInfoType = type;

                  if (this._renderDrawInfo) {
                    this._renderDrawInfo.setDrawInfoType(type);
                  }
                }
              }, {
                key: "renderDrawInfo",
                get: function get() {
                  return this._renderDrawInfo;
                }
              }, {
                key: "material",
                get: function get() {
                  return this._material;
                },
                set: function set(val) {
                  this._material = val;

                  if (this._renderDrawInfo) {
                    this._renderDrawInfo.setMaterial(val);
                  }
                }
              }, {
                key: "dataHash",
                get: function get() {
                  return this._dataHash;
                },
                set: function set(val) {
                  this._dataHash = val;

                  if (this._renderDrawInfo) {
                    this._renderDrawInfo.setDataHash(val);
                  }
                }
              }, {
                key: "multiOwner",
                get: function get() {
                  return this._multiOwner;
                },
                set: function set(val) {
                  this._multiOwner = val;
                }
              }, {
                key: "batcher",
                get: function get() {
                  if (!this._batcher) {
                    this._batcher = director.root.batcher2D;
                  }

                  return this._batcher;
                }
              }]);

              return BaseRenderData;
            }());
            var RenderData = exports('RenderData', function (_BaseRenderData) {
              _inheritsLoose(RenderData, _BaseRenderData);

              RenderData.add = function add(vertexFormat, accessor) {
                if (vertexFormat === void 0) {
                  vertexFormat = vfmtPosUvColor;
                }

                var rd = new RenderData(vertexFormat, accessor);

                if (!accessor) {
                  var batcher = director.root.batcher2D;
                  accessor = batcher.switchBufferAccessor(rd._vertexFormat);
                }

                rd._accessor = accessor;
                return rd;
              };

              RenderData.remove = function remove(data) {
                data.clear();
                data._accessor = null;
              };

              function RenderData(vertexFormat, accessor) {
                var _this;

                if (vertexFormat === void 0) {
                  vertexFormat = vfmtPosUvColor;
                }

                _this = _BaseRenderData.call(this, vertexFormat) || this;
                _this._vertDirty = true;
                _this._textureHash = 0;
                _this.indices = null;
                _this.layer = 0;
                _this.nodeDirty = true;
                _this.passDirty = true;
                _this.textureDirty = true;
                _this.hashDirty = true;
                _this._data = [];
                _this._pivotX = 0;
                _this._pivotY = 0;
                _this._width = 0;
                _this._height = 0;
                _this._frame = null;
                _this._accessor = null;
                _this.vertexRow = 1;
                _this.vertexCol = 1;

                if (!accessor) {
                  accessor = _this.batcher.switchBufferAccessor(_this._vertexFormat);
                }

                _this._accessor = accessor;
                return _this;
              }

              var _proto2 = RenderData.prototype;

              _proto2.resize = function resize(vertexCount, indexCount) {
                if (vertexCount === this._vc && indexCount === this._ic && this.chunk) return;
                this._vc = vertexCount;
                this._ic = indexCount;

                if (this.chunk) {
                  this._accessor.recycleChunk(this.chunk);

                  this.chunk = null;
                }

                this.chunk = this._accessor.allocateChunk(vertexCount, indexCount);
                this.updateHash();
              };

              _proto2.setRenderDrawInfoAttributes = function setRenderDrawInfoAttributes() {
              };

              _proto2.fillDrawInfoAttributes = function fillDrawInfoAttributes(drawInfo) {
              };

              _proto2.syncRender2dBuffer = function syncRender2dBuffer() {
              };

              _proto2.resizeAndCopy = function resizeAndCopy(vertexCount, indexCount) {
                if (vertexCount === this._vc && indexCount === this._ic && this.chunk) return;
                this._vc = vertexCount;
                this._ic = indexCount;
                var oldChunk = this.chunk;
                this.chunk = this._accessor.allocateChunk(vertexCount, indexCount);

                if (oldChunk) {
                  this.chunk.vb.set(oldChunk.vb);

                  this._accessor.recycleChunk(oldChunk);
                }

                this.updateHash();
              };

              _proto2.getMeshBuffer = function getMeshBuffer() {
                if (this.chunk && this._accessor) {
                  return this._accessor.getMeshBuffer(this.chunk.bufferId);
                } else {
                  return null;
                }
              };

              _proto2.updateNode = function updateNode(comp) {
                this.layer = comp.node.layer;
                this.nodeDirty = false;
                this.hashDirty = true;
              };

              _proto2.updatePass = function updatePass(comp) {
                this.material = comp.getRenderMaterial(0);
                this.passDirty = false;
                this.hashDirty = true;
              };

              _proto2.updateTexture = function updateTexture(frame) {
                this.frame = frame;
                this.textureHash = frame.getHash();
                this.textureDirty = false;
                this.hashDirty = true;
              };

              _proto2.updateHash = function updateHash() {
                var bid = this.chunk ? this.chunk.bufferId : -1;
                var hashString = "" + bid + this.layer + " " + this.textureHash;
                this.dataHash = murmurhash2_32_gc(hashString, 666);
                this.hashDirty = false;
              };

              _proto2.updateRenderData = function updateRenderData(comp, frame) {
                if (this.passDirty) {
                  this.material = comp.getRenderMaterial(0);
                  this.passDirty = false;
                  this.hashDirty = true;

                  if (this._renderDrawInfo) {
                    this._renderDrawInfo.setMaterial(this.material);
                  }
                }

                if (this.nodeDirty) {
                  var renderScene = comp.node.scene ? comp._getRenderScene() : null;
                  this.layer = comp.node.layer;

                  if (renderScene !== null) {
                    this.nodeDirty = false;
                  }

                  this.hashDirty = true;
                }

                if (this.textureDirty) {
                  this.frame = frame;
                  this.textureHash = frame.getHash();
                  this.textureDirty = false;
                  this.hashDirty = true;

                  if (this._renderDrawInfo) {
                    this._renderDrawInfo.setTexture(this.frame ? this.frame.getGFXTexture() : null);

                    this._renderDrawInfo.setSampler(this.frame ? this.frame.getGFXSampler() : null);
                  }
                }

                if (this.hashDirty) {
                  this.updateHash();

                  if (this._renderDrawInfo) {
                    this._renderDrawInfo.setDataHash(this.dataHash);
                  }
                }
              };

              _proto2.updateSizeNPivot = function updateSizeNPivot(width, height, pivotX, pivotY) {
                if (width !== this._width || height !== this._height || pivotX !== this._pivotX || pivotY !== this._pivotY) {
                  this._width = width;
                  this._height = height;
                  this._pivotX = pivotX;
                  this._pivotY = pivotY;
                  this.vertDirty = true;
                }
              };

              _proto2.clear = function clear() {
                this.resize(0, 0);
                this._data.length = 0;
                this._pivotX = 0;
                this._pivotY = 0;
                this._width = 0;
                this._height = 0;
                this.indices = null;
                this.vertDirty = true;
                this.material = null;
                this.nodeDirty = true;
                this.passDirty = true;
                this.textureDirty = true;
                this.hashDirty = true;
                this.layer = 0;
                this.frame = null;
                this.textureHash = 0;
                this.dataHash = 0;
              };

              RenderData.createStaticVBAccessor = function createStaticVBAccessor(attributes, vCount, iCount) {
                var device = director.root.device;
                var accessor = new StaticVBAccessor(device, attributes, vCount, iCount);
                return accessor;
              };

              _createClass(RenderData, [{
                key: "dataLength",
                get: function get() {
                  return this._data.length;
                },
                set: function set(length) {
                  var data = this._data;

                  if (data.length !== length) {
                    var value = data.length;
                    var i = 0;

                    for (i = length; i < value; i++) {
                      _dataPool.free(data[i]);
                    }

                    for (i = value; i < length; i++) {
                      data[i] = _dataPool.alloc();
                    }

                    data.length = length;
                  }

                  this.syncRender2dBuffer();
                }
              }, {
                key: "data",
                get: function get() {
                  return this._data;
                }
              }, {
                key: "vertDirty",
                get: function get() {
                  return this._vertDirty;
                },
                set: function set(val) {
                  this._vertDirty = val;

                  if (this._renderDrawInfo && val) {
                    this._renderDrawInfo.setVertDirty(val);
                  }
                }
              }, {
                key: "textureHash",
                get: function get() {
                  return this._textureHash;
                },
                set: function set(val) {
                  this._textureHash = val;
                }
              }, {
                key: "frame",
                get: function get() {
                  return this._frame;
                },
                set: function set(val) {
                  this._frame = val;

                  if (this._renderDrawInfo) {
                    if (this._frame) {
                      this._renderDrawInfo.setTexture(this._frame.getGFXTexture());

                      this._renderDrawInfo.setSampler(this._frame.getGFXSampler());
                    } else {
                      this._renderDrawInfo.setTexture(null);

                      this._renderDrawInfo.setSampler(null);
                    }
                  }
                }
              }, {
                key: "accessor",
                get: function get() {
                  return this._accessor;
                }
              }]);

              return RenderData;
            }(BaseRenderData));
            var MeshRenderData = exports('MeshRenderData', function (_BaseRenderData2) {
              _inheritsLoose(MeshRenderData, _BaseRenderData2);

              MeshRenderData.add = function add(vertexFormat) {
                if (vertexFormat === void 0) {
                  vertexFormat = vfmtPosUvColor;
                }

                var rd = new MeshRenderData();
                rd._floatStride = vertexFormat === vfmtPosUvColor ? DEFAULT_STRIDE : getAttributeStride(vertexFormat) >> 2;
                rd._vertexFormat = vertexFormat;
                return rd;
              };

              MeshRenderData.remove = function remove(data) {
                data.clear();
              };

              function MeshRenderData(vertexFormat) {
                var _this2;

                if (vertexFormat === void 0) {
                  vertexFormat = vfmtPosUvColor;
                }

                _this2 = _BaseRenderData2.call(this, vertexFormat) || this;
                _this2._isMeshBuffer = true;
                _this2.vData = void 0;
                _this2.iData = void 0;
                _this2.vertexStart = 0;
                _this2.vertexRange = 0;
                _this2.indexStart = 0;
                _this2.indexRange = 0;
                _this2.lastFilledIndex = 0;
                _this2.lastFilledVertex = 0;
                _this2.frame = void 0;
                _this2._byteLength = 0;
                _this2._vertexBuffers = [];
                _this2._indexBuffer = null;
                _this2._iaPool = null;
                _this2._iaInfo = null;
                _this2.vData = new Float32Array(256 * _this2.stride);
                _this2.iData = new Uint16Array(256 * 6);
                return _this2;
              }

              var _proto3 = MeshRenderData.prototype;

              _proto3.request = function request(vertexCount, indexCount) {
                var byteOffset = this._byteLength + vertexCount * this.stride;
                var succeed = this.reserve(vertexCount, indexCount);
                if (!succeed) return false;
                this._vc += vertexCount;
                this._ic += indexCount;
                this._byteLength = byteOffset;
                this.vertexRange = this._vc;
                this.indexRange = this._ic;
                return true;
              };

              _proto3.reserve = function reserve(vertexCount, indexCount) {
                var newVBytes = this._byteLength + vertexCount * this.stride;
                var newICount = this.indexCount + indexCount;

                if (vertexCount + this.vertexCount > 65535) {
                  return false;
                }

                var byteLength = this.vData.byteLength;
                var indicesLength = this.iData.length;
                var vCount = this.vData.length;
                var iCount = this.iData.length;

                if (newVBytes > byteLength || newICount > indicesLength) {
                  while (byteLength < newVBytes || indicesLength < newICount) {
                    vCount *= 2;
                    iCount *= 2;
                    byteLength = vCount * 4;
                    indicesLength = iCount;
                  }

                  this._reallocBuffer(vCount, iCount);
                }

                return true;
              };

              _proto3.resize = function resize(vertexCount, indexCount) {
                var byteLength = vertexCount * this.stride;
                assertIsTrue(vertexCount >= 0 && indexCount >= 0 && byteLength <= this.vData.byteLength && indexCount <= this.iData.length);
                this._vc = vertexCount;
                this._ic = indexCount;
                this._byteLength = byteLength;
                this.updateRange(0, vertexCount, 0, indexCount);
              };

              _proto3.updateRange = function updateRange(vertOffset, vertexCount, indexOffset, indexCount) {
                assertIsTrue(vertexCount >= 0 && indexCount >= 0 && vertexCount <= this._vc && indexCount <= this._ic);
                this.vertexStart = vertOffset;
                this.indexStart = indexOffset;
                this.vertexRange = vertexCount;
                this.indexRange = indexCount;
              };

              _proto3.requestIA = function requestIA(device) {
                this._initIAInfo(device);

                var ia = this._iaPool.add();

                ia.firstIndex = this.indexStart;
                ia.indexCount = this.indexRange;
                return ia;
              };

              _proto3.uploadBuffers = function uploadBuffers() {
                if (this._byteLength === 0 || !this._vertexBuffers[0] || !this._indexBuffer) {
                  return;
                }

                var indexCount = this._ic;
                var verticesData = new Float32Array(this.vData.buffer, 0, this._byteLength >> 2);
                var indicesData = new Uint16Array(this.iData.buffer, 0, indexCount);
                var vertexBuffer = this._vertexBuffers[0];

                if (this._byteLength > vertexBuffer.size) {
                  vertexBuffer.resize(this._byteLength);
                }

                vertexBuffer.update(verticesData);
                var indexBytes = indexCount << 1;

                if (indexBytes > this._indexBuffer.size) {
                  this._indexBuffer.resize(indexBytes);
                }

                this._indexBuffer.update(indicesData);
              };

              _proto3.freeIAPool = function freeIAPool() {
                if (this._iaPool) {
                  this._iaPool.reset();
                }
              };

              _proto3.reset = function reset() {
                this._vc = 0;
                this._ic = 0;
                this._byteLength = 0;
                this.vertexStart = 0;
                this.vertexRange = 0;
                this.indexStart = 0;
                this.indexRange = 0;
                this.lastFilledIndex = 0;
                this.lastFilledVertex = 0;
                this.material = null;
                this.freeIAPool();
              };

              _proto3.clear = function clear() {
                this.reset();

                if (this._iaPool) {
                  this._iaPool.destroy();
                }

                if (this._vertexBuffers[0]) {
                  this._vertexBuffers[0].destroy();

                  this._vertexBuffers = [];
                }

                this._iaInfo = null;
                this.vData = new Float32Array(256 * this.stride);
                this.iData = new Uint16Array(256 * 6);
              };

              _proto3._initIAInfo = function _initIAInfo(device) {
                var _this3 = this;

                if (!this._iaInfo) {
                  var vbStride = this.stride;
                  var vbs = this._vertexBuffers;

                  if (!vbs.length) {
                    vbs.push(device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, vbStride, vbStride)));
                  }

                  var ibStride = Uint16Array.BYTES_PER_ELEMENT;

                  if (!this._indexBuffer) {
                    this._indexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, ibStride, ibStride));
                  }

                  this._iaInfo = new InputAssemblerInfo(this._vertexFormat, vbs, this._indexBuffer);
                  this._iaPool = new RecyclePool(function () {
                    return device.createInputAssembler(_this3._iaInfo);
                  }, 1, function (ia) {
                    ia.destroy();
                  });
                }
              };

              _proto3._reallocBuffer = function _reallocBuffer(vCount, iCount) {
                var oldVData = this.vData;
                this.vData = new Float32Array(vCount);

                if (oldVData) {
                  this.vData.set(oldVData, 0);
                }

                var oldIData = this.iData;
                this.iData = new Uint16Array(iCount);

                if (oldIData) {
                  this.iData.set(oldIData, 0);
                }
              };

              _proto3.setRenderDrawInfoAttributes = function setRenderDrawInfoAttributes() {
              };

              _proto3.particleInitRenderDrawInfo = function particleInitRenderDrawInfo(entity) {
              };

              _createClass(MeshRenderData, [{
                key: "formatByte",
                get: function get() {
                  return this.stride;
                },
                set: function set(value) {}
              }, {
                key: "floatStride",
                get: function get() {
                  return this._floatStride;
                }
              }, {
                key: "vDataOffset",
                get: function get() {
                  return this._byteLength >>> 2;
                }
              }]);

              return MeshRenderData;
            }(BaseRenderData));

            var _meshDataPool = new RecyclePool(function () {
              return new MeshRenderData();
            }, 32);

            var _dec$6, _dec2$1, _class$6, _class2$4, _initializer$3, _initializer2$1, _class3, _temp$1;

            var _vec2a = new Vec2();

            var _vec2b = new Vec2();

            var _vec3a = new Vec3();

            var _mat4_temp = new Mat4();

            var _matrix = new Mat4();

            var _worldMatrix = new Mat4();

            var _zeroMatrix = new Mat4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

            var _rect = new Rect$1();

            var UITransform = exports('UITransform', (_dec$6 = ccclass$p('cc.UITransform'), _dec2$1 = executionOrder(110), _dec$6(_class$6 = _dec2$1(_class$6 = disallowMultiple(_class$6 = (_class2$4 = (_temp$1 = _class3 = function (_Component) {
              _inheritsLoose(UITransform, _Component);

              function UITransform() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._priority = 0;
                _this._contentSize = _initializer$3 && _initializer$3();
                _this._anchorPoint = _initializer2$1 && _initializer2$1();
                return _this;
              }

              var _proto = UITransform.prototype;

              _proto.__preload = function __preload() {
                this.node._uiProps.uiTransformComp = this;
              };

              _proto.onLoad = function onLoad() {
                if (this.node.parent) {
                  UITransform.insertChangeMap(this.node.parent);
                }
              };

              _proto.onEnable = function onEnable() {
                this.node.on(NodeEventType.PARENT_CHANGED, this._parentChanged, this);

                this._markRenderDataDirty();
              };

              _proto.onDisable = function onDisable() {
                this.node.off(NodeEventType.PARENT_CHANGED, this._parentChanged, this);
              };

              _proto.onDestroy = function onDestroy() {
                this.node._uiProps.uiTransformComp = null;
              };

              _proto.setContentSize = function setContentSize(size, height) {
                var locContentSize = this._contentSize;

                if (height === undefined) {
                  size = size;

                  if (approx(size.width, locContentSize.width, EPSILON$2) && approx(size.height, locContentSize.height, EPSILON$2)) {
                    return;
                  }

                  locContentSize.width = size.width;
                  locContentSize.height = size.height;
                } else {
                  size = size;

                  if (approx(size, locContentSize.width, EPSILON$2) && approx(height, locContentSize.height, EPSILON$2)) {
                    return;
                  }

                  locContentSize.width = size;
                  locContentSize.height = height;
                }

                {
                  this.node.emit(NodeEventType.SIZE_CHANGED);
                }

                this._markRenderDataDirty();
              };

              _proto.setAnchorPoint = function setAnchorPoint(point, y) {
                var locAnchorPoint = this._anchorPoint;

                if (y === undefined) {
                  point = point;

                  if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) {
                    return;
                  }

                  locAnchorPoint.x = point.x;
                  locAnchorPoint.y = point.y;
                } else {
                  if (point === locAnchorPoint.x && y === locAnchorPoint.y) {
                    return;
                  }

                  locAnchorPoint.x = point;
                  locAnchorPoint.y = y;
                }

                this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);

                this._markRenderDataDirty();
              };

              _proto.isHit = function isHit(uiPoint) {
                var w = this._contentSize.width;
                var h = this._contentSize.height;
                var v2WorldPt = _vec2a;
                var testPt = _vec2b;

                var cameras = this._getRenderScene().cameras;

                for (var i = 0; i < cameras.length; i++) {
                  var camera = cameras[i];
                  if (!(camera.visibility & this.node.layer)) continue;
                  camera.node.getWorldRT(_mat4_temp);
                  var m12 = _mat4_temp.m12;
                  var m13 = _mat4_temp.m13;
                  var center = visibleRect.center;
                  _mat4_temp.m12 = center.x - (_mat4_temp.m00 * m12 + _mat4_temp.m04 * m13);
                  _mat4_temp.m13 = center.y - (_mat4_temp.m01 * m12 + _mat4_temp.m05 * m13);
                  Mat4.invert(_mat4_temp, _mat4_temp);
                  Vec2.transformMat4(v2WorldPt, uiPoint, _mat4_temp);
                  this.node.getWorldMatrix(_worldMatrix);
                  Mat4.invert(_mat4_temp, _worldMatrix);

                  if (Mat4.strictEquals(_mat4_temp, _zeroMatrix)) {
                    continue;
                  }

                  Vec2.transformMat4(testPt, v2WorldPt, _mat4_temp);
                  testPt.x += this._anchorPoint.x * w;
                  testPt.y += this._anchorPoint.y * h;
                  var hit = false;

                  if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
                    hit = this._maskTest(v2WorldPt);
                  }

                  if (hit) {
                    return true;
                  }
                }

                return false;
              };

              _proto.hitTest = function hitTest(screenPoint, windowId) {
                if (windowId === void 0) {
                  windowId = 0;
                }

                var w = this._contentSize.width;
                var h = this._contentSize.height;
                var v3WorldPt = _vec3a;
                var v2WorldPt = _vec2a;
                var testPt = _vec2b;

                var cameras = this._getRenderScene().cameras;

                for (var i = 0; i < cameras.length; i++) {
                  var camera = cameras[i];

                  if (!(camera.visibility & this.node.layer) || camera.window && !camera.window.swapchain) {
                    continue;
                  }

                  if (camera.systemWindowId !== windowId) {
                    continue;
                  }

                  Vec3.set(v3WorldPt, screenPoint.x, screenPoint.y, 0);
                  camera.screenToWorld(v3WorldPt, v3WorldPt);
                  Vec2.set(v2WorldPt, v3WorldPt.x, v3WorldPt.y);
                  this.node.getWorldMatrix(_worldMatrix);
                  Mat4.invert(_mat4_temp, _worldMatrix);

                  if (Mat4.strictEquals(_mat4_temp, _zeroMatrix)) {
                    continue;
                  }

                  Vec2.transformMat4(testPt, v2WorldPt, _mat4_temp);
                  testPt.x += this._anchorPoint.x * w;
                  testPt.y += this._anchorPoint.y * h;
                  var hit = false;

                  if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
                    hit = this._maskTest(v2WorldPt);
                  }

                  if (hit) {
                    return true;
                  }
                }

                return false;
              };

              _proto._maskTest = function _maskTest(pointInWorldSpace) {
                var _this$node, _this$node$eventProce;

                var maskList = (_this$node = this.node) === null || _this$node === void 0 ? void 0 : (_this$node$eventProce = _this$node.eventProcessor) === null || _this$node$eventProce === void 0 ? void 0 : _this$node$eventProce.maskList;

                if (maskList) {
                  var parent = this.node;
                  var length = maskList.length;

                  for (var i = 0, j = 0; parent && j < length; ++i, parent = parent.parent) {
                    var temp = maskList[j];

                    if (i === temp.index) {
                      if (parent === temp.comp.node) {
                        var comp = temp.comp;

                        if (comp && comp._enabled && !comp.isHit(pointInWorldSpace)) {
                          return false;
                        }

                        j++;
                      } else {
                        maskList.length = j;
                        break;
                      }
                    } else if (i > temp.index) {
                      maskList.length = j;
                      break;
                    }
                  }
                }

                return true;
              };

              _proto.convertToNodeSpaceAR = function convertToNodeSpaceAR(worldPoint, out) {
                this.node.getWorldMatrix(_worldMatrix);
                Mat4.invert(_mat4_temp, _worldMatrix);

                if (!out) {
                  out = new Vec3();
                }

                return Vec3.transformMat4(out, worldPoint, _mat4_temp);
              };

              _proto.convertToWorldSpaceAR = function convertToWorldSpaceAR(nodePoint, out) {
                this.node.getWorldMatrix(_worldMatrix);

                if (!out) {
                  out = new Vec3();
                }

                return Vec3.transformMat4(out, nodePoint, _worldMatrix);
              };

              _proto.getBoundingBox = function getBoundingBox() {
                Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
                var width = this._contentSize.width;
                var height = this._contentSize.height;
                var rect = new Rect$1(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                rect.transformMat4(_matrix);
                return rect;
              };

              _proto.getBoundingBoxToWorld = function getBoundingBoxToWorld() {
                if (this.node.parent) {
                  var m = this.node.parent.getWorldMatrix();
                  return this.getBoundingBoxTo(m);
                }

                return this.getBoundingBox();
              };

              _proto.getBoundingBoxTo = function getBoundingBoxTo(parentMat) {
                Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
                var width = this._contentSize.width;
                var height = this._contentSize.height;
                var rect = new Rect$1(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                Mat4.multiply(_worldMatrix, parentMat, _matrix);
                rect.transformMat4(_worldMatrix);

                if (!this.node.children || this.node.children.length === 0) {
                  return rect;
                }

                var locChildren = this.node.children;

                for (var _iterator = _createForOfIteratorHelperLoose(locChildren), _step; !(_step = _iterator()).done;) {
                  var child = _step.value;

                  if (child && child.active) {
                    var uiTransform = child.getComponent(UITransform);

                    if (uiTransform) {
                      var childRect = uiTransform.getBoundingBoxTo(parentMat);

                      if (childRect) {
                        Rect$1.union(rect, rect, childRect);
                      }
                    }
                  }
                }

                return rect;
              };

              _proto.getComputeAABB = function getComputeAABB(out) {
                var width = this._contentSize.width;
                var height = this._contentSize.height;

                _rect.set(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);

                _rect.transformMat4(this.node.worldMatrix);

                var px = _rect.x + _rect.width * 0.5;
                var py = _rect.y + _rect.height * 0.5;
                var pz = this.node.worldPosition.z;
                var w = _rect.width / 2;
                var h = _rect.height / 2;
                var l = 0.001;

                if (out != null) {
                  AABB.set(out, px, py, pz, w, h, l);
                  return out;
                } else {
                  return new AABB(px, py, pz, w, h, l);
                }
              };

              _proto._parentChanged = function _parentChanged(node) {
                if (this.node.getComponent('cc.RenderRoot2D')) {
                  return;
                }

                if (this.node.parent) {
                  UITransform.insertChangeMap(this.node.parent);
                }
              };

              _proto._markRenderDataDirty = function _markRenderDataDirty() {
                var uiComp = this.node._uiProps.uiComp;

                if (uiComp) {
                  uiComp.markForUpdateRenderData();
                }
              };

              UITransform.insertChangeMap = function insertChangeMap(node) {
                var key = node.uuid;

                if (!UITransform.priorityChangeNodeMap.has(key)) {
                  UITransform.priorityChangeNodeMap.set(key, node);
                }
              };

              UITransform._sortChildrenSibling = function _sortChildrenSibling(node) {
                var siblings = node.children;

                if (siblings) {
                  siblings.sort(function (a, b) {
                    var aComp = a._uiProps.uiTransformComp;
                    var bComp = b._uiProps.uiTransformComp;
                    var ca = aComp ? aComp._priority : 0;
                    var cb = bComp ? bComp._priority : 0;
                    var diff = ca - cb;
                    if (diff === 0) return a.getSiblingIndex() - b.getSiblingIndex();
                    return diff;
                  });
                }
              };

              UITransform._sortSiblings = function _sortSiblings() {
                UITransform.priorityChangeNodeMap.forEach(function (node, ID) {
                  UITransform._sortChildrenSibling(node);

                  node._updateSiblingIndex();

                  node.emit('childrenSiblingOrderChanged');
                });
                UITransform.priorityChangeNodeMap.clear();
              };

              UITransform._cleanChangeMap = function _cleanChangeMap() {
                UITransform.priorityChangeNodeMap.clear();
              };

              _createClass(UITransform, [{
                key: "contentSize",
                get: function get() {
                  return this._contentSize;
                },
                set: function set(value) {
                  if (this._contentSize.equals(value)) {
                    return;
                  }

                  this._contentSize.set(value);

                  {
                    this.node.emit(NodeEventType.SIZE_CHANGED);
                  }

                  this._markRenderDataDirty();
                }
              }, {
                key: "width",
                get: function get() {
                  return this._contentSize.width;
                },
                set: function set(value) {
                  if (this._contentSize.width === value) {
                    return;
                  }

                  this._contentSize.width = value;

                  {
                    this.node.emit(NodeEventType.SIZE_CHANGED);
                  }

                  this._markRenderDataDirty();
                }
              }, {
                key: "height",
                get: function get() {
                  return this._contentSize.height;
                },
                set: function set(value) {
                  if (this.contentSize.height === value) {
                    return;
                  }

                  this._contentSize.height = value;

                  {
                    this.node.emit(NodeEventType.SIZE_CHANGED);
                  }

                  this._markRenderDataDirty();
                }
              }, {
                key: "anchorPoint",
                get: function get() {
                  return this._anchorPoint;
                },
                set: function set(value) {
                  if (this._anchorPoint.equals(value)) {
                    return;
                  }

                  this._anchorPoint.set(value);

                  this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);

                  this._markRenderDataDirty();
                }
              }, {
                key: "anchorX",
                get: function get() {
                  return this._anchorPoint.x;
                },
                set: function set(value) {
                  if (this._anchorPoint.x === value) {
                    return;
                  }

                  this._anchorPoint.x = value;
                  this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);

                  this._markRenderDataDirty();
                }
              }, {
                key: "anchorY",
                get: function get() {
                  return this._anchorPoint.y;
                },
                set: function set(value) {
                  if (this._anchorPoint.y === value) {
                    return;
                  }

                  this._anchorPoint.y = value;
                  this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);

                  this._markRenderDataDirty();
                }
              }, {
                key: "priority",
                get: function get() {
                  return this._priority;
                },
                set: function set(value) {
                  if (this._priority === value) {
                    return;
                  }

                  if (this.node.getComponent('cc.RenderRoot2D')) {
                    warnID(6706);
                    return;
                  }

                  this._priority = value;

                  if (this.node.parent) {
                    UITransform.insertChangeMap(this.node.parent);
                  }
                }
              }, {
                key: "visibility",
                get: function get() {
                  var camera = director.root.batcher2D.getFirstRenderCamera(this.node);
                  return camera ? camera.visibility : 0;
                }
              }, {
                key: "cameraPriority",
                get: function get() {
                  var camera = director.root.batcher2D.getFirstRenderCamera(this.node);
                  return camera ? camera.priority : 0;
                }
              }]);

              return UITransform;
            }(Component), _class3.EventType = NodeEventType, _class3.priorityChangeNodeMap = new Map(), _temp$1), (_initializer$3 = applyDecoratedInitializer(_class2$4.prototype, "_contentSize", [serializable$j], function () {
              return new Size$1(100, 100);
            }), _initializer2$1 = applyDecoratedInitializer(_class2$4.prototype, "_anchorPoint", [serializable$j], function () {
              return new Vec2(0.5, 0.5);
            })), _class2$4)) || _class$6) || _class$6) || _class$6));
            director.on(Director.EVENT_AFTER_UPDATE, UITransform._sortSiblings);
            director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, UITransform._cleanChangeMap);

            var _dec$7, _dec2$2, _dec3, _dec4, _class$7, _class2$5, _initializer$4, _initializer2$2, _initializer3$1, _initializer4$1, _initializer5, _class3$1, _temp$2;
            ccenum(BlendFactor);
            ccenum(BlendOp);
            ccenum(ColorMask);
            var InstanceMaterialType;

            (function (InstanceMaterialType) {
              InstanceMaterialType[InstanceMaterialType["ADD_COLOR"] = 0] = "ADD_COLOR";
              InstanceMaterialType[InstanceMaterialType["ADD_COLOR_AND_TEXTURE"] = 1] = "ADD_COLOR_AND_TEXTURE";
              InstanceMaterialType[InstanceMaterialType["GRAYSCALE"] = 2] = "GRAYSCALE";
              InstanceMaterialType[InstanceMaterialType["USE_ALPHA_SEPARATED"] = 3] = "USE_ALPHA_SEPARATED";
              InstanceMaterialType[InstanceMaterialType["USE_ALPHA_SEPARATED_AND_GRAY"] = 4] = "USE_ALPHA_SEPARATED_AND_GRAY";
            })(InstanceMaterialType || (InstanceMaterialType = exports('InstanceMaterialType', {})));

            var UIRenderer = exports('UIRenderer', (_dec$7 = ccclass$p('cc.UIRenderer'), _dec2$2 = requireComponent(UITransform), _dec3 = type$8(Material), _dec4 = type$8(Material), _dec$7(_class$7 = _dec2$2(_class$7 = (_class2$5 = (_temp$2 = _class3$1 = function (_Renderer) {
              _inheritsLoose(UIRenderer, _Renderer);

              function UIRenderer() {
                var _this;

                _this = _Renderer.call(this) || this;
                _this._renderData = null;
                _this._materials = _initializer$4 && _initializer$4();
                _this._customMaterial = _initializer2$2 && _initializer2$2();
                _this._srcBlendFactor = _initializer3$1 && _initializer3$1();
                _this._dstBlendFactor = _initializer4$1 && _initializer4$1();
                _this._color = _initializer5 && _initializer5();
                _this._stencilStage = Stage.DISABLED;
                _this._assembler = null;
                _this._postAssembler = null;
                _this._renderDataFlag = true;
                _this._renderFlag = true;
                _this._renderEntity = void 0;
                _this._instanceMaterialType = -1;
                _this._srcBlendFactorCache = BlendFactor.SRC_ALPHA;
                _this._dstBlendFactorCache = BlendFactor.ONE_MINUS_SRC_ALPHA;
                _this._dirtyVersion = -1;
                _this._internalId = -1;
                _this._useVertexOpacity = false;
                _this._lastParent = null;
                _this._renderEntity = _this.createRenderEntity();
                return _this;
              }

              var _proto = UIRenderer.prototype;

              _proto.onLoad = function onLoad() {
                this._renderEntity.setNode(this.node);
              };

              _proto.__preload = function __preload() {
                this.node._uiProps.uiComp = this;

                if (this._flushAssembler) {
                  this._flushAssembler();
                }
              };

              _proto.onEnable = function onEnable() {
                this.node.on(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
                this.node.on(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
                this.node.on(NodeEventType.PARENT_CHANGED, this._colorDirty, this);
                this.updateMaterial();

                this._colorDirty();

                uiRendererManager.addRenderer(this);
                this.markForUpdateRenderData();
              };

              _proto.onRestore = function onRestore() {
                this.updateMaterial();
                this.markForUpdateRenderData();
              };

              _proto.onDisable = function onDisable() {
                this.node.off(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
                this.node.off(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
                this.node.off(NodeEventType.PARENT_CHANGED, this._colorDirty, this);
                uiRendererManager.removeRenderer(this);
                this._renderFlag = false;
                this._renderEntity.enabled = false;
              };

              _proto.onDestroy = function onDestroy() {
                this._renderEntity.setNode(null);

                if (this.node._uiProps.uiComp === this) {
                  this.node._uiProps.uiComp = null;
                }

                this.destroyRenderData();

                if (this._materialInstances) {
                  for (var i = 0; i < this._materialInstances.length; i++) {
                    var instance = this._materialInstances[i];

                    if (instance) {
                      instance.destroy();
                    }
                  }
                }
              };

              _proto.markForUpdateRenderData = function markForUpdateRenderData(enable) {
                if (enable === void 0) {
                  enable = true;
                }

                if (enable) {
                  var renderData = this.renderData;

                  if (renderData) {
                    renderData.vertDirty = true;
                  }

                  uiRendererManager.markDirtyRenderer(this);
                }
              };

              _proto.requestRenderData = function requestRenderData(drawInfoType) {
                if (drawInfoType === void 0) {
                  drawInfoType = RenderDrawInfoType.COMP;
                }

                var data = RenderData.add();
                data.initRenderDrawInfo(this, drawInfoType);
                this._renderData = data;
                return data;
              };

              _proto.destroyRenderData = function destroyRenderData() {
                if (!this.renderData) {
                  return;
                }

                this.renderData.removeRenderDrawInfo(this);
                RenderData.remove(this.renderData);
                this._renderData = null;
              };

              _proto.updateRenderer = function updateRenderer() {
                if (this._assembler) {
                  this._assembler.updateRenderData(this);
                }

                this._renderFlag = this._canRender();
                this._renderEntity.enabled = this._renderFlag;
              };

              _proto.fillBuffers = function fillBuffers(render) {
                if (this._renderFlag) {
                  this._render(render);
                }
              };

              _proto.postUpdateAssembler = function postUpdateAssembler(render) {
                if (this._postAssembler && this._renderFlag) {
                  this._postRender(render);
                }
              };

              _proto._render = function _render(render) {};

              _proto._postRender = function _postRender(render) {};

              _proto._canRender = function _canRender() {
                {
                  assert(this.isValid, 'this component should not be invalid!');
                }

                return this.getSharedMaterial(0) !== null && this._enabled && this._color.a > 0;
              };

              _proto._postCanRender = function _postCanRender() {};

              _proto.updateMaterial = function updateMaterial() {
                if (this._customMaterial) {
                  if (this.getSharedMaterial(0) !== this._customMaterial) {
                    this.setMaterial(this._customMaterial, 0);
                  }

                  return;
                }

                var mat = this._updateBuiltinMaterial();

                this.setMaterial(mat, 0);

                if (this.stencilStage === Stage.ENTER_LEVEL || this.stencilStage === Stage.ENTER_LEVEL_INVERTED) {
                  this.getMaterialInstance(0).recompileShaders({
                    USE_ALPHA_TEST: true
                  });
                }

                this._updateBlendFunc();
              };

              _proto._updateColor = function _updateColor() {
                this.node._uiProps.colorDirty = true;
                this.setEntityColorDirty(true);
                this.setEntityColor(this._color);
                this.setEntityOpacity(this.node._uiProps.localOpacity);

                if (this._assembler) {
                  this._assembler.updateColor(this);

                  var renderFlag = this._renderFlag;
                  this._renderFlag = this._canRender();
                  this.setEntityEnabled(this._renderFlag);

                  if (renderFlag !== this._renderFlag) {
                    var renderData = this.renderData;

                    if (renderData) {
                      renderData.vertDirty = true;
                    }
                  }
                }
              };

              UIRenderer.setEntityColorDirtyRecursively = function setEntityColorDirtyRecursively(node, dirty) {
                var render = node._uiProps.uiComp;

                if (render && render.color) {
                  render._renderEntity.colorDirty = dirty;
                }

                for (var i = 0; i < node.children.length; i++) {
                  UIRenderer.setEntityColorDirtyRecursively(node.children[i], dirty);
                }
              };

              _proto.setEntityColorDirty = function setEntityColorDirty(dirty) {
              };

              _proto.setEntityColor = function setEntityColor(color) {
              };

              _proto.setEntityOpacity = function setEntityOpacity(opacity) {
              };

              _proto.setEntityEnabled = function setEntityEnabled(enabled) {
              };

              _proto._updateBlendFunc = function _updateBlendFunc() {
                var target = this.getRenderMaterial(0).passes[0].blendState.targets[0];
                this._dstBlendFactorCache = target.blendDst;
                this._srcBlendFactorCache = target.blendSrc;

                if (this._dstBlendFactorCache !== this._dstBlendFactor || this._srcBlendFactorCache !== this._srcBlendFactor) {
                  target = this.getMaterialInstance(0).passes[0].blendState.targets[0];
                  target.blend = true;
                  target.blendDstAlpha = BlendFactor.ONE_MINUS_SRC_ALPHA;
                  target.blendDst = this._dstBlendFactor;
                  target.blendSrc = this._srcBlendFactor;
                  var targetPass = this.getMaterialInstance(0).passes[0];
                  targetPass.blendState.setTarget(0, target);

                  targetPass._updatePassHash();

                  this._dstBlendFactorCache = this._dstBlendFactor;
                  this._srcBlendFactorCache = this._srcBlendFactor;
                }
              };

              _proto._nodeStateChange = function _nodeStateChange(transformType) {
                if (this.renderData) {
                  this.markForUpdateRenderData();
                }

                for (var i = 0; i < this.node.children.length; ++i) {
                  var child = this.node.children[i];
                  var renderComp = child.getComponent(UIRenderer);

                  if (renderComp) {
                    renderComp.markForUpdateRenderData();
                  }
                }
              };

              _proto._colorDirty = function _colorDirty() {
                this.node._uiProps.colorDirty = true;
                this.setEntityColorDirty(true);
              };

              _proto._onMaterialModified = function _onMaterialModified(idx, material) {
                if (this.renderData) {
                  this.markForUpdateRenderData();
                  this.renderData.passDirty = true;
                }

                _Renderer.prototype._onMaterialModified.call(this, idx, material);
              };

              _proto._updateBuiltinMaterial = function _updateBuiltinMaterial() {
                var mat;

                switch (this._instanceMaterialType) {
                  case InstanceMaterialType.ADD_COLOR:
                    mat = builtinResMgr.get("ui-base-material");
                    break;

                  case InstanceMaterialType.GRAYSCALE:
                    mat = builtinResMgr.get("ui-sprite-gray-material");
                    break;

                  case InstanceMaterialType.USE_ALPHA_SEPARATED:
                    mat = builtinResMgr.get("ui-sprite-alpha-sep-material");
                    break;

                  case InstanceMaterialType.USE_ALPHA_SEPARATED_AND_GRAY:
                    mat = builtinResMgr.get("ui-sprite-gray-alpha-sep-material");
                    break;

                  default:
                    mat = builtinResMgr.get("ui-sprite-material");
                    break;
                }

                return mat;
              };

              _proto.setNodeDirty = function setNodeDirty() {
                if (this.renderData) {
                  this.renderData.nodeDirty = true;
                }
              };

              _proto.setTextureDirty = function setTextureDirty() {
                if (this.renderData) {
                  this.renderData.textureDirty = true;
                }
              };

              _proto.createRenderEntity = function createRenderEntity() {
                return new RenderEntity(RenderEntityType.STATIC);
              };

              _createClass(UIRenderer, [{
                key: "sharedMaterials",
                get: function get() {
                  return  this._materials;
                },
                set: function set(val) {
                  for (var i = 0; i < val.length; i++) {
                    if (val[i] !== this._materials[i]) {
                      this.setMaterial(val[i], i);
                    }
                  }

                  if (val.length < this._materials.length) {
                    for (var _i = val.length; _i < this._materials.length; _i++) {
                      this.setMaterial(null, _i);
                    }

                    this._materials.splice(val.length);
                  }
                }
              }, {
                key: "customMaterial",
                get: function get() {
                  return this._customMaterial;
                },
                set: function set(val) {
                  this._customMaterial = val;
                  this.updateMaterial();
                }
              }, {
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(value) {
                  if (this._color.equals(value)) {
                    return;
                  }

                  this._color.set(value);

                  this._updateColor();
                }
              }, {
                key: "renderData",
                get: function get() {
                  return this._renderData;
                }
              }, {
                key: "useVertexOpacity",
                get: function get() {
                  return this._useVertexOpacity;
                }
              }, {
                key: "stencilStage",
                get: function get() {
                  return this._stencilStage;
                },
                set: function set(val) {
                  this._stencilStage = val;

                  this._renderEntity.setStencilStage(val);
                }
              }, {
                key: "batcher",
                get: function get() {
                  return director.root.batcher2D;
                }
              }, {
                key: "renderEntity",
                get: function get() {
                  {
                    assert(this._renderEntity, 'this._renderEntity should not be invalid');
                  }

                  return this._renderEntity;
                }
              }]);

              return UIRenderer;
            }(Renderer), _class3$1.BlendState = BlendFactor, _class3$1.Assembler = null, _class3$1.PostAssembler = null, _temp$2), (_applyDecoratedDescriptor(_class2$5.prototype, "sharedMaterials", [override$1], Object.getOwnPropertyDescriptor(_class2$5.prototype, "sharedMaterials"), _class2$5.prototype), _applyDecoratedDescriptor(_class2$5.prototype, "customMaterial", [_dec3], Object.getOwnPropertyDescriptor(_class2$5.prototype, "customMaterial"), _class2$5.prototype), _initializer$4 = applyDecoratedInitializer(_class2$5.prototype, "_materials", [override$1], function () {
              return [];
            }), _initializer2$2 = applyDecoratedInitializer(_class2$5.prototype, "_customMaterial", [_dec4], function () {
              return null;
            }), _initializer3$1 = applyDecoratedInitializer(_class2$5.prototype, "_srcBlendFactor", [serializable$j], function () {
              return BlendFactor.SRC_ALPHA;
            }), _initializer4$1 = applyDecoratedInitializer(_class2$5.prototype, "_dstBlendFactor", [serializable$j], function () {
              return BlendFactor.ONE_MINUS_SRC_ALPHA;
            }), _initializer5 = applyDecoratedInitializer(_class2$5.prototype, "_color", [serializable$j], function () {
              return Color$1.WHITE.clone();
            })), _class2$5)) || _class$7) || _class$7));
            legacyCC.internal.UIRenderer = UIRenderer;

            var _dec$8, _dec2$3, _dec3$1, _dec4$1, _dec5, _dec6, _dec7, _class$8, _class2$6, _initializer$5, _initializer2$3, _initializer3$2, _initializer4$2, _initializer5$1, _initializer6, _initializer7, _initializer8, _initializer9, _initializer10, _initializer11, _initializer12, _initializer13, _initializer14, _initializer15, _initializer16, _initializer17, _class3$2, _temp$3;
            var tempColor = Color$1.WHITE.clone();
            var HorizontalTextAlignment;

            (function (HorizontalTextAlignment) {
              HorizontalTextAlignment[HorizontalTextAlignment["LEFT"] = 0] = "LEFT";
              HorizontalTextAlignment[HorizontalTextAlignment["CENTER"] = 1] = "CENTER";
              HorizontalTextAlignment[HorizontalTextAlignment["RIGHT"] = 2] = "RIGHT";
            })(HorizontalTextAlignment || (HorizontalTextAlignment = exports('HorizontalTextAlignment', {})));

            ccenum(HorizontalTextAlignment);
            var VerticalTextAlignment;

            (function (VerticalTextAlignment) {
              VerticalTextAlignment[VerticalTextAlignment["TOP"] = 0] = "TOP";
              VerticalTextAlignment[VerticalTextAlignment["CENTER"] = 1] = "CENTER";
              VerticalTextAlignment[VerticalTextAlignment["BOTTOM"] = 2] = "BOTTOM";
            })(VerticalTextAlignment || (VerticalTextAlignment = exports('VerticalTextAlignment', {})));

            ccenum(VerticalTextAlignment);
            var Overflow;

            (function (Overflow) {
              Overflow[Overflow["NONE"] = 0] = "NONE";
              Overflow[Overflow["CLAMP"] = 1] = "CLAMP";
              Overflow[Overflow["SHRINK"] = 2] = "SHRINK";
              Overflow[Overflow["RESIZE_HEIGHT"] = 3] = "RESIZE_HEIGHT";
            })(Overflow || (Overflow = exports('Overflow', {})));

            ccenum(Overflow);
            var CacheMode;

            (function (CacheMode) {
              CacheMode[CacheMode["NONE"] = 0] = "NONE";
              CacheMode[CacheMode["BITMAP"] = 1] = "BITMAP";
              CacheMode[CacheMode["CHAR"] = 2] = "CHAR";
            })(CacheMode || (CacheMode = exports('CacheMode', {})));

            ccenum(CacheMode);
            var Label = exports('Label', (_dec$8 = ccclass$p('cc.Label'), _dec2$3 = executionOrder(110), _dec3$1 = type$8(HorizontalTextAlignment), _dec4$1 = type$8(VerticalTextAlignment), _dec5 = type$8(Overflow), _dec6 = type$8(Font), _dec7 = type$8(CacheMode), _dec$8(_class$8 = _dec2$3(_class$8 = (_class2$6 = (_temp$3 = _class3$2 = function (_UIRenderer) {
              _inheritsLoose(Label, _UIRenderer);

              function Label() {
                var _this;

                _this = _UIRenderer.call(this) || this;
                _this._string = _initializer$5 && _initializer$5();
                _this._horizontalAlign = _initializer2$3 && _initializer2$3();
                _this._verticalAlign = _initializer3$2 && _initializer3$2();
                _this._actualFontSize = _initializer4$2 && _initializer4$2();
                _this._fontSize = _initializer5$1 && _initializer5$1();
                _this._fontFamily = _initializer6 && _initializer6();
                _this._lineHeight = _initializer7 && _initializer7();
                _this._overflow = _initializer8 && _initializer8();
                _this._enableWrapText = _initializer9 && _initializer9();
                _this._font = _initializer10 && _initializer10();
                _this._isSystemFontUsed = _initializer11 && _initializer11();
                _this._spacingX = _initializer12 && _initializer12();
                _this._isItalic = _initializer13 && _initializer13();
                _this._isBold = _initializer14 && _initializer14();
                _this._isUnderline = _initializer15 && _initializer15();
                _this._underlineHeight = _initializer16 && _initializer16();
                _this._cacheMode = _initializer17 && _initializer17();
                _this._N$file = null;
                _this._texture = null;
                _this._ttfSpriteFrame = null;
                _this._userDefinedFont = null;
                _this._assemblerData = null;
                _this._fontAtlas = null;
                _this._letterTexture = null;
                _this._contentWidth = 0;

                _this._ttfSpriteFrame = null;
                return _this;
              }

              var _proto = Label.prototype;

              _proto.onEnable = function onEnable() {
                _UIRenderer.prototype.onEnable.call(this);

                if (!this._font && !this._isSystemFontUsed) {
                  this.useSystemFont = true;
                }

                if (this._isSystemFontUsed && !this._fontFamily) {
                  this.fontFamily = 'Arial';
                }

                this._applyFontTexture();
              };

              _proto.onDestroy = function onDestroy() {
                if (this._assembler && this._assembler.resetAssemblerData) {
                  this._assembler.resetAssemblerData(this._assemblerData);
                }

                this._assemblerData = null;

                if (this._ttfSpriteFrame) {
                  this._ttfSpriteFrame._resetDynamicAtlasFrame();

                  var tex = this._ttfSpriteFrame.texture;

                  this._ttfSpriteFrame.destroy();

                  if (tex) {
                    var tex2d = tex;

                    if (tex2d.image) {
                      tex2d.image.destroy();
                    }

                    tex.destroy();
                  }

                  this._ttfSpriteFrame = null;
                }

                this._letterTexture = null;

                _UIRenderer.prototype.onDestroy.call(this);
              };

              _proto.updateRenderData = function updateRenderData(force) {
                if (force === void 0) {
                  force = false;
                }

                if (force) {
                  this._flushAssembler();

                  if (this.renderData) this.renderData.vertDirty = true;

                  this._applyFontTexture();
                }

                if (this._assembler) {
                  this._assembler.updateRenderData(this);
                }
              };

              _proto._render = function _render(render) {
                render.commitComp(this, this.renderData, this._texture, this._assembler, null);
              };

              _proto._updateColor = function _updateColor() {
                _UIRenderer.prototype._updateColor.call(this);

                this.markForUpdateRenderData();
              };

              _proto.setEntityColor = function setEntityColor(color) {
              };

              _proto._canRender = function _canRender() {
                if (!_UIRenderer.prototype._canRender.call(this) || !this._string) {
                  return false;
                }

                var font = this._font;

                if (font && font instanceof BitmapFont) {
                  var spriteFrame = font.spriteFrame;

                  if (!spriteFrame || !spriteFrame.texture) {
                    return false;
                  }
                }

                return true;
              };

              _proto._flushAssembler = function _flushAssembler() {
                var assembler = Label.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this.destroyRenderData();
                  this._assembler = assembler;
                }

                if (!this.renderData) {
                  if (this._assembler && this._assembler.createData) {
                    this._renderData = this._assembler.createData(this);
                    this.renderData.material = this.material;

                    this._updateColor();
                  }
                }
              };

              _proto._applyFontTexture = function _applyFontTexture() {
                this.markForUpdateRenderData();
                var font = this._font;

                if (font instanceof BitmapFont) {
                  var spriteFrame = font.spriteFrame;

                  if (spriteFrame && spriteFrame.texture) {
                    this._texture = spriteFrame;

                    if (this.renderData) {
                      this.renderData.textureDirty = true;
                    }

                    this.changeMaterialForDefine();

                    if (this._assembler) {
                      this._assembler.updateRenderData(this);
                    }
                  }
                } else {
                  if (this.cacheMode === CacheMode.CHAR) {
                    this._letterTexture = this._assembler.getAssemblerData();
                    this._texture = this._letterTexture;
                  } else if (!this._ttfSpriteFrame) {
                    this._ttfSpriteFrame = new SpriteFrame();
                    this._assemblerData = this._assembler.getAssemblerData();
                    var image = new ImageAsset(this._assemblerData.canvas);
                    var texture = new Texture2D();
                    texture.image = image;
                    this._ttfSpriteFrame.texture = texture;
                  }

                  if (this.cacheMode !== CacheMode.CHAR) {
                    this._texture = this._ttfSpriteFrame;
                  }

                  this.changeMaterialForDefine();
                }
              };

              _proto.changeMaterialForDefine = function changeMaterialForDefine() {
                if (!this._texture) {
                  return;
                }

                var value = false;

                if (this.cacheMode !== CacheMode.CHAR) {
                  var spriteFrame = this._texture;
                  var texture = spriteFrame.texture;

                  if (texture instanceof TextureBase) {
                    var format = texture.getPixelFormat();
                    value = format === PixelFormat.RGBA_ETC1 || format === PixelFormat.RGB_A_PVRTC_4BPPV1 || format === PixelFormat.RGB_A_PVRTC_2BPPV1;
                  }
                }

                if (value) {
                  this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED;
                } else {
                  this._instanceMaterialType = InstanceMaterialType.ADD_COLOR_AND_TEXTURE;
                }

                this.updateMaterial();
              };

              _proto._updateBlendFunc = function _updateBlendFunc() {

                _UIRenderer.prototype._updateBlendFunc.call(this);
              };

              _createClass(Label, [{
                key: "string",
                get: function get() {
                  return this._string;
                },
                set: function set(value) {
                  if (value === null || value === undefined) {
                    value = '';
                  } else {
                    value = value.toString();
                  }

                  if (this._string === value) {
                    return;
                  }

                  this._string = value;
                  this.markForUpdateRenderData();
                }
              }, {
                key: "horizontalAlign",
                get: function get() {
                  return this._horizontalAlign;
                },
                set: function set(value) {
                  if (this._horizontalAlign === value) {
                    return;
                  }

                  this._horizontalAlign = value;
                  this.markForUpdateRenderData();
                }
              }, {
                key: "verticalAlign",
                get: function get() {
                  return this._verticalAlign;
                },
                set: function set(value) {
                  if (this._verticalAlign === value) {
                    return;
                  }

                  this._verticalAlign = value;
                  this.markForUpdateRenderData();
                }
              }, {
                key: "actualFontSize",
                get: function get() {
                  return this._actualFontSize;
                },
                set: function set(value) {
                  this._actualFontSize = value;
                }
              }, {
                key: "fontSize",
                get: function get() {
                  return this._fontSize;
                },
                set: function set(value) {
                  if (this._fontSize === value) {
                    return;
                  }

                  this._fontSize = value;
                  this.markForUpdateRenderData();
                }
              }, {
                key: "lineHeight",
                get: function get() {
                  return this._lineHeight;
                },
                set: function set(value) {
                  if (this._lineHeight === value) {
                    return;
                  }

                  this._lineHeight = value;
                  this.markForUpdateRenderData();
                }
              }, {
                key: "spacingX",
                get: function get() {
                  return this._spacingX;
                },
                set: function set(value) {
                  if (this._spacingX === value) {
                    return;
                  }

                  this._spacingX = value;
                  this.markForUpdateRenderData();
                }
              }, {
                key: "overflow",
                get: function get() {
                  return this._overflow;
                },
                set: function set(value) {
                  if (this._overflow === value) {
                    return;
                  }

                  this._overflow = value;
                  this.markForUpdateRenderData();
                }
              }, {
                key: "enableWrapText",
                get: function get() {
                  return this._enableWrapText;
                },
                set: function set(value) {
                  if (this._enableWrapText === value) {
                    return;
                  }

                  this._enableWrapText = value;
                  this.markForUpdateRenderData();
                }
              }, {
                key: "useSystemFont",
                get: function get() {
                  return this._isSystemFontUsed;
                },
                set: function set(value) {
                  if (this._isSystemFontUsed === value) {
                    return;
                  }

                  this.destroyRenderData();

                  this._isSystemFontUsed = !!value;

                  if (value) {
                    this.font = null;
                  }

                  this._flushAssembler();

                  this.markForUpdateRenderData();
                }
              }, {
                key: "fontFamily",
                get: function get() {
                  return this._fontFamily;
                },
                set: function set(value) {
                  if (this._fontFamily === value) {
                    return;
                  }

                  this._fontFamily = value;
                  this.markForUpdateRenderData();
                }
              }, {
                key: "font",
                get: function get() {
                  return this._font;
                },
                set: function set(value) {
                  if (this._font === value) {
                    return;
                  }

                  this._isSystemFontUsed = !value;

                  this._font = value;
                  this.destroyRenderData();
                  this._fontAtlas = null;
                  this.updateRenderData(true);
                }
              }, {
                key: "cacheMode",
                get: function get() {
                  return this._cacheMode;
                },
                set: function set(value) {
                  if (this._cacheMode === value) {
                    return;
                  }

                  if (this._cacheMode === CacheMode.BITMAP && !(this._font instanceof BitmapFont) && this._ttfSpriteFrame) {
                    this._ttfSpriteFrame._resetDynamicAtlasFrame();
                  }

                  if (this._cacheMode === CacheMode.CHAR) {
                    this._ttfSpriteFrame = null;
                  }

                  this._cacheMode = value;
                  this.updateRenderData(true);
                }
              }, {
                key: "isBold",
                get: function get() {
                  return this._isBold;
                },
                set: function set(value) {
                  if (this._isBold === value) {
                    return;
                  }

                  this._isBold = value;
                  this.markForUpdateRenderData();
                }
              }, {
                key: "isItalic",
                get: function get() {
                  return this._isItalic;
                },
                set: function set(value) {
                  if (this._isItalic === value) {
                    return;
                  }

                  this._isItalic = value;
                  this.markForUpdateRenderData();
                }
              }, {
                key: "isUnderline",
                get: function get() {
                  return this._isUnderline;
                },
                set: function set(value) {
                  if (this._isUnderline === value) {
                    return;
                  }

                  this._isUnderline = value;
                  this.markForUpdateRenderData();
                }
              }, {
                key: "underlineHeight",
                get: function get() {
                  return this._underlineHeight;
                },
                set: function set(value) {
                  if (this._underlineHeight === value) return;
                  this._underlineHeight = value;
                  this.markForUpdateRenderData();
                }
              }, {
                key: "spriteFrame",
                get: function get() {
                  return this._texture;
                }
              }, {
                key: "ttfSpriteFrame",
                get: function get() {
                  return this._ttfSpriteFrame;
                }
              }, {
                key: "assemblerData",
                get: function get() {
                  return this._assemblerData;
                }
              }, {
                key: "fontAtlas",
                get: function get() {
                  return this._fontAtlas;
                },
                set: function set(value) {
                  this._fontAtlas = value;
                }
              }, {
                key: "_bmFontOriginalSize",
                get: function get() {
                  if (this._font instanceof BitmapFont) {
                    return this._font.fontSize;
                  } else {
                    return -1;
                  }
                }
              }, {
                key: "contentWidth",
                get: function get() {
                  return this._contentWidth;
                },
                set: function set(val) {
                  this._contentWidth = val;
                }
              }]);

              return Label;
            }(UIRenderer), _class3$2.HorizontalAlign = HorizontalTextAlignment, _class3$2.VerticalAlign = VerticalTextAlignment, _class3$2.Overflow = Overflow, _class3$2.CacheMode = CacheMode, _class3$2._canvasPool = CanvasPool.getInstance(), _temp$3), (_applyDecoratedDescriptor(_class2$6.prototype, "horizontalAlign", [_dec3$1], Object.getOwnPropertyDescriptor(_class2$6.prototype, "horizontalAlign"), _class2$6.prototype), _applyDecoratedDescriptor(_class2$6.prototype, "verticalAlign", [_dec4$1], Object.getOwnPropertyDescriptor(_class2$6.prototype, "verticalAlign"), _class2$6.prototype), _applyDecoratedDescriptor(_class2$6.prototype, "overflow", [_dec5], Object.getOwnPropertyDescriptor(_class2$6.prototype, "overflow"), _class2$6.prototype), _applyDecoratedDescriptor(_class2$6.prototype, "font", [_dec6], Object.getOwnPropertyDescriptor(_class2$6.prototype, "font"), _class2$6.prototype), _applyDecoratedDescriptor(_class2$6.prototype, "cacheMode", [_dec7], Object.getOwnPropertyDescriptor(_class2$6.prototype, "cacheMode"), _class2$6.prototype), _initializer$5 = applyDecoratedInitializer(_class2$6.prototype, "_string", [serializable$j], function () {
              return 'label';
            }), _initializer2$3 = applyDecoratedInitializer(_class2$6.prototype, "_horizontalAlign", [serializable$j], function () {
              return HorizontalTextAlignment.CENTER;
            }), _initializer3$2 = applyDecoratedInitializer(_class2$6.prototype, "_verticalAlign", [serializable$j], function () {
              return VerticalTextAlignment.CENTER;
            }), _initializer4$2 = applyDecoratedInitializer(_class2$6.prototype, "_actualFontSize", [serializable$j], function () {
              return 0;
            }), _initializer5$1 = applyDecoratedInitializer(_class2$6.prototype, "_fontSize", [serializable$j], function () {
              return 40;
            }), _initializer6 = applyDecoratedInitializer(_class2$6.prototype, "_fontFamily", [serializable$j], function () {
              return 'Arial';
            }), _initializer7 = applyDecoratedInitializer(_class2$6.prototype, "_lineHeight", [serializable$j], function () {
              return 40;
            }), _initializer8 = applyDecoratedInitializer(_class2$6.prototype, "_overflow", [serializable$j], function () {
              return Overflow.NONE;
            }), _initializer9 = applyDecoratedInitializer(_class2$6.prototype, "_enableWrapText", [serializable$j], function () {
              return true;
            }), _initializer10 = applyDecoratedInitializer(_class2$6.prototype, "_font", [serializable$j], function () {
              return null;
            }), _initializer11 = applyDecoratedInitializer(_class2$6.prototype, "_isSystemFontUsed", [serializable$j], function () {
              return true;
            }), _initializer12 = applyDecoratedInitializer(_class2$6.prototype, "_spacingX", [serializable$j], function () {
              return 0;
            }), _initializer13 = applyDecoratedInitializer(_class2$6.prototype, "_isItalic", [serializable$j], function () {
              return false;
            }), _initializer14 = applyDecoratedInitializer(_class2$6.prototype, "_isBold", [serializable$j], function () {
              return false;
            }), _initializer15 = applyDecoratedInitializer(_class2$6.prototype, "_isUnderline", [serializable$j], function () {
              return false;
            }), _initializer16 = applyDecoratedInitializer(_class2$6.prototype, "_underlineHeight", [serializable$j], function () {
              return 2;
            }), _initializer17 = applyDecoratedInitializer(_class2$6.prototype, "_cacheMode", [serializable$j], function () {
              return CacheMode.NONE;
            })), _class2$6)) || _class$8) || _class$8));
            legacyCC.Label = Label;

            var LineCap;

            (function (LineCap) {
              LineCap[LineCap["BUTT"] = 0] = "BUTT";
              LineCap[LineCap["ROUND"] = 1] = "ROUND";
              LineCap[LineCap["SQUARE"] = 2] = "SQUARE";
            })(LineCap || (LineCap = {}));

            ccenum(LineCap);
            var LineJoin;

            (function (LineJoin) {
              LineJoin[LineJoin["BEVEL"] = 0] = "BEVEL";
              LineJoin[LineJoin["ROUND"] = 1] = "ROUND";
              LineJoin[LineJoin["MITER"] = 2] = "MITER";
            })(LineJoin || (LineJoin = {}));

            ccenum(LineJoin);
            var PointFlags;

            (function (PointFlags) {
              PointFlags[PointFlags["PT_CORNER"] = 1] = "PT_CORNER";
              PointFlags[PointFlags["PT_LEFT"] = 2] = "PT_LEFT";
              PointFlags[PointFlags["PT_BEVEL"] = 4] = "PT_BEVEL";
              PointFlags[PointFlags["PT_INNERBEVEL"] = 8] = "PT_INNERBEVEL";
            })(PointFlags || (PointFlags = {}));

            ccenum(PointFlags);

            var PI = Math.PI;
            var min = Math.min;
            var max = Math.max;
            var cos = Math.cos;
            var sin = Math.sin;
            var abs = Math.abs;
            var sign = Math.sign;
            var KAPPA90 = 0.5522847493;
            function arc(ctx, cx, cy, r, startAngle, endAngle, counterclockwise) {
              counterclockwise = counterclockwise || false;
              var a = 0;
              var da = 0;
              var hda = 0;
              var kappa = 0;
              var dx = 0;
              var dy = 0;
              var x = 0;
              var y = 0;
              var tanx = 0;
              var tany = 0;
              var px = 0;
              var py = 0;
              var ptanx = 0;
              var ptany = 0;
              var i = 0;
              var ndivs = 0;
              da = endAngle - startAngle;

              if (counterclockwise) {
                if (abs(da) >= PI * 2) {
                  da = PI * 2;
                } else {
                  while (da < 0) {
                    da += PI * 2;
                  }
                }
              } else if (abs(da) >= PI * 2) {
                da = -PI * 2;
              } else {
                while (da > 0) {
                  da -= PI * 2;
                }
              }

              ndivs = max(1, min(abs(da) / (PI * 0.5) + 0.5, 5)) | 0;
              hda = da / ndivs / 2.0;
              kappa = abs(4.0 / 3.0 * (1 - cos(hda)) / sin(hda));

              if (!counterclockwise) {
                kappa = -kappa;
              }

              for (i = 0; i <= ndivs; i++) {
                a = startAngle + da * (i / ndivs);
                dx = cos(a);
                dy = sin(a);
                x = cx + dx * r;
                y = cy + dy * r;
                tanx = -dy * r * kappa;
                tany = dx * r * kappa;

                if (i === 0) {
                  ctx.moveTo(x, y);
                } else {
                  ctx.bezierCurveTo(px + ptanx, py + ptany, x - tanx, y - tany, x, y);
                }

                px = x;
                py = y;
                ptanx = tanx;
                ptany = tany;
              }
            }
            function ellipse(ctx, cx, cy, rx, ry) {
              ctx.moveTo(cx - rx, cy);
              ctx.bezierCurveTo(cx - rx, cy + ry * KAPPA90, cx - rx * KAPPA90, cy + ry, cx, cy + ry);
              ctx.bezierCurveTo(cx + rx * KAPPA90, cy + ry, cx + rx, cy + ry * KAPPA90, cx + rx, cy);
              ctx.bezierCurveTo(cx + rx, cy - ry * KAPPA90, cx + rx * KAPPA90, cy - ry, cx, cy - ry);
              ctx.bezierCurveTo(cx - rx * KAPPA90, cy - ry, cx - rx, cy - ry * KAPPA90, cx - rx, cy);
              ctx.close();
            }
            function roundRect(ctx, x, y, w, h, r) {
              if (r < 0.1) {
                ctx.rect(x, y, w, h);
              } else {
                var rx = min(r, abs(w) * 0.5) * sign(w);
                var ry = min(r, abs(h) * 0.5) * sign(h);
                ctx.moveTo(x, y + ry);
                ctx.lineTo(x, y + h - ry);
                ctx.bezierCurveTo(x, y + h - ry * (1 - KAPPA90), x + rx * (1 - KAPPA90), y + h, x + rx, y + h);
                ctx.lineTo(x + w - rx, y + h);
                ctx.bezierCurveTo(x + w - rx * (1 - KAPPA90), y + h, x + w, y + h - ry * (1 - KAPPA90), x + w, y + h - ry);
                ctx.lineTo(x + w, y + ry);
                ctx.bezierCurveTo(x + w, y + ry * (1 - KAPPA90), x + w - rx * (1 - KAPPA90), y, x + w - rx, y);
                ctx.lineTo(x + rx, y);
                ctx.bezierCurveTo(x + rx * (1 - KAPPA90), y, x, y + ry * (1 - KAPPA90), x, y + ry);
                ctx.close();
              }
            }
            function tesselateBezier(ctx, x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
              var x12 = 0;
              var y12 = 0;
              var x23 = 0;
              var y23 = 0;
              var x34 = 0;
              var y34 = 0;
              var x123 = 0;
              var y123 = 0;
              var x234 = 0;
              var y234 = 0;
              var x1234 = 0;
              var y1234 = 0;
              var dx = 0;
              var dy = 0;
              var d2 = 0;
              var d3 = 0;

              if (level > 10) {
                return;
              }

              x12 = (x1 + x2) * 0.5;
              y12 = (y1 + y2) * 0.5;
              x23 = (x2 + x3) * 0.5;
              y23 = (y2 + y3) * 0.5;
              x34 = (x3 + x4) * 0.5;
              y34 = (y3 + y4) * 0.5;
              x123 = (x12 + x23) * 0.5;
              y123 = (y12 + y23) * 0.5;
              dx = x4 - x1;
              dy = y4 - y1;
              d2 = abs((x2 - x4) * dy - (y2 - y4) * dx);
              d3 = abs((x3 - x4) * dy - (y3 - y4) * dx);

              if ((d2 + d3) * (d2 + d3) < ctx.tessTol * (dx * dx + dy * dy)) {
                ctx.addPoint(x4, y4, type === 0 ? type | PointFlags.PT_BEVEL : type);
                return;
              }

              x234 = (x23 + x34) * 0.5;
              y234 = (y23 + y34) * 0.5;
              x1234 = (x123 + x234) * 0.5;
              y1234 = (y123 + y234) * 0.5;
              tesselateBezier(ctx, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1, 0);
              tesselateBezier(ctx, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type);
            }

            var Point = function (_Vec) {
              _inheritsLoose(Point, _Vec);

              function Point(x, y) {
                var _this;

                _this = _Vec.call(this, x, y) || this;
                _this.dx = 0;
                _this.dy = 0;
                _this.dmx = 0;
                _this.dmy = 0;
                _this.flags = 0;
                _this.len = 0;

                _this.reset();

                return _this;
              }

              var _proto = Point.prototype;

              _proto.reset = function reset() {
                this.dx = 0;
                this.dy = 0;
                this.dmx = 0;
                this.dmy = 0;
                this.flags = 0;
                this.len = 0;
              };

              return Point;
            }(Vec2);
            var Path = function () {
              function Path() {
                this.closed = false;
                this.bevel = 0;
                this.complex = true;
                this.points = [];
                this.reset();
              }

              var _proto2 = Path.prototype;

              _proto2.reset = function reset() {
                this.closed = false;
                this.bevel = 0;
                this.complex = true;

                if (this.points) {
                  this.points.length = 0;
                } else {
                  this.points = [];
                }
              };

              return Path;
            }();
            var Impl = function () {
              function Impl(comp) {
                this.dataOffset = 0;
                this.updatePathOffset = false;
                this.pathLength = 0;
                this.pathOffset = 0;
                this.paths = [];
                this.tessTol = 0.25;
                this.distTol = 0.01;
                this.fillColor = Color$1.WHITE.clone();
                this.lineCap = LineCap.BUTT;
                this.strokeColor = Color$1.BLACK.clone();
                this.lineJoin = LineJoin.MITER;
                this.lineWidth = 0;
                this.pointsOffset = 0;
                this._commandX = 0;
                this._commandY = 0;
                this._points = [];
                this._renderDataList = [];
                this._curPath = null;
                this._comp = void 0;
                this._comp = comp;
              }

              var _proto3 = Impl.prototype;

              _proto3.moveTo = function moveTo(x, y) {
                if (this.updatePathOffset) {
                  this.pathOffset = this.pathLength;
                  this.updatePathOffset = false;
                }

                this._addPath();

                this.addPoint(x, y, PointFlags.PT_CORNER);
                this._commandX = x;
                this._commandY = y;
              };

              _proto3.lineTo = function lineTo(x, y) {
                this.addPoint(x, y, PointFlags.PT_CORNER);
                this._commandX = x;
                this._commandY = y;
              };

              _proto3.bezierCurveTo = function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
                var path = this._curPath;
                var last = path.points[path.points.length - 1];

                if (!last) {
                  return;
                }

                if (last.x === c1x && last.y === c1y && c2x === x && c2y === y) {
                  this.lineTo(x, y);
                  return;
                }

                tesselateBezier(this, last.x, last.y, c1x, c1y, c2x, c2y, x, y, 0, PointFlags.PT_CORNER);
                this._commandX = x;
                this._commandY = y;
              };

              _proto3.quadraticCurveTo = function quadraticCurveTo(cx, cy, x, y) {
                var x0 = this._commandX;
                var y0 = this._commandY;
                this.bezierCurveTo(x0 + 2.0 / 3.0 * (cx - x0), y0 + 2.0 / 3.0 * (cy - y0), x + 2.0 / 3.0 * (cx - x), y + 2.0 / 3.0 * (cy - y), x, y);
              };

              _proto3.arc = function arc$1(cx, cy, r, startAngle, endAngle, counterclockwise) {
                arc(this, cx, cy, r, startAngle, endAngle, counterclockwise);
              };

              _proto3.ellipse = function ellipse$1(cx, cy, rx, ry) {
                ellipse(this, cx, cy, rx, ry);

                this._curPath.complex = false;
              };

              _proto3.circle = function circle(cx, cy, r) {
                ellipse(this, cx, cy, r, r);

                this._curPath.complex = false;
              };

              _proto3.rect = function rect(x, y, w, h) {
                this.moveTo(x, y);
                this.lineTo(x + w, y);
                this.lineTo(x + w, y + h);
                this.lineTo(x, y + h);
                this.close();
                this._curPath.complex = false;
              };

              _proto3.roundRect = function roundRect$1(x, y, w, h, r) {
                roundRect(this, x, y, w, h, r);

                this._curPath.complex = false;
              };

              _proto3.clear = function clear() {
                this.pathLength = 0;
                this.pathOffset = 0;
                this.pointsOffset = 0;
                this.dataOffset = 0;
                this._curPath = null;
                this.paths.length = 0;
                this._points.length = 0;
                var dataList = this._renderDataList;

                for (var i = 0, l = dataList.length; i < l; i++) {
                  var data = dataList[i];

                  if (!data) {
                    continue;
                  }

                  MeshRenderData.remove(data);
                  data.removeRenderDrawInfo(this._comp);
                }

                this._renderDataList.length = 0;
              };

              _proto3.close = function close() {
                this._curPath.closed = true;
              };

              _proto3.requestRenderData = function requestRenderData() {
                var renderData = MeshRenderData.add();

                this._renderDataList.push(renderData);

                return renderData;
              };

              _proto3.getRenderDataList = function getRenderDataList() {
                if (this._renderDataList.length === 0) {
                  this.requestRenderData();
                }

                return this._renderDataList;
              };

              _proto3.addPoint = function addPoint(x, y, flags) {
                var path = this._curPath;

                if (!path) {
                  return;
                }

                var points = this._points;
                var pathPoints = path.points;
                var offset = this.pointsOffset++;
                var pt = points[offset];

                if (!pt) {
                  pt = new Point(x, y);
                  points.push(pt);
                } else {
                  pt.x = x;
                  pt.y = y;
                }

                pt.flags = flags;
                pathPoints.push(pt);
              };

              _proto3._addPath = function _addPath() {
                var offset = this.pathLength;
                var path = this.paths[offset];

                if (!path) {
                  path = new Path();
                  this.paths.push(path);
                } else {
                  path.reset();
                }

                this.pathLength++;
                this._curPath = path;
                return path;
              };

              return Impl;
            }();

            var _dec$9, _dec2$4, _dec3$2, _dec4$2, _class$9, _class2$7, _initializer$6, _initializer2$4, _initializer3$3, _initializer4$3, _initializer5$2, _initializer6$1, _class3$3, _temp$4;
            var attributes = vfmtPosColor.concat([new Attribute('a_dist', Format.R32F)]);
            var componentPerVertex = getComponentPerVertex(attributes);
            var stride = getAttributeStride(attributes);
            var Graphics = exports('Graphics', (_dec$9 = ccclass$p('cc.Graphics'), _dec2$4 = executionOrder(110), _dec3$2 = type$8(LineJoin), _dec4$2 = type$8(LineCap), _dec$9(_class$9 = _dec2$4(_class$9 = (_class2$7 = (_temp$4 = _class3$3 = function (_UIRenderer) {
              _inheritsLoose(Graphics, _UIRenderer);

              function Graphics() {
                var _this;

                _this = _UIRenderer.call(this) || this;
                _this.impl = null;
                _this.model = null;
                _this._lineWidth = _initializer$6 && _initializer$6();
                _this._strokeColor = _initializer2$4 && _initializer2$4();
                _this._lineJoin = _initializer3$3 && _initializer3$3();
                _this._lineCap = _initializer4$3 && _initializer4$3();
                _this._fillColor = _initializer5$2 && _initializer5$2();
                _this._miterLimit = _initializer6$1 && _initializer6$1();
                _this._isDrawing = false;
                _this._isNeedUploadData = true;
                _this._graphicsUseSubMeshes = [];
                _this._instanceMaterialType = InstanceMaterialType.ADD_COLOR;
                _this.impl = new Impl(_assertThisInitialized(_this));

                return _this;
              }

              var _proto = Graphics.prototype;

              _proto.onRestore = function onRestore() {
                if (!this.impl) {
                  this._flushAssembler();
                }
              };

              _proto.onLoad = function onLoad() {
                _UIRenderer.prototype.onLoad.call(this);

                {
                  this.model = director.root.createModel(Model);
                  this.model.node = this.model.transform = this.node;
                }

                this._flushAssembler();
              };

              _proto.onEnable = function onEnable() {
                _UIRenderer.prototype.onEnable.call(this);

                this._updateMtlForGraphics();
              };

              _proto.onDestroy = function onDestroy() {
                this._sceneGetter = null;

                {
                  if (this.model) {
                    director.root.destroyModel(this.model);
                    this.model = null;
                  }

                  var subMeshLength = this._graphicsUseSubMeshes.length;

                  if (subMeshLength > 0) {
                    for (var i = 0; i < subMeshLength; ++i) {
                      this._graphicsUseSubMeshes[i].destroy();
                    }

                    this._graphicsUseSubMeshes.length = 0;
                  }
                }

                if (this.impl) {
                  this._isDrawing = false;
                  this.impl.clear();
                  this.impl = null;
                }

                _UIRenderer.prototype.onDestroy.call(this);
              };

              _proto.moveTo = function moveTo(x, y) {
                if (!this.impl) {
                  return;
                }

                this.impl.moveTo(x, y);
              };

              _proto.lineTo = function lineTo(x, y) {
                if (!this.impl) {
                  return;
                }

                this.impl.lineTo(x, y);
              };

              _proto.bezierCurveTo = function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
                if (!this.impl) {
                  return;
                }

                this.impl.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
              };

              _proto.quadraticCurveTo = function quadraticCurveTo(cx, cy, x, y) {
                if (!this.impl) {
                  return;
                }

                this.impl.quadraticCurveTo(cx, cy, x, y);
              };

              _proto.arc = function arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
                if (!this.impl) {
                  return;
                }

                this.impl.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
              };

              _proto.ellipse = function ellipse(cx, cy, rx, ry) {
                if (!this.impl) {
                  return;
                }

                this.impl.ellipse(cx, cy, rx, ry);
              };

              _proto.circle = function circle(cx, cy, r) {
                if (!this.impl) {
                  return;
                }

                this.impl.circle(cx, cy, r);
              };

              _proto.rect = function rect(x, y, w, h) {
                if (!this.impl) {
                  return;
                }

                this.impl.rect(x, y, w, h);
              };

              _proto.roundRect = function roundRect(x, y, w, h, r) {
                if (!this.impl) {
                  return;
                }

                this.impl.roundRect(x, y, w, h, r);
              };

              _proto.fillRect = function fillRect(x, y, w, h) {
                this.rect(x, y, w, h);
                this.fill();
              };

              _proto.clear = function clear() {
                if (!this.impl) {
                  return;
                }

                this.impl.clear();
                this._isDrawing = false;

                if (this.model) {
                  for (var i = 0; i < this.model.subModels.length; i++) {
                    var subModel = this.model.subModels[i];
                    subModel.inputAssembler.indexCount = 0;
                  }
                }

                this.markForUpdateRenderData();
              };

              _proto.close = function close() {
                if (!this.impl) {
                  return;
                }

                this.impl.close();
              };

              _proto.stroke = function stroke() {
                if (!this._assembler) {
                  this._flushAssembler();
                }

                this._isDrawing = true;
                this._isNeedUploadData = true;

                this._assembler.stroke(this);
              };

              _proto.fill = function fill() {
                if (!this._assembler) {
                  this._flushAssembler();
                }

                this._isDrawing = true;
                this._isNeedUploadData = true;

                this._assembler.fill(this);
              };

              _proto._updateMtlForGraphics = function _updateMtlForGraphics() {
                var mat;

                if (this._customMaterial) {
                  mat = this.getMaterialInstance(0);
                } else {
                  mat = builtinResMgr.get('ui-graphics-material');
                  this.setMaterial(mat, 0);
                  mat = this.getMaterialInstance(0);
                  mat.recompileShaders({
                    USE_LOCAL: true
                  });
                }
              };

              _proto.activeSubModel = function activeSubModel(idx) {
                if (!this.model) {
                  warnID(4500, this.node.name);
                  return;
                }

                if (this.model.subModels.length <= idx) {
                  var gfxDevice = deviceManager.gfxDevice;
                  var vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 65535 * stride, stride));
                  var indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 65535 * Uint16Array.BYTES_PER_ELEMENT * 2, Uint16Array.BYTES_PER_ELEMENT));
                  var renderMesh = new RenderingSubMesh([vertexBuffer], attributes, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
                  renderMesh.subMeshIdx = 0;
                  this.model.initSubModel(idx, renderMesh, this.getMaterialInstance(0));

                  this._graphicsUseSubMeshes.push(renderMesh);
                }
              };

              _proto._uploadData = function _uploadData() {
                var impl = this.impl;

                if (!impl) {
                  return;
                }

                var renderDataList = impl && impl.getRenderDataList();

                if (renderDataList.length <= 0 || !this.model) {
                  return;
                }

                var subModelList = this.model.subModels;

                for (var i = 0; i < renderDataList.length; i++) {
                  var renderData = renderDataList[i];
                  var ia = subModelList[i].inputAssembler;

                  if (renderData.lastFilledVertex === renderData.vertexStart) {
                    continue;
                  }

                  var vb = new Float32Array(renderData.vData.buffer, 0, renderData.vertexStart * componentPerVertex);
                  ia.vertexBuffers[0].update(vb);
                  ia.vertexCount = renderData.vertexStart;
                  var ib = new Uint16Array(renderData.iData.buffer, 0, renderData.indexStart);
                  ia.indexBuffer.update(ib);
                  ia.indexCount = renderData.indexStart;
                  renderData.lastFilledVertex = renderData.vertexStart;
                  renderData.lastFilledIndex = renderData.indexStart;
                }

                this._isNeedUploadData = false;
              };

              _proto._render = function _render(render) {
                if (this._isNeedUploadData) {
                  if (this.impl) {
                    var renderDataList = this.impl.getRenderDataList();
                    var len = this.model.subModels.length;

                    if (renderDataList.length > len) {
                      for (var i = len; i < renderDataList.length; i++) {
                        this.activeSubModel(i);
                      }
                    }
                  }

                  this._uploadData();
                }

                render.commitModel(this, this.model, this.getMaterialInstance(0));
              };

              _proto._flushAssembler = function _flushAssembler() {
                var assembler = Graphics.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this._assembler = assembler;
                }
              };

              _proto._canRender = function _canRender() {
                if (!_UIRenderer.prototype._canRender.call(this)) {
                  return false;
                }

                {
                  return !!this.model && this._isDrawing;
                }
              };

              _proto.updateRenderer = function updateRenderer() {
                _UIRenderer.prototype.updateRenderer.call(this);
              };

              _proto.createRenderEntity = function createRenderEntity() {
                return new RenderEntity(RenderEntityType.DYNAMIC);
              };

              _createClass(Graphics, [{
                key: "lineWidth",
                get: function get() {
                  return this._lineWidth;
                },
                set: function set(value) {
                  this._lineWidth = value;

                  if (!this.impl) {
                    return;
                  }

                  this.impl.lineWidth = value;
                }
              }, {
                key: "lineJoin",
                get: function get() {
                  return this._lineJoin;
                },
                set: function set(value) {
                  this._lineJoin = value;

                  if (!this.impl) {
                    return;
                  }

                  this.impl.lineJoin = value;
                }
              }, {
                key: "lineCap",
                get: function get() {
                  return this._lineCap;
                },
                set: function set(value) {
                  this._lineCap = value;

                  if (!this.impl) {
                    return;
                  }

                  this.impl.lineCap = value;
                }
              }, {
                key: "strokeColor",
                get: function get() {
                  return this._strokeColor;
                },
                set: function set(value) {
                  if (!this.impl) {
                    return;
                  }

                  this._strokeColor.set(value);

                  this.impl.strokeColor = this._strokeColor;
                }
              }, {
                key: "fillColor",
                get: function get() {
                  return this._fillColor;
                },
                set: function set(value) {
                  if (!this.impl) {
                    return;
                  }

                  this._fillColor.set(value);

                  this.impl.fillColor = this._fillColor;
                }
              }, {
                key: "miterLimit",
                get: function get() {
                  return this._miterLimit;
                },
                set: function set(value) {
                  this._miterLimit = value;
                }
              }, {
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(value) {
                  if (this._color === value) {
                    return;
                  }

                  this._color.set(value);
                }
              }, {
                key: "graphicsNativeProxy",
                get: function get() {
                  return this._graphicsNativeProxy;
                }
              }]);

              return Graphics;
            }(UIRenderer), _class3$3.LineJoin = LineJoin, _class3$3.LineCap = LineCap, _temp$4), (_applyDecoratedDescriptor(_class2$7.prototype, "lineJoin", [_dec3$2], Object.getOwnPropertyDescriptor(_class2$7.prototype, "lineJoin"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "lineCap", [_dec4$2], Object.getOwnPropertyDescriptor(_class2$7.prototype, "lineCap"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "color", [override$1], Object.getOwnPropertyDescriptor(_class2$7.prototype, "color"), _class2$7.prototype), _initializer$6 = applyDecoratedInitializer(_class2$7.prototype, "_lineWidth", [serializable$j], function () {
              return 1;
            }), _initializer2$4 = applyDecoratedInitializer(_class2$7.prototype, "_strokeColor", [serializable$j], function () {
              return Color$1.BLACK.clone();
            }), _initializer3$3 = applyDecoratedInitializer(_class2$7.prototype, "_lineJoin", [serializable$j], function () {
              return LineJoin.MITER;
            }), _initializer4$3 = applyDecoratedInitializer(_class2$7.prototype, "_lineCap", [serializable$j], function () {
              return LineCap.BUTT;
            }), _initializer5$2 = applyDecoratedInitializer(_class2$7.prototype, "_fillColor", [serializable$j], function () {
              return Color$1.WHITE.clone();
            }), _initializer6$1 = applyDecoratedInitializer(_class2$7.prototype, "_miterLimit", [serializable$j], function () {
              return 10;
            })), _class2$7)) || _class$9) || _class$9));
            legacyCC.Graphics = Graphics;

            var _dec$a, _dec2$5, _dec3$3, _dec4$3, _dec5$1, _dec6$1, _dec7$1, _class$a, _class2$8, _initializer$7, _initializer2$5, _initializer3$4, _initializer4$4, _initializer5$3, _initializer6$2, _initializer7$1, _initializer8$1, _initializer9$1, _initializer10$1, _class3$4, _temp$5;
            var SpriteType;

            (function (SpriteType) {
              SpriteType[SpriteType["SIMPLE"] = 0] = "SIMPLE";
              SpriteType[SpriteType["SLICED"] = 1] = "SLICED";
              SpriteType[SpriteType["TILED"] = 2] = "TILED";
              SpriteType[SpriteType["FILLED"] = 3] = "FILLED";
            })(SpriteType || (SpriteType = {}));

            ccenum(SpriteType);
            var FillType;

            (function (FillType) {
              FillType[FillType["HORIZONTAL"] = 0] = "HORIZONTAL";
              FillType[FillType["VERTICAL"] = 1] = "VERTICAL";
              FillType[FillType["RADIAL"] = 2] = "RADIAL";
            })(FillType || (FillType = {}));

            ccenum(FillType);
            var SizeMode;

            (function (SizeMode) {
              SizeMode[SizeMode["CUSTOM"] = 0] = "CUSTOM";
              SizeMode[SizeMode["TRIMMED"] = 1] = "TRIMMED";
              SizeMode[SizeMode["RAW"] = 2] = "RAW";
            })(SizeMode || (SizeMode = {}));

            ccenum(SizeMode);
            var EventType;

            (function (EventType) {
              EventType["SPRITE_FRAME_CHANGED"] = "spriteframe-changed";
            })(EventType || (EventType = {}));

            var Sprite = exports('Sprite', (_dec$a = ccclass$p('cc.Sprite'), _dec2$5 = executionOrder(110), _dec3$3 = type$8(SpriteAtlas), _dec4$3 = type$8(SpriteFrame), _dec5$1 = type$8(SpriteType), _dec6$1 = type$8(FillType), _dec7$1 = type$8(SizeMode), _dec$a(_class$a = _dec2$5(_class$a = (_class2$8 = (_temp$5 = _class3$4 = function (_UIRenderer) {
              _inheritsLoose(Sprite, _UIRenderer);

              function Sprite() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _UIRenderer.call.apply(_UIRenderer, [this].concat(args)) || this;
                _this._spriteFrame = _initializer$7 && _initializer$7();
                _this._type = _initializer2$5 && _initializer2$5();
                _this._fillType = _initializer3$4 && _initializer3$4();
                _this._sizeMode = _initializer4$4 && _initializer4$4();
                _this._fillCenter = _initializer5$3 && _initializer5$3();
                _this._fillStart = _initializer6$2 && _initializer6$2();
                _this._fillRange = _initializer7$1 && _initializer7$1();
                _this._isTrimmedMode = _initializer8$1 && _initializer8$1();
                _this._useGrayscale = _initializer9$1 && _initializer9$1();
                _this._atlas = _initializer10$1 && _initializer10$1();
                return _this;
              }

              var _proto = Sprite.prototype;

              _proto.__preload = function __preload() {
                this.changeMaterialForDefine();

                _UIRenderer.prototype.__preload.call(this);
              };

              _proto.onEnable = function onEnable() {
                _UIRenderer.prototype.onEnable.call(this);

                this._activateMaterial();

                var spriteFrame = this._spriteFrame;

                if (spriteFrame) {
                  this._updateUVs();

                  if (this._type === SpriteType.SLICED) {
                    spriteFrame.on(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
                  }
                }
              };

              _proto.onDisable = function onDisable() {
                _UIRenderer.prototype.onDisable.call(this);

                if (this._spriteFrame && this._type === SpriteType.SLICED) {
                  this._spriteFrame.off(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
                }
              };

              _proto.onDestroy = function onDestroy() {

                _UIRenderer.prototype.onDestroy.call(this);
              };

              _proto.changeSpriteFrameFromAtlas = function changeSpriteFrameFromAtlas(name) {
                if (!this._atlas) {
                  console.warn('SpriteAtlas is null.');
                  return;
                }

                var sprite = this._atlas.getSpriteFrame(name);

                this.spriteFrame = sprite;
              };

              _proto.changeMaterialForDefine = function changeMaterialForDefine() {
                var texture;
                var lastInstanceMaterialType = this._instanceMaterialType;

                if (this._spriteFrame) {
                  texture = this._spriteFrame.texture;
                }

                var value = false;

                if (texture instanceof TextureBase) {
                  var format = texture.getPixelFormat();
                  value = format === PixelFormat.RGBA_ETC1 || format === PixelFormat.RGB_A_PVRTC_4BPPV1 || format === PixelFormat.RGB_A_PVRTC_2BPPV1;
                }

                if (value && this.grayscale) {
                  this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED_AND_GRAY;
                } else if (value) {
                  this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED;
                } else if (this.grayscale) {
                  this._instanceMaterialType = InstanceMaterialType.GRAYSCALE;
                } else {
                  this._instanceMaterialType = InstanceMaterialType.ADD_COLOR_AND_TEXTURE;
                }

                if (lastInstanceMaterialType !== this._instanceMaterialType) {
                  this.updateMaterial();
                }
              };

              _proto._updateBuiltinMaterial = function _updateBuiltinMaterial() {
                var mat = _UIRenderer.prototype._updateBuiltinMaterial.call(this);

                if (this.spriteFrame && this.spriteFrame.texture instanceof RenderTexture) {
                  var defines = _extends({
                    SAMPLE_FROM_RT: true
                  }, mat.passes[0].defines);

                  var renderMat = new Material();
                  renderMat.initialize({
                    effectAsset: mat.effectAsset,
                    defines: defines
                  });
                  mat = renderMat;
                }

                return mat;
              };

              _proto._render = function _render(render) {
                render.commitComp(this, this.renderData, this._spriteFrame, this._assembler, null);
              };

              _proto._canRender = function _canRender() {
                if (!_UIRenderer.prototype._canRender.call(this)) {
                  return false;
                }

                var spriteFrame = this._spriteFrame;

                if (!spriteFrame || !spriteFrame.texture) {
                  return false;
                }

                return true;
              };

              _proto._flushAssembler = function _flushAssembler() {
                var assembler = Sprite.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this.destroyRenderData();
                  this._assembler = assembler;
                }

                if (!this.renderData) {
                  if (this._assembler && this._assembler.createData) {
                    this._renderData = this._assembler.createData(this);
                    this.renderData.material = this.getRenderMaterial(0);
                    this.markForUpdateRenderData();

                    if (this.spriteFrame) {
                      this._assembler.updateUVs(this);
                    }

                    this._updateColor();
                  }
                }

                if (this._spriteFrame) {
                  if (this._type === SpriteType.SLICED) {
                    this._spriteFrame.on(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
                  } else {
                    this._spriteFrame.off(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
                  }
                }
              };

              _proto._applySpriteSize = function _applySpriteSize() {
                if (this._spriteFrame) {
                  {
                    if (SizeMode.RAW === this._sizeMode) {
                      var size = this._spriteFrame.originalSize;

                      this.node._uiProps.uiTransformComp.setContentSize(size);
                    } else if (SizeMode.TRIMMED === this._sizeMode) {
                      var rect = this._spriteFrame.rect;

                      this.node._uiProps.uiTransformComp.setContentSize(rect.width, rect.height);
                    }
                  }
                }
              };

              _proto._resized = function _resized() {
                {
                  return;
                }
              };

              _proto._activateMaterial = function _activateMaterial() {
                var spriteFrame = this._spriteFrame;
                var material = this.getRenderMaterial(0);

                if (spriteFrame) {
                  if (material) {
                    this.markForUpdateRenderData();
                  }
                }

                if (this.renderData) {
                  this.renderData.material = material;
                }
              };

              _proto._updateUVs = function _updateUVs() {
                if (this._assembler) {
                  this._assembler.updateUVs(this);
                }
              };

              _proto._applySpriteFrame = function _applySpriteFrame(oldFrame) {
                var spriteFrame = this._spriteFrame;

                if (oldFrame && this._type === SpriteType.SLICED) {
                  oldFrame.off(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
                }

                var textureChanged = false;

                if (spriteFrame) {
                  if (!oldFrame || oldFrame.texture !== spriteFrame.texture) {
                    textureChanged = true;
                  }

                  if (textureChanged) {
                    if (this.renderData) this.renderData.textureDirty = true;
                    this.changeMaterialForDefine();
                  }

                  this._applySpriteSize();

                  if (this._type === SpriteType.SLICED) {
                    spriteFrame.on(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
                  }
                }
              };

              _createClass(Sprite, [{
                key: "spriteAtlas",
                get: function get() {
                  return this._atlas;
                },
                set: function set(value) {
                  if (this._atlas === value) {
                    return;
                  }

                  this._atlas = value;
                }
              }, {
                key: "spriteFrame",
                get: function get() {
                  return this._spriteFrame;
                },
                set: function set(value) {
                  if (this._spriteFrame === value) {
                    return;
                  }

                  var lastSprite = this._spriteFrame;
                  this._spriteFrame = value;
                  this.markForUpdateRenderData();

                  this._applySpriteFrame(lastSprite);
                }
              }, {
                key: "type",
                get: function get() {
                  return this._type;
                },
                set: function set(value) {
                  if (this._type !== value) {
                    this._type = value;

                    this._flushAssembler();
                  }
                }
              }, {
                key: "fillType",
                get: function get() {
                  return this._fillType;
                },
                set: function set(value) {
                  if (this._fillType !== value) {
                    if (value === FillType.RADIAL || this._fillType === FillType.RADIAL) {
                      this.destroyRenderData();
                    } else if (this.renderData) {
                      this.markForUpdateRenderData(true);
                    }
                  }

                  this._fillType = value;

                  this._flushAssembler();
                }
              }, {
                key: "fillCenter",
                get: function get() {
                  return this._fillCenter;
                },
                set: function set(value) {
                  this._fillCenter.x = value.x;
                  this._fillCenter.y = value.y;

                  if (this._type === SpriteType.FILLED && this.renderData) {
                    this.markForUpdateRenderData();
                  }
                }
              }, {
                key: "fillStart",
                get: function get() {
                  return this._fillStart;
                },
                set: function set(value) {
                  this._fillStart = clamp$1(value, 0, 1);

                  if (this._type === SpriteType.FILLED && this.renderData) {
                    this.markForUpdateRenderData();

                    this._updateUVs();
                  }
                }
              }, {
                key: "fillRange",
                get: function get() {
                  return this._fillRange;
                },
                set: function set(value) {
                  this._fillRange = clamp$1(value, -1, 1);

                  if (this._type === SpriteType.FILLED && this.renderData) {
                    this.markForUpdateRenderData();

                    this._updateUVs();
                  }
                }
              }, {
                key: "trim",
                get: function get() {
                  return this._isTrimmedMode;
                },
                set: function set(value) {
                  if (this._isTrimmedMode === value) {
                    return;
                  }

                  this._isTrimmedMode = value;

                  if (this._type === SpriteType.SIMPLE && this.renderData) {
                    this.markForUpdateRenderData(true);
                  }
                }
              }, {
                key: "grayscale",
                get: function get() {
                  return this._useGrayscale;
                },
                set: function set(value) {
                  if (this._useGrayscale === value) {
                    return;
                  }

                  this._useGrayscale = value;
                  this.changeMaterialForDefine();
                  this.updateMaterial();
                }
              }, {
                key: "sizeMode",
                get: function get() {
                  return this._sizeMode;
                },
                set: function set(value) {
                  if (this._sizeMode === value) {
                    return;
                  }

                  this._sizeMode = value;

                  if (value !== SizeMode.CUSTOM) {
                    this._applySpriteSize();
                  }
                }
              }]);

              return Sprite;
            }(UIRenderer), _class3$4.FillType = FillType, _class3$4.Type = SpriteType, _class3$4.SizeMode = SizeMode, _class3$4.EventType = EventType, _temp$5), (_applyDecoratedDescriptor(_class2$8.prototype, "spriteAtlas", [_dec3$3], Object.getOwnPropertyDescriptor(_class2$8.prototype, "spriteAtlas"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "spriteFrame", [_dec4$3], Object.getOwnPropertyDescriptor(_class2$8.prototype, "spriteFrame"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "type", [_dec5$1], Object.getOwnPropertyDescriptor(_class2$8.prototype, "type"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "fillType", [_dec6$1], Object.getOwnPropertyDescriptor(_class2$8.prototype, "fillType"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "sizeMode", [_dec7$1], Object.getOwnPropertyDescriptor(_class2$8.prototype, "sizeMode"), _class2$8.prototype), _initializer$7 = applyDecoratedInitializer(_class2$8.prototype, "_spriteFrame", [serializable$j], function () {
              return null;
            }), _initializer2$5 = applyDecoratedInitializer(_class2$8.prototype, "_type", [serializable$j], function () {
              return SpriteType.SIMPLE;
            }), _initializer3$4 = applyDecoratedInitializer(_class2$8.prototype, "_fillType", [serializable$j], function () {
              return FillType.HORIZONTAL;
            }), _initializer4$4 = applyDecoratedInitializer(_class2$8.prototype, "_sizeMode", [serializable$j], function () {
              return SizeMode.TRIMMED;
            }), _initializer5$3 = applyDecoratedInitializer(_class2$8.prototype, "_fillCenter", [serializable$j], function () {
              return new Vec2(0, 0);
            }), _initializer6$2 = applyDecoratedInitializer(_class2$8.prototype, "_fillStart", [serializable$j], function () {
              return 0;
            }), _initializer7$1 = applyDecoratedInitializer(_class2$8.prototype, "_fillRange", [serializable$j], function () {
              return 0;
            }), _initializer8$1 = applyDecoratedInitializer(_class2$8.prototype, "_isTrimmedMode", [serializable$j], function () {
              return true;
            }), _initializer9$1 = applyDecoratedInitializer(_class2$8.prototype, "_useGrayscale", [serializable$j], function () {
              return false;
            }), _initializer10$1 = applyDecoratedInitializer(_class2$8.prototype, "_atlas", [serializable$j], function () {
              return null;
            })), _class2$8)) || _class$a) || _class$a));
            legacyCC.Sprite = Sprite;

            var _dec$b, _dec2$6, _dec3$4, _class$b, _class2$9, _initializer$8, _initializer2$6, _initializer3$5, _initializer4$5, _class3$5, _temp$6;

            var _worldMatrix$1 = new Mat4();

            var _vec2_temp = new Vec2();

            var _mat4_temp$1 = new Mat4();

            var _circlePoints = [];

            function _calculateCircle(center, radius, segments) {
              _circlePoints.length = 0;
              var anglePerStep = Math.PI * 2 / segments;

              for (var step = 0; step < segments; ++step) {
                _circlePoints.push(new Vec3(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y, 0));
              }

              return _circlePoints;
            }

            var MaskType;

            (function (MaskType) {
              MaskType[MaskType["GRAPHICS_RECT"] = 0] = "GRAPHICS_RECT";
              MaskType[MaskType["GRAPHICS_ELLIPSE"] = 1] = "GRAPHICS_ELLIPSE";
              MaskType[MaskType["GRAPHICS_STENCIL"] = 2] = "GRAPHICS_STENCIL";
              MaskType[MaskType["SPRITE_STENCIL"] = 3] = "SPRITE_STENCIL";
            })(MaskType || (MaskType = {}));

            ccenum(MaskType);
            var SEGMENTS_MIN = 3;
            var SEGMENTS_MAX = 10000;
            var Mask = exports('Mask', (_dec$b = ccclass$p('cc.Mask'), _dec2$6 = executionOrder(110), _dec3$4 = type$8(MaskType), _dec$b(_class$b = _dec2$6(_class$b = (_class2$9 = (_temp$6 = _class3$5 = function (_Component) {
              _inheritsLoose(Mask, _Component);

              function Mask() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._type = _initializer$8 && _initializer$8();
                _this._inverted = _initializer2$6 && _initializer2$6();
                _this._segments = _initializer3$5 && _initializer3$5();
                _this._alphaThreshold = _initializer4$5 && _initializer4$5();
                _this._sprite = null;
                _this._graphics = null;
                _this._stencilStage = Stage.DISABLED;
                return _this;
              }

              var _proto = Mask.prototype;

              _proto.onLoad = function onLoad() {
                this._changeRenderType();
              };

              _proto.onEnable = function onEnable() {
                this._changeRenderType();

                this._updateGraphics();

                this._enableRender();

                this.node.on(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
                this.node.on(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
              };

              _proto.onRestore = function onRestore() {
                this._changeRenderType();

                this._updateGraphics();
              };

              _proto.onDisable = function onDisable() {
                this._disableRender();

                this.node.off(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
                this.node.off(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
              };

              _proto.onDestroy = function onDestroy() {
                this._removeMaskNode();
              };

              _proto.isHit = function isHit(worldPt) {
                var uiTrans = this.node._uiProps.uiTransformComp;
                var size = uiTrans.contentSize;
                var w = size.width;
                var h = size.height;
                var testPt = _vec2_temp;
                this.node.getWorldMatrix(_worldMatrix$1);
                Mat4.invert(_mat4_temp$1, _worldMatrix$1);
                Vec2.transformMat4(testPt, worldPt, _mat4_temp$1);
                var ap = uiTrans.anchorPoint;
                testPt.x += ap.x * w;
                testPt.y += ap.y * h;
                var result = false;

                if (this.type === MaskType.GRAPHICS_RECT || this.type === MaskType.GRAPHICS_STENCIL || this.type === MaskType.SPRITE_STENCIL) {
                  result = testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h;
                } else if (this.type === MaskType.GRAPHICS_ELLIPSE) {
                  var rx = w / 2;
                  var ry = h / 2;
                  var px = testPt.x - 0.5 * w;
                  var py = testPt.y - 0.5 * h;
                  result = px * px / (rx * rx) + py * py / (ry * ry) < 1;
                }

                if (this._inverted) {
                  result = !result;
                }

                return result;
              };

              _proto._nodeStateChange = function _nodeStateChange(type) {
                this._updateGraphics();
              };

              _proto._changeRenderType = function _changeRenderType() {
                var isGraphics = this._type !== MaskType.SPRITE_STENCIL;

                if (isGraphics) {
                  this._createGraphics();
                } else {
                  this._createSprite();
                }
              };

              _proto._createSprite = function _createSprite() {
                if (!this._sprite) {
                  var sprite = this._sprite = this.node.getComponent(Sprite);

                  if (!sprite) {
                    var node = this.node;
                    sprite = this._sprite = node.addComponent(Sprite);
                  }

                  sprite.color = Color$1.WHITE.clone();
                  sprite.sizeMode = 0;
                }

                this._sprite.stencilStage = this.inverted ? Stage.ENTER_LEVEL_INVERTED : Stage.ENTER_LEVEL;

                this._sprite.updateMaterial();
              };

              _proto._createGraphics = function _createGraphics() {
                if (!this._graphics) {
                  var graphics = this._graphics = this.node.getComponent(Graphics);

                  if (!graphics) {
                    var node = this.node;
                    graphics = this._graphics = node.addComponent(Graphics);
                  }

                  graphics.lineWidth = 1;
                  var color = Color$1.WHITE.clone();
                  color.a = 0;
                  graphics.fillColor = color;
                }

                this._graphics.stencilStage = this.inverted ? Stage.ENTER_LEVEL_INVERTED : Stage.ENTER_LEVEL;
              };

              _proto._updateGraphics = function _updateGraphics() {
                if (!this._graphics || this._type !== MaskType.GRAPHICS_RECT && this._type !== MaskType.GRAPHICS_ELLIPSE) {
                  return;
                }

                var uiTrans = this.node._uiProps.uiTransformComp;
                var graphics = this._graphics;
                graphics.clear();
                var size = uiTrans.contentSize;
                var width = size.width;
                var height = size.height;
                var ap = uiTrans.anchorPoint;
                var x = -width * ap.x;
                var y = -height * ap.y;

                if (this._type === MaskType.GRAPHICS_RECT) {
                  graphics.rect(x, y, width, height);
                } else if (this._type === MaskType.GRAPHICS_ELLIPSE) {
                  var center = new Vec3(x + width / 2, y + height / 2, 0);
                  var radius = new Vec3(width / 2, height / 2, 0);

                  var points = _calculateCircle(center, radius, this._segments);

                  for (var i = 0; i < points.length; ++i) {
                    var point = points[i];

                    if (i === 0) {
                      graphics.moveTo(point.x, point.y);
                    } else {
                      graphics.lineTo(point.x, point.y);
                    }
                  }

                  graphics.close();
                }

                graphics.fill();
              };

              _proto._enableRender = function _enableRender() {
                if (this.subComp) {
                  this.subComp.enabled = true;
                }
              };

              _proto._disableRender = function _disableRender() {
                if (this.subComp) {
                  this.subComp.stencilStage = Stage.DISABLED;
                  this.subComp.updateMaterial();

                  if (this.node.activeInHierarchy) {
                    this.subComp.enabled = false;
                  }
                }
              };

              _proto._removeMaskNode = function _removeMaskNode() {
                if (this._sprite) {
                  this._sprite.destroy();

                  this._sprite = null;
                }

                if (this._graphics) {
                  this._graphics.destroy();

                  this._graphics = null;
                }
              };

              _proto.markForUpdateRenderData = function markForUpdateRenderData(enable) {
                if (enable === void 0) {
                  enable = true;
                }

                warnID(9007);

                if (this.subComp) {
                  this.subComp.markForUpdateRenderData(enable);
                }
              };

              _proto.requestRenderData = function requestRenderData(any) {
                warnID(9007);
              };

              _proto.destroyRenderData = function destroyRenderData() {
                warnID(9007);
              };

              _proto.updateRenderer = function updateRenderer() {
                warnID(9007);

                if (this.subComp) {
                  this.subComp.updateRenderer();
                }
              };

              _proto.fillBuffers = function fillBuffers(render) {
                warnID(9007);
              };

              _proto.postUpdateAssembler = function postUpdateAssembler(render) {
                warnID(9007);
              };

              _proto.setNodeDirty = function setNodeDirty() {
                warnID(9007);

                if (this.subComp) {
                  this.subComp.setNodeDirty();
                }
              };

              _proto.setTextureDirty = function setTextureDirty() {
                warnID(9007);

                if (this.subComp) {
                  this.subComp.setTextureDirty();
                }
              };

              _proto.getMaterial = function getMaterial(idx) {
                warnID(9007);

                if (this.subComp) {
                  return this.subComp.getSharedMaterial(idx);
                }

                return null;
              };

              _proto.setMaterial = function setMaterial(material, index) {
                warnID(9007);

                if (this.subComp) {
                  this.subComp.setMaterial(material, index);
                }
              };

              _proto.getMaterialInstance = function getMaterialInstance(idx) {
                warnID(9007);

                if (this.subComp) {
                  return this.subComp.getMaterialInstance(idx);
                }

                return null;
              };

              _proto.setMaterialInstance = function setMaterialInstance(matInst, index) {
                warnID(9007);

                if (this.subComp) {
                  this.subComp.setMaterialInstance(matInst, index);
                }
              };

              _proto.getRenderMaterial = function getRenderMaterial(index) {
                warnID(9007);

                if (this.subComp) {
                  return this.subComp.getRenderMaterial(index);
                }

                return null;
              };

              _createClass(Mask, [{
                key: "type",
                get: function get() {
                  return this._type;
                },
                set: function set(value) {
                  if (this._type === value) {
                    return;
                  }

                  this._type = value;

                  if (this._type !== MaskType.SPRITE_STENCIL) {
                    if (this._sprite) {
                      this.node.removeComponent(Sprite);

                      this._sprite._destroyImmediate();

                      this._sprite = null;
                    }

                    this._changeRenderType();

                    this._updateGraphics();
                  } else {
                    if (this._graphics) {
                      this._graphics.clear();

                      this.node.removeComponent(Graphics);

                      this._graphics._destroyImmediate();

                      this._graphics = null;
                    }

                    this._changeRenderType();
                  }
                }
              }, {
                key: "inverted",
                get: function get() {
                  return this._inverted;
                },
                set: function set(value) {
                  this._inverted = value;
                  this.subComp.stencilStage = this.inverted ? Stage.ENTER_LEVEL_INVERTED : Stage.ENTER_LEVEL;
                }
              }, {
                key: "segments",
                get: function get() {
                  return this._segments;
                },
                set: function set(value) {
                  if (this._segments === value) {
                    return;
                  }

                  this._segments = clamp$1(value, SEGMENTS_MIN, SEGMENTS_MAX);

                  this._updateGraphics();
                }
              }, {
                key: "spriteFrame",
                get: function get() {
                  if (this._sprite) {
                    return this._sprite.spriteFrame;
                  }

                  return null;
                },
                set: function set(value) {
                  if (this._sprite) {
                    this._sprite.spriteFrame = value;
                  } else {
                    console.error('please change type to sprite_stencil first');
                  }
                }
              }, {
                key: "alphaThreshold",
                get: function get() {
                  return this._alphaThreshold;
                },
                set: function set(value) {
                  if (this._alphaThreshold === value) {
                    return;
                  }

                  this._alphaThreshold = value;

                  if (this.type === MaskType.SPRITE_STENCIL && this._sprite) {
                    var mat = this._sprite.getMaterialInstance(0);

                    mat.setProperty('alphaThreshold', this._alphaThreshold);
                  }
                }
              }, {
                key: "subComp",
                get: function get() {
                  return this._graphics || this._sprite;
                }
              }, {
                key: "customMaterial",
                get: function get() {
                  warnID(9007);

                  if (this.subComp) {
                    return this.subComp.customMaterial;
                  }

                  return null;
                },
                set: function set(val) {
                  warnID(9007);

                  if (this.subComp) {
                    this.subComp.customMaterial = val;
                  }
                }
              }, {
                key: "color",
                get: function get() {
                  warnID(9007);

                  if (this.subComp) {
                    return this.subComp.color;
                  }

                  return null;
                },
                set: function set(value) {
                  warnID(9007);

                  if (this.subComp && value) {
                    this.subComp.color = value;
                  }
                }
              }, {
                key: "sharedMaterial",
                get: function get() {
                  warnID(9007);

                  if (this.subComp) {
                    return this.subComp.sharedMaterial;
                  }

                  return null;
                }
              }, {
                key: "sharedMaterials",
                get: function get() {
                  warnID(9007);

                  if (this.subComp) {
                    return this.subComp.sharedMaterials;
                  }

                  return null;
                },
                set: function set(val) {
                  warnID(9007);

                  if (this.subComp && val) {
                    this.subComp.sharedMaterials = val;
                  }
                }
              }, {
                key: "material",
                get: function get() {
                  warnID(9007);

                  if (this.subComp) {
                    return this.subComp.material;
                  }

                  return null;
                },
                set: function set(val) {
                  warnID(9007);

                  if (this.subComp) {
                    this.subComp.material = val;
                  }
                }
              }, {
                key: "materials",
                get: function get() {
                  warnID(9007);

                  if (this.subComp) {
                    return this.subComp.materials;
                  }

                  return [null];
                },
                set: function set(val) {
                  warnID(9007);

                  if (this.subComp) {
                    this.subComp.materials = val;
                  }
                }
              }]);

              return Mask;
            }(Component), _class3$5.Type = MaskType, _temp$6), (_applyDecoratedDescriptor(_class2$9.prototype, "type", [_dec3$4], Object.getOwnPropertyDescriptor(_class2$9.prototype, "type"), _class2$9.prototype), _initializer$8 = applyDecoratedInitializer(_class2$9.prototype, "_type", [serializable$j], function () {
              return MaskType.GRAPHICS_RECT;
            }), _initializer2$6 = applyDecoratedInitializer(_class2$9.prototype, "_inverted", [serializable$j], function () {
              return false;
            }), _initializer3$5 = applyDecoratedInitializer(_class2$9.prototype, "_segments", [serializable$j], function () {
              return 64;
            }), _initializer4$5 = applyDecoratedInitializer(_class2$9.prototype, "_alphaThreshold", [serializable$j], function () {
              return 0.1;
            })), _class2$9)) || _class$b) || _class$b));
            NodeEventProcessor._maskComp = Mask;
            legacyCC.Mask = Mask;

            var eventRegx = /^(click)(\s)*=|(param)(\s)*=/;
            var imageAttrReg = /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*align(\s)*=|(\s)*offset(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
            var HtmlTextParser = exports('HtmlTextParser', function () {
              function HtmlTextParser() {
                this._specialSymbolArray = [];
                this._stack = [];
                this._resultObjectArray = [];

                this._specialSymbolArray.push([/&lt;/g, '<']);

                this._specialSymbolArray.push([/&gt;/g, '>']);

                this._specialSymbolArray.push([/&amp;/g, '&']);

                this._specialSymbolArray.push([/&quot;/g, '"']);

                this._specialSymbolArray.push([/&apos;/g, '\'']);
              }

              var _proto = HtmlTextParser.prototype;

              _proto.parse = function parse(htmlString) {
                this._resultObjectArray.length = 0;
                this._stack.length = 0;
                var startIndex = 0;
                var length = htmlString.length;

                while (startIndex < length) {
                  var tagEndIndex = htmlString.indexOf('>', startIndex);
                  var tagBeginIndex = -1;

                  if (tagEndIndex >= 0) {
                    tagBeginIndex = htmlString.lastIndexOf('<', tagEndIndex);
                    var noTagBegin = tagBeginIndex < startIndex - 1;

                    if (noTagBegin) {
                      tagBeginIndex = htmlString.indexOf('<', tagEndIndex + 1);
                      tagEndIndex = htmlString.indexOf('>', tagBeginIndex + 1);
                    }
                  }

                  if (tagBeginIndex < 0) {
                    this._stack.pop();

                    this._processResult(htmlString.substring(startIndex));

                    startIndex = length;
                  } else {
                    var newStr = htmlString.substring(startIndex, tagBeginIndex);
                    var tagStr = htmlString.substring(tagBeginIndex + 1, tagEndIndex);
                    if (tagStr === '') newStr = htmlString.substring(startIndex, tagEndIndex + 1);

                    this._processResult(newStr);

                    if (tagEndIndex === -1) {
                      tagEndIndex = tagBeginIndex;
                    } else if (htmlString.charAt(tagBeginIndex + 1) === '/') {
                      this._stack.pop();
                    } else {
                      this._addToStack(tagStr);
                    }

                    startIndex = tagEndIndex + 1;
                  }
                }

                return this._resultObjectArray;
              };

              _proto._attributeToObject = function _attributeToObject(attribute) {
                attribute = attribute.trim();
                var obj = {};
                var header = /^(color|size)(\s)*=/.exec(attribute);
                var tagName = '';
                var nextSpace = 0;
                var eventHanlderString = '';

                if (header) {
                  tagName = header[0];
                  attribute = attribute.substring(tagName.length).trim();

                  if (attribute === '') {
                    return obj;
                  }

                  nextSpace = attribute.indexOf(' ');

                  switch (tagName[0]) {
                    case 'c':
                      if (nextSpace > -1) {
                        obj.color = attribute.substring(0, nextSpace).trim();
                      } else {
                        obj.color = attribute;
                      }

                      break;

                    case 's':
                      obj.size = parseInt(attribute);
                      break;
                  }

                  if (nextSpace > -1) {
                    eventHanlderString = attribute.substring(nextSpace + 1).trim();
                    obj.event = this._processEventHandler(eventHanlderString);
                  }

                  return obj;
                }

                header = /^(br(\s)*\/)/.exec(attribute);

                if (header && header[0].length > 0) {
                  tagName = header[0].trim();

                  if (tagName.startsWith('br') && tagName[tagName.length - 1] === '/') {
                    obj.isNewLine = true;

                    this._resultObjectArray.push({
                      text: '',
                      style: {
                        isNewLine: true
                      }
                    });

                    return obj;
                  }
                }

                header = /^(img(\s)*src(\s)*=[^>]+\/)/.exec(attribute);
                var remainingArgument = '';
                var rightQuot = -1;

                if (header && header[0].length > 0) {
                  tagName = header[0].trim();

                  if (tagName.startsWith('img') && tagName[tagName.length - 1] === '/') {
                    header = imageAttrReg.exec(attribute);
                    var tagValue;
                    var isValidImageTag = false;

                    while (header) {
                      attribute = attribute.substring(attribute.indexOf(header[0]));
                      tagName = attribute.substr(0, header[0].length);
                      var originTagNameLength = tagName.length;
                      tagName = tagName.replace(/[^a-zA-Z]/g, '').trim();
                      tagName = tagName.toLowerCase();
                      remainingArgument = attribute.substring(originTagNameLength).trim();

                      if (tagName === 'src') {
                        rightQuot = this.getRightQuotationIndex(remainingArgument);
                      } else {
                        rightQuot = -1;
                      }

                      nextSpace = remainingArgument.indexOf(' ', rightQuot + 1 >= remainingArgument.length ? -1 : rightQuot + 1);
                      tagValue = nextSpace > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument;
                      attribute = remainingArgument.substring(nextSpace).trim();

                      if (tagValue.endsWith('/')) {
                        tagValue = tagValue.slice(0, -1);
                      }

                      if (tagName === 'src') {
                        switch (tagValue.charCodeAt(0)) {
                          case 34:
                          case 39:
                            isValidImageTag = true;
                            tagValue = tagValue.slice(1, -1);
                            break;
                        }

                        obj.isImage = true;
                        obj.src = tagValue;
                      } else if (tagName === 'height') {
                        obj.imageHeight = parseInt(tagValue);
                      } else if (tagName === 'width') {
                        obj.imageWidth = parseInt(tagValue);
                      } else if (tagName === 'align') {
                        switch (tagValue.charCodeAt(0)) {
                          case 34:
                          case 39:
                            tagValue = tagValue.slice(1, -1);
                            break;
                        }

                        obj.imageAlign = tagValue.toLowerCase();
                      } else if (tagName === 'offset') {
                        obj.imageOffset = tagValue;
                      } else if (tagName === 'click') {
                        obj.event = this._processEventHandler(tagName + "=" + tagValue);
                      }

                      if (obj.event && tagName === 'param') {
                        obj.event[tagName] = tagValue.replace(/^"|"$/g, '');
                      }

                      header = imageAttrReg.exec(attribute);
                    }

                    if (isValidImageTag && obj.isImage) {
                      this._resultObjectArray.push({
                        text: '',
                        style: obj
                      });
                    }

                    return {};
                  }
                }

                header = /^(outline(\s)*[^>]*)/.exec(attribute);

                if (header) {
                  attribute = header[0].substring('outline'.length).trim();
                  var defaultOutlineObject = {
                    color: '#ffffff',
                    width: 1
                  };

                  if (attribute) {
                    var outlineAttrReg = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
                    header = outlineAttrReg.exec(attribute);

                    var _tagValue;

                    while (header) {
                      attribute = attribute.substring(attribute.indexOf(header[0]));
                      tagName = attribute.substr(0, header[0].length);
                      remainingArgument = attribute.substring(tagName.length).trim();
                      nextSpace = remainingArgument.indexOf(' ');

                      if (nextSpace > -1) {
                        _tagValue = remainingArgument.substr(0, nextSpace);
                      } else {
                        _tagValue = remainingArgument;
                      }

                      tagName = tagName.replace(/[^a-zA-Z]/g, '').trim();
                      tagName = tagName.toLowerCase();
                      attribute = remainingArgument.substring(nextSpace).trim();

                      if (tagName === 'click') {
                        obj.event = this._processEventHandler(tagName + "=" + _tagValue);
                      } else if (tagName === 'color') {
                        defaultOutlineObject.color = _tagValue;
                      } else if (tagName === 'width') {
                        defaultOutlineObject.width = parseInt(_tagValue);
                      }

                      if (obj.event && tagName === 'param') {
                        obj.event[tagName] = _tagValue.replace(/^"|"$/g, '');
                      }

                      header = outlineAttrReg.exec(attribute);
                    }
                  }

                  obj.outline = defaultOutlineObject;
                }

                header = /^(on|u|b|i)(\s)*/.exec(attribute);

                if (header && header[0].length > 0) {
                  tagName = header[0];
                  attribute = attribute.substring(tagName.length).trim();

                  switch (tagName[0]) {
                    case 'u':
                      obj.underline = true;
                      break;

                    case 'i':
                      obj.italic = true;
                      break;

                    case 'b':
                      obj.bold = true;
                      break;
                  }

                  if (attribute === '') {
                    return obj;
                  }

                  obj.event = this._processEventHandler(attribute);
                }

                return obj;
              };

              _proto.getRightQuotationIndex = function getRightQuotationIndex(remainingArgument) {
                var leftQuot = -1;
                var rightQuot = -1;
                var leftSingleQuot = remainingArgument.indexOf('\'');
                var leftDoubleQuot = remainingArgument.indexOf('"');
                var useSingleQuot = leftSingleQuot > -1 && (leftSingleQuot < leftDoubleQuot || leftDoubleQuot === -1);
                var useDoubleQuot = leftDoubleQuot > -1 && (leftDoubleQuot < leftSingleQuot || leftSingleQuot === -1);

                if (useSingleQuot) {
                  leftQuot = leftSingleQuot;
                  rightQuot = remainingArgument.indexOf('\'', leftQuot + 1 >= remainingArgument.length ? -1 : leftQuot + 1);
                } else if (useDoubleQuot) {
                  leftQuot = leftDoubleQuot;
                  rightQuot = remainingArgument.indexOf('"', leftQuot + 1 >= remainingArgument.length ? -1 : leftQuot + 1);
                }

                return rightQuot;
              };

              _proto._processEventHandler = function _processEventHandler(eventString) {
                var obj = {};
                var index = 0;
                var isValidTag = false;
                var eventNames = eventRegx.exec(eventString);

                while (eventNames) {
                  var eventName = eventNames[0];
                  var eventValue = '';
                  isValidTag = false;
                  eventString = eventString.substring(eventName.length).trim();

                  if (eventString.charAt(0) === '"') {
                    index = eventString.indexOf('"', 1);

                    if (index > -1) {
                      eventValue = eventString.substring(1, index).trim();
                      isValidTag = true;
                    }

                    index++;
                  } else if (eventString.charAt(0) === '\'') {
                    index = eventString.indexOf('\'', 1);

                    if (index > -1) {
                      eventValue = eventString.substring(1, index).trim();
                      isValidTag = true;
                    }

                    index++;
                  } else {
                    var match = /(\S)+/.exec(eventString);

                    if (match) {
                      eventValue = match[0];
                    } else {
                      eventValue = '';
                    }

                    index = eventValue.length;
                  }

                  if (isValidTag) {
                    eventName = eventName.substring(0, eventName.length - 1).trim();
                    obj[eventName] = eventValue;
                  }

                  eventString = eventString.substring(index).trim();
                  eventNames = eventRegx.exec(eventString);
                }

                return obj;
              };

              _proto._addToStack = function _addToStack(attribute) {
                var obj = this._attributeToObject(attribute);

                if (this._stack.length === 0) {
                  this._stack.push(obj);
                } else {
                  if (obj.isNewLine || obj.isImage) {
                    return;
                  }

                  var previousTagObj = this._stack[this._stack.length - 1];

                  for (var key in previousTagObj) {
                    if (!obj[key]) {
                      obj[key] = previousTagObj[key];
                    }
                  }

                  this._stack.push(obj);
                }
              };

              _proto._processResult = function _processResult(value) {
                if (value.length === 0) {
                  return;
                }

                value = this._escapeSpecialSymbol(value);

                if (this._stack.length > 0) {
                  this._resultObjectArray.push({
                    text: value,
                    style: this._stack[this._stack.length - 1]
                  });
                } else {
                  this._resultObjectArray.push({
                    text: value
                  });
                }
              };

              _proto._escapeSpecialSymbol = function _escapeSpecialSymbol(str) {
                for (var _iterator = _createForOfIteratorHelperLoose(this._specialSymbolArray), _step; !(_step = _iterator()).done;) {
                  var symbolArr = _step.value;
                  var key = symbolArr[0];
                  var value = symbolArr[1];
                  str = str.replace(key, value);
                }

                return str;
              };

              return HtmlTextParser;
            }());

            var _dec$c, _dec2$7, _dec3$5, _class$c, _class2$a, _initializer$9, _initializer2$7;
            var LabelOutline = exports('LabelOutline', (_dec$c = ccclass$p('cc.LabelOutline'), _dec2$7 = executionOrder(110), _dec3$5 = requireComponent(Label), _dec$c(_class$c = _dec2$7(_class$c = _dec3$5(_class$c = (_class2$a = function (_Component) {
              _inheritsLoose(LabelOutline, _Component);

              function LabelOutline() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._color = _initializer$9 && _initializer$9();
                _this._width = _initializer2$7 && _initializer2$7();
                return _this;
              }

              var _proto = LabelOutline.prototype;

              _proto.onEnable = function onEnable() {
                this._updateRenderData();
              };

              _proto.onDisable = function onDisable() {
                this._updateRenderData();
              };

              _proto._updateRenderData = function _updateRenderData() {
                var label = this.node.getComponent(Label);

                if (label) {
                  label.updateRenderData(true);
                }
              };

              _createClass(LabelOutline, [{
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(value) {
                  if (this._color === value) {
                    return;
                  }

                  this._color.set(value);

                  this._updateRenderData();
                }
              }, {
                key: "width",
                get: function get() {
                  return this._width;
                },
                set: function set(value) {
                  if (this._width === value) {
                    return;
                  }

                  this._width = value;

                  this._updateRenderData();
                }
              }]);

              return LabelOutline;
            }(Component), (_initializer$9 = applyDecoratedInitializer(_class2$a.prototype, "_color", [serializable$j], function () {
              return new Color$1(0, 0, 0, 255);
            }), _initializer2$7 = applyDecoratedInitializer(_class2$a.prototype, "_width", [serializable$j], function () {
              return 2;
            })), _class2$a)) || _class$c) || _class$c) || _class$c));
            legacyCC.LabelOutline = LabelOutline;

            deprecateModuleExportedName({
              Renderable2D: {
                newName: 'UIRenderer',
                since: '3.6.0',
                removed: false
              }
            });

            var _dec$d, _dec2$8, _dec3$6, _dec4$4, _dec5$2, _dec6$2, _dec7$2, _dec8, _dec9, _class$d, _class2$b, _initializer$a, _initializer2$8, _initializer3$6, _initializer4$6, _initializer5$4, _initializer6$3, _initializer7$2, _initializer8$2, _initializer9$2, _initializer10$2, _initializer11$1, _initializer12$1, _initializer13$1, _initializer14$1, _initializer15$1, _initializer16$1, _initializer17$1, _initializer18, _initializer19, _initializer20, _class3$6, _temp$7;

            var _temp_vec3_1 = new Vec3();

            var ProjectionType = Enum(CameraProjection);
            var FOVAxis = Enum(CameraFOVAxis);
            var Aperture = Enum(CameraAperture);
            var Shutter = Enum(CameraShutter);
            var ISO = Enum(CameraISO);
            var ClearFlag = Enum({
              SKYBOX: SKYBOX_FLAG | ClearFlagBit.DEPTH_STENCIL,
              SOLID_COLOR: ClearFlagBit.ALL,
              DEPTH_ONLY: ClearFlagBit.DEPTH_STENCIL,
              DONT_CLEAR: ClearFlagBit.NONE
            });
            var Camera = exports('Camera', (_dec$d = ccclass$p('cc.Camera'), _dec2$8 = type$8(Layers.BitMask), _dec3$6 = type$8(ClearFlag), _dec4$4 = type$8(ProjectionType), _dec5$2 = type$8(FOVAxis), _dec6$2 = type$8(Aperture), _dec7$2 = type$8(Shutter), _dec8 = type$8(ISO), _dec9 = type$8(RenderTexture), _dec$d(_class$d = (_class2$b = (_temp$7 = _class3$6 = function (_Component) {
              _inheritsLoose(Camera, _Component);

              function Camera() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._projection = _initializer$a && _initializer$a();
                _this._priority = _initializer2$8 && _initializer2$8();
                _this._fov = _initializer3$6 && _initializer3$6();
                _this._fovAxis = _initializer4$6 && _initializer4$6();
                _this._orthoHeight = _initializer5$4 && _initializer5$4();
                _this._near = _initializer6$3 && _initializer6$3();
                _this._far = _initializer7$2 && _initializer7$2();
                _this._color = _initializer8$2 && _initializer8$2();
                _this._depth = _initializer9$2 && _initializer9$2();
                _this._stencil = _initializer10$2 && _initializer10$2();
                _this._clearFlags = _initializer11$1 && _initializer11$1();
                _this._rect = _initializer12$1 && _initializer12$1();
                _this._aperture = _initializer13$1 && _initializer13$1();
                _this._shutter = _initializer14$1 && _initializer14$1();
                _this._iso = _initializer15$1 && _initializer15$1();
                _this._screenScale = _initializer16$1 && _initializer16$1();
                _this._visibility = _initializer17$1 && _initializer17$1();
                _this._targetTexture = _initializer18 && _initializer18();
                _this._camera = null;
                _this._inEditorMode = false;
                _this._flows = undefined;
                _this._cameraType = _initializer19 && _initializer19();
                _this._trackingType = _initializer20 && _initializer20();
                return _this;
              }

              var _proto = Camera.prototype;

              _proto.onLoad = function onLoad() {
                this._createCamera();
              };

              _proto.onEnable = function onEnable() {
                this.node.hasChangedFlags |= TransformBit.POSITION;

                if (this._camera) {
                  this._attachToScene();
                }
              };

              _proto.onDisable = function onDisable() {
                if (this._camera) {
                  this._detachFromScene();
                }
              };

              _proto.onDestroy = function onDestroy() {
                if (this._camera) {
                  this._camera.destroy();

                  this._camera = null;
                }

                if (this._targetTexture) {
                  this._targetTexture.off('resize');
                }
              };

              _proto.screenPointToRay = function screenPointToRay(x, y, out) {
                if (!out) {
                  out = Ray.create();
                }

                if (this._camera) {
                  this._camera.screenPointToRay(out, x, y);
                }

                return out;
              };

              _proto.worldToScreen = function worldToScreen(worldPos, out) {
                if (!out) {
                  out = new Vec3();
                }

                if (this._camera) {
                  this._camera.worldToScreen(out, worldPos);
                }

                return out;
              };

              _proto.screenToWorld = function screenToWorld(screenPos, out) {
                if (!out) {
                  out = this.node.getWorldPosition();
                }

                if (this._camera) {
                  this._camera.screenToWorld(out, screenPos);
                }

                return out;
              };

              _proto.convertToUINode = function convertToUINode(wpos, uiNode, out) {
                if (!out) {
                  out = new Vec3();
                }

                if (!this._camera) {
                  return out;
                }

                this.worldToScreen(wpos, _temp_vec3_1);
                var cmp = uiNode.getComponent('cc.UITransform');
                var designSize = legacyCC.view.getVisibleSize();
                var xoffset = _temp_vec3_1.x - this._camera.width * 0.5;
                var yoffset = _temp_vec3_1.y - this._camera.height * 0.5;
                _temp_vec3_1.x = xoffset / legacyCC.view.getScaleX() + designSize.width * 0.5;
                _temp_vec3_1.y = yoffset / legacyCC.view.getScaleY() + designSize.height * 0.5;

                if (cmp) {
                  cmp.convertToNodeSpaceAR(_temp_vec3_1, out);
                }

                return out;
              };

              _proto._createCamera = function _createCamera() {
                if (!this._camera) {
                  this._camera = legacyCC.director.root.createCamera();

                  this._camera.initialize({
                    name: this.node.name,
                    node: this.node,
                    projection: this._projection,
                    window: this._inEditorMode ? legacyCC.director.root && legacyCC.director.root.mainWindow : legacyCC.director.root && legacyCC.director.root.tempWindow,
                    priority: this._priority,
                    cameraType: this.cameraType,
                    trackingType: this.trackingType
                  });

                  this._camera.setViewportInOrientedSpace(this._rect);

                  this._camera.fovAxis = this._fovAxis;
                  this._camera.fov = toRadian(this._fov);
                  this._camera.orthoHeight = this._orthoHeight;
                  this._camera.nearClip = this._near;
                  this._camera.farClip = this._far;
                  this._camera.clearColor = this._color;
                  this._camera.clearDepth = this._depth;
                  this._camera.clearStencil = this._stencil;
                  this._camera.clearFlag = this._clearFlags;
                  this._camera.visibility = this._visibility;
                  this._camera.aperture = this._aperture;
                  this._camera.shutter = this._shutter;
                  this._camera.iso = this._iso;
                }

                this._updateTargetTexture();
              };

              _proto._attachToScene = function _attachToScene() {
                if (!this.node.scene || !this._camera) {
                  return;
                }

                if (this._camera && this._camera.scene) {
                  this._camera.scene.removeCamera(this._camera);
                }

                var rs = this._getRenderScene();

                rs.addCamera(this._camera);
              };

              _proto._detachFromScene = function _detachFromScene() {
                if (this._camera && this._camera.scene) {
                  this._camera.scene.removeCamera(this._camera);
                }
              };

              _proto._checkTargetTextureEvent = function _checkTargetTextureEvent(old) {
                var _this2 = this;

                if (old) {
                  old.off('resize');
                }

                if (this._targetTexture) {
                  this._targetTexture.on('resize', function (window) {
                    if (_this2._camera) {
                      _this2._camera.setFixedSize(window.width, window.height);
                    }
                  }, this);
                }
              };

              _proto._updateTargetTexture = function _updateTargetTexture() {
                if (!this._camera) {
                  return;
                }

                if (this._targetTexture) {
                  var window = this._targetTexture.window;

                  this._camera.changeTargetWindow(window);

                  this._camera.setFixedSize(window.width, window.height);
                }
              };

              _createClass(Camera, [{
                key: "camera",
                get: function get() {
                  return this._camera;
                }
              }, {
                key: "priority",
                get: function get() {
                  return this._priority;
                },
                set: function set(val) {
                  this._priority = val;

                  if (this._camera) {
                    this._camera.priority = val;
                  }
                }
              }, {
                key: "visibility",
                get: function get() {
                  return this._visibility;
                },
                set: function set(val) {
                  this._visibility = val;

                  if (this._camera) {
                    this._camera.visibility = val;
                  }
                }
              }, {
                key: "clearFlags",
                get: function get() {
                  return this._clearFlags;
                },
                set: function set(val) {
                  this._clearFlags = val;

                  if (this._camera) {
                    this._camera.clearFlag = val;
                  }
                }
              }, {
                key: "clearColor",
                get: function get() {
                  return this._color;
                },
                set: function set(val) {
                  this._color.set(val);

                  if (this._camera) {
                    this._camera.clearColor = this._color;
                  }
                }
              }, {
                key: "clearDepth",
                get: function get() {
                  return this._depth;
                },
                set: function set(val) {
                  this._depth = val;

                  if (this._camera) {
                    this._camera.clearDepth = val;
                  }
                }
              }, {
                key: "clearStencil",
                get: function get() {
                  return this._stencil;
                },
                set: function set(val) {
                  this._stencil = val;

                  if (this._camera) {
                    this._camera.clearStencil = val;
                  }
                }
              }, {
                key: "projection",
                get: function get() {
                  return this._projection;
                },
                set: function set(val) {
                  this._projection = val;

                  if (this._camera) {
                    this._camera.projectionType = val;
                  }
                }
              }, {
                key: "fovAxis",
                get: function get() {
                  return this._fovAxis;
                },
                set: function set(val) {
                  if (val === this._fovAxis) {
                    return;
                  }

                  this._fovAxis = val;

                  if (this._camera) {
                    this._camera.fovAxis = val;

                    if (val === CameraFOVAxis.VERTICAL) {
                      this.fov = this._fov * this._camera.aspect;
                    } else {
                      this.fov = this._fov / this._camera.aspect;
                    }
                  }
                }
              }, {
                key: "fov",
                get: function get() {
                  return this._fov;
                },
                set: function set(val) {
                  this._fov = val;

                  if (this._camera) {
                    this._camera.fov = toRadian(val);
                  }
                }
              }, {
                key: "orthoHeight",
                get: function get() {
                  return this._orthoHeight;
                },
                set: function set(val) {
                  this._orthoHeight = val;

                  if (this._camera) {
                    this._camera.orthoHeight = val;
                  }
                }
              }, {
                key: "near",
                get: function get() {
                  return this._near;
                },
                set: function set(val) {
                  this._near = val;

                  if (this._camera) {
                    this._camera.nearClip = val;
                  }
                }
              }, {
                key: "far",
                get: function get() {
                  return this._far;
                },
                set: function set(val) {
                  this._far = val;

                  if (this._camera) {
                    this._camera.farClip = val;
                  }
                }
              }, {
                key: "aperture",
                get: function get() {
                  return this._aperture;
                },
                set: function set(val) {
                  this._aperture = val;

                  if (this._camera) {
                    this._camera.aperture = val;
                  }
                }
              }, {
                key: "shutter",
                get: function get() {
                  return this._shutter;
                },
                set: function set(val) {
                  this._shutter = val;

                  if (this._camera) {
                    this._camera.shutter = val;
                  }
                }
              }, {
                key: "iso",
                get: function get() {
                  return this._iso;
                },
                set: function set(val) {
                  this._iso = val;

                  if (this._camera) {
                    this._camera.iso = val;
                  }
                }
              }, {
                key: "rect",
                get: function get() {
                  return this._rect;
                },
                set: function set(val) {
                  this._rect = val;

                  if (this._camera) {
                    this._camera.setViewportInOrientedSpace(val);
                  }
                }
              }, {
                key: "targetTexture",
                get: function get() {
                  return this._targetTexture;
                },
                set: function set(value) {
                  if (this._targetTexture === value) {
                    return;
                  }

                  var old = this._targetTexture;
                  this._targetTexture = value;

                  this._checkTargetTextureEvent(old);

                  this._updateTargetTexture();

                  if (!value && this._camera) {
                    this._camera.changeTargetWindow( null);

                    this._camera.isWindowSize = true;
                  }

                  this.node.emit(Camera.TARGET_TEXTURE_CHANGE, this);
                }
              }, {
                key: "screenScale",
                get: function get() {
                  return this._screenScale;
                },
                set: function set(val) {
                  this._screenScale = val;

                  if (this._camera) {
                    this._camera.screenScale = val;
                  }
                }
              }, {
                key: "inEditorMode",
                get: function get() {
                  return this._inEditorMode;
                },
                set: function set(value) {
                  this._inEditorMode = value;

                  if (this._camera) {
                    this._camera.changeTargetWindow(value ? legacyCC.director.root && legacyCC.director.root.mainWindow : legacyCC.director.root && legacyCC.director.root.tempWindow);
                  }
                }
              }, {
                key: "cameraType",
                get: function get() {
                  return this._cameraType;
                },
                set: function set(val) {
                  if (this._cameraType === val) {
                    return;
                  }

                  this._cameraType = val;

                  if (this.camera) {
                    this.camera.cameraType = val;
                  }
                }
              }, {
                key: "trackingType",
                get: function get() {
                  return this._trackingType;
                },
                set: function set(val) {
                  if (this._trackingType === val) {
                    return;
                  }

                  this._trackingType = val;

                  if (this.camera) {
                    this.camera.trackingType = val;
                  }
                }
              }]);

              return Camera;
            }(Component), _class3$6.ProjectionType = ProjectionType, _class3$6.FOVAxis = FOVAxis, _class3$6.ClearFlag = ClearFlag, _class3$6.Aperture = Aperture, _class3$6.Shutter = Shutter, _class3$6.ISO = ISO, _class3$6.TARGET_TEXTURE_CHANGE = 'tex-change', _temp$7), (_initializer$a = applyDecoratedInitializer(_class2$b.prototype, "_projection", [serializable$j], function () {
              return ProjectionType.PERSPECTIVE;
            }), _initializer2$8 = applyDecoratedInitializer(_class2$b.prototype, "_priority", [serializable$j], function () {
              return 0;
            }), _initializer3$6 = applyDecoratedInitializer(_class2$b.prototype, "_fov", [serializable$j], function () {
              return 45;
            }), _initializer4$6 = applyDecoratedInitializer(_class2$b.prototype, "_fovAxis", [serializable$j], function () {
              return FOVAxis.VERTICAL;
            }), _initializer5$4 = applyDecoratedInitializer(_class2$b.prototype, "_orthoHeight", [serializable$j], function () {
              return 10;
            }), _initializer6$3 = applyDecoratedInitializer(_class2$b.prototype, "_near", [serializable$j], function () {
              return 1;
            }), _initializer7$2 = applyDecoratedInitializer(_class2$b.prototype, "_far", [serializable$j], function () {
              return 1000;
            }), _initializer8$2 = applyDecoratedInitializer(_class2$b.prototype, "_color", [serializable$j], function () {
              return new Color$1('#333333');
            }), _initializer9$2 = applyDecoratedInitializer(_class2$b.prototype, "_depth", [serializable$j], function () {
              return 1;
            }), _initializer10$2 = applyDecoratedInitializer(_class2$b.prototype, "_stencil", [serializable$j], function () {
              return 0;
            }), _initializer11$1 = applyDecoratedInitializer(_class2$b.prototype, "_clearFlags", [serializable$j], function () {
              return ClearFlag.SOLID_COLOR;
            }), _initializer12$1 = applyDecoratedInitializer(_class2$b.prototype, "_rect", [serializable$j], function () {
              return new Rect$1(0, 0, 1, 1);
            }), _initializer13$1 = applyDecoratedInitializer(_class2$b.prototype, "_aperture", [serializable$j], function () {
              return Aperture.F16_0;
            }), _initializer14$1 = applyDecoratedInitializer(_class2$b.prototype, "_shutter", [serializable$j], function () {
              return Shutter.D125;
            }), _initializer15$1 = applyDecoratedInitializer(_class2$b.prototype, "_iso", [serializable$j], function () {
              return ISO.ISO100;
            }), _initializer16$1 = applyDecoratedInitializer(_class2$b.prototype, "_screenScale", [serializable$j], function () {
              return 1;
            }), _initializer17$1 = applyDecoratedInitializer(_class2$b.prototype, "_visibility", [serializable$j], function () {
              return CAMERA_DEFAULT_MASK;
            }), _initializer18 = applyDecoratedInitializer(_class2$b.prototype, "_targetTexture", [serializable$j], function () {
              return null;
            }), _initializer19 = applyDecoratedInitializer(_class2$b.prototype, "_cameraType", [serializable$j], function () {
              return CameraType.DEFAULT;
            }), _initializer20 = applyDecoratedInitializer(_class2$b.prototype, "_trackingType", [serializable$j], function () {
              return TrackingType.NO_TRACKING;
            }), _applyDecoratedDescriptor(_class2$b.prototype, "visibility", [_dec2$8], Object.getOwnPropertyDescriptor(_class2$b.prototype, "visibility"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "clearFlags", [_dec3$6], Object.getOwnPropertyDescriptor(_class2$b.prototype, "clearFlags"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "projection", [_dec4$4], Object.getOwnPropertyDescriptor(_class2$b.prototype, "projection"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "fovAxis", [_dec5$2], Object.getOwnPropertyDescriptor(_class2$b.prototype, "fovAxis"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "aperture", [_dec6$2], Object.getOwnPropertyDescriptor(_class2$b.prototype, "aperture"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "shutter", [_dec7$2], Object.getOwnPropertyDescriptor(_class2$b.prototype, "shutter"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "iso", [_dec8], Object.getOwnPropertyDescriptor(_class2$b.prototype, "iso"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "targetTexture", [_dec9], Object.getOwnPropertyDescriptor(_class2$b.prototype, "targetTexture"), _class2$b.prototype)), _class2$b)) || _class$d));
            legacyCC.Camera = Camera;

            var _orientationMap;
            var localWinSize = new Size$1();
            var orientationMap = (_orientationMap = {}, _orientationMap[macro.ORIENTATION_AUTO] = Orientation.AUTO, _orientationMap[macro.ORIENTATION_LANDSCAPE] = Orientation.LANDSCAPE, _orientationMap[macro.ORIENTATION_PORTRAIT] = Orientation.PORTRAIT, _orientationMap);
            var View = exports('View', function (_Eventify) {
              _inheritsLoose(View, _Eventify);

              function View() {
                var _this;

                _this = _Eventify.call(this) || this;
                _this._designResolutionSize = void 0;
                _this._scaleX = void 0;
                _this._scaleY = void 0;
                _this._viewportRect = void 0;
                _this._visibleRect = void 0;
                _this._autoFullScreen = void 0;
                _this._retinaEnabled = void 0;
                _this._resizeCallback = void 0;
                _this._resolutionPolicy = void 0;
                _this._rpExactFit = void 0;
                _this._rpShowAll = void 0;
                _this._rpNoBorder = void 0;
                _this._rpFixedHeight = void 0;
                _this._rpFixedWidth = void 0;
                var _strategyer = ContainerStrategy;
                var _strategy = ContentStrategy;
                _this._designResolutionSize = new Size$1(0, 0);
                _this._scaleX = 1;
                _this._scaleY = 1;
                _this._viewportRect = new Rect$1(0, 0, 0, 0);
                _this._visibleRect = new Rect$1(0, 0, 0, 0);
                _this._autoFullScreen = false;
                _this._retinaEnabled = false;
                _this._resizeCallback = null;
                _this._rpExactFit = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT);
                _this._rpShowAll = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.SHOW_ALL);
                _this._rpNoBorder = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER);
                _this._rpFixedHeight = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT);
                _this._rpFixedWidth = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH);
                _this._resolutionPolicy = _this._rpShowAll;
                return _this;
              }

              var _proto = View.prototype;

              _proto.init = function init() {
                var windowSize = screen.windowSize;
                var w = windowSize.width;
                var h = windowSize.height;
                this._designResolutionSize.width = w;
                this._designResolutionSize.height = h;
                this._viewportRect.width = w;
                this._viewportRect.height = h;
                this._visibleRect.width = w;
                this._visibleRect.height = h;
                localWinSize.width = this._visibleRect.width;
                localWinSize.height = this._visibleRect.height;

                if (visibleRect) {
                  visibleRect.init(this._visibleRect);
                }

                {
                  this.resizeWithBrowserSize(true);
                  var designResolution = settings.querySettings(Settings.Category.SCREEN, 'designResolution');

                  if (designResolution) {
                    this.setDesignResolutionSize(Number(designResolution.width), Number(designResolution.height), designResolution.policy || ResolutionPolicy.FIXED_HEIGHT);
                  }
                }

                screenAdapter.on('window-resize', this._updateAdaptResult, this);
                screenAdapter.on('orientation-change', this._updateAdaptResult, this);
                screenAdapter.on('fullscreen-change', this._updateAdaptResult, this);
              };

              _proto.resizeWithBrowserSize = function resizeWithBrowserSize(enabled) {
                screenAdapter.handleResizeEvent = enabled;
              };

              _proto.setResizeCallback = function setResizeCallback(callback) {
                if (typeof callback === 'function' || callback == null) {
                  this._resizeCallback = callback;
                }
              };

              _proto.setOrientation = function setOrientation(orientation) {
                screenAdapter.orientation = orientationMap[orientation];
              };

              _proto.adjustViewportMeta = function adjustViewportMeta(enabled) {};

              _proto.enableRetina = function enableRetina(enabled) {
                this._retinaEnabled = !!enabled;
              };

              _proto.isRetinaEnabled = function isRetinaEnabled() {
                return this._retinaEnabled;
              };

              _proto.enableAutoFullScreen = function enableAutoFullScreen(enabled) {
                if (enabled === this._autoFullScreen) {
                  return;
                }

                this._autoFullScreen = enabled;

                if (enabled) {
                  screen.requestFullScreen()["catch"](function (e) {});
                }
              };

              _proto.isAutoFullScreenEnabled = function isAutoFullScreenEnabled() {
                return this._autoFullScreen;
              };

              _proto.setCanvasSize = function setCanvasSize(width, height) {
                screenAdapter.resolutionScale = 1;
                var dpr = screenAdapter.devicePixelRatio;
                var windowSize = new Size$1(width * dpr, height * dpr);
                screen.windowSize = windowSize;
              };

              _proto.getCanvasSize = function getCanvasSize() {
                return screen.windowSize;
              };

              _proto.getFrameSize = function getFrameSize() {
                var dpr = screenAdapter.devicePixelRatio;
                var sizeInCssPixels = screen.windowSize;
                sizeInCssPixels.width /= dpr;
                sizeInCssPixels.height /= dpr;
                return sizeInCssPixels;
              };

              _proto.setFrameSize = function setFrameSize(width, height) {
                var dpr = screenAdapter.devicePixelRatio;
                screen.windowSize = new Size$1(width * dpr, height * dpr);
              };

              _proto.getVisibleSize = function getVisibleSize() {
                return new Size$1(this._visibleRect.width, this._visibleRect.height);
              };

              _proto.getVisibleSizeInPixel = function getVisibleSizeInPixel() {
                return new Size$1(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
              };

              _proto.getVisibleOrigin = function getVisibleOrigin() {
                return new Vec2(this._visibleRect.x, this._visibleRect.y);
              };

              _proto.getVisibleOriginInPixel = function getVisibleOriginInPixel() {
                return new Vec2(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
              };

              _proto.getResolutionPolicy = function getResolutionPolicy() {
                return this._resolutionPolicy;
              };

              _proto._updateResolutionPolicy = function _updateResolutionPolicy(resolutionPolicy) {
                if (resolutionPolicy instanceof ResolutionPolicy) {
                  this._resolutionPolicy = resolutionPolicy;
                } else {
                  var _locPolicy = ResolutionPolicy;

                  if (resolutionPolicy === _locPolicy.EXACT_FIT) {
                    this._resolutionPolicy = this._rpExactFit;
                  }

                  if (resolutionPolicy === _locPolicy.SHOW_ALL) {
                    this._resolutionPolicy = this._rpShowAll;
                  }

                  if (resolutionPolicy === _locPolicy.NO_BORDER) {
                    this._resolutionPolicy = this._rpNoBorder;
                  }

                  if (resolutionPolicy === _locPolicy.FIXED_HEIGHT) {
                    this._resolutionPolicy = this._rpFixedHeight;
                  }

                  if (resolutionPolicy === _locPolicy.FIXED_WIDTH) {
                    this._resolutionPolicy = this._rpFixedWidth;
                  }
                }
              };

              _proto.setResolutionPolicy = function setResolutionPolicy(resolutionPolicy) {
                this._updateResolutionPolicy(resolutionPolicy);

                var designedResolution = view.getDesignResolutionSize();
                view.setDesignResolutionSize(designedResolution.width, designedResolution.height, resolutionPolicy);
              };

              _proto.setDesignResolutionSize = function setDesignResolutionSize(width, height, resolutionPolicy) {
                if (!(width > 0 && height > 0)) {
                  errorID(2200);
                  return;
                }

                this._updateResolutionPolicy(resolutionPolicy);

                var policy = this._resolutionPolicy;

                if (policy) {
                  policy.preApply(this);
                }

                this._designResolutionSize.width = width;
                this._designResolutionSize.height = height;
                var result = policy.apply(this, this._designResolutionSize);

                if (result.scale && result.scale.length === 2) {
                  this._scaleX = result.scale[0];
                  this._scaleY = result.scale[1];
                }

                if (result.viewport) {
                  var vp = this._viewportRect;
                  var vb = this._visibleRect;
                  var rv = result.viewport;
                  vp.x = rv.x;
                  vp.y = rv.y;
                  vp.width = rv.width;
                  vp.height = rv.height;
                  vb.x = 0;
                  vb.y = 0;
                  vb.width = rv.width / this._scaleX;
                  vb.height = rv.height / this._scaleY;
                }

                policy.postApply(this);
                localWinSize.width = this._visibleRect.width;
                localWinSize.height = this._visibleRect.height;

                if (visibleRect) {
                  visibleRect.init(this._visibleRect);
                }

                this.emit('design-resolution-changed');
              };

              _proto.getDesignResolutionSize = function getDesignResolutionSize() {
                return new Size$1(this._designResolutionSize.width, this._designResolutionSize.height);
              };

              _proto.setRealPixelResolution = function setRealPixelResolution(width, height, resolutionPolicy) {
                {
                  document.documentElement.style.width = width + "px";
                  document.body.style.width = width + "px";
                  document.body.style.left = '0px';
                  document.body.style.top = '0px';
                }

                this.setDesignResolutionSize(width, height, resolutionPolicy);
              };

              _proto.getViewportRect = function getViewportRect() {
                return this._viewportRect;
              };

              _proto.getScaleX = function getScaleX() {
                return this._scaleX;
              };

              _proto.getScaleY = function getScaleY() {
                return this._scaleY;
              };

              _proto.getDevicePixelRatio = function getDevicePixelRatio() {
                return screenAdapter.devicePixelRatio;
              };

              _proto.convertToLocationInView = function convertToLocationInView(tx, ty, relatedPos, out) {
                if (out === void 0) {
                  out = new Vec2();
                }

                var x = screenAdapter.devicePixelRatio * (tx - relatedPos.left);
                var y = screenAdapter.devicePixelRatio * (relatedPos.top + relatedPos.height - ty);

                if (screenAdapter.isFrameRotated) {
                  out.x = screen.windowSize.width - y;
                  out.y = x;
                } else {
                  out.x = x;
                  out.y = y;
                }

                return out;
              };

              _proto._convertToUISpace = function _convertToUISpace(point) {
                var viewport = this._viewportRect;
                point.x = (point.x - viewport.x) / this._scaleX;
                point.y = (point.y - viewport.y) / this._scaleY;
              };

              _proto._updateAdaptResult = function _updateAdaptResult(width, height, windowId) {
                var _this$_resizeCallback;

                legacyCC.director.root.resize(width, height, windowId === undefined ? 1 : windowId);
                var w = this._designResolutionSize.width;
                var h = this._designResolutionSize.height;

                if (width > 0) {
                  this.setDesignResolutionSize(w, h, this._resolutionPolicy);
                }

                this.emit('canvas-resize');
                (_this$_resizeCallback = this._resizeCallback) === null || _this$_resizeCallback === void 0 ? void 0 : _this$_resizeCallback.call(this);
              };

              return View;
            }(Eventify(System)));
            View.instance = void 0;

            var ContainerStrategy = function () {
              function ContainerStrategy() {
                this.name = 'ContainerStrategy';
              }

              var _proto2 = ContainerStrategy.prototype;

              _proto2.preApply = function preApply(_view) {};

              _proto2.apply = function apply(_view, designedResolution) {};

              _proto2.postApply = function postApply(_view) {};

              _proto2._setupCanvas = function _setupCanvas() {
                var locCanvas = legacyCC.game.canvas;

                if (locCanvas) {
                  var windowSize = screen.windowSize;
                  locCanvas.width = windowSize.width;
                  locCanvas.height = windowSize.height;
                }
              };

              return ContainerStrategy;
            }();

            ContainerStrategy.EQUAL_TO_FRAME = void 0;
            ContainerStrategy.PROPORTION_TO_FRAME = void 0;

            var ContentStrategy = function () {
              function ContentStrategy() {
                this.name = 'ContentStrategy';
                this._result = void 0;
                this._result = {
                  scale: [1, 1],
                  viewport: null
                };
              }

              var _proto3 = ContentStrategy.prototype;

              _proto3.preApply = function preApply(_view) {};

              _proto3.apply = function apply(_view, designedResolution) {
                return {
                  scale: [1, 1]
                };
              };

              _proto3.postApply = function postApply(_view) {};

              _proto3._buildResult = function _buildResult(containerW, containerH, contentW, contentH, scaleX, scaleY) {
                if (Math.abs(containerW - contentW) < 2) {
                  contentW = containerW;
                }

                if (Math.abs(containerH - contentH) < 2) {
                  contentH = containerH;
                }

                var viewport = new Rect$1(Math.round((containerW - contentW) / 2), Math.round((containerH - contentH) / 2), contentW, contentH);
                this._result.scale = [scaleX, scaleY];
                this._result.viewport = viewport;
                return this._result;
              };

              return ContentStrategy;
            }();

            ContentStrategy.EXACT_FIT = void 0;
            ContentStrategy.SHOW_ALL = void 0;
            ContentStrategy.NO_BORDER = void 0;
            ContentStrategy.FIXED_HEIGHT = void 0;
            ContentStrategy.FIXED_WIDTH = void 0;

            (function () {
              var EqualToFrame = function (_ContainerStrategy) {
                _inheritsLoose(EqualToFrame, _ContainerStrategy);

                function EqualToFrame() {
                  var _this2;

                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }

                  _this2 = _ContainerStrategy.call.apply(_ContainerStrategy, [this].concat(args)) || this;
                  _this2.name = 'EqualToFrame';
                  return _this2;
                }

                var _proto4 = EqualToFrame.prototype;

                _proto4.apply = function apply(_view, designedResolution) {
                  screenAdapter.isProportionalToFrame = false;

                  this._setupCanvas();
                };

                return EqualToFrame;
              }(ContainerStrategy);

              var ProportionalToFrame = function (_ContainerStrategy2) {
                _inheritsLoose(ProportionalToFrame, _ContainerStrategy2);

                function ProportionalToFrame() {
                  var _this3;

                  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args[_key2] = arguments[_key2];
                  }

                  _this3 = _ContainerStrategy2.call.apply(_ContainerStrategy2, [this].concat(args)) || this;
                  _this3.name = 'ProportionalToFrame';
                  return _this3;
                }

                var _proto5 = ProportionalToFrame.prototype;

                _proto5.apply = function apply(_view, designedResolution) {
                  screenAdapter.isProportionalToFrame = true;

                  this._setupCanvas();
                };

                return ProportionalToFrame;
              }(ContainerStrategy);

              ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame();
              ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();

              var ExactFit = function (_ContentStrategy) {
                _inheritsLoose(ExactFit, _ContentStrategy);

                function ExactFit() {
                  var _this4;

                  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                    args[_key3] = arguments[_key3];
                  }

                  _this4 = _ContentStrategy.call.apply(_ContentStrategy, [this].concat(args)) || this;
                  _this4.name = 'ExactFit';
                  return _this4;
                }

                var _proto6 = ExactFit.prototype;

                _proto6.apply = function apply(_view, designedResolution) {
                  var windowSize = screen.windowSize;
                  var containerW = windowSize.width;
                  var containerH = windowSize.height;
                  var scaleX = containerW / designedResolution.width;
                  var scaleY = containerH / designedResolution.height;
                  return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
                };

                return ExactFit;
              }(ContentStrategy);

              var ShowAll = function (_ContentStrategy2) {
                _inheritsLoose(ShowAll, _ContentStrategy2);

                function ShowAll() {
                  var _this5;

                  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                    args[_key4] = arguments[_key4];
                  }

                  _this5 = _ContentStrategy2.call.apply(_ContentStrategy2, [this].concat(args)) || this;
                  _this5.name = 'ShowAll';
                  return _this5;
                }

                var _proto7 = ShowAll.prototype;

                _proto7.apply = function apply(_view, designedResolution) {
                  var windowSize = screen.windowSize;
                  var containerW = windowSize.width;
                  var containerH = windowSize.height;
                  var designW = designedResolution.width;
                  var designH = designedResolution.height;
                  var scaleX = containerW / designW;
                  var scaleY = containerH / designH;
                  var scale = 0;
                  var contentW;
                  var contentH;

                  if (scaleX < scaleY) {
                    scale = scaleX;
                    contentW = containerW;
                    contentH = designH * scale;
                  } else {
                    scale = scaleY;
                    contentW = designW * scale;
                    contentH = containerH;
                  }

                  return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                };

                return ShowAll;
              }(ContentStrategy);

              var NoBorder = function (_ContentStrategy3) {
                _inheritsLoose(NoBorder, _ContentStrategy3);

                function NoBorder() {
                  var _this6;

                  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                    args[_key5] = arguments[_key5];
                  }

                  _this6 = _ContentStrategy3.call.apply(_ContentStrategy3, [this].concat(args)) || this;
                  _this6.name = 'NoBorder';
                  return _this6;
                }

                var _proto8 = NoBorder.prototype;

                _proto8.apply = function apply(_view, designedResolution) {
                  var windowSize = screen.windowSize;
                  var containerW = windowSize.width;
                  var containerH = windowSize.height;
                  var designW = designedResolution.width;
                  var designH = designedResolution.height;
                  var scaleX = containerW / designW;
                  var scaleY = containerH / designH;
                  var scale;
                  var contentW;
                  var contentH;

                  if (scaleX < scaleY) {
                    scale = scaleY;
                    contentW = designW * scale;
                    contentH = containerH;
                  } else {
                    scale = scaleX;
                    contentW = containerW;
                    contentH = designH * scale;
                  }

                  return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                };

                return NoBorder;
              }(ContentStrategy);

              var FixedHeight = function (_ContentStrategy4) {
                _inheritsLoose(FixedHeight, _ContentStrategy4);

                function FixedHeight() {
                  var _this7;

                  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                    args[_key6] = arguments[_key6];
                  }

                  _this7 = _ContentStrategy4.call.apply(_ContentStrategy4, [this].concat(args)) || this;
                  _this7.name = 'FixedHeight';
                  return _this7;
                }

                var _proto9 = FixedHeight.prototype;

                _proto9.apply = function apply(_view, designedResolution) {
                  var windowSize = screen.windowSize;
                  var containerW = windowSize.width;
                  var containerH = windowSize.height;
                  var designH = designedResolution.height;
                  var scale = containerH / designH;
                  var contentW = containerW;
                  var contentH = containerH;
                  return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                };

                return FixedHeight;
              }(ContentStrategy);

              var FixedWidth = function (_ContentStrategy5) {
                _inheritsLoose(FixedWidth, _ContentStrategy5);

                function FixedWidth() {
                  var _this8;

                  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
                    args[_key7] = arguments[_key7];
                  }

                  _this8 = _ContentStrategy5.call.apply(_ContentStrategy5, [this].concat(args)) || this;
                  _this8.name = 'FixedWidth';
                  return _this8;
                }

                var _proto10 = FixedWidth.prototype;

                _proto10.apply = function apply(_view, designedResolution) {
                  var windowSize = screen.windowSize;
                  var containerW = windowSize.width;
                  var containerH = windowSize.height;
                  var designW = designedResolution.width;
                  var scale = containerW / designW;
                  var contentW = containerW;
                  var contentH = containerH;
                  return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                };

                return FixedWidth;
              }(ContentStrategy);

              ContentStrategy.EXACT_FIT = new ExactFit();
              ContentStrategy.SHOW_ALL = new ShowAll();
              ContentStrategy.NO_BORDER = new NoBorder();
              ContentStrategy.FIXED_HEIGHT = new FixedHeight();
              ContentStrategy.FIXED_WIDTH = new FixedWidth();
            })();

            var ResolutionPolicy = exports('ResolutionPolicy', function () {
              function ResolutionPolicy(containerStg, contentStg) {
                this.name = 'ResolutionPolicy';
                this._containerStrategy = void 0;
                this._contentStrategy = void 0;
                this._containerStrategy = null;
                this._contentStrategy = null;
                this.setContainerStrategy(containerStg);
                this.setContentStrategy(contentStg);
              }

              var _proto11 = ResolutionPolicy.prototype;

              _proto11.preApply = function preApply(_view) {
                this._contentStrategy.preApply(_view);
              };

              _proto11.apply = function apply(_view, designedResolution) {
                this._containerStrategy.apply(_view, designedResolution);

                return this._contentStrategy.apply(_view, designedResolution);
              };

              _proto11.postApply = function postApply(_view) {
                this._contentStrategy.postApply(_view);
              };

              _proto11.setContainerStrategy = function setContainerStrategy(containerStg) {
                if (containerStg instanceof ContainerStrategy) {
                  this._containerStrategy = containerStg;
                }
              };

              _proto11.setContentStrategy = function setContentStrategy(contentStg) {
                if (contentStg instanceof ContentStrategy) {
                  this._contentStrategy = contentStg;
                }
              };

              _createClass(ResolutionPolicy, [{
                key: "canvasSize",
                get: function get() {
                  return screen.windowSize;
                }
              }]);

              return ResolutionPolicy;
            }());
            ResolutionPolicy.EXACT_FIT = 0;
            ResolutionPolicy.NO_BORDER = 1;
            ResolutionPolicy.SHOW_ALL = 2;
            ResolutionPolicy.FIXED_HEIGHT = 3;
            ResolutionPolicy.FIXED_WIDTH = 4;
            ResolutionPolicy.UNKNOWN = 5;
            ResolutionPolicy.ContainerStrategy = ContainerStrategy;
            ResolutionPolicy.ContentStrategy = ContentStrategy;
            legacyCC.ResolutionPolicy = ResolutionPolicy;
            var view = exports('view', View.instance = legacyCC.view = new View());
            director.registerSystem('view', view, 0);
            legacyCC.winSize = localWinSize;

            var _dec$e, _dec2$9, _dec3$7, _class$e;
            var RenderRoot2D = exports('RenderRoot2D', (_dec$e = ccclass$p('cc.RenderRoot2D'), _dec2$9 = executionOrder(100), _dec3$7 = requireComponent(UITransform), _dec$e(_class$e = _dec2$9(_class$e = _dec3$7(_class$e = disallowMultiple(_class$e = function (_Component) {
              _inheritsLoose(RenderRoot2D, _Component);

              function RenderRoot2D() {
                return _Component.apply(this, arguments) || this;
              }

              var _proto = RenderRoot2D.prototype;

              _proto.onEnable = function onEnable() {
                legacyCC.director.root.batcher2D.addScreen(this);
              };

              _proto.onDisable = function onDisable() {
                legacyCC.director.root.batcher2D.removeScreen(this);
              };

              _proto.onDestroy = function onDestroy() {
                legacyCC.director.root.batcher2D.removeScreen(this);
              };

              return RenderRoot2D;
            }(Component)) || _class$e) || _class$e) || _class$e) || _class$e));

            var _dec$f, _dec2$a, _dec3$8, _dec4$5, _class$f, _class2$c, _initializer$b, _initializer2$9;

            var _worldPos = new Vec3();

            var RenderMode = Enum({
              OVERLAY: 0,
              INTERSPERSE: 1
            });
            var Canvas = exports('Canvas', (_dec$f = ccclass$p('cc.Canvas'), _dec2$a = executionOrder(100), _dec3$8 = type$8(Camera), _dec4$5 = type$8(Camera), _dec$f(_class$f = _dec2$a(_class$f = disallowMultiple(_class$f = (_class2$c = function (_RenderRoot2D) {
              _inheritsLoose(Canvas, _RenderRoot2D);

              function Canvas() {
                var _this;

                _this = _RenderRoot2D.call(this) || this;
                _this._cameraComponent = _initializer$b && _initializer$b();
                _this._alignCanvasWithScreen = _initializer2$9 && _initializer2$9();
                _this._thisOnCameraResized = void 0;
                _this._fitDesignResolution = void 0;
                _this._pos = new Vec3();
                _this._renderMode = RenderMode.OVERLAY;
                _this._thisOnCameraResized = _this._onResizeCamera.bind(_assertThisInitialized(_this));

                return _this;
              }

              var _proto = Canvas.prototype;

              _proto.__preload = function __preload() {
                var widget = this.getComponent('cc.Widget');

                if (widget) {
                  widget.updateAlignment();
                }

                {
                  if (this._cameraComponent) {
                    this._cameraComponent._createCamera();

                    this._cameraComponent.node.on(Camera.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
                  }
                }

                this._onResizeCamera();

                {
                  this.node.on(NodeEventType.TRANSFORM_CHANGED, this._thisOnCameraResized);
                }
              };

              _proto.onEnable = function onEnable() {
                _RenderRoot2D.prototype.onEnable.call(this);

                if ( this._cameraComponent) {
                  this._cameraComponent.node.on(Camera.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
                }
              };

              _proto.onDisable = function onDisable() {
                _RenderRoot2D.prototype.onDisable.call(this);

                if (this._cameraComponent) {
                  this._cameraComponent.node.off(Camera.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
                }
              };

              _proto.onDestroy = function onDestroy() {
                _RenderRoot2D.prototype.onDestroy.call(this);

                {
                  this.node.off(NodeEventType.TRANSFORM_CHANGED, this._thisOnCameraResized);
                }
              };

              _proto._onResizeCamera = function _onResizeCamera() {
                if (this._cameraComponent && this._alignCanvasWithScreen) {
                  if (this._cameraComponent.targetTexture) {
                    this._cameraComponent.orthoHeight = visibleRect.height / 2;
                  } else {
                    var size = screen.windowSize;
                    this._cameraComponent.orthoHeight = size.height / view.getScaleY() / 2;
                  }

                  this.node.getWorldPosition(_worldPos);

                  this._cameraComponent.node.setWorldPosition(_worldPos.x, _worldPos.y, 1000);
                }
              };

              _proto._getViewPriority = function _getViewPriority() {
                if (this._cameraComponent) {
                  var _this$cameraComponent;

                  var priority = (_this$cameraComponent = this.cameraComponent) === null || _this$cameraComponent === void 0 ? void 0 : _this$cameraComponent.priority;
                  priority = this._renderMode === RenderMode.OVERLAY ? priority | 1 << 30 : priority & ~(1 << 30);
                  return priority;
                }

                return 0;
              };

              _createClass(Canvas, [{
                key: "renderMode",
                get: function get() {
                  return this._renderMode;
                },
                set: function set(val) {
                  this._renderMode = val;

                  if (this._cameraComponent) {
                    this._cameraComponent.priority = this._getViewPriority();
                  }
                }
              }, {
                key: "cameraComponent",
                get: function get() {
                  return this._cameraComponent;
                },
                set: function set(value) {
                  if (this._cameraComponent === value) {
                    return;
                  }

                  this._cameraComponent = value;

                  this._onResizeCamera();
                }
              }, {
                key: "alignCanvasWithScreen",
                get: function get() {
                  return this._alignCanvasWithScreen;
                },
                set: function set(value) {
                  this._alignCanvasWithScreen = value;

                  this._onResizeCamera();
                }
              }]);

              return Canvas;
            }(RenderRoot2D), (_applyDecoratedDescriptor(_class2$c.prototype, "cameraComponent", [_dec3$8], Object.getOwnPropertyDescriptor(_class2$c.prototype, "cameraComponent"), _class2$c.prototype), _initializer$b = applyDecoratedInitializer(_class2$c.prototype, "_cameraComponent", [_dec4$5], function () {
              return null;
            }), _initializer2$9 = applyDecoratedInitializer(_class2$c.prototype, "_alignCanvasWithScreen", [serializable$j], function () {
              return true;
            })), _class2$c)) || _class$f) || _class$f) || _class$f));
            legacyCC.Canvas = Canvas;

            var _dec$g, _dec2$b, _dec3$9, _class$g;
            var UIComponent = exports('UIComponent', (_dec$g = ccclass$p('cc.UIComponent'), _dec2$b = requireComponent(UITransform), _dec3$9 = executionOrder(110), _dec$g(_class$g = _dec2$b(_class$g = _dec3$9(_class$g = disallowMultiple(_class$g = function (_Component) {
              _inheritsLoose(UIComponent, _Component);

              function UIComponent() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._lastParent = null;
                _this.stencilStage = Stage.DISABLED;
                return _this;
              }

              var _proto = UIComponent.prototype;

              _proto.__preload = function __preload() {
                this.node._uiProps.uiComp = this;
              };

              _proto.onEnable = function onEnable() {};

              _proto.onDisable = function onDisable() {};

              _proto.onDestroy = function onDestroy() {
                if (this.node._uiProps.uiComp === this) {
                  this.node._uiProps.uiComp = null;
                }
              };

              _proto.postUpdateAssembler = function postUpdateAssembler(render) {};

              _proto.markForUpdateRenderData = function markForUpdateRenderData(enable) {
              };

              _proto.setNodeDirty = function setNodeDirty() {};

              _proto.setTextureDirty = function setTextureDirty() {};

              return UIComponent;
            }(Component)) || _class$g) || _class$g) || _class$g) || _class$g));

            function rayAABB2(ray, min, max) {
              var o = ray.o;
              var d = ray.d;
              var ix = 1 / d.x;
              var iy = 1 / d.y;
              var iz = 1 / d.z;
              var t1 = (min.x - o.x) * ix;
              var t2 = (max.x - o.x) * ix;
              var t3 = (min.y - o.y) * iy;
              var t4 = (max.y - o.y) * iy;
              var t5 = (min.z - o.z) * iz;
              var t6 = (max.z - o.z) * iz;
              var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
              var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

              if (tmax < 0 || tmin > tmax) {
                return 0;
              }

              return tmin > 0 ? tmin : tmax;
            }

            var raySubMesh = function () {
              var tri = Triangle$1.create();
              var deOpt = {
                distance: Infinity,
                doubleSided: false,
                mode: ERaycastMode.ANY
              };
              var minDis = 0;

              var fillResult = function fillResult(m, d, i0, i1, i2, r) {
                if (m === ERaycastMode.CLOSEST) {
                  if (minDis > d || minDis === 0) {
                    minDis = d;

                    if (r) {
                      if (r.length === 0) {
                        r.push({
                          distance: d,
                          vertexIndex0: i0 / 3,
                          vertexIndex1: i1 / 3,
                          vertexIndex2: i2 / 3
                        });
                      } else {
                        r[0].distance = d;
                        r[0].vertexIndex0 = i0 / 3;
                        r[0].vertexIndex1 = i1 / 3;
                        r[0].vertexIndex2 = i2 / 3;
                      }
                    }
                  }
                } else {
                  minDis = d;
                  if (r) r.push({
                    distance: d,
                    vertexIndex0: i0 / 3,
                    vertexIndex1: i1 / 3,
                    vertexIndex2: i2 / 3
                  });
                }
              };

              var narrowphase = function narrowphase(vb, ib, pm, ray, opt) {
                if (pm === PrimitiveMode.TRIANGLE_LIST) {
                  var cnt = ib.length;

                  for (var j = 0; j < cnt; j += 3) {
                    var i0 = ib[j] * 3;
                    var i1 = ib[j + 1] * 3;
                    var i2 = ib[j + 2] * 3;
                    Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);
                    Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                    Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                    var dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
                    if (dist === 0 || dist > opt.distance) continue;
                    fillResult(opt.mode, dist, i0, i1, i2, opt.result);
                    if (opt.mode === ERaycastMode.ANY) return dist;
                  }
                } else if (pm === PrimitiveMode.TRIANGLE_STRIP) {
                  var _cnt = ib.length - 2;

                  var rev = 0;

                  for (var _j = 0; _j < _cnt; _j += 1) {
                    var _i = ib[_j - rev] * 3;

                    var _i2 = ib[_j + rev + 1] * 3;

                    var _i3 = ib[_j + 2] * 3;

                    Vec3.set(tri.a, vb[_i], vb[_i + 1], vb[_i + 2]);
                    Vec3.set(tri.b, vb[_i2], vb[_i2 + 1], vb[_i2 + 2]);
                    Vec3.set(tri.c, vb[_i3], vb[_i3 + 1], vb[_i3 + 2]);
                    rev = ~rev;

                    var _dist = intersect.rayTriangle(ray, tri, opt.doubleSided);

                    if (_dist === 0 || _dist > opt.distance) continue;
                    fillResult(opt.mode, _dist, _i, _i2, _i3, opt.result);
                    if (opt.mode === ERaycastMode.ANY) return _dist;
                  }
                } else if (pm === PrimitiveMode.TRIANGLE_FAN) {
                  var _cnt2 = ib.length - 1;

                  var _i4 = ib[0] * 3;

                  Vec3.set(tri.a, vb[_i4], vb[_i4 + 1], vb[_i4 + 2]);

                  for (var _j2 = 1; _j2 < _cnt2; _j2 += 1) {
                    var _i5 = ib[_j2] * 3;

                    var _i6 = ib[_j2 + 1] * 3;

                    Vec3.set(tri.b, vb[_i5], vb[_i5 + 1], vb[_i5 + 2]);
                    Vec3.set(tri.c, vb[_i6], vb[_i6 + 1], vb[_i6 + 2]);

                    var _dist2 = intersect.rayTriangle(ray, tri, opt.doubleSided);

                    if (_dist2 === 0 || _dist2 > opt.distance) continue;
                    fillResult(opt.mode, _dist2, _i4, _i5, _i6, opt.result);
                    if (opt.mode === ERaycastMode.ANY) return _dist2;
                  }
                }

                return minDis;
              };

              return function (ray, submesh, options) {
                minDis = 0;
                if (submesh.geometricInfo.positions.length === 0) return minDis;
                var opt = options === undefined ? deOpt : options;
                var min = submesh.geometricInfo.boundingBox.min;
                var max = submesh.geometricInfo.boundingBox.max;

                if (rayAABB2(ray, min, max)) {
                  var pm = submesh.primitiveMode;
                  var _submesh$geometricInf = submesh.geometricInfo,
                      vb = _submesh$geometricInf.positions,
                      ib = _submesh$geometricInf.indices;
                  narrowphase(vb, ib, pm, ray, opt);
                }

                return minDis;
              };
            }();

            var rayMesh = function () {
              var minDis = 0;
              var deOpt = {
                distance: Infinity,
                doubleSided: false,
                mode: ERaycastMode.ANY
              };
              return function (ray, mesh, options) {
                minDis = 0;
                var opt = options === undefined ? deOpt : options;
                var length = mesh.renderingSubMeshes.length;
                var min = mesh.struct.minPosition;
                var max = mesh.struct.maxPosition;
                if (min && max && !rayAABB2(ray, min, max)) return minDis;

                for (var i = 0; i < length; i++) {
                  var sm = mesh.renderingSubMeshes[i];
                  var dis = raySubMesh(ray, sm, opt);

                  if (dis) {
                    if (opt.mode === ERaycastMode.CLOSEST) {
                      if (minDis === 0 || minDis > dis) {
                        minDis = dis;
                        if (opt.subIndices) opt.subIndices[0] = i;
                      }
                    } else {
                      minDis = dis;
                      if (opt.subIndices) opt.subIndices.push(i);

                      if (opt.mode === ERaycastMode.ANY) {
                        return dis;
                      }
                    }
                  }
                }

                if (minDis && opt.mode === ERaycastMode.CLOSEST) {
                  if (opt.result) {
                    opt.result[0].distance = minDis;
                    opt.result.length = 1;
                  }

                  if (opt.subIndices) opt.subIndices.length = 1;
                }

                return minDis;
              };
            }();

            var rayModel = function () {
              var minDis = 0;
              var deOpt = {
                distance: Infinity,
                doubleSided: false,
                mode: ERaycastMode.ANY
              };
              var modelRay = new Ray();
              var m4 = new Mat4();
              return function (r, model, options) {
                minDis = 0;
                var opt = options === undefined ? deOpt : options;
                var wb = model.worldBounds;
                if (wb && !intersect.rayAABB(r, wb)) return minDis;
                Ray.copy(modelRay, r);

                if (model.node) {
                  Mat4.invert(m4, model.node.getWorldMatrix(m4));
                  Vec3.transformMat4(modelRay.o, r.o, m4);
                  Vec3.transformMat4Normal(modelRay.d, r.d, m4);
                }

                var subModels = model.subModels;

                for (var i = 0; i < subModels.length; i++) {
                  var subMesh = subModels[i].subMesh;
                  var dis = raySubMesh(modelRay, subMesh, opt);

                  if (dis) {
                    if (opt.mode === ERaycastMode.CLOSEST) {
                      if (minDis === 0 || minDis > dis) {
                        minDis = dis;
                        if (opt.subIndices) opt.subIndices[0] = i;
                      }
                    } else {
                      minDis = dis;
                      if (opt.subIndices) opt.subIndices.push(i);

                      if (opt.mode === ERaycastMode.ANY) {
                        return dis;
                      }
                    }
                  }
                }

                if (minDis && opt.mode === ERaycastMode.CLOSEST) {
                  if (opt.result) {
                    opt.result[0].distance = minDis;
                    opt.result.length = 1;
                  }

                  if (opt.subIndices) opt.subIndices.length = 1;
                }

                return minDis;
              };
            }();

            intersect.rayModel = rayModel;
            intersect.raySubMesh = raySubMesh;
            intersect.rayMesh = rayMesh;

            var _dec$h, _dec2$c, _class$h, _class2$d, _initializer$c;
            var ccclass = ccclass$p,
                serializable = serializable$j,
                type = type$8;
            var PrefabLink = exports('PrefabLink', (_dec$h = ccclass('cc.PrefabLink'), _dec2$c = type(Prefab), _dec$h(_class$h = (_class2$d = function (_Component) {
              _inheritsLoose(PrefabLink, _Component);

              function PrefabLink() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this.prefab = _initializer$c && _initializer$c();
                return _this;
              }

              return PrefabLink;
            }(Component), (_initializer$c = applyDecoratedInitializer(_class2$d.prototype, "prefab", [_dec2$c, serializable], function () {
              return null;
            })), _class2$d)) || _class$h));

            var _dec$i, _dec2$d, _dec3$a, _class$i, _class2$e, _initializer$d, _initializer2$a, _initializer3$7, _initializer4$7, _initializer5$5, _initializer6$4;
            var SpriteMode;

            (function (SpriteMode) {
              SpriteMode[SpriteMode["SIMPLE"] = 0] = "SIMPLE";
              SpriteMode[SpriteMode["SLICED"] = 1] = "SLICED";
              SpriteMode[SpriteMode["TILED"] = 2] = "TILED";
            })(SpriteMode || (SpriteMode = {}));

            var SpriteRenderer = exports('SpriteRenderer', (_dec$i = ccclass$p('cc.SpriteRenderer'), _dec2$d = executionOrder(100), _dec3$a = type$8(SpriteFrame), _dec$i(_class$i = _dec2$d(_class$i = (_class2$e = function (_ModelRenderer) {
              _inheritsLoose(SpriteRenderer, _ModelRenderer);

              function SpriteRenderer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _ModelRenderer.call.apply(_ModelRenderer, [this].concat(args)) || this;
                _this._spriteFrame = _initializer$d && _initializer$d();
                _this._mode = _initializer2$a && _initializer2$a();
                _this._color = _initializer3$7 && _initializer3$7();
                _this._flipX = _initializer4$7 && _initializer4$7();
                _this._flipY = _initializer5$5 && _initializer5$5();
                _this._size = _initializer6$4 && _initializer6$4();
                _this._model = null;
                return _this;
              }

              var _proto = SpriteRenderer.prototype;

              _proto.onLoad = function onLoad() {
                if (this._spriteFrame) {
                  if (!this._spriteFrame.mesh) {
                    this._spriteFrame.ensureMeshData();
                  }

                  this._spriteFrame.mesh.initialize();
                }

                this._updateModels();
              };

              _proto.onRestore = function onRestore() {
                this._updateModels();

                if (this.enabledInHierarchy) {
                  this._attachToScene();
                }
              };

              _proto.onEnable = function onEnable() {
                _ModelRenderer.prototype.onEnable.call(this);

                if (!this._model) {
                  this._updateModels();
                }

                this._attachToScene();
              };

              _proto.onDisable = function onDisable() {
                if (this._model) {
                  this._detachFromScene();
                }
              };

              _proto.onDestroy = function onDestroy() {
                if (this._model) {
                  legacyCC.director.root.destroyModel(this._model);
                  this._model = null;
                  this._models.length = 0;
                }
              };

              _proto._updateModels = function _updateModels() {
                if (!this._spriteFrame) {
                  return;
                }

                var model = this._model;

                if (model) {
                  model.destroy();
                  model.initialize();
                  model.node = model.transform = this.node;
                } else {
                  this._createModel();
                }

                if (this._model) {
                  var mesh = this._spriteFrame.mesh;

                  this._model.createBoundingShape(mesh.struct.minPosition, mesh.struct.maxPosition);

                  this._updateModelParams();

                  this._onUpdateLocalDescriptorSet();
                }
              };

              _proto._createModel = function _createModel() {
                var model = this._model = legacyCC.director.root.createModel(Model);
                model.visFlags = this.visibility;
                model.node = model.transform = this.node;
                this._models.length = 0;

                this._models.push(this._model);
              };

              _proto._updateModelParams = function _updateModelParams() {
                if (!this._spriteFrame || !this._model) {
                  return;
                }

                this._spriteFrame.ensureMeshData();

                var mesh = this._spriteFrame.mesh;
                this.node.hasChangedFlags |= TransformBit.POSITION;
                this._model.transform.hasChangedFlags |= TransformBit.POSITION;
                var meshCount = mesh ? mesh.renderingSubMeshes.length : 0;
                var renderingMesh = mesh.renderingSubMeshes;

                if (renderingMesh) {
                  for (var i = 0; i < meshCount; ++i) {
                    var material = this.getRenderMaterial(i);

                    if (material && !material.isValid) {
                      material = null;
                    }

                    var subMeshData = renderingMesh[i];

                    if (subMeshData) {
                      this._model.initSubModel(i, subMeshData, material || this._getBuiltinMaterial());
                    }
                  }
                }

                this._model.enabled = true;
              };

              _proto._getBuiltinMaterial = function _getBuiltinMaterial() {
                return builtinResMgr.get('missing-material');
              };

              _proto._onMaterialModified = function _onMaterialModified(idx, material) {
                _ModelRenderer.prototype._onMaterialModified.call(this, idx, material);

                if (!this._spriteFrame || !this._model || !this._model.inited) {
                  return;
                }

                this._onRebuildPSO(idx, material || this._getBuiltinMaterial());
              };

              _proto._onRebuildPSO = function _onRebuildPSO(idx, material) {
                if (!this._model || !this._model.inited) {
                  return;
                }

                this._model.setSubModelMaterial(idx, material);

                this._onUpdateLocalDescriptorSet();
              };

              _proto._onUpdateLocalDescriptorSet = function _onUpdateLocalDescriptorSet() {
                if (!this._spriteFrame || !this._model || !this._model.inited) {
                  return;
                }

                var texture = this._spriteFrame.getGFXTexture();

                var sampler = this._spriteFrame.getGFXSampler();

                var subModels = this._model.subModels;
                var binding = ModelLocalBindings.SAMPLER_SPRITE;

                for (var i = 0; i < subModels.length; i++) {
                  var descriptorSet = subModels[i].descriptorSet;
                  descriptorSet.bindTexture(binding, texture);
                  descriptorSet.bindSampler(binding, sampler);
                  descriptorSet.update();
                }
              };

              _proto._attachToScene = function _attachToScene() {
                if (!this.node.scene || !this._model) {
                  return;
                }

                var renderScene = this._getRenderScene();

                if (this._model.scene !== null) {
                  this._detachFromScene();
                }

                renderScene.addModel(this._model);
              };

              _proto._detachFromScene = function _detachFromScene() {
                if (this._model && this._model.scene) {
                  this._model.scene.removeModel(this._model);
                }
              };

              _createClass(SpriteRenderer, [{
                key: "spriteFrame",
                get: function get() {
                  return this._spriteFrame;
                },
                set: function set(value) {
                  if (this._spriteFrame === value) {
                    return;
                  }

                  var lastSprite = this._spriteFrame;
                  this._spriteFrame = value;

                  if (this._spriteFrame) {
                    this._spriteFrame.ensureMeshData();

                    var mesh = this._spriteFrame.mesh;
                    mesh.initialize();
                  }

                  this._updateModels();

                  if (this.enabledInHierarchy) {
                    this._attachToScene();
                  }
                }
              }, {
                key: "model",
                get: function get() {
                  return this._model;
                }
              }]);

              return SpriteRenderer;
            }(ModelRenderer), (_applyDecoratedDescriptor(_class2$e.prototype, "spriteFrame", [_dec3$a], Object.getOwnPropertyDescriptor(_class2$e.prototype, "spriteFrame"), _class2$e.prototype), _initializer$d = applyDecoratedInitializer(_class2$e.prototype, "_spriteFrame", [serializable$j], function () {
              return null;
            }), _initializer2$a = applyDecoratedInitializer(_class2$e.prototype, "_mode", [serializable$j], function () {
              return SpriteMode.SIMPLE;
            }), _initializer3$7 = applyDecoratedInitializer(_class2$e.prototype, "_color", [serializable$j], function () {
              return Color$1.WHITE.clone();
            }), _initializer4$7 = applyDecoratedInitializer(_class2$e.prototype, "_flipX", [serializable$j], function () {
              return false;
            }), _initializer5$5 = applyDecoratedInitializer(_class2$e.prototype, "_flipY", [serializable$j], function () {
              return false;
            }), _initializer6$4 = applyDecoratedInitializer(_class2$e.prototype, "_size", [serializable$j], function () {
              return new Vec2();
            })), _class2$e)) || _class$i) || _class$i));

            var _dec$j, _dec2$e, _dec3$b, _dec4$6, _dec5$3, _dec6$3, _dec7$3, _class$j, _class2$f, _initializer$e, _initializer2$b, _initializer3$8, _initializer4$8, _initializer5$6, _initializer6$5, _initializer7$3, _initializer8$3, _initializer9$3, _initializer10$3, _initializer11$2, _initializer12$2, _initializer13$2, _class3$7, _temp$8;

            var _htmlTextParser = new HtmlTextParser();

            var RichTextChildName = 'RICHTEXT_CHILD';
            var RichTextChildImageName = 'RICHTEXT_Image_CHILD';

            var _tempSize = new Vec2();

            var _tempSizeLeft = new Vec2();

            var labelPool = new Pool$1(function (seg) {

              if (!legacyCC.isValid(seg.node)) {
                return false;
              } else {
                var outline = seg.node.getComponent(LabelOutline);

                if (outline) {
                  outline.width = 0;
                }
              }

              return true;
            }, 20);
            var imagePool = new Pool$1(function (seg) {

              return legacyCC.isValid(seg.node);
            }, 10);

            function createSegment(type) {
              return {
                node: new Node(type),
                comp: null,
                lineCount: 0,
                styleIndex: 0,
                imageOffset: '',
                clickParam: '',
                clickHandler: '',
                type: type
              };
            }

            function getSegmentByPool(type, content) {
              var seg;

              if (type === RichTextChildName) {
                seg = labelPool._get();
              } else if (type === RichTextChildImageName) {
                seg = imagePool._get();
              }

              seg = seg || createSegment(type);
              var node = seg.node;

              if (!node) {
                node = new Node(type);
              }

              node.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;

              if (type === RichTextChildImageName) {
                seg.comp = node.getComponent(Sprite) || node.addComponent(Sprite);
                seg.comp.spriteFrame = content;
                seg.comp.type = Sprite.Type.SLICED;
                seg.comp.sizeMode = Sprite.SizeMode.CUSTOM;
              } else {
                seg.comp = node.getComponent(Label) || node.addComponent(Label);
                seg.comp.string = content;
                seg.comp.horizontalAlign = HorizontalTextAlignment.LEFT;
                seg.comp.verticalAlign = VerticalTextAlignment.TOP;
                seg.comp.underlineHeight = 2;
              }

              node.setPosition(0, 0, 0);
              var trans = node._uiProps.uiTransformComp;
              trans.setAnchorPoint(0.5, 0.5);
              seg.node = node;
              seg.lineCount = 0;
              seg.styleIndex = 0;
              seg.imageOffset = '';
              seg.clickParam = '';
              seg.clickHandler = '';
              return seg;
            }

            var RichText = exports('RichText', (_dec$j = ccclass$p('cc.RichText'), _dec2$e = executionOrder(110), _dec3$b = type$8(HorizontalTextAlignment), _dec4$6 = type$8(VerticalTextAlignment), _dec5$3 = type$8(Font), _dec6$3 = type$8(CacheMode), _dec7$3 = type$8(SpriteAtlas), _dec$j(_class$j = _dec2$e(_class$j = (_class2$f = (_temp$8 = _class3$7 = function (_Component) {
              _inheritsLoose(RichText, _Component);

              function RichText() {
                var _this;

                _this = _Component.call(this) || this;
                _this._lineHeight = _initializer$e && _initializer$e();
                _this._string = _initializer2$b && _initializer2$b();
                _this._horizontalAlign = _initializer3$8 && _initializer3$8();
                _this._verticalAlign = _initializer4$8 && _initializer4$8();
                _this._fontSize = _initializer5$6 && _initializer5$6();
                _this._maxWidth = _initializer6$5 && _initializer6$5();
                _this._fontFamily = _initializer7$3 && _initializer7$3();
                _this._font = _initializer8$3 && _initializer8$3();
                _this._isSystemFontUsed = _initializer9$3 && _initializer9$3();
                _this._userDefinedFont = _initializer10$3 && _initializer10$3();
                _this._cacheMode = _initializer11$2 && _initializer11$2();
                _this._imageAtlas = _initializer12$2 && _initializer12$2();
                _this._handleTouchEvent = _initializer13$2 && _initializer13$2();
                _this._textArray = [];
                _this._segments = [];
                _this._labelSegmentsCache = [];
                _this._linesWidth = [];
                _this._lineCount = 1;
                _this._labelWidth = 0;
                _this._labelHeight = 0;
                _this._layoutDirty = true;
                _this._lineOffsetX = 0;
                _this._updateRichTextStatus = void 0;
                _this._labelChildrenNum = 0;

                _this._updateRichTextStatus = _this._updateRichText;
                return _this;
              }

              var _proto = RichText.prototype;

              _proto.onLoad = function onLoad() {
                this.node.on(NodeEventType.LAYER_CHANGED, this._applyLayer, this);
                this.node.on(NodeEventType.ANCHOR_CHANGED, this._updateRichTextPosition, this);
              };

              _proto.onEnable = function onEnable() {
                if (this.handleTouchEvent) {
                  this._addEventListeners();
                }

                this._updateRichText();

                this._activateChildren(true);
              };

              _proto.onDisable = function onDisable() {
                if (this.handleTouchEvent) {
                  this._removeEventListeners();
                }

                this._activateChildren(false);
              };

              _proto.onRestore = function onRestore() {
                {
                  return;
                }
              };

              _proto.onDestroy = function onDestroy() {
                for (var _iterator = _createForOfIteratorHelperLoose(this._segments), _step; !(_step = _iterator()).done;) {
                  var seg = _step.value;
                  seg.node.removeFromParent();

                  if (seg.type === RichTextChildName) {
                    labelPool.put(seg);
                  } else if (seg.type === RichTextChildImageName) {
                    imagePool.put(seg);
                  }
                }

                this.node.off(NodeEventType.ANCHOR_CHANGED, this._updateRichTextPosition, this);
                this.node.off(NodeEventType.LAYER_CHANGED, this._applyLayer, this);
              };

              _proto._addEventListeners = function _addEventListeners() {
                this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
              };

              _proto._removeEventListeners = function _removeEventListeners() {
                this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
              };

              _proto._updateLabelSegmentTextAttributes = function _updateLabelSegmentTextAttributes() {
                var _this2 = this;

                this._segments.forEach(function (item) {
                  _this2._applyTextAttribute(item);
                });
              };

              _proto._createFontLabel = function _createFontLabel(str) {
                return getSegmentByPool(RichTextChildName, str);
              };

              _proto._createImage = function _createImage(spriteFrame) {
                return getSegmentByPool(RichTextChildImageName, spriteFrame);
              };

              _proto._onTTFLoaded = function _onTTFLoaded() {
                if (this._font instanceof TTFFont) {
                  this._layoutDirty = true;

                  this._updateRichText();
                } else {
                  this._layoutDirty = true;

                  this._updateRichText();
                }
              };

              _proto.splitLongStringApproximatelyIn2048 = function splitLongStringApproximatelyIn2048(text, styleIndex) {
                var approxSize = text.length * this.fontSize;
                var partStringArr = [];

                if (approxSize <= 2048 * 0.8) {
                  partStringArr.push(text);
                  return partStringArr;
                }

                this._calculateSize(_tempSize, styleIndex, text);

                if (_tempSize.x < 2048) {
                  partStringArr.push(text);
                } else {
                  var multilineTexts = text.split('\n');

                  for (var i = 0; i < multilineTexts.length; i++) {
                    this._calculateSize(_tempSize, styleIndex, multilineTexts[i]);

                    if (_tempSize.x < 2048) {
                      partStringArr.push(multilineTexts[i]);
                    } else {
                      var thisPartSplitResultArr = this.splitLongStringOver2048(multilineTexts[i], styleIndex);
                      partStringArr.push.apply(partStringArr, thisPartSplitResultArr);
                    }
                  }
                }

                return partStringArr;
              };

              _proto.splitLongStringOver2048 = function splitLongStringOver2048(text, styleIndex) {
                var partStringArr = [];
                var longStr = text;
                var curStart = 0;
                var curEnd = longStr.length / 2;
                var curString = longStr.substring(curStart, curEnd);
                var leftString = longStr.substring(curEnd);

                var curStringSize = this._calculateSize(_tempSize, styleIndex, curString);

                var leftStringSize = this._calculateSize(_tempSizeLeft, styleIndex, leftString);

                var maxWidth = this._maxWidth;

                if (this._maxWidth === 0) {
                  maxWidth = 2047.9;
                }

                var lineCountForOnePart = 1;
                var sizeForOnePart = lineCountForOnePart * maxWidth;

                while (curStringSize.x > sizeForOnePart) {
                  curEnd /= 2;

                  if (curEnd < 1) {
                    curEnd *= 2;
                    break;
                  }

                  curString = curString.substring(curStart, curEnd);
                  leftString = longStr.substring(curEnd);

                  this._calculateSize(curStringSize, styleIndex, curString);
                }

                var leftTryTimes = 1000;
                var curWordStep = 1;

                while (leftTryTimes && curStart < text.length) {
                  while (leftTryTimes && curStringSize.x < sizeForOnePart) {
                    var nextPartExec = getEnglishWordPartAtFirst(leftString);

                    if (nextPartExec && nextPartExec.length > 0) {
                      curWordStep = nextPartExec[0].length;
                    }

                    curEnd += curWordStep;
                    curString = longStr.substring(curStart, curEnd);
                    leftString = longStr.substring(curEnd);

                    this._calculateSize(curStringSize, styleIndex, curString);

                    leftTryTimes--;
                  }

                  while (leftTryTimes && curString.length >= 2 && curStringSize.x > sizeForOnePart) {
                    curEnd -= curWordStep;
                    curString = longStr.substring(curStart, curEnd);

                    this._calculateSize(curStringSize, styleIndex, curString);

                    curWordStep = 1;
                    leftTryTimes--;
                  }

                  if (curString.length >= 2) {
                    var lastWordExec = getEnglishWordPartAtLast(curString);

                    if (lastWordExec && lastWordExec.length > 0 && curString !== lastWordExec[0]) {
                      curEnd -= lastWordExec[0].length;
                      curString = longStr.substring(curStart, curEnd);
                    }
                  }

                  partStringArr.push(curString);
                  var partStep = curString.length;
                  curStart = curEnd;
                  curEnd += partStep;
                  curString = longStr.substring(curStart, curEnd);
                  leftString = longStr.substring(curEnd);

                  this._calculateSize(leftStringSize, styleIndex, leftString);

                  this._calculateSize(curStringSize, styleIndex, curString);

                  leftTryTimes--;

                  if (leftStringSize.x < 2048 && curStringSize.x < sizeForOnePart) {
                    partStringArr.push(curString);
                    curStart = text.length;
                    curEnd = text.length;
                    curString = leftString;

                    if (leftString !== '') {
                      partStringArr.push(curString);
                    }

                    break;
                  }
                }

                return partStringArr;
              };

              _proto._measureText = function _measureText(styleIndex, string) {
                var _this3 = this;

                var func = function func(s) {
                  var width = _this3._calculateSize(_tempSize, styleIndex, s).x;

                  return width;
                };

                if (string) {
                  return func(string);
                } else {
                  return func;
                }
              };

              _proto._calculateSize = function _calculateSize(out, styleIndex, s) {
                var label;

                if (this._labelSegmentsCache.length === 0) {
                  label = this._createFontLabel(s);

                  this._labelSegmentsCache.push(label);
                } else {
                  label = this._labelSegmentsCache[0];
                  label.node.getComponent(Label).string = s;
                }

                label.styleIndex = styleIndex;

                this._applyTextAttribute(label);

                var size = label.node._uiProps.uiTransformComp.contentSize;
                Vec2.set(out, size.x, size.y);
                return out;
              };

              _proto._onTouchEnded = function _onTouchEnded(event) {
                var _this4 = this;

                var components = this.node.getComponents(Component);

                var _loop = function _loop() {
                  var seg = _step2.value;
                  var clickHandler = seg.clickHandler;
                  var clickParam = seg.clickParam;

                  if (clickHandler && _this4._containsTouchLocation(seg, event.touch.getUILocation())) {
                    components.forEach(function (component) {
                      var func = component[clickHandler];

                      if (component.enabledInHierarchy && func) {
                        func.call(component, event, clickParam);
                      }
                    });
                    event.propagationStopped = true;
                  }
                };

                for (var _iterator2 = _createForOfIteratorHelperLoose(this._segments), _step2; !(_step2 = _iterator2()).done;) {
                  _loop();
                }
              };

              _proto._containsTouchLocation = function _containsTouchLocation(label, point) {
                var comp = label.node.getComponent(UITransform);

                if (!comp) {
                  return false;
                }

                var myRect = comp.getBoundingBoxToWorld();
                return myRect.contains(point);
              };

              _proto._resetState = function _resetState() {
                var children = this.node.children;

                for (var i = children.length - 1; i >= 0; i--) {
                  var child = children[i];

                  if (child.name === RichTextChildName || child.name === RichTextChildImageName) {
                    {
                      assert(child.parent === this.node);
                    }

                    child.parent = null;
                    var segment = createSegment(child.name);
                    segment.node = child;

                    if (child.name === RichTextChildName) {
                      segment.comp = child.getComponent(Label);
                      labelPool.put(segment);
                    } else {
                      segment.comp = child.getComponent(Sprite);
                      imagePool.put(segment);
                    }

                    this._labelChildrenNum--;
                  }
                }

                this._segments.length = 0;
                this._labelSegmentsCache.length = 0;
                this._linesWidth.length = 0;
                this._lineOffsetX = 0;
                this._lineCount = 1;
                this._labelWidth = 0;
                this._labelHeight = 0;
                this._layoutDirty = true;
              };

              _proto._activateChildren = function _activateChildren(active) {
                for (var i = this.node.children.length - 1; i >= 0; i--) {
                  var child = this.node.children[i];

                  if (child.name === RichTextChildName || child.name === RichTextChildImageName) {
                    child.active = active;
                  }
                }
              };

              _proto._addLabelSegment = function _addLabelSegment(stringToken, styleIndex) {
                var labelSegment;

                if (this._labelSegmentsCache.length === 0) {
                  labelSegment = this._createFontLabel(stringToken);
                } else {
                  labelSegment = this._labelSegmentsCache.pop();
                  var label = labelSegment.node.getComponent(Label);

                  if (label) {
                    label.string = stringToken;
                  }
                }

                var labelComp = labelSegment.comp;

                if (labelComp.verticalAlign !== this._verticalAlign) {
                  labelComp.verticalAlign = this._verticalAlign;
                }

                labelSegment.styleIndex = styleIndex;
                labelSegment.lineCount = this._lineCount;

                labelSegment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0);

                labelSegment.node.layer = this.node.layer;
                this.node.insertChild(labelSegment.node, this._labelChildrenNum++);

                this._applyTextAttribute(labelSegment);

                this._segments.push(labelSegment);

                return labelSegment;
              };

              _proto._updateRichTextWithMaxWidth = function _updateRichTextWithMaxWidth(labelString, labelWidth, styleIndex) {
                var fragmentWidth = labelWidth;
                var labelSegment;

                if (this._lineOffsetX > 0 && fragmentWidth + this._lineOffsetX > this._maxWidth) {
                  var checkStartIndex = 0;

                  while (this._lineOffsetX <= this._maxWidth) {
                    var checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length);

                    var checkString = labelString.substr(checkStartIndex, checkEndIndex);

                    var checkStringWidth = this._measureText(styleIndex, checkString);

                    if (this._lineOffsetX + checkStringWidth <= this._maxWidth) {
                      this._lineOffsetX += checkStringWidth;
                      checkStartIndex += checkEndIndex;
                    } else {
                      if (checkStartIndex > 0) {
                        var remainingString = labelString.substr(0, checkStartIndex);

                        this._addLabelSegment(remainingString, styleIndex);

                        labelString = labelString.substr(checkStartIndex, labelString.length);
                        fragmentWidth = this._measureText(styleIndex, labelString);
                      }

                      this._updateLineInfo();

                      break;
                    }
                  }
                }

                if (fragmentWidth > this._maxWidth) {
                  var fragments = fragmentText(labelString, fragmentWidth, this._maxWidth, this._measureText(styleIndex));

                  for (var k = 0; k < fragments.length; ++k) {
                    var splitString = fragments[k];
                    labelSegment = this._addLabelSegment(splitString, styleIndex);
                    var labelSize = labelSegment.node._uiProps.uiTransformComp.contentSize;
                    this._lineOffsetX += labelSize.width;

                    if (fragments.length > 1 && k < fragments.length - 1) {
                      this._updateLineInfo();
                    }
                  }
                } else {
                  this._lineOffsetX += fragmentWidth;

                  this._addLabelSegment(labelString, styleIndex);
                }
              };

              _proto._isLastComponentCR = function _isLastComponentCR(stringToken) {
                return stringToken.length - 1 === stringToken.lastIndexOf('\n');
              };

              _proto._updateLineInfo = function _updateLineInfo() {
                this._linesWidth.push(this._lineOffsetX);

                this._lineOffsetX = 0;
                this._lineCount++;
              };

              _proto._needsUpdateTextLayout = function _needsUpdateTextLayout(newTextArray) {
                if (this._layoutDirty || !this._textArray || !newTextArray) {
                  return true;
                }

                if (this._textArray.length !== newTextArray.length) {
                  return true;
                }

                for (var i = 0; i < this._textArray.length; i++) {
                  var oldItem = this._textArray[i];
                  var newItem = newTextArray[i];

                  if (oldItem.text !== newItem.text) {
                    return true;
                  } else {
                    var oldStyle = oldItem.style;
                    var newStyle = newItem.style;

                    if (oldStyle) {
                      if (newStyle) {
                        if (!!newStyle.outline !== !!oldStyle.outline) {
                          return true;
                        }

                        if (oldStyle.size !== newStyle.size || oldStyle.italic !== newStyle.italic || oldStyle.isImage !== newStyle.isImage) {
                          return true;
                        }

                        if (oldStyle.src !== newStyle.src || oldStyle.imageAlign !== newStyle.imageAlign || oldStyle.imageHeight !== newStyle.imageHeight || oldStyle.imageWidth !== newStyle.imageWidth || oldStyle.imageOffset !== newStyle.imageOffset) {
                          return true;
                        }
                      } else if (oldStyle.size || oldStyle.italic || oldStyle.isImage || oldStyle.outline) {
                        return true;
                      }
                    } else if (newStyle) {
                      if (newStyle.size || newStyle.italic || newStyle.isImage || newStyle.outline) {
                        return true;
                      }
                    }
                  }
                }

                return false;
              };

              _proto._addRichTextImageElement = function _addRichTextImageElement(richTextElement) {
                if (!richTextElement.style) {
                  return;
                }

                var style = richTextElement.style;
                var spriteFrameName = style.src;

                var spriteFrame = this._imageAtlas && spriteFrameName && this._imageAtlas.getSpriteFrame(spriteFrameName);

                if (!spriteFrame) {
                  warnID(4400);
                } else {
                  var segment = this._createImage(spriteFrame);

                  var sprite = segment.comp;

                  switch (style.imageAlign) {
                    case 'top':
                      segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 1);

                      break;

                    case 'center':
                      segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0.5);

                      break;

                    default:
                      segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0);

                      break;
                  }

                  if (style.imageOffset) {
                    segment.imageOffset = style.imageOffset;
                  }

                  segment.node.layer = this.node.layer;
                  this.node.insertChild(segment.node, this._labelChildrenNum++);

                  this._segments.push(segment);

                  var spriteRect = spriteFrame.rect.clone();
                  var scaleFactor = 1;
                  var spriteWidth = spriteRect.width;
                  var spriteHeight = spriteRect.height;
                  var expectWidth = style.imageWidth || 0;
                  var expectHeight = style.imageHeight || 0;

                  if (expectHeight > 0) {
                    scaleFactor = expectHeight / spriteHeight;
                    spriteWidth *= scaleFactor;
                    spriteHeight *= scaleFactor;
                  } else {
                    scaleFactor = this._lineHeight / spriteHeight;
                    spriteWidth *= scaleFactor;
                    spriteHeight *= scaleFactor;
                  }

                  if (expectWidth > 0) {
                    spriteWidth = expectWidth;
                  }

                  if (this._maxWidth > 0) {
                    if (this._lineOffsetX + spriteWidth > this._maxWidth) {
                      this._updateLineInfo();
                    }

                    this._lineOffsetX += spriteWidth;
                  } else {
                    this._lineOffsetX += spriteWidth;

                    if (this._lineOffsetX > this._labelWidth) {
                      this._labelWidth = this._lineOffsetX;
                    }
                  }

                  segment.node._uiProps.uiTransformComp.setContentSize(spriteWidth, spriteHeight);

                  segment.lineCount = this._lineCount;
                  segment.clickHandler = '';
                  segment.clickParam = '';
                  var event = style.event;

                  if (event) {
                    segment.clickHandler = event.click;
                    segment.clickParam = event.param;
                  }
                }
              };

              _proto._updateRichText = function _updateRichText() {
                if (!this.enabledInHierarchy) {
                  return;
                }

                var newTextArray = _htmlTextParser.parse(this._string);

                if (!this._needsUpdateTextLayout(newTextArray)) {
                  this._textArray = newTextArray.slice();

                  this._updateLabelSegmentTextAttributes();

                  return;
                }

                this._textArray = newTextArray.slice();

                this._resetState();

                var lastEmptyLine = false;
                var label;

                for (var i = 0; i < this._textArray.length; ++i) {
                  var richTextElement = this._textArray[i];
                  var text = richTextElement.text;

                  if (text === undefined) {
                    continue;
                  }

                  if (text === '') {
                    if (richTextElement.style && richTextElement.style.isNewLine) {
                      this._updateLineInfo();

                      continue;
                    }

                    if (richTextElement.style && richTextElement.style.isImage && this._imageAtlas) {
                      this._addRichTextImageElement(richTextElement);

                      continue;
                    }
                  }

                  var splitArr = this.splitLongStringApproximatelyIn2048(text, i);
                  text = splitArr.join('\n');
                  var multilineTexts = text.split('\n');

                  for (var j = 0; j < multilineTexts.length; ++j) {
                    var labelString = multilineTexts[j];

                    if (labelString === '') {
                      if (this._isLastComponentCR(text) && j === multilineTexts.length - 1) {
                        continue;
                      }

                      this._updateLineInfo();

                      lastEmptyLine = true;
                      continue;
                    }

                    lastEmptyLine = false;

                    if (this._maxWidth > 0) {
                      var labelWidth = this._measureText(i, labelString);

                      this._updateRichTextWithMaxWidth(labelString, labelWidth, i);

                      if (multilineTexts.length > 1 && j < multilineTexts.length - 1) {
                        this._updateLineInfo();
                      }
                    } else {
                      label = this._addLabelSegment(labelString, i);
                      this._lineOffsetX += label.node._uiProps.uiTransformComp.width;

                      if (this._lineOffsetX > this._labelWidth) {
                        this._labelWidth = this._lineOffsetX;
                      }

                      if (multilineTexts.length > 1 && j < multilineTexts.length - 1) {
                        this._updateLineInfo();
                      }
                    }
                  }
                }

                if (!lastEmptyLine) {
                  this._linesWidth.push(this._lineOffsetX);
                }

                if (this._maxWidth > 0) {
                  this._labelWidth = this._maxWidth;
                }

                this._labelHeight = (this._lineCount + BASELINE_RATIO) * this._lineHeight;

                this.node._uiProps.uiTransformComp.setContentSize(this._labelWidth, this._labelHeight);

                this._updateRichTextPosition();

                this._layoutDirty = false;
              };

              _proto._getFirstWordLen = function _getFirstWordLen(text, startIndex, textLen) {
                var character = text.charAt(startIndex);

                if (isUnicodeCJK(character) || isUnicodeSpace(character)) {
                  return 1;
                }

                var len = 1;

                for (var index = startIndex + 1; index < textLen; ++index) {
                  character = text.charAt(index);

                  if (isUnicodeSpace(character) || isUnicodeCJK(character)) {
                    break;
                  }

                  len++;
                }

                return len;
              };

              _proto._updateRichTextPosition = function _updateRichTextPosition() {
                var nextTokenX = 0;
                var nextLineIndex = 1;
                var totalLineCount = this._lineCount;
                var trans = this.node._uiProps.uiTransformComp;
                var anchorX = trans.anchorX;
                var anchorY = trans.anchorY;

                for (var i = 0; i < this._segments.length; ++i) {
                  var segment = this._segments[i];
                  var lineCount = segment.lineCount;

                  if (lineCount > nextLineIndex) {
                    nextTokenX = 0;
                    nextLineIndex = lineCount;
                  }

                  var lineOffsetX = this._labelWidth * (this._horizontalAlign * 0.5 - anchorX);

                  switch (this._horizontalAlign) {
                    case HorizontalTextAlignment.LEFT:
                      break;

                    case HorizontalTextAlignment.CENTER:
                      lineOffsetX -= this._linesWidth[lineCount - 1] / 2;
                      break;

                    case HorizontalTextAlignment.RIGHT:
                      lineOffsetX -= this._linesWidth[lineCount - 1];
                      break;
                  }

                  var pos = segment.node.position;
                  segment.node.setPosition(nextTokenX + lineOffsetX, this._lineHeight * (totalLineCount - lineCount) - this._labelHeight * anchorY, pos.z);

                  if (lineCount === nextLineIndex) {
                    nextTokenX += segment.node._uiProps.uiTransformComp.width;
                  }

                  var sprite = segment.node.getComponent(Sprite);

                  if (sprite) {
                    var position = segment.node.position.clone();
                    var lineHeightSet = this._lineHeight;
                    var lineHeightReal = this._lineHeight * (1 + BASELINE_RATIO);

                    switch (segment.node._uiProps.uiTransformComp.anchorY) {
                      case 1:
                        position.y += lineHeightSet + (lineHeightReal - lineHeightSet) / 2;
                        break;

                      case 0.5:
                        position.y += lineHeightReal / 2;
                        break;

                      default:
                        position.y += (lineHeightReal - lineHeightSet) / 2;
                        break;
                    }

                    if (segment.imageOffset) {
                      var offsets = segment.imageOffset.split(',');

                      if (offsets.length === 1 && offsets[0]) {
                        var offsetY = parseFloat(offsets[0]);
                        if (Number.isInteger(offsetY)) position.y += offsetY;
                      } else if (offsets.length === 2) {
                        var offsetX = parseFloat(offsets[0]);

                        var _offsetY = parseFloat(offsets[1]);

                        if (Number.isInteger(offsetX)) position.x += offsetX;
                        if (Number.isInteger(_offsetY)) position.y += _offsetY;
                      }
                    }

                    segment.node.position = position;
                  }

                  var outline = segment.node.getComponent(LabelOutline);

                  if (outline) {
                    var _position = segment.node.position.clone();

                    _position.y -= outline.width;
                    segment.node.position = _position;
                  }
                }
              };

              _proto._convertLiteralColorValue = function _convertLiteralColorValue(color) {
                var colorValue = color.toUpperCase();

                if (Color$1[colorValue]) {
                  var colorUse = Color$1[colorValue];
                  return colorUse;
                } else {
                  var out = new Color$1();
                  return out.fromHEX(color);
                }
              };

              _proto._applyTextAttribute = function _applyTextAttribute(labelSeg) {
                var label = labelSeg.node.getComponent(Label);

                if (!label) {
                  return;
                }

                this._resetLabelState(label);

                var index = labelSeg.styleIndex;
                var textStyle;

                if (this._textArray[index]) {
                  textStyle = this._textArray[index].style;
                }

                if (textStyle) {
                  label.color = this._convertLiteralColorValue(textStyle.color || 'white');
                  label.isBold = !!textStyle.bold;
                  label.isItalic = !!textStyle.italic;
                  label.isUnderline = !!textStyle.underline;

                  if (textStyle.outline) {
                    var labelOutline = labelSeg.node.getComponent(LabelOutline);

                    if (!labelOutline) {
                      labelOutline = labelSeg.node.addComponent(LabelOutline);
                    }

                    labelOutline.color = this._convertLiteralColorValue(textStyle.outline.color);
                    labelOutline.width = textStyle.outline.width;
                  }

                  label.fontSize = textStyle.size || this._fontSize;
                  labelSeg.clickHandler = '';
                  labelSeg.clickParam = '';
                  var event = textStyle.event;

                  if (event) {
                    labelSeg.clickHandler = event.click || '';
                    labelSeg.clickParam = event.param || '';
                  }
                }

                label.cacheMode = this._cacheMode;
                var isAsset = this._font instanceof Font;

                if (isAsset && !this._isSystemFontUsed) {
                  label.font = this._font;
                } else {
                  label.fontFamily = this._fontFamily;
                }

                label.useSystemFont = this._isSystemFontUsed;
                label.lineHeight = this._lineHeight;
                label.updateRenderData(true);
              };

              _proto._applyLayer = function _applyLayer() {
                for (var _iterator3 = _createForOfIteratorHelperLoose(this._segments), _step3; !(_step3 = _iterator3()).done;) {
                  var seg = _step3.value;
                  seg.node.layer = this.node.layer;
                }
              };

              _proto._resetLabelState = function _resetLabelState(label) {
                label.fontSize = this._fontSize;
                label.color = Color$1.WHITE;
                label.isBold = false;
                label.isItalic = false;
                label.isUnderline = false;
              };

              _createClass(RichText, [{
                key: "string",
                get: function get() {
                  return this._string;
                },
                set: function set(value) {
                  if (this._string === value) {
                    return;
                  }

                  this._string = value;

                  this._updateRichTextStatus();
                }
              }, {
                key: "horizontalAlign",
                get: function get() {
                  return this._horizontalAlign;
                },
                set: function set(value) {
                  if (this.horizontalAlign === value) {
                    return;
                  }

                  this._horizontalAlign = value;
                  this._layoutDirty = true;

                  this._updateRichTextStatus();
                }
              }, {
                key: "verticalAlign",
                get: function get() {
                  return this._verticalAlign;
                },
                set: function set(value) {
                  if (this._verticalAlign === value) {
                    return;
                  }

                  this._verticalAlign = value;
                  this._layoutDirty = true;

                  this._updateRichTextStatus();
                }
              }, {
                key: "fontSize",
                get: function get() {
                  return this._fontSize;
                },
                set: function set(value) {
                  if (this._fontSize === value) {
                    return;
                  }

                  this._fontSize = value;
                  this._layoutDirty = true;

                  this._updateRichTextStatus();
                }
              }, {
                key: "fontFamily",
                get: function get() {
                  return this._fontFamily;
                },
                set: function set(value) {
                  if (this._fontFamily === value) return;
                  this._fontFamily = value;
                  this._layoutDirty = true;

                  this._updateRichTextStatus();
                }
              }, {
                key: "font",
                get: function get() {
                  return this._font;
                },
                set: function set(value) {
                  if (this._font === value) {
                    return;
                  }

                  this._font = value;
                  this._layoutDirty = true;

                  if (this._font) {

                    this.useSystemFont = false;

                    this._onTTFLoaded();
                  } else {
                    this.useSystemFont = true;
                  }

                  this._updateRichTextStatus();
                }
              }, {
                key: "useSystemFont",
                get: function get() {
                  return this._isSystemFontUsed;
                },
                set: function set(value) {
                  if (this._isSystemFontUsed === value) {
                    return;
                  }

                  this._isSystemFontUsed = value;

                  this._layoutDirty = true;

                  this._updateRichTextStatus();
                }
              }, {
                key: "cacheMode",
                get: function get() {
                  return this._cacheMode;
                },
                set: function set(value) {
                  if (this._cacheMode === value) {
                    return;
                  }

                  this._cacheMode = value;

                  this._updateRichTextStatus();
                }
              }, {
                key: "maxWidth",
                get: function get() {
                  return this._maxWidth;
                },
                set: function set(value) {
                  if (this._maxWidth === value) {
                    return;
                  }

                  this._maxWidth = value;
                  this._layoutDirty = true;

                  this._updateRichTextStatus();
                }
              }, {
                key: "lineHeight",
                get: function get() {
                  return this._lineHeight;
                },
                set: function set(value) {
                  if (this._lineHeight === value) {
                    return;
                  }

                  this._lineHeight = value;
                  this._layoutDirty = true;

                  this._updateRichTextStatus();
                }
              }, {
                key: "imageAtlas",
                get: function get() {
                  return this._imageAtlas;
                },
                set: function set(value) {
                  if (this._imageAtlas === value) {
                    return;
                  }

                  this._imageAtlas = value;
                  this._layoutDirty = true;

                  this._updateRichTextStatus();
                }
              }, {
                key: "handleTouchEvent",
                get: function get() {
                  return this._handleTouchEvent;
                },
                set: function set(value) {
                  if (this._handleTouchEvent === value) {
                    return;
                  }

                  this._handleTouchEvent = value;

                  if (this.enabledInHierarchy) {
                    if (this.handleTouchEvent) {
                      this._addEventListeners();
                    } else {
                      this._removeEventListeners();
                    }
                  }
                }
              }]);

              return RichText;
            }(Component), _class3$7.HorizontalAlign = HorizontalTextAlignment, _class3$7.VerticalAlign = VerticalTextAlignment, _temp$8), (_applyDecoratedDescriptor(_class2$f.prototype, "horizontalAlign", [_dec3$b], Object.getOwnPropertyDescriptor(_class2$f.prototype, "horizontalAlign"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "verticalAlign", [_dec4$6], Object.getOwnPropertyDescriptor(_class2$f.prototype, "verticalAlign"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "font", [_dec5$3], Object.getOwnPropertyDescriptor(_class2$f.prototype, "font"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "cacheMode", [_dec6$3], Object.getOwnPropertyDescriptor(_class2$f.prototype, "cacheMode"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "imageAtlas", [_dec7$3], Object.getOwnPropertyDescriptor(_class2$f.prototype, "imageAtlas"), _class2$f.prototype), _initializer$e = applyDecoratedInitializer(_class2$f.prototype, "_lineHeight", [serializable$j], function () {
              return 40;
            }), _initializer2$b = applyDecoratedInitializer(_class2$f.prototype, "_string", [serializable$j], function () {
              return '<color=#00ff00>Rich</color><color=#0fffff>Text</color>';
            }), _initializer3$8 = applyDecoratedInitializer(_class2$f.prototype, "_horizontalAlign", [serializable$j], function () {
              return HorizontalTextAlignment.LEFT;
            }), _initializer4$8 = applyDecoratedInitializer(_class2$f.prototype, "_verticalAlign", [serializable$j], function () {
              return VerticalTextAlignment.TOP;
            }), _initializer5$6 = applyDecoratedInitializer(_class2$f.prototype, "_fontSize", [serializable$j], function () {
              return 40;
            }), _initializer6$5 = applyDecoratedInitializer(_class2$f.prototype, "_maxWidth", [serializable$j], function () {
              return 0;
            }), _initializer7$3 = applyDecoratedInitializer(_class2$f.prototype, "_fontFamily", [serializable$j], function () {
              return 'Arial';
            }), _initializer8$3 = applyDecoratedInitializer(_class2$f.prototype, "_font", [serializable$j], function () {
              return null;
            }), _initializer9$3 = applyDecoratedInitializer(_class2$f.prototype, "_isSystemFontUsed", [serializable$j], function () {
              return true;
            }), _initializer10$3 = applyDecoratedInitializer(_class2$f.prototype, "_userDefinedFont", [serializable$j], function () {
              return null;
            }), _initializer11$2 = applyDecoratedInitializer(_class2$f.prototype, "_cacheMode", [serializable$j], function () {
              return CacheMode.NONE;
            }), _initializer12$2 = applyDecoratedInitializer(_class2$f.prototype, "_imageAtlas", [serializable$j], function () {
              return null;
            }), _initializer13$2 = applyDecoratedInitializer(_class2$f.prototype, "_handleTouchEvent", [serializable$j], function () {
              return true;
            })), _class2$f)) || _class$j) || _class$j));
            legacyCC.RichText = RichText;

            var _dec$k, _dec2$f, _class$k;
            var UIMeshRenderer = exports('UIMeshRenderer', (_dec$k = ccclass$p('cc.UIMeshRenderer'), _dec2$f = executionOrder(110), _dec$k(_class$k = _dec2$f(_class$k = function (_Component) {
              _inheritsLoose(UIMeshRenderer, _Component);

              function UIMeshRenderer() {
                var _this;

                _this = _Component.call(this) || this;
                _this._modelComponent = null;
                _this._dirtyVersion = -1;
                _this._internalId = -1;
                _this.stencilStage = Stage.DISABLED;
                _this._renderData = null;
                _this._renderEntity = new RenderEntity(RenderEntityType.DYNAMIC);

                return _this;
              }

              var _proto = UIMeshRenderer.prototype;

              _proto.__preload = function __preload() {
                this.node._uiProps.uiComp = this;
              };

              _proto.onEnable = function onEnable() {
                uiRendererManager.addRenderer(this);
                this.markForUpdateRenderData();
              };

              _proto.onDisable = function onDisable() {
                uiRendererManager.removeRenderer(this);
                this.renderEntity.enabled = this._canRender();
              };

              _proto.onLoad = function onLoad() {
                if (!this.node._uiProps.uiTransformComp) {
                  this.node.addComponent('cc.UITransform');
                }

                this._modelComponent = this.getComponent('cc.ModelRenderer');

                if (!this._modelComponent) {
                  console.warn("node '" + (this.node && this.node.name) + "' doesn't have any renderable component");
                  return;
                }

                this.renderEntity.setNode(this.node);
              };

              _proto.onDestroy = function onDestroy() {
                this.renderEntity.setNode(null);

                if (this.node._uiProps.uiComp === this) {
                  this.node._uiProps.uiComp = null;
                }

                this._modelComponent = this.getComponent('cc.ModelRenderer');

                if (!this._modelComponent) {
                  return;
                }

                this._modelComponent._sceneGetter = null;
              };

              _proto._render = function _render(render) {
                if (this._modelComponent) {
                  var models = this._modelComponent._collectModels();

                  this._modelComponent._detachFromScene();

                  for (var i = 0; i < models.length; i++) {
                    if (models[i].enabled) {
                      render.commitModel(this, models[i], this._modelComponent.material);
                    }
                  }

                  return true;
                }

                return false;
              };

              _proto.fillBuffers = function fillBuffers(render) {
                if (this.enabled) {
                  this._render(render);
                }
              };

              _proto.updateRenderer = function updateRenderer() {
              };

              _proto._uploadRenderData = function _uploadRenderData(index) {
              };

              _proto.postUpdateAssembler = function postUpdateAssembler(render) {};

              _proto.update = function update() {

                this._fitUIRenderQueue();
              };

              _proto._fitUIRenderQueue = function _fitUIRenderQueue() {
                if (!this._modelComponent) {
                  return;
                }

                var matNum = this._modelComponent.sharedMaterials.length;

                for (var i = 0; i < matNum; i++) {
                  var material = this._modelComponent.getMaterialInstance(i);

                  if (material == null) {
                    continue;
                  }

                  var passes = material.passes;
                  var passNum = passes.length;

                  for (var j = 0; j < passNum; j++) {
                    var pass = passes[j];
                    pass._priority = RenderPriority.MAX - 11;
                    material.recompileShaders({
                      CC_FORCE_FORWARD_SHADING: true
                    }, j);
                  }
                }
              };

              _proto.markForUpdateRenderData = function markForUpdateRenderData(enable) {

                uiRendererManager.markDirtyRenderer(this);
              };

              _proto.setNodeDirty = function setNodeDirty() {};

              _proto.setTextureDirty = function setTextureDirty() {};

              _proto._canRender = function _canRender() {
                return this.enabled && this._modelComponent !== null;
              };

              _createClass(UIMeshRenderer, [{
                key: "modelComponent",
                get: function get() {
                  return this._modelComponent;
                }
              }, {
                key: "renderEntity",
                get: function get() {
                  {
                    assert(this._renderEntity, 'this._renderEntity should not be invalid');
                  }

                  return this._renderEntity;
                }
              }, {
                key: "renderData",
                get: function get() {
                  return this._renderData;
                }
              }]);

              return UIMeshRenderer;
            }(Component)) || _class$k) || _class$k));
            legacyCC.UIMeshRenderer = UIMeshRenderer;

            var UI_VIS_FLAG = Layers.Enum.NONE | Layers.Enum.UI_3D;
            var DrawBatch2D = function () {
              function DrawBatch2D() {
                this.model = null;
                this.texture = null;
                this.sampler = null;
                this.useLocalData = null;
                this.isStatic = false;
                this.textureHash = 0;
                this.samplerHash = 0;
                this._passes = [];
                this._shaders = [];
                this._visFlags = UI_VIS_FLAG;
                this._inputAssembler = null;
                this._descriptorSet = null;
              }

              var _proto = DrawBatch2D.prototype;

              _proto.destroy = function destroy(ui) {
                this._passes = [];
              };

              _proto.clear = function clear() {
                this._inputAssembler = null;
                this._descriptorSet = null;
                this.texture = null;
                this.sampler = null;
                this.textureHash = 0;
                this.samplerHash = 0;
                this.model = null;
                this.isStatic = false;
                this.useLocalData = null;
                this.visFlags = UI_VIS_FLAG;
              };

              _proto.fillPasses = function fillPasses(mat, dss, dssHash, patches) {
                if (mat) {
                  var passes = mat.passes;

                  if (!passes) {
                    return;
                  }
                  this._shaders.length = passes.length;

                  for (var i = 0; i < passes.length; i++) {
                    if (!this._passes[i]) {
                      this._passes[i] = new Pass(legacyCC.director.root);
                    }

                    var mtlPass = passes[i];
                    var passInUse = this._passes[i];
                    mtlPass.update();

                    if (!dss) {
                      dss = mtlPass.depthStencilState;
                      dssHash = 0;
                    }

                    passInUse._initPassFromTarget(mtlPass, dss, dssHash);

                    this._shaders[i] = passInUse.getShaderVariant(patches);
                  }
                }
              };

              _createClass(DrawBatch2D, [{
                key: "inputAssembler",
                get: function get() {
                  return this._inputAssembler;
                },
                set: function set(ia) {
                  this._inputAssembler = ia;
                }
              }, {
                key: "descriptorSet",
                get: function get() {
                  return this._descriptorSet;
                },
                set: function set(ds) {
                  this._descriptorSet = ds;
                }
              }, {
                key: "visFlags",
                get: function get() {
                  return this._visFlags;
                },
                set: function set(vis) {
                  this._visFlags = vis;
                }
              }, {
                key: "passes",
                get: function get() {
                  return this._passes;
                }
              }, {
                key: "shaders",
                get: function get() {
                  return this._shaders;
                }
              }]);

              return DrawBatch2D;
            }();

            var _dec$l, _dec2$g, _class$l, _class2$g;
            var UIStaticBatch = exports('UIStaticBatch', (_dec$l = ccclass$p('cc.UIStaticBatch'), _dec2$g = executionOrder(110), _dec$l(_class$l = _dec2$g(_class$l = (_class2$g = function (_UIRenderer) {
              _inheritsLoose(UIStaticBatch, _UIRenderer);

              function UIStaticBatch() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _UIRenderer.call.apply(_UIRenderer, [this].concat(args)) || this;
                _this._init = false;
                _this._bufferAccessor = null;
                _this._dirty = true;
                _this._uiDrawBatchList = [];
                return _this;
              }

              var _proto = UIStaticBatch.prototype;

              _proto.postUpdateAssembler = function postUpdateAssembler(render) {};

              _proto.markAsDirty = function markAsDirty() {};

              _proto._requireDrawBatch = function _requireDrawBatch() {
                var batch = new DrawBatch2D();
                batch.isStatic = true;

                this._uiDrawBatchList.push(batch);

                return batch;
              };

              _proto._clearData = function _clearData() {
                if (this._bufferAccessor) {
                  this._bufferAccessor.reset();

                  var ui = this._getBatcher();

                  for (var i = 0; i < this._uiDrawBatchList.length; i++) {
                    var element = this._uiDrawBatchList[i];
                    element.destroy(ui);
                  }
                }

                this._uiDrawBatchList.length = 0;
                this._init = false;
              };

              _proto._getBatcher = function _getBatcher() {
                if (director.root && director.root.batcher2D) {
                  return director.root.batcher2D;
                }

                warnID(9301);
                return null;
              };

              _createClass(UIStaticBatch, [{
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(value) {
                  if (this._color === value) {
                    return;
                  }

                  this._color.set(value);
                }
              }, {
                key: "drawBatchList",
                get: function get() {
                  return this._uiDrawBatchList;
                }
              }]);

              return UIStaticBatch;
            }(UIRenderer), (_applyDecoratedDescriptor(_class2$g.prototype, "color", [override$1], Object.getOwnPropertyDescriptor(_class2$g.prototype, "color"), _class2$g.prototype)), _class2$g)) || _class$l) || _class$l));

            var _dec$m, _dec2$h, _dec3$c, _class$m, _class2$h, _initializer$f, _initializer2$c, _initializer3$9;
            var LabelShadow = exports('LabelShadow', (_dec$m = ccclass$p('cc.LabelShadow'), _dec2$h = executionOrder(110), _dec3$c = requireComponent(Label), _dec$m(_class$m = _dec2$h(_class$m = _dec3$c(_class$m = (_class2$h = function (_Component) {
              _inheritsLoose(LabelShadow, _Component);

              function LabelShadow() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._color = _initializer$f && _initializer$f();
                _this._offset = _initializer2$c && _initializer2$c();
                _this._blur = _initializer3$9 && _initializer3$9();
                return _this;
              }

              var _proto = LabelShadow.prototype;

              _proto.onEnable = function onEnable() {
                this._updateRenderData();
              };

              _proto.onDisable = function onDisable() {
                this._updateRenderData();
              };

              _proto._updateRenderData = function _updateRenderData() {
                var label = this.node.getComponent(Label);

                if (label) {
                  label.updateRenderData(true);
                }
              };

              _createClass(LabelShadow, [{
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(value) {
                  if (this._color === value) {
                    return;
                  }

                  this._color.set(value);

                  this._updateRenderData();
                }
              }, {
                key: "offset",
                get: function get() {
                  return this._offset;
                },
                set: function set(value) {
                  this._offset = value;

                  this._updateRenderData();
                }
              }, {
                key: "blur",
                get: function get() {
                  return this._blur;
                },
                set: function set(value) {
                  this._blur = value;

                  this._updateRenderData();
                }
              }]);

              return LabelShadow;
            }(Component), (_initializer$f = applyDecoratedInitializer(_class2$h.prototype, "_color", [serializable$j], function () {
              return new Color$1(0, 0, 0, 255);
            }), _initializer2$c = applyDecoratedInitializer(_class2$h.prototype, "_offset", [serializable$j], function () {
              return new Vec2(2, 2);
            }), _initializer3$9 = applyDecoratedInitializer(_class2$h.prototype, "_blur", [serializable$j], function () {
              return 2;
            })), _class2$h)) || _class$m) || _class$m) || _class$m));

            var _dec$n, _dec2$i, _class$n, _class2$i, _initializer$g;
            var UIOpacity = exports('UIOpacity', (_dec$n = ccclass$p('cc.UIOpacity'), _dec2$i = executionOrder(110), _dec$n(_class$n = _dec2$i(_class$n = disallowMultiple(_class$n = (_class2$i = function (_Component) {
              _inheritsLoose(UIOpacity, _Component);

              function UIOpacity() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._opacity = _initializer$g && _initializer$g();
                return _this;
              }

              var _proto = UIOpacity.prototype;

              _proto.setEntityLocalOpacityDirtyRecursively = function setEntityLocalOpacityDirtyRecursively(dirty) {
              };

              UIOpacity.setEntityLocalOpacityDirtyRecursively = function setEntityLocalOpacityDirtyRecursively(node, dirty, interruptParentOpacity) {
                if (!node.isValid) {
                  return;
                }

                var render = node._uiProps.uiComp;
                var uiOp = node.getComponent(UIOpacity);
                var interruptOpacity = interruptParentOpacity;

                if (render && render.color) {
                  render.renderEntity.colorDirty = dirty;

                  if (uiOp) {
                    render.renderEntity.localOpacity = interruptOpacity * uiOp.opacity / 255;
                  } else {
                    render.renderEntity.localOpacity = interruptOpacity;
                  }

                  interruptOpacity = 1;
                } else if (uiOp) {
                  interruptOpacity = interruptOpacity * uiOp.opacity / 255;
                }

                for (var i = 0; i < node.children.length; i++) {
                  UIOpacity.setEntityLocalOpacityDirtyRecursively(node.children[i], dirty || interruptOpacity < 1, interruptOpacity);
                }
              };

              _proto.onEnable = function onEnable() {
                this.node._uiProps.localOpacity = this._opacity / 255;
                this.setEntityLocalOpacityDirtyRecursively(true);
              };

              _proto.onDisable = function onDisable() {
                this.node._uiProps.localOpacity = 1;
                this.setEntityLocalOpacityDirtyRecursively(true);
              };

              _createClass(UIOpacity, [{
                key: "opacity",
                get: function get() {
                  return this._opacity;
                },
                set: function set(value) {
                  if (this._opacity === value) {
                    return;
                  }

                  value = clampf(value, 0, 255);
                  this._opacity = value;
                  this.node._uiProps.localOpacity = value / 255;
                  this.setEntityLocalOpacityDirtyRecursively(true);
                }
              }]);

              return UIOpacity;
            }(Component), (_initializer$g = applyDecoratedInitializer(_class2$i.prototype, "_opacity", [serializable$j], function () {
              return 255;
            })), _class2$i)) || _class$n) || _class$n) || _class$n));

            var Aim = function Aim(i, x, y) {
              this.i = void 0;
              this.x = void 0;
              this.y = void 0;
              this.prev = null;
              this.next = null;
              this.z = null;
              this.prevZ = null;
              this.nextZ = null;
              this.steiner = false;
              this.i = i;
              this.x = x;
              this.y = y;
            };

            function linkedList(datas, start, end, dim, clockwise) {
              var i = 0;
              var last = null;

              if (clockwise === signedArea(datas, start, end, dim) > 0) {
                for (i = start; i < end; i += dim) {
                  last = insertNode(i, datas[i], datas[i + 1], last);
                }
              } else {
                for (i = end - dim; i >= start; i -= dim) {
                  last = insertNode(i, datas[i], datas[i + 1], last);
                }
              }

              if (last && equals(last, last.next)) {
                removeNode(last);
                last = last.next;
              }

              return last;
            }

            function filterPoints(start, end) {
              if (end === void 0) {
                end = null;
              }

              if (!start) {
                return start;
              }

              if (!end) {
                end = start;
              }

              var p = start;
              var again = false;

              do {
                again = false;

                if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                  removeNode(p);
                  p = end = p.prev;

                  if (p === p.next) {
                    return null;
                  }

                  again = true;
                } else {
                  p = p.next;
                }
              } while (again || p !== end);

              return end;
            }

            function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
              if (pass === void 0) {
                pass = 0;
              }

              if (!ear) {
                return;
              }

              if (!pass && size) {
                indexCurve(ear, minX, minY, size);
              }

              var stop = ear;
              var prev = null;
              var next = null;

              while (ear.prev !== ear.next) {
                prev = ear.prev;
                next = ear.next;

                if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
                  triangles.push(prev.i / dim);
                  triangles.push(ear.i / dim);
                  triangles.push(next.i / dim);
                  removeNode(ear);
                  ear = next.next;
                  stop = next.next;
                  continue;
                }

                ear = next;

                if (ear === stop) {
                  if (!pass) {
                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
                  } else if (pass === 1) {
                    ear = cureLocalIntersections(ear, triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, size, 2);
                  } else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, size);
                  }

                  break;
                }
              }
            }

            function isEar(ear) {
              var a = ear.prev;
              var b = ear;
              var c = ear.next;

              if (area(a, b, c) >= 0) {
                return false;
              }

              var p = ear.next.next;

              while (p !== ear.prev) {
                if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
                  return false;
                }

                p = p.next;
              }

              return true;
            }

            function isEarHashed(ear, minX, minY, size) {
              var a = ear.prev;
              var b = ear;
              var c = ear.next;

              if (area(a, b, c) >= 0) {
                return false;
              }

              var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;
              var minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;
              var maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;
              var maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
              var minZ = zOrder(minTX, minTY, minX, minY, size);
              var maxZ = zOrder(maxTX, maxTY, minX, minY, size);
              var p = ear.nextZ;

              while (p && p.z <= maxZ) {
                if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
                  return false;
                }

                p = p.nextZ;
              }

              p = ear.prevZ;

              while (p && p.z >= minZ) {
                if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
                  return false;
                }

                p = p.prevZ;
              }

              return true;
            }

            function cureLocalIntersections(start, triangles, dim) {
              var p = start;

              do {
                var a = p.prev;
                var b = p.next.next;

                if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                  triangles.push(a.i / dim);
                  triangles.push(p.i / dim);
                  triangles.push(b.i / dim);
                  removeNode(p);
                  removeNode(p.next);
                  p = start = b;
                }

                p = p.next;
              } while (p !== start);

              return p;
            }

            function splitEarcut(start, triangles, dim, minX, minY, size) {
              var a = start;

              do {
                var b = a.next.next;

                while (b !== a.prev) {
                  if (a.i !== b.i && isValidDiagonal(a, b)) {
                    var c = splitPolygon(a, b);
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);
                    earcutLinked(a, triangles, dim, minX, minY, size);
                    earcutLinked(c, triangles, dim, minX, minY, size);
                    return;
                  }

                  b = b.next;
                }

                a = a.next;
              } while (a !== start);
            }

            function eliminateHoles(datas, holeIndices, outerNode, dim) {
              var queue = [];
              var i = 0;
              var len = 0;
              var start = 0;
              var end = 0;
              var list = null;

              for (i = 0, len = holeIndices.length; i < len; i++) {
                start = holeIndices[i] * dim;
                end = i < len - 1 ? holeIndices[i + 1] * dim : datas.length;
                list = linkedList(datas, start, end, dim, false);

                if (!list) {
                  continue;
                }

                if (list === list.next) {
                  list.steiner = true;
                }

                queue.push(getLeftmost(list));
              }

              queue.sort(compareX);

              if (!outerNode) {
                return outerNode;
              }

              for (i = 0; i < queue.length; i++) {
                eliminateHole(queue[i], outerNode);
                outerNode = filterPoints(outerNode, outerNode.next);
              }

              return outerNode;
            }

            function compareX(a, b) {
              return a.x - b.x;
            }

            function eliminateHole(hole, outerNode) {
              outerNode = findHoleBridge(hole, outerNode);

              if (outerNode) {
                var b = splitPolygon(outerNode, hole);
                filterPoints(b, b.next);
              }
            }

            function findHoleBridge(hole, outerNode) {
              var p = outerNode;
              var hx = hole.x;
              var hy = hole.y;
              var qx = -Infinity;
              var m = null;

              do {
                if (hy <= p.y && hy >= p.next.y) {
                  var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

                  if (x <= hx && x > qx) {
                    qx = x;

                    if (x === hx) {
                      if (hy === p.y) {
                        return p;
                      }

                      if (hy === p.next.y) {
                        return p.next;
                      }
                    }

                    m = p.x < p.next.x ? p : p.next;
                  }
                }

                p = p.next;
              } while (p !== outerNode);

              if (!m) {
                return null;
              }

              if (hx === qx) {
                return m.prev;
              }

              var stop = m;
              var mx = m.x;
              var my = m.y;
              var tanMin = Infinity;
              var tan;
              p = m.next;

              while (p !== stop) {
                if (hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                  tan = Math.abs(hy - p.y) / (hx - p.x);

                  if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                  }
                }

                p = p.next;
              }

              return m;
            }

            function indexCurve(start, minX, minY, size) {
              var p = start;

              do {
                if (p.z === null) {
                  p.z = zOrder(p.x, p.y, minX, minY, size);
                }

                p.prevZ = p.prev;
                p.nextZ = p.next;
                p = p.next;
              } while (p !== start);

              p.prevZ.nextZ = null;
              p.prevZ = null;
              sortLinked(p);
            }

            function sortLinked(list) {
              var i = 0;
              var p = null;
              var q = null;
              var e = null;
              var tail = null;
              var numMerges = 0;
              var pSize = 0;
              var qSize = 0;
              var inSize = 1;

              do {
                p = list;
                list = null;
                tail = null;
                numMerges = 0;

                while (p) {
                  numMerges++;
                  q = p;
                  pSize = 0;

                  for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;

                    if (!q) {
                      break;
                    }
                  }

                  qSize = inSize;

                  while (pSize > 0 || qSize > 0 && q) {
                    if (pSize === 0) {
                      e = q;
                      q = q.nextZ;
                      qSize--;
                    } else if (qSize === 0 || !q) {
                      e = p;
                      p = p.nextZ;
                      pSize--;
                    } else if (p.z <= q.z) {
                      e = p;
                      p = p.nextZ;
                      pSize--;
                    } else {
                      e = q;
                      q = q.nextZ;
                      qSize--;
                    }

                    if (tail) {
                      tail.nextZ = e;
                    } else {
                      list = e;
                    }

                    e.prevZ = tail;
                    tail = e;
                  }

                  p = q;
                }

                tail.nextZ = null;
                inSize *= 2;
              } while (numMerges > 1);

              return list;
            }

            function zOrder(x, y, minX, minY, size) {
              x = 32767 * (x - minX) / size;
              y = 32767 * (y - minY) / size;
              x = (x | x << 8) & 0x00FF00FF;
              x = (x | x << 4) & 0x0F0F0F0F;
              x = (x | x << 2) & 0x33333333;
              x = (x | x << 1) & 0x55555555;
              y = (y | y << 8) & 0x00FF00FF;
              y = (y | y << 4) & 0x0F0F0F0F;
              y = (y | y << 2) & 0x33333333;
              y = (y | y << 1) & 0x55555555;
              return x | y << 1;
            }

            function getLeftmost(start) {
              var p = start;
              var leftmost = start;

              do {
                if (p.x < leftmost.x) {
                  leftmost = p;
                }

                p = p.next;
              } while (p !== start);

              return leftmost;
            }

            function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
              return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
            }

            function isValidDiagonal(a, b) {
              return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
            }

            function area(p, q, r) {
              return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
            }

            function equals(p1, p2) {
              return p1.x === p2.x && p1.y === p2.y;
            }

            function intersects(p1, q1, p2, q2) {
              if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) {
                return true;
              }

              return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
            }

            function intersectsPolygon(a, b) {
              var p = a;

              do {
                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {
                  return true;
                }

                p = p.next;
              } while (p !== a);

              return false;
            }

            function locallyInside(a, b) {
              return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
            }

            function middleInside(a, b) {
              var p = a;
              var inside = false;
              var px = (a.x + b.x) / 2;
              var py = (a.y + b.y) / 2;

              do {
                if (p.y > py !== p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {
                  inside = !inside;
                }

                p = p.next;
              } while (p !== a);

              return inside;
            }

            function splitPolygon(a, b) {
              var a2 = new Aim(a.i, a.x, a.y);
              var b2 = new Aim(b.i, b.x, b.y);
              var an = a.next;
              var bp = b.prev;
              a.next = b;
              b.prev = a;
              a2.next = an;
              an.prev = a2;
              b2.next = a2;
              a2.prev = b2;
              bp.next = b2;
              b2.prev = bp;
              return b2;
            }

            function insertNode(i, x, y, last) {
              var p = new Aim(i, x, y);

              if (!last) {
                p.prev = p;
                p.next = p;
              } else {
                p.next = last.next;
                p.prev = last;
                last.next.prev = p;
                last.next = p;
              }

              return p;
            }

            function removeNode(p) {
              p.next.prev = p.prev;
              p.prev.next = p.next;

              if (p.prevZ) {
                p.prevZ.nextZ = p.nextZ;
              }

              if (p.nextZ) {
                p.nextZ.prevZ = p.prevZ;
              }
            }

            function signedArea(datas, start, end, dim) {
              var sum = 0;

              for (var i = start, j = end - dim; i < end; i += dim) {
                sum += (datas[j] - datas[i]) * (datas[i + 1] + datas[j + 1]);
                j = i;
              }

              return sum;
            }

            function earcut(datas, holeIndices, dim) {
              dim = dim || 3;
              var hasHoles = holeIndices ? holeIndices.length : 0;
              var outerLen = hasHoles ? holeIndices[0] * dim : datas.length;
              var outerNode = linkedList(datas, 0, outerLen, dim, true);
              var triangles = [];

              if (!outerNode) {
                return triangles;
              }

              var minX = 0;
              var minY = 0;
              var maxX = 0;
              var maxY = 0;
              var x = 0;
              var y = 0;
              var size = 0;

              if (hasHoles) {
                outerNode = eliminateHoles(datas, holeIndices, outerNode, dim);
              }

              if (datas.length > 80 * dim) {
                minX = maxX = datas[0];
                minY = maxY = datas[1];

                for (var i = dim; i < outerLen; i += dim) {
                  x = datas[i];
                  y = datas[i + 1];

                  if (x < minX) {
                    minX = x;
                  }

                  if (y < minY) {
                    minY = y;
                  }

                  if (x > maxX) {
                    maxX = x;
                  }

                  if (y > maxY) {
                    maxY = y;
                  }
                }

                size = Math.max(maxX - minX, maxY - minY);
              }

              earcutLinked(outerNode, triangles, dim, minX, minY, size);
              return triangles;
            }

            var MAX_VERTEX = 65535;
            var MAX_INDICES = MAX_VERTEX * 2;
            var PI$1 = Math.PI;
            var min$1 = Math.min;
            var max$1 = Math.max;
            var ceil = Math.ceil;
            var acos = Math.acos;
            var cos$1 = Math.cos;
            var sin$1 = Math.sin;
            var atan2 = Math.atan2;
            var attrBytes = 8;
            var _renderData = null;
            var _impl = null;

            var _curColor = new Color$1();

            var vec3_temps = [];

            for (var i = 0; i < 4; i++) {
              vec3_temps.push(new Vec3());
            }

            function curveDivs(r, arc, tol) {
              var da = acos(r / (r + tol)) * 2.0;
              return max$1(2, ceil(arc / da));
            }

            function clamp(v, minNum, maxNum) {
              if (v < minNum) {
                return minNum;
              } else if (v > maxNum) {
                return maxNum;
              }

              return v;
            }

            var graphicsAssembler = {
              useModel: true,
              updateRenderData: function updateRenderData(graphics) {
              },
              fillBuffers: function fillBuffers(graphics, renderer) {},
              renderIA: function renderIA(graphics, renderer) {},
              getRenderData: function getRenderData(graphics, vertexCount) {
                if (!_impl) {
                  return null;
                }

                var renderDataList = _impl.getRenderDataList();

                var renderData = renderDataList[_impl.dataOffset];

                if (!renderData) {
                  return null;
                }

                var meshBuffer = renderData;
                var maxVertexCount = meshBuffer ? meshBuffer.vertexStart + vertexCount : 0;

                if (maxVertexCount > MAX_VERTEX || maxVertexCount * 3 > MAX_INDICES) {
                  ++_impl.dataOffset;

                  if (_impl.dataOffset < renderDataList.length) {
                    renderData = renderDataList[_impl.dataOffset];
                  } else {
                    renderData = _impl.requestRenderData();
                    renderDataList[_impl.dataOffset] = renderData;
                  }

                  meshBuffer = renderData;
                }

                if (meshBuffer && meshBuffer.vertexCount < maxVertexCount) {
                  meshBuffer.request(vertexCount, vertexCount * 3);
                }

                return renderData;
              },
              stroke: function stroke(graphics) {
                Color$1.copy(_curColor, graphics.strokeColor);

                if (!graphics.impl) {
                  return;
                }

                this._flattenPaths(graphics.impl);

                this._expandStroke(graphics);

                graphics.impl.updatePathOffset = true;
                this.end(graphics);
              },
              fill: function fill(graphics) {
                Color$1.copy(_curColor, graphics.fillColor);

                this._expandFill(graphics);

                if (graphics.impl) {
                  graphics.impl.updatePathOffset = true;
                }

                this.end(graphics);
              },
              end: function end(graphics) {
                graphics.markForUpdateRenderData();
              },
              _expandStroke: function _expandStroke(graphics) {
                var w = graphics.lineWidth * 0.5;
                var lineCap = graphics.lineCap;
                var lineJoin = graphics.lineJoin;
                var miterLimit = graphics.miterLimit;
                _impl = graphics.impl;

                if (!_impl) {
                  return;
                }

                var nCap = curveDivs(w, PI$1, _impl.tessTol);

                this._calculateJoins(_impl, w, lineJoin, miterLimit);

                var paths = _impl.paths;
                var vertexCount = 0;

                for (var _i = _impl.pathOffset, l = _impl.pathLength; _i < l; _i++) {
                  var path = paths[_i];
                  var pointsLength = path.points.length;

                  if (lineJoin === LineJoin.ROUND) {
                    vertexCount += (pointsLength + path.bevel * (nCap + 2) + 1) * 2;
                  } else {
                    vertexCount += (pointsLength + path.bevel * 5 + 1) * 2;
                  }

                  if (!path.closed) {
                    if (lineCap === LineCap.ROUND) {
                      vertexCount += (nCap * 2 + 2) * 2;
                    } else {
                      vertexCount += (3 + 3) * 2;
                    }
                  }
                }

                var meshBuffer = _renderData = this.getRenderData(graphics, vertexCount);

                if (!meshBuffer) {
                  return;
                }

                var vData = meshBuffer.vData;
                var iData = meshBuffer.iData;

                for (var _i2 = _impl.pathOffset, _l = _impl.pathLength; _i2 < _l; _i2++) {
                  var _path = paths[_i2];
                  var pts = _path.points;
                  var _pointsLength = pts.length;
                  var offset = meshBuffer.vertexStart;
                  var p0 = void 0;
                  var p1 = void 0;
                  var start = 0;
                  var end = 0;
                  var loop = _path.closed;

                  if (loop) {
                    p0 = pts[_pointsLength - 1];
                    p1 = pts[0];
                    start = 0;
                    end = _pointsLength;
                  } else {
                    p0 = pts[0];
                    p1 = pts[1];
                    start = 1;
                    end = _pointsLength - 1;
                  }

                  p1 = p1 || p0;

                  if (!loop) {
                    var dPos = new Point(p1.x, p1.y);
                    dPos.subtract(p0);
                    dPos.normalize();
                    var dx = dPos.x;
                    var dy = dPos.y;

                    if (lineCap === LineCap.BUTT) {
                      this._buttCapStart(p0, dx, dy, w, 0);
                    } else if (lineCap === LineCap.SQUARE) {
                      this._buttCapStart(p0, dx, dy, w, w);
                    } else if (lineCap === LineCap.ROUND) {
                      this._roundCapStart(p0, dx, dy, w, nCap);
                    }
                  }

                  for (var j = start; j < end; ++j) {
                    if (lineJoin === LineJoin.ROUND) {
                      this._roundJoin(p0, p1, w, w, nCap);
                    } else if ((p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) !== 0) {
                      this._bevelJoin(p0, p1, w, w);
                    } else {
                      this._vSet(p1.x + p1.dmx * w, p1.y + p1.dmy * w, 1);

                      this._vSet(p1.x - p1.dmx * w, p1.y - p1.dmy * w, -1);
                    }

                    p0 = p1;
                    p1 = pts[j + 1];
                  }

                  if (loop) {
                    var vDataOffset = offset * attrBytes;

                    this._vSet(vData[vDataOffset], vData[vDataOffset + 1], 1);

                    this._vSet(vData[vDataOffset + attrBytes], vData[vDataOffset + attrBytes + 1], -1);
                  } else {
                    var _dPos = new Point(p1.x, p1.y);

                    _dPos.subtract(p0);

                    _dPos.normalize();

                    var _dx = _dPos.x;
                    var _dy = _dPos.y;

                    if (lineCap === LineCap.BUTT) {
                      this._buttCapEnd(p1, _dx, _dy, w, 0);
                    } else if (lineCap === LineCap.SQUARE) {
                      this._buttCapEnd(p1, _dx, _dy, w, w);
                    } else if (lineCap === LineCap.ROUND) {
                      this._roundCapEnd(p1, _dx, _dy, w, nCap);
                    }
                  }

                  var indicesOffset = meshBuffer.indexStart;

                  for (var begin = offset + 2, over = meshBuffer.vertexStart; begin < over; begin++) {
                    iData[indicesOffset++] = begin - 2;
                    iData[indicesOffset++] = begin - 1;
                    iData[indicesOffset++] = begin;
                  }

                  meshBuffer.indexStart = indicesOffset;
                }

                _renderData = null;
                _impl = null;
              },
              _expandFill: function _expandFill(graphics) {
                _impl = graphics.impl;

                if (!_impl) {
                  return;
                }

                var paths = _impl.paths;
                var vertexCount = 0;

                for (var _i3 = _impl.pathOffset, l = _impl.pathLength; _i3 < l; _i3++) {
                  var path = paths[_i3];
                  var pointsLength = path.points.length;
                  vertexCount += pointsLength;
                }

                var renderData = _renderData = this.getRenderData(graphics, vertexCount);

                if (!renderData) {
                  return;
                }

                var meshBuffer = renderData;
                var vData = meshBuffer.vData;
                var iData = meshBuffer.iData;

                for (var _i4 = _impl.pathOffset, _l2 = _impl.pathLength; _i4 < _l2; _i4++) {
                  var _path2 = paths[_i4];
                  var pts = _path2.points;
                  var _pointsLength2 = pts.length;

                  if (_pointsLength2 === 0) {
                    continue;
                  }

                  var vertexOffset = renderData.vertexStart;

                  for (var j = 0; j < _pointsLength2; ++j) {
                    this._vSet(pts[j].x, pts[j].y);
                  }

                  var indicesOffset = renderData.indexStart;

                  if (_path2.complex) {
                    var earcutData = [];

                    for (var _j = vertexOffset, end = renderData.vertexStart; _j < end; _j++) {
                      var vDataOffset = _j * attrBytes;
                      earcutData.push(vData[vDataOffset++]);
                      earcutData.push(vData[vDataOffset++]);
                      earcutData.push(vData[vDataOffset++]);
                    }

                    var newIndices = earcut(earcutData, null, 3);

                    if (!newIndices || newIndices.length === 0) {
                      continue;
                    }

                    for (var _j2 = 0, nIndices = newIndices.length; _j2 < nIndices; _j2++) {
                      iData[indicesOffset++] = newIndices[_j2] + vertexOffset;
                    }
                  } else {
                    var first = vertexOffset;

                    for (var start = vertexOffset + 2, _end = meshBuffer.vertexStart; start < _end; start++) {
                      iData[indicesOffset++] = first;
                      iData[indicesOffset++] = start - 1;
                      iData[indicesOffset++] = start;
                    }
                  }

                  meshBuffer.indexStart = indicesOffset;
                }

                _renderData = null;
                _impl = null;
              },
              _calculateJoins: function _calculateJoins(impl, w, lineJoin, miterLimit) {
                var iw = 0.0;

                if (w > 0.0) {
                  iw = 1 / w;
                }

                var paths = impl.paths;

                for (var _i5 = impl.pathOffset, l = impl.pathLength; _i5 < l; _i5++) {
                  var path = paths[_i5];
                  var pts = path.points;
                  var ptsLength = pts.length;
                  var p0 = pts[ptsLength - 1];
                  var p1 = pts[0];
                  path.bevel = 0;

                  for (var j = 0; j < ptsLength; j++) {
                    var dmr2 = 0;
                    var cross = 0;
                    var limit = 0;
                    var dlx0 = p0.dy;
                    var dly0 = -p0.dx;
                    var dlx1 = p1.dy;
                    var dly1 = -p1.dx;
                    p1.dmx = (dlx0 + dlx1) * 0.5;
                    p1.dmy = (dly0 + dly1) * 0.5;
                    dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy;

                    if (dmr2 > 0.000001) {
                      var scale = 1 / dmr2;

                      if (scale > 600) {
                        scale = 600;
                      }

                      p1.dmx *= scale;
                      p1.dmy *= scale;
                    }

                    cross = p1.dx * p0.dy - p0.dx * p1.dy;

                    if (cross > 0) {
                      p1.flags |= PointFlags.PT_LEFT;
                    }

                    limit = max$1(11, min$1(p0.len, p1.len) * iw);

                    if (dmr2 * limit * limit < 1) {
                      p1.flags |= PointFlags.PT_INNERBEVEL;
                    }

                    if (p1.flags & PointFlags.PT_CORNER) {
                      if (dmr2 * miterLimit * miterLimit < 1 || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) {
                        p1.flags |= PointFlags.PT_BEVEL;
                      }
                    }

                    if ((p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) !== 0) {
                      path.bevel++;
                    }

                    p0 = p1;
                    p1 = pts[j + 1];
                  }
                }
              },
              _flattenPaths: function _flattenPaths(impl) {
                var paths = impl.paths;

                for (var _i6 = impl.pathOffset, l = impl.pathLength; _i6 < l; _i6++) {
                  var path = paths[_i6];
                  var pts = path.points;
                  var p0 = pts[pts.length - 1];
                  var p1 = pts[0];

                  if (pts.length > 2 && p0.equals(p1)) {
                    path.closed = true;
                    pts.pop();
                    p0 = pts[pts.length - 1];
                  }

                  for (var j = 0, size = pts.length; j < size; j++) {
                    var dPos = new Point(p1.x, p1.y);
                    dPos.subtract(p0);
                    p0.len = dPos.length();

                    if (dPos.x || dPos.y) {
                      dPos.normalize();
                    }

                    p0.dx = dPos.x;
                    p0.dy = dPos.y;
                    p0 = p1;
                    p1 = pts[j + 1];
                  }
                }
              },
              _chooseBevel: function _chooseBevel(bevel, p0, p1, w) {
                var x = p1.x;
                var y = p1.y;
                var x0 = 0;
                var y0 = 0;
                var x1 = 0;
                var y1 = 0;

                if (bevel !== 0) {
                  x0 = x + p0.dy * w;
                  y0 = y - p0.dx * w;
                  x1 = x + p1.dy * w;
                  y1 = y - p1.dx * w;
                } else {
                  x0 = x1 = x + p1.dmx * w;
                  y0 = y1 = y + p1.dmy * w;
                }

                return [x0, y0, x1, y1];
              },
              _buttCapStart: function _buttCapStart(p, dx, dy, w, d) {
                var px = p.x - dx * d;
                var py = p.y - dy * d;
                var dlx = dy;
                var dly = -dx;

                this._vSet(px + dlx * w, py + dly * w, 1);

                this._vSet(px - dlx * w, py - dly * w, -1);
              },
              _buttCapEnd: function _buttCapEnd(p, dx, dy, w, d) {
                var px = p.x + dx * d;
                var py = p.y + dy * d;
                var dlx = dy;
                var dly = -dx;

                this._vSet(px + dlx * w, py + dly * w, 1);

                this._vSet(px - dlx * w, py - dly * w, -1);
              },
              _roundCapStart: function _roundCapStart(p, dx, dy, w, nCap) {
                var px = p.x;
                var py = p.y;
                var dlx = dy;
                var dly = -dx;

                for (var _i7 = 0; _i7 < nCap; _i7++) {
                  var a = _i7 / (nCap - 1) * PI$1;
                  var ax = cos$1(a) * w;
                  var ay = sin$1(a) * w;

                  this._vSet(px - dlx * ax - dx * ay, py - dly * ax - dy * ay, 1);

                  this._vSet(px, py, 0);
                }

                this._vSet(px + dlx * w, py + dly * w, 1);

                this._vSet(px - dlx * w, py - dly * w, -1);
              },
              _roundCapEnd: function _roundCapEnd(p, dx, dy, w, nCap) {
                var px = p.x;
                var py = p.y;
                var dlx = dy;
                var dly = -dx;

                this._vSet(px + dlx * w, py + dly * w, 1);

                this._vSet(px - dlx * w, py - dly * w, -1);

                for (var _i8 = 0; _i8 < nCap; _i8++) {
                  var a = _i8 / (nCap - 1) * PI$1;
                  var ax = cos$1(a) * w;
                  var ay = sin$1(a) * w;

                  this._vSet(px, py, 0);

                  this._vSet(px - dlx * ax + dx * ay, py - dly * ax + dy * ay, 1);
                }
              },
              _roundJoin: function _roundJoin(p0, p1, lw, rw, nCap) {
                var dlx0 = p0.dy;
                var dly0 = -p0.dx;
                var dlx1 = p1.dy;
                var dly1 = -p1.dx;
                var p1x = p1.x;
                var p1y = p1.y;

                if ((p1.flags & PointFlags.PT_LEFT) !== 0) {
                  var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);

                  var lx0 = out[0];
                  var ly0 = out[1];
                  var lx1 = out[2];
                  var ly1 = out[3];
                  var a0 = atan2(-dly0, -dlx0);
                  var a1 = atan2(-dly1, -dlx1);

                  if (a1 > a0) {
                    a1 -= PI$1 * 2;
                  }

                  this._vSet(lx0, ly0, 1);

                  this._vSet(p1x - dlx0 * rw, p1.y - dly0 * rw, -1);

                  var n = clamp(ceil((a0 - a1) / PI$1) * nCap, 2, nCap);

                  for (var _i9 = 0; _i9 < n; _i9++) {
                    var u = _i9 / (n - 1);
                    var a = a0 + u * (a1 - a0);
                    var rx = p1x + cos$1(a) * rw;
                    var ry = p1y + sin$1(a) * rw;

                    this._vSet(p1x, p1y, 0);

                    this._vSet(rx, ry, -1);
                  }

                  this._vSet(lx1, ly1, 1);

                  this._vSet(p1x - dlx1 * rw, p1y - dly1 * rw, -1);
                } else {
                  var _out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);

                  var rx0 = _out[0];
                  var ry0 = _out[1];
                  var rx1 = _out[2];
                  var ry1 = _out[3];

                  var _a = atan2(dly0, dlx0);

                  var _a2 = atan2(dly1, dlx1);

                  if (_a2 < _a) {
                    _a2 += PI$1 * 2;
                  }

                  this._vSet(p1x + dlx0 * rw, p1y + dly0 * rw, 1);

                  this._vSet(rx0, ry0, -1);

                  var _n = clamp(ceil((_a2 - _a) / PI$1) * nCap, 2, nCap);

                  for (var _i10 = 0; _i10 < _n; _i10++) {
                    var _u = _i10 / (_n - 1);

                    var _a3 = _a + _u * (_a2 - _a);

                    var lx = p1x + cos$1(_a3) * lw;
                    var ly = p1y + sin$1(_a3) * lw;

                    this._vSet(lx, ly, 1);

                    this._vSet(p1x, p1y, 0);
                  }

                  this._vSet(p1x + dlx1 * rw, p1y + dly1 * rw, 1);

                  this._vSet(rx1, ry1, -1);
                }
              },
              _bevelJoin: function _bevelJoin(p0, p1, lw, rw) {
                var rx0 = 0;
                var ry0 = 0;
                var rx1 = 0;
                var ry1 = 0;
                var lx0 = 0;
                var ly0 = 0;
                var lx1 = 0;
                var ly1 = 0;
                var dlx0 = p0.dy;
                var dly0 = -p0.dx;
                var dlx1 = p1.dy;
                var dly1 = -p1.dx;

                if (p1.flags & PointFlags.PT_LEFT) {
                  var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);

                  lx0 = out[0];
                  ly0 = out[1];
                  lx1 = out[2];
                  ly1 = out[3];

                  this._vSet(lx0, ly0, 1);

                  this._vSet(p1.x - dlx0 * rw, p1.y - dly0 * rw, -1);

                  this._vSet(lx1, ly1, 1);

                  this._vSet(p1.x - dlx1 * rw, p1.y - dly1 * rw, -1);
                } else {
                  var _out2 = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);

                  rx0 = _out2[0];
                  ry0 = _out2[1];
                  rx1 = _out2[2];
                  ry1 = _out2[3];

                  this._vSet(p1.x + dlx0 * lw, p1.y + dly0 * lw, 1);

                  this._vSet(rx0, ry0, -1);

                  this._vSet(p1.x + dlx1 * lw, p1.y + dly1 * lw, 1);

                  this._vSet(rx1, ry1, -1);
                }
              },
              _vSet: function _vSet(x, y, distance) {
                if (distance === void 0) {
                  distance = 0;
                }

                if (!_renderData) {
                  return;
                }

                var meshBuffer = _renderData;
                var dataOffset = meshBuffer.vertexStart * attrBytes;
                var vData = meshBuffer.vData;
                vData[dataOffset++] = x;
                vData[dataOffset++] = y;
                vData[dataOffset++] = 0;
                Color$1.toArray(vData, _curColor, dataOffset);
                dataOffset += 4;
                vData[dataOffset++] = distance;
                meshBuffer.vertexStart++;
              }
            };

            var graphicsAssemblerManager = exports('graphicsAssembler', {
              getAssembler: function getAssembler(sprite) {
                return graphicsAssembler;
              }
            });
            Graphics.Assembler = graphicsAssemblerManager;

            var LetterInfo = function LetterInfo() {
              this["char"] = '';
              this.valid = true;
              this.x = 0;
              this.y = 0;
              this.line = 0;
              this.hash = '';
            };

            var _tmpRect = new Rect$1();

            var _defaultLetterAtlas = new LetterAtlas(64, 64);

            var _defaultFontAtlas = new FontAtlas(null);

            var _comp = null;
            var _uiTrans = null;
            var _horizontalKerning = [];
            var _lettersInfo = [];
            var _linesWidth = [];
            var _linesOffsetX = [];

            var _labelDimensions = new Size$1();

            var _contentSize = new Size$1();

            var letterPosition = new Vec2();
            var _lineSpacing = 0;
            var _fntConfig = null;
            var _numberOfLines = 0;
            var _textDesiredHeight = 0;
            var _letterOffsetY = 0;
            var _tailoredTopY = 0;
            var _tailoredBottomY = 0;
            var _bmfontScale = 1.0;
            var _spriteFrame = null;
            var _string = '';
            var _fontSize = 0;
            var _originFontSize = 0;
            var _hAlign = 0;
            var _vAlign = 0;
            var _spacingX = 0;
            var _lineHeight = 0;
            var _overflow = 0;
            var _isWrapText = false;
            var _labelWidth = 0;
            var _labelHeight = 0;
            var _maxLineWidth = 0;
            var QUAD_INDICES;
            var bmfontUtils = {
              updateRenderData: function updateRenderData(comp) {
                if (!comp.renderData) {
                  return;
                }

                if (_comp === comp) {
                  return;
                }

                if (comp.renderData.vertDirty) {
                  _comp = comp;
                  _uiTrans = _comp.node._uiProps.uiTransformComp;

                  this._updateFontFamily(comp);

                  this._updateProperties(comp);

                  this._updateLabelInfo(comp);

                  this._updateContent();

                  _comp.actualFontSize = _fontSize;

                  _uiTrans.setContentSize(_contentSize);

                  this.updateUVs(comp);
                  this.updateColor(comp);
                  _comp.renderData.vertDirty = false;
                  _comp = null;

                  this._resetProperties();
                }

                if (comp.spriteFrame) {
                  var renderData = comp.renderData;
                  renderData.updateRenderData(comp, comp.spriteFrame);
                }
              },
              updateUVs: function updateUVs(label) {
                var renderData = label.renderData;
                var vData = renderData.chunk.vb;
                var vertexCount = renderData.vertexCount;
                var dataList = renderData.data;
                var vertexOffset = 3;

                for (var i = 0; i < vertexCount; i++) {
                  var vert = dataList[i];
                  vData[vertexOffset] = vert.u;
                  vData[vertexOffset + 1] = vert.v;
                  vertexOffset += 9;
                }
              },
              updateColor: function updateColor(label) {
              },
              _updateFontScale: function _updateFontScale() {
                _bmfontScale = _fontSize / _originFontSize;
              },
              _updateFontFamily: function _updateFontFamily(comp) {
                var fontAsset = comp.font;
                _spriteFrame = fontAsset.spriteFrame;
                _fntConfig = fontAsset.fntConfig;
                shareLabelInfo.fontAtlas = fontAsset.fontDefDictionary;

                if (!shareLabelInfo.fontAtlas) {
                  if (comp.cacheMode === CacheMode.CHAR) {
                    shareLabelInfo.fontAtlas = _defaultLetterAtlas;
                  } else {
                    shareLabelInfo.fontAtlas = _defaultFontAtlas;
                  }
                }

                dynamicAtlasManager.packToDynamicAtlas(comp, _spriteFrame);
              },
              _updateLabelInfo: function _updateLabelInfo(comp) {
                shareLabelInfo.hash = '';
                shareLabelInfo.margin = 0;
              },
              _updateProperties: function _updateProperties(comp) {
                _string = comp.string.toString();
                _fontSize = comp.fontSize;
                _originFontSize = _fntConfig ? _fntConfig.fontSize : comp.fontSize;
                _hAlign = comp.horizontalAlign;
                _vAlign = comp.verticalAlign;
                _spacingX = comp.spacingX;
                _overflow = comp.overflow;
                _lineHeight = comp._lineHeight;
                var contentSize = _uiTrans.contentSize;
                _contentSize.width = contentSize.width;
                _contentSize.height = contentSize.height;

                if (_overflow === Overflow.NONE) {
                  _isWrapText = false;
                  _contentSize.width += shareLabelInfo.margin * 2;
                  _contentSize.height += shareLabelInfo.margin * 2;
                } else if (_overflow === Overflow.RESIZE_HEIGHT) {
                  _isWrapText = true;
                  _contentSize.height += shareLabelInfo.margin * 2;
                } else {
                  _isWrapText = comp.enableWrapText;
                }

                shareLabelInfo.lineHeight = _lineHeight;
                shareLabelInfo.fontSize = _fontSize;

                this._setupBMFontOverflowMetrics();
              },
              _resetProperties: function _resetProperties() {
                _fntConfig = null;
                _spriteFrame = null;
                shareLabelInfo.hash = '';
                shareLabelInfo.margin = 0;
              },
              _updateContent: function _updateContent() {
                this._updateFontScale();

                this._computeHorizontalKerningForText();

                this._alignText();
              },
              _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {
                var string = _string;
                var stringLen = string.length;
                var kerningDict = _fntConfig.kerningDict;
                var horizontalKerning = _horizontalKerning;

                if (!kerningDict) {
                  return;
                }

                var prev = -1;

                for (var i = 0; i < stringLen; ++i) {
                  var key = string.charCodeAt(i);
                  var kerningAmount = kerningDict[prev << 16 | key & 0xffff] || 0;

                  if (i < stringLen - 1) {
                    horizontalKerning[i] = kerningAmount;
                  } else {
                    horizontalKerning[i] = 0;
                  }

                  prev = key;
                }
              },
              _multilineTextWrap: function _multilineTextWrap(nextTokenFunc) {
                var textLen = _string.length;
                var lineIndex = 0;
                var nextTokenX = 0;
                var nextTokenY = 0;
                var longestLine = 0;
                var letterRight = 0;
                var highestY = 0;
                var lowestY = 0;
                var letterDef = null;

                for (var index = 0; index < textLen;) {
                  var character = _string.charAt(index);

                  if (character === '\n') {
                    _linesWidth.push(letterRight);

                    letterRight = 0;
                    lineIndex++;
                    nextTokenX = 0;
                    nextTokenY -= _lineHeight * this._getFontScale() + _lineSpacing;

                    this._recordPlaceholderInfo(index, character);

                    index++;
                    continue;
                  }

                  var tokenLen = nextTokenFunc(_string, index, textLen);
                  var tokenHighestY = highestY;
                  var tokenLowestY = lowestY;
                  var tokenRight = letterRight;
                  var nextLetterX = nextTokenX;
                  var newLine = false;

                  for (var tmp = 0; tmp < tokenLen; ++tmp) {
                    var letterIndex = index + tmp;
                    character = _string.charAt(letterIndex);

                    if (character === '\r') {
                      this._recordPlaceholderInfo(letterIndex, character);

                      continue;
                    }

                    letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);

                    if (!letterDef) {
                      this._recordPlaceholderInfo(letterIndex, character);

                      console.log("Can't find letter definition in texture atlas " + _fntConfig.atlasName + " for letter:" + character);
                      continue;
                    }

                    var letterX = nextLetterX + letterDef.offsetX * _bmfontScale - shareLabelInfo.margin;

                    if (_isWrapText && _maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef.w * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character)) {
                      _linesWidth.push(letterRight);

                      letterRight = 0;
                      lineIndex++;
                      nextTokenX = 0;
                      nextTokenY -= _lineHeight * this._getFontScale() + _lineSpacing;
                      newLine = true;
                      break;
                    } else {
                      letterPosition.x = letterX;
                    }

                    letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale;

                    this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex);

                    if (letterIndex + 1 < _horizontalKerning.length && letterIndex < textLen - 1) {
                      nextLetterX += _horizontalKerning[letterIndex + 1] * _bmfontScale;
                    }

                    nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX;
                    tokenRight = letterPosition.x + letterDef.w * _bmfontScale;

                    if (tokenHighestY < letterPosition.y) {
                      tokenHighestY = letterPosition.y;
                    }

                    if (tokenLowestY > letterPosition.y - letterDef.h * _bmfontScale) {
                      tokenLowestY = letterPosition.y - letterDef.h * _bmfontScale;
                    }
                  }

                  if (newLine) {
                    continue;
                  }

                  nextTokenX = nextLetterX;
                  letterRight = tokenRight;

                  if (highestY < tokenHighestY) {
                    highestY = tokenHighestY;
                  }

                  if (lowestY > tokenLowestY) {
                    lowestY = tokenLowestY;
                  }

                  if (longestLine < letterRight) {
                    longestLine = letterRight;
                  }

                  index += tokenLen;
                }

                _linesWidth.push(letterRight);

                _numberOfLines = lineIndex + 1;
                _textDesiredHeight = _numberOfLines * _lineHeight * this._getFontScale();

                if (_numberOfLines > 1) {
                  _textDesiredHeight += (_numberOfLines - 1) * _lineSpacing;
                }

                _contentSize.width = _labelWidth;
                _contentSize.height = _labelHeight;

                if (_labelWidth <= 0) {
                  _contentSize.width = parseFloat(longestLine.toFixed(2)) + shareLabelInfo.margin * 2;
                }

                if (_labelHeight <= 0) {
                  _contentSize.height = parseFloat(_textDesiredHeight.toFixed(2)) + shareLabelInfo.margin * 2;
                }

                _tailoredTopY = _contentSize.height;
                _tailoredBottomY = 0;

                if (highestY > 0) {
                  _tailoredTopY = _contentSize.height + highestY;
                }

                if (lowestY < -_textDesiredHeight) {
                  _tailoredBottomY = _textDesiredHeight + lowestY;
                }

                return true;
              },
              _getFirstCharLen: function _getFirstCharLen() {
                return 1;
              },
              _getFontScale: function _getFontScale() {
                return _overflow === Overflow.SHRINK ? _bmfontScale : 1;
              },
              _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
                var character = text.charAt(startIndex);

                if (isUnicodeCJK(character) || character === '\n' || isUnicodeSpace(character)) {
                  return 1;
                }

                var len = 1;
                var letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);

                if (!letterDef) {
                  return len;
                }

                var nextLetterX = letterDef.xAdvance * _bmfontScale + _spacingX;
                var letterX = 0;

                for (var index = startIndex + 1; index < textLen; ++index) {
                  character = text.charAt(index);
                  letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);

                  if (!letterDef) {
                    break;
                  }

                  letterX = nextLetterX + letterDef.offsetX * _bmfontScale;

                  if (letterX + letterDef.w * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character) && _maxLineWidth > 0) {
                    return len;
                  }

                  nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX;

                  if (character === '\n' || isUnicodeSpace(character) || isUnicodeCJK(character)) {
                    break;
                  }

                  len++;
                }

                return len;
              },
              _multilineTextWrapByWord: function _multilineTextWrapByWord() {
                return this._multilineTextWrap(this._getFirstWordLen);
              },
              _multilineTextWrapByChar: function _multilineTextWrapByChar() {
                return this._multilineTextWrap(this._getFirstCharLen);
              },
              _recordPlaceholderInfo: function _recordPlaceholderInfo(letterIndex, _char) {
                if (letterIndex >= _lettersInfo.length) {
                  var tmpInfo = new LetterInfo();

                  _lettersInfo.push(tmpInfo);
                }

                _lettersInfo[letterIndex]["char"] = _char;
                _lettersInfo[letterIndex].hash = "" + _char.charCodeAt(0) + shareLabelInfo.hash;
                _lettersInfo[letterIndex].valid = false;
              },
              _recordLetterInfo: function _recordLetterInfo(letterPosition, character, letterIndex, lineIndex) {
                if (letterIndex >= _lettersInfo.length) {
                  var tmpInfo = new LetterInfo();

                  _lettersInfo.push(tmpInfo);
                }

                var _char2 = character.charCodeAt(0);

                var key = "" + _char2 + shareLabelInfo.hash;
                _lettersInfo[letterIndex].line = lineIndex;
                _lettersInfo[letterIndex]["char"] = character;
                _lettersInfo[letterIndex].hash = key;
                _lettersInfo[letterIndex].valid = shareLabelInfo.fontAtlas.getLetter(key).valid;
                _lettersInfo[letterIndex].x = letterPosition.x;
                _lettersInfo[letterIndex].y = letterPosition.y;
              },
              _alignText: function _alignText() {
                _textDesiredHeight = 0;
                _linesWidth.length = 0;

                {
                  this._multilineTextWrapByWord();
                }

                this._computeAlignmentOffset();

                if (_overflow === Overflow.SHRINK) {
                  if (_fontSize > 0 && this._isVerticalClamp()) {
                    this._shrinkLabelToContentSize(this._isVerticalClamp);
                  }
                }

                if (!this._updateQuads()) {
                  if (_overflow === Overflow.SHRINK) {
                    this._shrinkLabelToContentSize(this._isHorizontalClamp);
                  }
                }
              },
              _scaleFontSizeDown: function _scaleFontSizeDown(fontSize) {
                var shouldUpdateContent = true;

                if (!fontSize) {
                  fontSize = 0.1;
                  shouldUpdateContent = false;
                }

                _fontSize = fontSize;

                if (shouldUpdateContent) {
                  this._updateContent();
                }
              },
              _shrinkLabelToContentSize: function _shrinkLabelToContentSize(lambda) {
                var fontSize = _fontSize;
                var left = 0;
                var right = fontSize | 0;
                var mid = 0;

                while (left < right) {
                  mid = left + right + 1 >> 1;
                  var newFontSize = mid;

                  if (newFontSize <= 0) {
                    break;
                  }

                  _bmfontScale = newFontSize / _originFontSize;

                  {
                    this._multilineTextWrapByWord();
                  }

                  this._computeAlignmentOffset();

                  if (lambda()) {
                    right = mid - 1;
                  } else {
                    left = mid;
                  }
                }

                if (left >= 0) {
                  this._scaleFontSizeDown(left);
                }
              },
              _isVerticalClamp: function _isVerticalClamp() {
                if (_textDesiredHeight > _contentSize.height) {
                  return true;
                } else {
                  return false;
                }
              },
              _isHorizontalClamp: function _isHorizontalClamp() {
                var letterClamp = false;

                for (var ctr = 0, l = _string.length; ctr < l; ++ctr) {
                  var letterInfo = _lettersInfo[ctr];

                  if (letterInfo.valid) {
                    var letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(letterInfo["char"], shareLabelInfo);

                    if (!letterDef) {
                      continue;
                    }

                    var px = letterInfo.x + letterDef.w * _bmfontScale;
                    var lineIndex = letterInfo.line;

                    if (_labelWidth > 0) {
                      if (!_isWrapText) {
                        if (px > _contentSize.width) {
                          letterClamp = true;
                          break;
                        }
                      } else {
                        var wordWidth = _linesWidth[lineIndex];

                        if (wordWidth > _contentSize.width && (px > _contentSize.width || px < 0)) {
                          letterClamp = true;
                          break;
                        }
                      }
                    }
                  }
                }

                return letterClamp;
              },
              _isHorizontalClamped: function _isHorizontalClamped(px, lineIndex) {
                var wordWidth = _linesWidth[lineIndex];
                var letterOverClamp = px > _contentSize.width || px < 0;

                if (!_isWrapText) {
                  return letterOverClamp;
                } else {
                  return wordWidth > _contentSize.width && letterOverClamp;
                }
              },
              _updateQuads: function _updateQuads() {
                if (!_comp) {
                  return false;
                }

                var texture = _spriteFrame ? _spriteFrame.texture : shareLabelInfo.fontAtlas.getTexture();
                var renderData = _comp.renderData;
                renderData.dataLength = 0;
                renderData.resize(0, 0);
                var anchorPoint = _uiTrans.anchorPoint;
                var contentSize = _contentSize;
                var appX = anchorPoint.x * contentSize.width;
                var appY = anchorPoint.y * contentSize.height;
                var ret = true;

                for (var ctr = 0, l = _string.length; ctr < l; ++ctr) {
                  var letterInfo = _lettersInfo[ctr];

                  if (!letterInfo.valid) {
                    continue;
                  }

                  var letterDef = shareLabelInfo.fontAtlas.getLetter(letterInfo.hash);

                  if (!letterDef) {
                    console.warn('Can\'t find letter in this bitmap-font');
                    continue;
                  }

                  _tmpRect.height = letterDef.h;
                  _tmpRect.width = letterDef.w;
                  _tmpRect.x = letterDef.u;
                  _tmpRect.y = letterDef.v;
                  var py = letterInfo.y + _letterOffsetY;

                  if (_labelHeight > 0) {
                    if (py > _tailoredTopY) {
                      var clipTop = py - _tailoredTopY;
                      _tmpRect.y += clipTop;
                      _tmpRect.height -= clipTop;
                      py -= clipTop;
                    }

                    if (py - _tmpRect.height * _bmfontScale < _tailoredBottomY && _overflow === Overflow.CLAMP) {
                      _tmpRect.height = py < _tailoredBottomY ? 0 : (py - _tailoredBottomY) / _bmfontScale;
                    }
                  }

                  var lineIndex = letterInfo.line;
                  var px = letterInfo.x + letterDef.w / 2 * _bmfontScale + _linesOffsetX[lineIndex];

                  if (_labelWidth > 0) {
                    if (this._isHorizontalClamped(px, lineIndex)) {
                      if (_overflow === Overflow.CLAMP) {
                        _tmpRect.width = 0;
                      } else if (_overflow === Overflow.SHRINK) {
                        if (_contentSize.width > letterDef.w) {
                          ret = false;
                          break;
                        } else {
                          _tmpRect.width = 0;
                        }
                      }
                    }
                  }

                  if (_tmpRect.height > 0 && _tmpRect.width > 0) {
                    var isRotated = this._determineRect();

                    var letterPositionX = letterInfo.x + _linesOffsetX[letterInfo.line];
                    this.appendQuad(_comp, texture, _tmpRect, isRotated, letterPositionX - appX, py - appY, _bmfontScale);
                  }
                }

                var indexCount = renderData.indexCount;
                this.createQuadIndices(indexCount);
                renderData.chunk.setIndexBuffer(QUAD_INDICES);
                return ret;
              },
              createQuadIndices: function createQuadIndices(indexCount) {
                if (indexCount % 6 !== 0) {
                  console.error('illegal index count!');
                  return;
                }

                var quadCount = indexCount / 6;
                QUAD_INDICES = null;
                QUAD_INDICES = new Uint16Array(indexCount);
                var offset = 0;

                for (var i = 0; i < quadCount; i++) {
                  QUAD_INDICES[offset++] = 0 + i * 4;
                  QUAD_INDICES[offset++] = 1 + i * 4;
                  QUAD_INDICES[offset++] = 2 + i * 4;
                  QUAD_INDICES[offset++] = 1 + i * 4;
                  QUAD_INDICES[offset++] = 3 + i * 4;
                  QUAD_INDICES[offset++] = 2 + i * 4;
                }
              },
              appendQuad: function appendQuad(comp, texture, rect, rotated, x, y, scale) {},
              _determineRect: function _determineRect() {
                var isRotated = _spriteFrame.isRotated();

                var originalSize = _spriteFrame.getOriginalSize();

                var rect = _spriteFrame.getRect();

                var offset = _spriteFrame.getOffset();

                var trimmedLeft = offset.x + (originalSize.width - rect.width) / 2;
                var trimmedTop = offset.y - (originalSize.height - rect.height) / 2;

                if (!isRotated) {
                  _tmpRect.x += rect.x - trimmedLeft;
                  _tmpRect.y += rect.y + trimmedTop;
                } else {
                  var originalX = _tmpRect.x;
                  _tmpRect.x = rect.x + rect.height - _tmpRect.y - _tmpRect.height - trimmedTop;
                  _tmpRect.y = originalX + rect.y - trimmedLeft;

                  if (_tmpRect.y < 0) {
                    _tmpRect.height += trimmedTop;
                  }
                }

                return isRotated;
              },
              _computeAlignmentOffset: function _computeAlignmentOffset() {
                _linesOffsetX.length = 0;

                switch (_hAlign) {
                  case HorizontalTextAlignment.LEFT:
                    for (var i = 0; i < _numberOfLines; ++i) {
                      _linesOffsetX.push(0);
                    }

                    break;

                  case HorizontalTextAlignment.CENTER:
                    for (var _i = 0, l = _linesWidth.length; _i < l; _i++) {
                      _linesOffsetX.push((_contentSize.width - _linesWidth[_i]) / 2);
                    }

                    break;

                  case HorizontalTextAlignment.RIGHT:
                    for (var _i2 = 0, _l = _linesWidth.length; _i2 < _l; _i2++) {
                      _linesOffsetX.push(_contentSize.width - _linesWidth[_i2]);
                    }

                    break;
                }

                _letterOffsetY = _contentSize.height;

                if (_vAlign !== VerticalTextAlignment.TOP) {
                  var blank = _contentSize.height - _textDesiredHeight + _lineHeight * this._getFontScale() - _originFontSize * _bmfontScale;

                  if (_vAlign === VerticalTextAlignment.BOTTOM) {
                    _letterOffsetY -= blank;
                  } else {
                    _letterOffsetY -= blank / 2;
                  }
                }
              },
              _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
                var newWidth = _contentSize.width;
                var newHeight = _contentSize.height;

                if (_overflow === Overflow.RESIZE_HEIGHT) {
                  newHeight = 0;
                }

                if (_overflow === Overflow.NONE) {
                  newWidth = 0;
                  newHeight = 0;
                }

                _labelWidth = newWidth;
                _labelHeight = newHeight;
                _labelDimensions.width = newWidth;
                _labelDimensions.height = newHeight;
                _maxLineWidth = newWidth;
              }
            };

            var tempColor$1 = new Color$1(255, 255, 255, 255);
            var bmfont = {
              createData: function createData(comp) {
                var renderData = comp.requestRenderData();
                renderData.resize(0, 0);
                return renderData;
              },
              fillBuffers: function fillBuffers(comp, renderer) {
                var node = comp.node;
                tempColor$1.set(comp.color);
                tempColor$1.a = node._uiProps.opacity * 255;
                fillMeshVertices3D(node, renderer, comp.renderData, tempColor$1);
              },
              appendQuad: function appendQuad(comp, spriteFrame, rect, rotated, x, y, scale) {
                var renderData = comp.renderData;

                if (!renderData) {
                  return;
                }

                var dataOffset = renderData.dataLength;
                renderData.dataLength += 4;
                renderData.resize(renderData.dataLength, renderData.dataLength / 2 * 3);
                var dataList = renderData.data;
                var texW = spriteFrame.width;
                var texH = spriteFrame.height;
                var rectWidth = rect.width;
                var rectHeight = rect.height;
                var l = 0;
                var b = 0;
                var t = 0;
                var r = 0;

                if (!rotated) {
                  l = rect.x / texW;
                  r = (rect.x + rectWidth) / texW;
                  b = (rect.y + rectHeight) / texH;
                  t = rect.y / texH;
                  dataList[dataOffset].u = l;
                  dataList[dataOffset].v = b;
                  dataList[dataOffset + 1].u = r;
                  dataList[dataOffset + 1].v = b;
                  dataList[dataOffset + 2].u = l;
                  dataList[dataOffset + 2].v = t;
                  dataList[dataOffset + 3].u = r;
                  dataList[dataOffset + 3].v = t;
                } else {
                  l = rect.x / texW;
                  r = (rect.x + rectHeight) / texW;
                  b = (rect.y + rectWidth) / texH;
                  t = rect.y / texH;
                  dataList[dataOffset].u = l;
                  dataList[dataOffset].v = t;
                  dataList[dataOffset + 1].u = l;
                  dataList[dataOffset + 1].v = b;
                  dataList[dataOffset + 2].u = r;
                  dataList[dataOffset + 2].v = t;
                  dataList[dataOffset + 3].u = r;
                  dataList[dataOffset + 3].v = b;
                }

                dataList[dataOffset].x = x;
                dataList[dataOffset].y = y - rectHeight * scale;
                dataList[dataOffset + 1].x = x + rectWidth * scale;
                dataList[dataOffset + 1].y = y - rectHeight * scale;
                dataList[dataOffset + 2].x = x;
                dataList[dataOffset + 2].y = y;
                dataList[dataOffset + 3].x = x + rectWidth * scale;
                dataList[dataOffset + 3].y = y;
              }
            };
            addon(bmfont, bmfontUtils);

            var _atlasWidth = 1024;
            var _atlasHeight = 1024;
            var _shareAtlas = null;
            var letterFont = mixin(bmfontUtils, {
              getAssemblerData: function getAssemblerData() {
                if (!_shareAtlas) {
                  _shareAtlas = new LetterAtlas(_atlasWidth, _atlasHeight);
                }

                return _shareAtlas.getTexture();
              },
              _updateFontFamily: function _updateFontFamily(comp) {
                shareLabelInfo.fontAtlas = _shareAtlas;
                shareLabelInfo.fontFamily = this._getFontFamily(comp);
                var outline = comp.getComponent(LabelOutline);

                if (outline && outline.enabled) {
                  shareLabelInfo.isOutlined = true;
                  shareLabelInfo.margin = outline.width;
                  shareLabelInfo.out = outline.color.clone();
                  shareLabelInfo.out.a = outline.color.a * comp.color.a / 255.0;
                } else {
                  shareLabelInfo.isOutlined = false;
                  shareLabelInfo.margin = 0;
                }
              },
              _getFontFamily: function _getFontFamily(comp) {
                var fontFamily = 'Arial';

                if (!comp.useSystemFont) {
                  if (comp.font) {
                    fontFamily = comp.font._nativeAsset || 'Arial';
                  }
                } else {
                  fontFamily = comp.fontFamily || 'Arial';
                }

                return fontFamily;
              },
              _updateLabelInfo: function _updateLabelInfo(comp) {
                shareLabelInfo.fontDesc = this._getFontDesc();
                shareLabelInfo.color = comp.color;
                shareLabelInfo.hash = computeHash(shareLabelInfo);
              },
              _getFontDesc: function _getFontDesc() {
                var fontDesc = shareLabelInfo.fontSize.toString() + "px ";
                fontDesc += shareLabelInfo.fontFamily;

                return fontDesc;
              },
              _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {},
              _determineRect: function _determineRect(tempRect) {
                return false;
              }
            });

            var tempColor$2 = new Color$1(255, 255, 255, 255);
            var letter = {
              createData: function createData(comp) {
                var renderData = comp.requestRenderData();
                renderData.resize(0, 0);
                return renderData;
              },
              fillBuffers: function fillBuffers(comp, renderer) {
                if (!comp.renderData) {
                  return;
                }

                var node = comp.node;
                tempColor$2.a = node._uiProps.opacity * 255;
                fillMeshVertices3D(node, renderer, comp.renderData, tempColor$2);
              },
              appendQuad: bmfont.appendQuad,
              updateColor: function updateColor(label) {
              }
            };
            addon(letter, letterFont);

            var Overflow$1 = Label.Overflow;
            var MAX_SIZE = 2048;

            var _BASELINE_OFFSET$1 = getBaselineOffset();

            var _invisibleAlpha = (1 / 255).toFixed(3);

            var _context = null;
            var _canvas = null;
            var _texture = null;
            var _fontDesc = '';
            var _string$1 = '';
            var _fontSize$1 = 0;
            var _drawFontsize = 0;
            var _splitStrings = [];

            var _canvasSize = new Size$1();

            var _lineHeight$1 = 0;
            var _hAlign$1 = 0;
            var _vAlign$1 = 0;

            var _color = new Color$1();

            var _alpha = 1;
            var _fontFamily = '';
            var _overflow$1 = Overflow$1.NONE;
            var _isWrapText$1 = false;
            var _outlineComp = null;

            var _outlineColor = Color$1.BLACK.clone();

            var _shadowComp = null;

            var _shadowColor = Color$1.BLACK.clone();

            var _canvasPadding = new Rect$1();

            var _contentSizeExtend = Size$1.ZERO.clone();

            var _nodeContentSize = Size$1.ZERO.clone();

            var _startPosition = Vec2.ZERO.clone();

            var _drawUnderlinePos = Vec2.ZERO.clone();

            var _drawUnderlineWidth = 0;
            var _underlineThickness = 0;
            var _isBold = false;
            var _isItalic = false;
            var _isUnderline = false;
            var Alignment = ['left', 'center', 'right'];
            var ttfUtils = {
              getAssemblerData: function getAssemblerData() {
                var sharedLabelData = Label._canvasPool.get();

                sharedLabelData.canvas.width = sharedLabelData.canvas.height = 1;
                return sharedLabelData;
              },
              resetAssemblerData: function resetAssemblerData(assemblerData) {
                if (assemblerData) {
                  Label._canvasPool.put(assemblerData);
                }
              },
              updateRenderData: function updateRenderData(comp) {
                if (!comp.renderData) {
                  return;
                }

                if (comp.renderData.vertDirty) {
                  var trans = comp.node._uiProps.uiTransformComp;

                  this._updateFontFamily(comp);

                  this._updateProperties(comp, trans);

                  this._calculateLabelFont();

                  this._updateLabelDimensions();

                  this._updateTexture(comp);

                  this._calDynamicAtlas(comp);

                  comp.actualFontSize = _fontSize$1;
                  trans.setContentSize(_canvasSize);
                  this.updateVertexData(comp);
                  this.updateUVs(comp);
                  comp.renderData.vertDirty = false;
                  comp.contentWidth = _nodeContentSize.width;
                  _context = null;
                  _canvas = null;
                  _texture = null;
                }

                if (comp.spriteFrame) {
                  var renderData = comp.renderData;
                  renderData.updateRenderData(comp, comp.spriteFrame);
                }
              },
              updateVertexData: function updateVertexData(comp) {},
              updateUVs: function updateUVs(comp) {},
              _updateFontFamily: function _updateFontFamily(comp) {
                if (!comp.useSystemFont) {
                  if (comp.font) {
                    _fontFamily = comp.font._nativeAsset || 'Arial';
                  } else {
                    _fontFamily = 'Arial';
                  }
                } else {
                  _fontFamily = comp.fontFamily || 'Arial';
                }
              },
              _updateProperties: function _updateProperties(comp, trans) {
                var assemblerData = comp.assemblerData;

                if (!assemblerData) {
                  return;
                }

                _context = assemblerData.context;
                _canvas = assemblerData.canvas;
                _texture = comp.spriteFrame;
                _string$1 = comp.string.toString();
                _fontSize$1 = comp.fontSize;
                _drawFontsize = _fontSize$1;
                _overflow$1 = comp.overflow;
                _nodeContentSize.width = _canvasSize.width = trans.width;
                _nodeContentSize.height = _canvasSize.height = trans.height;
                _underlineThickness = comp.underlineHeight;
                _lineHeight$1 = comp.lineHeight;
                _hAlign$1 = comp.horizontalAlign;
                _vAlign$1 = comp.verticalAlign;
                _color = comp.color;
                _alpha = comp.node._uiProps.opacity;
                _isBold = comp.isBold;
                _isItalic = comp.isItalic;
                _isUnderline = comp.isUnderline;

                if (_overflow$1 === Overflow$1.NONE) {
                  _isWrapText$1 = false;
                } else if (_overflow$1 === Overflow$1.RESIZE_HEIGHT) {
                  _isWrapText$1 = true;
                } else {
                  _isWrapText$1 = comp.enableWrapText;
                }

                _outlineComp = LabelOutline && comp.getComponent(LabelOutline);
                _outlineComp = _outlineComp && _outlineComp.enabled && _outlineComp.width > 0 ? _outlineComp : null;

                if (_outlineComp) {
                  _outlineColor.set(_outlineComp.color);
                }

                _shadowComp = LabelShadow && comp.getComponent(LabelShadow);
                _shadowComp = _shadowComp && _shadowComp.enabled ? _shadowComp : null;

                if (_shadowComp) {
                  _shadowColor.set(_shadowComp.color);
                }

                this._updatePaddingRect();
              },
              _updatePaddingRect: function _updatePaddingRect() {
                var top = 0;
                var bottom = 0;
                var left = 0;
                var right = 0;
                var outlineWidth = 0;
                _contentSizeExtend.width = _contentSizeExtend.height = 0;

                if (_outlineComp) {
                  outlineWidth = _outlineComp.width;
                  top = bottom = left = right = outlineWidth;
                  _contentSizeExtend.width = _contentSizeExtend.height = outlineWidth * 2;
                }

                if (_shadowComp) {
                  var shadowWidth = _shadowComp.blur + outlineWidth;
                  var offsetX = _shadowComp.offset.x;
                  var offsetY = _shadowComp.offset.y;
                  left = Math.max(left, -offsetX + shadowWidth);
                  right = Math.max(right, offsetX + shadowWidth);
                  top = Math.max(top, offsetY + shadowWidth);
                  bottom = Math.max(bottom, -offsetY + shadowWidth);
                }

                if (_isItalic) {
                  var offset = _drawFontsize * Math.tan(12 * 0.0174532925);

                  right += offset;
                  _contentSizeExtend.width += offset;
                }

                _canvasPadding.x = left;
                _canvasPadding.y = top;
                _canvasPadding.width = left + right;
                _canvasPadding.height = top + bottom;
              },
              _calculateFillTextStartPosition: function _calculateFillTextStartPosition() {
                var labelX = 0;

                if (_hAlign$1 === HorizontalTextAlignment.RIGHT) {
                  labelX = _canvasSize.width - _canvasPadding.width;
                } else if (_hAlign$1 === HorizontalTextAlignment.CENTER) {
                  labelX = (_canvasSize.width - _canvasPadding.width) / 2;
                }

                var lineHeight = this._getLineHeight();

                var drawStartY = lineHeight * (_splitStrings.length - 1);
                var firstLinelabelY = _fontSize$1 * (1 - BASELINE_RATIO / 2);

                if (_vAlign$1 !== VerticalTextAlignment.TOP) {
                  var blank = drawStartY + _canvasPadding.height + _fontSize$1 - _canvasSize.height;

                  if (_vAlign$1 === VerticalTextAlignment.BOTTOM) {
                    blank += BASELINE_RATIO / 2 * _fontSize$1;
                    firstLinelabelY -= blank;
                  } else {
                    firstLinelabelY -= blank / 2;
                  }
                }

                firstLinelabelY += _BASELINE_OFFSET$1 * _fontSize$1;

                _startPosition.set(labelX + _canvasPadding.x, firstLinelabelY + _canvasPadding.y);
              },
              _updateTexture: function _updateTexture(comp) {
                if (!_context || !_canvas) {
                  return;
                }

                _context.clearRect(0, 0, _canvas.width, _canvas.height);

                _context.font = _fontDesc;

                this._calculateFillTextStartPosition();

                var lineHeight = this._getLineHeight();

                _context.lineJoin = 'round';

                if (_outlineComp) {
                  _context.fillStyle = "rgba(" + _outlineColor.r + ", " + _outlineColor.g + ", " + _outlineColor.b + ", " + _invisibleAlpha + ")";

                  _context.fillRect(0, 0, _canvas.width, _canvas.height);
                } else if (comp._srcBlendFactor === BlendFactor.SRC_ALPHA) {
                  _context.fillStyle = "rgba(" + _color.r + ", " + _color.g + ", " + _color.b + ", " + _invisibleAlpha + ")";

                  _context.fillRect(0, 0, _canvas.width, _canvas.height);
                }

                _context.fillStyle = "rgb(" + _color.r + ", " + _color.g + ", " + _color.b + ")";
                var drawTextPosX = _startPosition.x;
                var drawTextPosY = 0;

                this._drawTextEffect(_startPosition, lineHeight);

                for (var i = 0; i < _splitStrings.length; ++i) {
                  drawTextPosY = _startPosition.y + i * lineHeight;

                  if (_outlineComp) {
                    _context.strokeText(_splitStrings[i], drawTextPosX, drawTextPosY);
                  }

                  _context.fillText(_splitStrings[i], drawTextPosX, drawTextPosY);
                }

                if (_shadowComp) {
                  _context.shadowColor = 'transparent';
                }

                this._uploadTexture(comp);
              },
              _uploadTexture: function _uploadTexture(comp) {
                if (comp.cacheMode === Label.CacheMode.BITMAP) {
                  var frame = comp.ttfSpriteFrame;
                  dynamicAtlasManager.deleteAtlasSpriteFrame(frame);

                  frame._resetDynamicAtlasFrame();
                }

                if (_texture && _canvas) {
                  var tex;

                  if (_texture instanceof SpriteFrame) {
                    tex = _texture.texture;
                  } else {
                    tex = _texture;
                  }

                  var uploadAgain = _canvas.width !== 0 && _canvas.height !== 0;

                  if (uploadAgain) {
                    tex.reset({
                      width: _canvas.width,
                      height: _canvas.height,
                      mipmapLevel: 1
                    });
                    tex.uploadData(_canvas);
                    tex.setWrapMode(WrapMode$1.CLAMP_TO_EDGE, WrapMode$1.CLAMP_TO_EDGE);

                    if (_texture instanceof SpriteFrame) {
                      _texture.rect = new Rect$1(0, 0, _canvas.width, _canvas.height);

                      _texture._calculateUV();
                    }

                    if (comp.renderData) {
                      comp.renderData.textureDirty = true;
                    }

                    if (legacyCC.director.root && legacyCC.director.root.batcher2D) {
                      {
                        legacyCC.director.root.batcher2D._releaseDescriptorSetCache(tex.getHash());
                      }
                    }
                  }
                }
              },
              _calDynamicAtlas: function _calDynamicAtlas(comp) {
                if (comp.cacheMode !== Label.CacheMode.BITMAP || !_canvas || _canvas.width <= 0 || _canvas.height <= 0) return;
                var frame = comp.ttfSpriteFrame;
                dynamicAtlasManager.packToDynamicAtlas(comp, frame);
              },
              _setupOutline: function _setupOutline() {
                _context.strokeStyle = "rgba(" + _outlineColor.r + ", " + _outlineColor.g + ", " + _outlineColor.b + ", " + _outlineColor.a / 255 + ")";
                _context.lineWidth = _outlineComp.width * 2;
              },
              _setupShadow: function _setupShadow() {
                _context.shadowColor = "rgba(" + _shadowColor.r + ", " + _shadowColor.g + ", " + _shadowColor.b + ", " + _shadowColor.a / 255 + ")";
                _context.shadowBlur = _shadowComp.blur;
                _context.shadowOffsetX = _shadowComp.offset.x;
                _context.shadowOffsetY = -_shadowComp.offset.y;
              },
              _drawTextEffect: function _drawTextEffect(startPosition, lineHeight) {
                if (!_shadowComp && !_outlineComp && !_isUnderline) return;
                var isMultiple = _splitStrings.length > 1 && _shadowComp;

                var measureText = this._measureText(_context, _fontDesc);

                var drawTextPosX = 0;
                var drawTextPosY = 0;

                if (_shadowComp) {
                  this._setupShadow();
                }

                if (_outlineComp) {
                  this._setupOutline();
                }

                for (var i = 0; i < _splitStrings.length; ++i) {
                  drawTextPosX = startPosition.x;
                  drawTextPosY = startPosition.y + i * lineHeight;

                  if (isMultiple) {
                    if (_outlineComp) {
                      _context.strokeText(_splitStrings[i], drawTextPosX, drawTextPosY);
                    }

                    _context.fillText(_splitStrings[i], drawTextPosX, drawTextPosY);
                  }

                  if (_isUnderline) {
                    _drawUnderlineWidth = measureText(_splitStrings[i]);

                    if (_hAlign$1 === HorizontalTextAlignment.RIGHT) {
                      _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth;
                    } else if (_hAlign$1 === HorizontalTextAlignment.CENTER) {
                      _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth / 2;
                    } else {
                      _drawUnderlinePos.x = startPosition.x;
                    }

                    _drawUnderlinePos.y = drawTextPosY + _drawFontsize / 8;

                    _context.fillRect(_drawUnderlinePos.x, _drawUnderlinePos.y, _drawUnderlineWidth, _underlineThickness);
                  }
                }

                if (isMultiple) {
                  _context.shadowColor = 'transparent';
                }
              },
              _updateLabelDimensions: function _updateLabelDimensions() {
                _canvasSize.width = Math.min(_canvasSize.width, MAX_SIZE);
                _canvasSize.height = Math.min(_canvasSize.height, MAX_SIZE);
                var recreate = false;

                if (_canvas.width !== _canvasSize.width) {
                  _canvas.width = _canvasSize.width;
                  recreate = true;
                }

                if (_canvas.height !== _canvasSize.height) {
                  _canvas.height = _canvasSize.height;
                  recreate = true;
                }

                if (recreate) _context.font = _fontDesc;
                _context.textAlign = Alignment[_hAlign$1];
                _context.textBaseline = 'alphabetic';
              },
              _getFontDesc: function _getFontDesc() {
                var fontDesc = _fontSize$1.toString() + "px ";
                fontDesc += _fontFamily;

                if (_isBold) {
                  fontDesc = "bold " + fontDesc;
                }

                if (_isItalic) {
                  fontDesc = "italic " + fontDesc;
                }

                return fontDesc;
              },
              _getLineHeight: function _getLineHeight() {
                var nodeSpacingY = _lineHeight$1;

                if (nodeSpacingY === 0) {
                  nodeSpacingY = _fontSize$1;
                } else {
                  nodeSpacingY = nodeSpacingY * _fontSize$1 / _drawFontsize;
                }

                return nodeSpacingY | 0;
              },
              _calculateParagraphLength: function _calculateParagraphLength(paragraphedStrings, ctx) {
                var paragraphLength = [];

                for (var _iterator = _createForOfIteratorHelperLoose(paragraphedStrings), _step; !(_step = _iterator()).done;) {
                  var para = _step.value;
                  var width = safeMeasureText(ctx, para, _fontDesc);
                  paragraphLength.push(width);
                }

                return paragraphLength;
              },
              _measureText: function _measureText(ctx, fontDesc) {
                return function (string) {
                  return safeMeasureText(ctx, string, fontDesc);
                };
              },
              _calculateShrinkFont: function _calculateShrinkFont(paragraphedStrings) {
                if (!_context) return;

                var paragraphLength = this._calculateParagraphLength(paragraphedStrings, _context);

                var i = 0;
                var totalHeight = 0;
                var maxLength = 0;

                if (_isWrapText$1) {
                  var canvasWidthNoMargin = _nodeContentSize.width;
                  var canvasHeightNoMargin = _nodeContentSize.height;

                  if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) {
                    return;
                  }

                  totalHeight = canvasHeightNoMargin + 1;
                  var actualFontSize = _fontSize$1 + 1;
                  var textFragment = [];
                  var left = 0;
                  var right = actualFontSize | 0;
                  var mid = 0;

                  while (left < right) {
                    mid = left + right + 1 >> 1;

                    if (mid <= 0) {
                      logID(4003);
                      break;
                    }

                    _fontSize$1 = mid;
                    _fontDesc = this._getFontDesc();
                    _context.font = _fontDesc;

                    var lineHeight = this._getLineHeight();

                    totalHeight = 0;

                    for (i = 0; i < paragraphedStrings.length; ++i) {
                      var allWidth = safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
                      textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context, _fontDesc));
                      totalHeight += textFragment.length * lineHeight;
                    }

                    if (totalHeight > canvasHeightNoMargin) {
                      right = mid - 1;
                    } else {
                      left = mid;
                    }
                  }

                  if (left === 0) {
                    logID(4003);
                  } else {
                    _fontSize$1 = left;
                    _fontDesc = this._getFontDesc();
                    _context.font = _fontDesc;
                  }
                } else {
                  totalHeight = paragraphedStrings.length * this._getLineHeight();

                  for (i = 0; i < paragraphedStrings.length; ++i) {
                    if (maxLength < paragraphLength[i]) {
                      maxLength = paragraphLength[i];
                    }
                  }

                  var scaleX = (_canvasSize.width - _canvasPadding.width) / maxLength;
                  var scaleY = _canvasSize.height / totalHeight;
                  _fontSize$1 = _drawFontsize * Math.min(1, scaleX, scaleY) | 0;
                  _fontDesc = this._getFontDesc();
                  _context.font = _fontDesc;
                }
              },
              _calculateWrapText: function _calculateWrapText(paragraphedStrings) {
                if (!_isWrapText$1 || !_context) return;
                _splitStrings = [];
                var canvasWidthNoMargin = _nodeContentSize.width;

                for (var i = 0; i < paragraphedStrings.length; ++i) {
                  var allWidth = safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
                  var textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context, _fontDesc));
                  _splitStrings = _splitStrings.concat(textFragment);
                }
              },
              _calculateLabelFont: function _calculateLabelFont() {
                if (!_context) {
                  return;
                }

                var paragraphedStrings = _string$1.split('\n');

                _splitStrings = paragraphedStrings;
                _fontDesc = this._getFontDesc();
                _context.font = _fontDesc;

                switch (_overflow$1) {
                  case Overflow$1.NONE:
                    {
                      var canvasSizeX = 0;
                      var canvasSizeY = 0;

                      for (var i = 0; i < paragraphedStrings.length; ++i) {
                        var paraLength = safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
                        canvasSizeX = canvasSizeX > paraLength ? canvasSizeX : paraLength;
                      }

                      canvasSizeY = (_splitStrings.length + BASELINE_RATIO) * this._getLineHeight();
                      var rawWidth = parseFloat(canvasSizeX.toFixed(2));
                      var rawHeight = parseFloat(canvasSizeY.toFixed(2));
                      _canvasSize.width = rawWidth + _canvasPadding.width;
                      _canvasSize.height = rawHeight + _canvasPadding.height;
                      _nodeContentSize.width = rawWidth + _contentSizeExtend.width;
                      _nodeContentSize.height = rawHeight + _contentSizeExtend.height;
                      break;
                    }

                  case Overflow$1.SHRINK:
                    {
                      this._calculateShrinkFont(paragraphedStrings);

                      this._calculateWrapText(paragraphedStrings);

                      break;
                    }

                  case Overflow$1.CLAMP:
                    {
                      this._calculateWrapText(paragraphedStrings);

                      break;
                    }

                  case Overflow$1.RESIZE_HEIGHT:
                    {
                      this._calculateWrapText(paragraphedStrings);

                      var _rawHeight = (_splitStrings.length + BASELINE_RATIO) * this._getLineHeight();

                      _canvasSize.height = _rawHeight + _canvasPadding.height;
                      _nodeContentSize.height = _rawHeight + _contentSizeExtend.height;
                      break;
                    }
                }
              }
            };

            var WHITE$1 = Color$1.WHITE.clone();
            var QUAD_INDICES$1 = Uint16Array.from([0, 1, 2, 1, 3, 2]);
            var ttf = {
              createData: function createData(comp) {
                var renderData = comp.requestRenderData();
                renderData.dataLength = 4;
                renderData.resize(4, 6);
                var vData = renderData.chunk.vb;
                vData[3] = vData[21] = vData[22] = vData[31] = 0;
                vData[4] = vData[12] = vData[13] = vData[30] = 1;
                var offset = 5;

                for (var i = 0; i < 4; i++) {
                  Color$1.toArray(vData, WHITE$1, offset);
                  offset += 9;
                }

                renderData.vertexRow = 2;
                renderData.vertexCol = 2;
                renderData.chunk.setIndexBuffer(QUAD_INDICES$1);
                return renderData;
              },
              fillBuffers: function fillBuffers(comp, renderer) {
                var renderData = comp.renderData;
                var chunk = renderData.chunk;
                var dataList = renderData.data;
                var node = comp.node;
                var vData = chunk.vb;
                var m = node.worldMatrix;
                var stride = renderData.floatStride;
                var offset = 0;
                var length = dataList.length;

                for (var i = 0; i < length; i++) {
                  var curData = dataList[i];
                  var x = curData.x;
                  var y = curData.y;
                  var rhw = m.m03 * x + m.m07 * y + m.m15;
                  rhw = rhw ? Math.abs(1 / rhw) : 1;
                  offset = i * stride;
                  vData[offset + 0] = (m.m00 * x + m.m04 * y + m.m12) * rhw;
                  vData[offset + 1] = (m.m01 * x + m.m05 * y + m.m13) * rhw;
                  vData[offset + 2] = (m.m02 * x + m.m06 * y + m.m14) * rhw;
                }

                var vid = chunk.vertexOffset;
                var meshBuffer = chunk.meshBuffer;
                var ib = chunk.meshBuffer.iData;
                var indexOffset = meshBuffer.indexOffset;
                ib[indexOffset++] = vid;
                ib[indexOffset++] = vid + 1;
                ib[indexOffset++] = vid + 2;
                ib[indexOffset++] = vid + 2;
                ib[indexOffset++] = vid + 1;
                ib[indexOffset++] = vid + 3;
                meshBuffer.indexOffset += 6;
              },
              updateVertexData: function updateVertexData(comp) {
                var renderData = comp.renderData;

                if (!renderData) {
                  return;
                }

                var uiTrans = comp.node._uiProps.uiTransformComp;
                var width = uiTrans.width;
                var height = uiTrans.height;
                var appX = uiTrans.anchorX * width;
                var appY = uiTrans.anchorY * height;
                var data = renderData.data;
                data[0].x = -appX;
                data[0].y = -appY;
                data[1].x = width - appX;
                data[1].y = -appY;
                data[2].x = -appX;
                data[2].y = height - appY;
                data[3].x = width - appX;
                data[3].y = height - appY;
              },
              updateUVs: function updateUVs(comp) {
                var renderData = comp.renderData;

                if (!renderData || !comp.ttfSpriteFrame) {
                  return;
                }

                var vData = renderData.chunk.vb;
                var uv = comp.ttfSpriteFrame.uv;
                vData[3] = uv[0];
                vData[4] = uv[1];
                vData[12] = uv[2];
                vData[13] = uv[3];
                vData[21] = uv[4];
                vData[22] = uv[5];
                vData[30] = uv[6];
                vData[31] = uv[7];
              },
              updateColor: function updateColor(comp) {}
            };
            addon(ttf, ttfUtils);

            var labelAssembler = exports('labelAssembler', {
              getAssembler: function getAssembler(comp) {
                var assembler = ttf;

                if (comp.font instanceof BitmapFont) {
                  assembler = bmfont;
                } else if (comp.cacheMode === Label.CacheMode.CHAR) {
                  assembler = letter;
                }

                return assembler;
              }
            });
            Label.Assembler = labelAssembler;

            var FillType$1 = Sprite.FillType;
            var m$1 = new Mat4();
            var QUAD_INDICES$2 = Uint16Array.from([0, 1, 2, 1, 3, 2]);
            var barFilled = {
              updateRenderData: function updateRenderData(sprite) {
                var frame = sprite.spriteFrame;
                dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
                var renderData = sprite.renderData;

                if (renderData && frame) {
                  var vertDirty = renderData.vertDirty;

                  if (!vertDirty) {
                    return;
                  }

                  var fillStart = sprite.fillStart;
                  var fillRange = sprite.fillRange;

                  if (fillRange < 0) {
                    fillStart += fillRange;
                    fillRange = -fillRange;
                  }

                  fillRange = fillStart + fillRange;
                  fillStart = fillStart > 1.0 ? 1.0 : fillStart;
                  fillStart = fillStart < 0.0 ? 0.0 : fillStart;
                  fillRange = fillRange > 1.0 ? 1.0 : fillRange;
                  fillRange = fillRange < 0.0 ? 0.0 : fillRange;
                  fillRange -= fillStart;
                  fillRange = fillRange < 0 ? 0 : fillRange;
                  var fillEnd = fillStart + fillRange;
                  fillEnd = fillEnd > 1 ? 1 : fillEnd;
                  this.updateUVs(sprite, fillStart, fillEnd);
                  this.updateVertexData(sprite, fillStart, fillEnd);
                  renderData.updateRenderData(sprite, frame);
                }
              },
              updateUVs: function updateUVs(sprite, fillStart, fillEnd) {
                var spriteFrame = sprite.spriteFrame;
                var renderData = sprite.renderData;
                var vData = renderData.chunk.vb;
                var atlasWidth = spriteFrame.width;
                var atlasHeight = spriteFrame.height;
                var textureRect = spriteFrame.rect;
                var ul = 0;
                var vb = 0;
                var ur = 0;
                var vt = 0;
                var quadUV0 = 0;
                var quadUV1 = 0;
                var quadUV2 = 0;
                var quadUV3 = 0;
                var quadUV4 = 0;
                var quadUV5 = 0;
                var quadUV6 = 0;
                var quadUV7 = 0;

                if (spriteFrame.isRotated()) {
                  ul = textureRect.x / atlasWidth;
                  vb = (textureRect.y + textureRect.width) / atlasHeight;
                  ur = (textureRect.x + textureRect.height) / atlasWidth;
                  vt = textureRect.y / atlasHeight;
                  quadUV0 = quadUV2 = ul;
                  quadUV4 = quadUV6 = ur;
                  quadUV3 = quadUV7 = vb;
                  quadUV1 = quadUV5 = vt;
                } else {
                  ul = textureRect.x / atlasWidth;
                  vb = (textureRect.y + textureRect.height) / atlasHeight;
                  ur = (textureRect.x + textureRect.width) / atlasWidth;
                  vt = textureRect.y / atlasHeight;
                  quadUV0 = quadUV4 = ul;
                  quadUV2 = quadUV6 = ur;
                  quadUV1 = quadUV3 = vb;
                  quadUV5 = quadUV7 = vt;
                }

                switch (sprite.fillType) {
                  case FillType$1.HORIZONTAL:
                    vData[3] = quadUV0 + (quadUV2 - quadUV0) * fillStart;
                    vData[4] = quadUV1 + (quadUV3 - quadUV1) * fillStart;
                    vData[12] = quadUV0 + (quadUV2 - quadUV0) * fillEnd;
                    vData[13] = quadUV1 + (quadUV3 - quadUV1) * fillEnd;
                    vData[21] = quadUV4 + (quadUV6 - quadUV4) * fillStart;
                    vData[22] = quadUV5 + (quadUV7 - quadUV5) * fillStart;
                    vData[30] = quadUV4 + (quadUV6 - quadUV4) * fillEnd;
                    vData[31] = quadUV5 + (quadUV7 - quadUV5) * fillEnd;
                    break;

                  case FillType$1.VERTICAL:
                    vData[3] = quadUV0 + (quadUV4 - quadUV0) * fillStart;
                    vData[4] = quadUV1 + (quadUV5 - quadUV1) * fillStart;
                    vData[12] = quadUV2 + (quadUV6 - quadUV2) * fillStart;
                    vData[13] = quadUV3 + (quadUV7 - quadUV3) * fillStart;
                    vData[21] = quadUV0 + (quadUV4 - quadUV0) * fillEnd;
                    vData[22] = quadUV1 + (quadUV5 - quadUV1) * fillEnd;
                    vData[30] = quadUV2 + (quadUV6 - quadUV2) * fillEnd;
                    vData[31] = quadUV3 + (quadUV7 - quadUV3) * fillEnd;
                    break;

                  default:
                    errorID(2626);
                    break;
                }
              },
              updateVertexData: function updateVertexData(sprite, fillStart, fillEnd) {
                var renderData = sprite.renderData;
                var dataList = renderData.data;
                var uiTrans = sprite.node._uiProps.uiTransformComp;
                var width = uiTrans.width;
                var height = uiTrans.height;
                var appX = uiTrans.anchorX * width;
                var appY = uiTrans.anchorY * height;
                var l = -appX;
                var b = -appY;
                var r = width - appX;
                var t = height - appY;
                var progressStart = 0;
                var progressEnd = 0;

                switch (sprite.fillType) {
                  case FillType$1.HORIZONTAL:
                    progressStart = l + (r - l) * fillStart;
                    progressEnd = l + (r - l) * fillEnd;
                    l = progressStart;
                    r = progressEnd;
                    break;

                  case FillType$1.VERTICAL:
                    progressStart = b + (t - b) * fillStart;
                    progressEnd = b + (t - b) * fillEnd;
                    b = progressStart;
                    t = progressEnd;
                    break;

                  default:
                    errorID(2626);
                    break;
                }

                dataList[0].x = l;
                dataList[0].y = b;
                dataList[1].x = r;
                dataList[1].y = b;
                dataList[2].x = l;
                dataList[2].y = t;
                dataList[3].x = r;
                dataList[3].y = t;
              },
              createData: function createData(sprite) {
                var renderData = sprite.requestRenderData();
                renderData.dataLength = 4;
                renderData.resize(4, 6);
                renderData.vertexRow = 2;
                renderData.vertexCol = 2;
                renderData.chunk.setIndexBuffer(QUAD_INDICES$2);
                var dataList = renderData.data;

                for (var _iterator = _createForOfIteratorHelperLoose(dataList), _step; !(_step = _iterator()).done;) {
                  var data = _step.value;
                  data.z = 0;
                }

                return renderData;
              },
              updateWorldVertexData: function updateWorldVertexData(sprite, chunk) {
                var node = sprite.node;
                node.getWorldMatrix(m$1);
                var renderData = sprite.renderData;
                var stride = renderData.floatStride;
                var dataList = sprite.renderData.data;
                var vData = chunk.vb;
                var offset = 0;

                for (var i = 0; i < 4; i++) {
                  var local = dataList[i];
                  var x = local.x;
                  var y = local.y;
                  var rhw = m$1.m03 * x + m$1.m07 * y + m$1.m15;
                  rhw = rhw ? Math.abs(1 / rhw) : 1;
                  offset = i * stride;
                  vData[offset] = (m$1.m00 * x + m$1.m04 * y + m$1.m12) * rhw;
                  vData[offset + 1] = (m$1.m01 * x + m$1.m05 * y + m$1.m13) * rhw;
                  vData[offset + 2] = (m$1.m02 * x + m$1.m06 * y + m$1.m14) * rhw;
                }
              },
              fillBuffers: function fillBuffers(sprite, renderer) {
                var renderData = sprite.renderData;
                var chunk = renderData.chunk;

                if (sprite.node.hasChangedFlags || renderData.vertDirty) {
                  this.updateWorldVertexData(sprite, chunk);
                  renderData.vertDirty = false;
                }

                var bid = chunk.bufferId;
                var vid = chunk.vertexOffset;
                var meshBuffer = chunk.meshBuffer;
                var ib = chunk.meshBuffer.iData;
                var indexOffset = meshBuffer.indexOffset;
                ib[indexOffset++] = vid;
                ib[indexOffset++] = vid + 1;
                ib[indexOffset++] = vid + 2;
                ib[indexOffset++] = vid + 2;
                ib[indexOffset++] = vid + 1;
                ib[indexOffset++] = vid + 3;
                meshBuffer.indexOffset += 6;
              },
              updateColor: function updateColor(sprite) {
                var renderData = sprite.renderData;
                var vData = renderData.chunk.vb;
                var stride = renderData.floatStride;
                var colorOffset = 5;
                var color = sprite.color;
                var colorR = color.r / 255;
                var colorG = color.g / 255;
                var colorB = color.b / 255;
                var colorA = sprite.node._uiProps.opacity;

                for (var i = 0; i < 4; i++) {
                  vData[colorOffset] = colorR;
                  vData[colorOffset + 1] = colorG;
                  vData[colorOffset + 2] = colorB;
                  vData[colorOffset + 3] = colorA;
                  colorOffset += stride;
                }
              }
            };

            var PI_2 = Math.PI * 2;
            var EPSILON = 1e-6;
            var m$2 = new Mat4();
            var _vertPos = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];

            var _vertices = new Array(4);

            var _uvs = new Array(8);

            var _intersectPoint_1 = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
            var _intersectPoint_2 = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];

            var _center = new Vec2();

            var _triangles = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
            var QUAD_INDICES$3;

            function _calcIntersectedPoints(left, right, bottom, top, center, angle, intersectPoints) {
              var sinAngle = Math.sin(angle);
              sinAngle = Math.abs(sinAngle) > EPSILON ? sinAngle : 0;
              var cosAngle = Math.cos(angle);
              cosAngle = Math.abs(cosAngle) > EPSILON ? cosAngle : 0;
              var tanAngle = 0;
              var cotAngle = 0;

              if (cosAngle !== 0) {
                tanAngle = sinAngle / cosAngle;

                if ((left - center.x) * cosAngle > 0) {
                  var yLeft = center.y + tanAngle * (left - center.x);
                  intersectPoints[0].x = left;
                  intersectPoints[0].y = yLeft;
                }

                if ((right - center.x) * cosAngle > 0) {
                  var yRight = center.y + tanAngle * (right - center.x);
                  intersectPoints[2].x = right;
                  intersectPoints[2].y = yRight;
                }
              }

              if (sinAngle !== 0) {
                cotAngle = cosAngle / sinAngle;

                if ((top - center.y) * sinAngle > 0) {
                  var xTop = center.x + cotAngle * (top - center.y);
                  intersectPoints[3].x = xTop;
                  intersectPoints[3].y = top;
                }

                if ((bottom - center.y) * sinAngle > 0) {
                  var xBottom = center.x + cotAngle * (bottom - center.y);
                  intersectPoints[1].x = xBottom;
                  intersectPoints[1].y = bottom;
                }
              }
            }

            function _calculateVertices(sprite) {
              var uiTrans = sprite.node._uiProps.uiTransformComp;
              var width = uiTrans.width;
              var height = uiTrans.height;
              var appX = uiTrans.anchorX * width;
              var appY = uiTrans.anchorY * height;
              var l = -appX;
              var b = -appY;
              var r = width - appX;
              var t = height - appY;
              var vertices = _vertices;
              vertices[0] = l;
              vertices[1] = b;
              vertices[2] = r;
              vertices[3] = t;
              var fillCenter = sprite.fillCenter;
              var cx = _center.x = Math.min(Math.max(0, fillCenter.x), 1) * (r - l) + l;
              var cy = _center.y = Math.min(Math.max(0, fillCenter.y), 1) * (t - b) + b;
              _vertPos[0].x = _vertPos[3].x = l;
              _vertPos[1].x = _vertPos[2].x = r;
              _vertPos[0].y = _vertPos[1].y = b;
              _vertPos[2].y = _vertPos[3].y = t;

              for (var _iterator = _createForOfIteratorHelperLoose(_triangles), _step; !(_step = _iterator()).done;) {
                var num = _step.value;
                Vec2.set(num, 0, 0);
              }

              if (cx !== vertices[0]) {
                Vec2.set(_triangles[0], 3, 0);
              }

              if (cx !== vertices[2]) {
                Vec2.set(_triangles[2], 1, 2);
              }

              if (cy !== vertices[1]) {
                Vec2.set(_triangles[1], 0, 1);
              }

              if (cy !== vertices[3]) {
                Vec2.set(_triangles[3], 2, 3);
              }
            }

            function _calculateUVs(spriteFrame) {
              var atlasWidth = spriteFrame.width;
              var atlasHeight = spriteFrame.height;
              var textureRect = spriteFrame.getRect();
              var u0 = 0;
              var u1 = 0;
              var v0 = 0;
              var v1 = 0;
              var uvs = _uvs;

              if (spriteFrame.isRotated()) {
                u0 = textureRect.x / atlasWidth;
                u1 = (textureRect.x + textureRect.height) / atlasWidth;
                v0 = textureRect.y / atlasHeight;
                v1 = (textureRect.y + textureRect.width) / atlasHeight;
                uvs[0] = uvs[2] = u0;
                uvs[4] = uvs[6] = u1;
                uvs[3] = uvs[7] = v1;
                uvs[1] = uvs[5] = v0;
              } else {
                u0 = textureRect.x / atlasWidth;
                u1 = (textureRect.x + textureRect.width) / atlasWidth;
                v0 = textureRect.y / atlasHeight;
                v1 = (textureRect.y + textureRect.height) / atlasHeight;
                uvs[0] = uvs[4] = u0;
                uvs[2] = uvs[6] = u1;
                uvs[1] = uvs[3] = v1;
                uvs[5] = uvs[7] = v0;
              }
            }

            function _getVertAngle(start, end) {
              var placementX = end.x - start.x;
              var placementY = end.y - start.y;

              if (placementX === 0 && placementY === 0) {
                return 0;
              } else if (placementX === 0) {
                if (placementY > 0) {
                  return Math.PI * 0.5;
                } else {
                  return Math.PI * 1.5;
                }
              } else {
                var angle = Math.atan(placementY / placementX);

                if (placementX < 0) {
                  angle += Math.PI;
                }

                return angle;
              }
            }

            function _generateTriangle(dataList, offset, vert0, vert1, vert2) {
              var vertices = _vertices;
              var v0x = vertices[0];
              var v0y = vertices[1];
              var v1x = vertices[2];
              var v1y = vertices[3];
              dataList[offset].x = vert0.x;
              dataList[offset].y = vert0.y;
              dataList[offset + 1].x = vert1.x;
              dataList[offset + 1].y = vert1.y;
              dataList[offset + 2].x = vert2.x;
              dataList[offset + 2].y = vert2.y;
              var progressX = 0;
              var progressY = 0;
              progressX = (vert0.x - v0x) / (v1x - v0x);
              progressY = (vert0.y - v0y) / (v1y - v0y);

              _generateUV(progressX, progressY, dataList, offset);

              progressX = (vert1.x - v0x) / (v1x - v0x);
              progressY = (vert1.y - v0y) / (v1y - v0y);

              _generateUV(progressX, progressY, dataList, offset + 1);

              progressX = (vert2.x - v0x) / (v1x - v0x);
              progressY = (vert2.y - v0y) / (v1y - v0y);

              _generateUV(progressX, progressY, dataList, offset + 2);
            }

            function _generateUV(progressX, progressY, data, offset) {
              var uvs = _uvs;
              var px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX;
              var px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX;
              var py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX;
              var py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX;
              var uv = data[offset];
              uv.u = px1 + (px2 - px1) * progressY;
              uv.v = py1 + (py2 - py1) * progressY;
            }

            var radialFilled = {
              useModel: false,
              createData: function createData(sprite) {
                return sprite.requestRenderData();
              },
              updateRenderData: function updateRenderData(sprite) {
                var frame = sprite.spriteFrame;
                dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
                this.updateUVs(sprite);
                var renderData = sprite.renderData;

                if (renderData && frame) {
                  if (!renderData.vertDirty) {
                    return;
                  }

                  var dataList = renderData.data;
                  var fillStart = sprite.fillStart;
                  var fillRange = sprite.fillRange;

                  if (fillRange < 0) {
                    fillStart += fillRange;
                    fillRange = -fillRange;
                  }

                  while (fillStart >= 1.0) {
                    fillStart -= 1.0;
                  }

                  while (fillStart < 0.0) {
                    fillStart += 1.0;
                  }

                  fillStart *= PI_2;
                  fillRange *= PI_2;
                  var fillEnd = fillStart + fillRange;

                  _calculateVertices(sprite);

                  _calculateUVs(frame);

                  _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart, _intersectPoint_1);

                  _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart + fillRange, _intersectPoint_2);

                  var offset = 0;

                  for (var triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
                    var triangle = _triangles[triangleIndex];

                    if (!triangle) {
                      continue;
                    }

                    if (fillRange >= PI_2) {
                      renderData.dataLength = offset + 3;

                      _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]);

                      offset += 3;
                      continue;
                    }

                    var startAngle = _getVertAngle(_center, _vertPos[triangle.x]);

                    var endAngle = _getVertAngle(_center, _vertPos[triangle.y]);

                    if (endAngle < startAngle) {
                      endAngle += PI_2;
                    }

                    startAngle -= PI_2;
                    endAngle -= PI_2;

                    for (var testIndex = 0; testIndex < 3; ++testIndex) {
                      if (startAngle >= fillEnd) ; else if (startAngle >= fillStart) {
                        renderData.dataLength = offset + 3;

                        if (endAngle >= fillEnd) {
                          _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _intersectPoint_2[triangleIndex]);
                        } else {
                          _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]);
                        }

                        offset += 3;
                      } else if (endAngle > fillStart) {
                        if (endAngle <= fillEnd) {
                          renderData.dataLength = offset + 3;

                          _generateTriangle(dataList, offset, _center, _intersectPoint_1[triangleIndex], _vertPos[triangle.y]);

                          offset += 3;
                        } else {
                          renderData.dataLength = offset + 3;

                          _generateTriangle(dataList, offset, _center, _intersectPoint_1[triangleIndex], _intersectPoint_2[triangleIndex]);

                          offset += 3;
                        }
                      }

                      startAngle += PI_2;
                      endAngle += PI_2;
                    }
                  }

                  if (offset === 0) {
                    renderData.dataLength = 0;
                  }

                  renderData.resize(offset, offset);

                  renderData.updateRenderData(sprite, frame);
                }
              },
              createQuadIndices: function createQuadIndices(indexCount) {
                QUAD_INDICES$3 = null;
                QUAD_INDICES$3 = new Uint16Array(indexCount);
                var offset = 0;

                for (var i = 0; i < indexCount; i++) {
                  QUAD_INDICES$3[offset++] = i;
                }
              },
              fillBuffers: function fillBuffers(comp, renderer) {
                var node = comp.node;
                var renderData = comp.renderData;
                var chunk = renderData.chunk;

                if (node.hasChangedFlags || renderData.vertDirty) {
                  this.updateWorldVertexAndUVData(comp, chunk);
                  renderData.vertDirty = false;
                }

                this.updateColorLate(comp);
                var bid = chunk.bufferId;
                var vid = chunk.vertexOffset;
                var meshBuffer = chunk.meshBuffer;
                var ib = chunk.meshBuffer.iData;
                var indexOffset = meshBuffer.indexOffset;

                for (var i = 0; i < renderData.indexCount; i++) {
                  ib[indexOffset + i] = vid + i;
                }

                meshBuffer.indexOffset += renderData.indexCount;
                meshBuffer.setDirty();
              },
              updateWorldUVData: function updateWorldUVData(sprite, chunk) {
                var renderData = sprite.renderData;
                var stride = renderData.floatStride;
                var dataList = renderData.data;
                var vData = renderData.chunk.vb;

                for (var i = 0; i < dataList.length; i++) {
                  var offset = i * stride;
                  vData[offset + 3] = dataList[i].u;
                  vData[offset + 4] = dataList[i].v;
                }
              },
              updateWorldVertexAndUVData: function updateWorldVertexAndUVData(sprite, chunk) {
                var node = sprite.node;
                node.getWorldMatrix(m$2);
                var renderData = sprite.renderData;
                var stride = renderData.floatStride;
                var dataList = sprite.renderData.data;
                var vData = chunk.vb;
                var vertexCount = renderData.vertexCount;
                var vertexOffset = 0;

                for (var i = 0; i < vertexCount; i++) {
                  var vert = dataList[i];
                  var x = vert.x;
                  var y = vert.y;
                  var rhw = m$2.m03 * x + m$2.m07 * y + m$2.m15;
                  rhw = rhw ? Math.abs(1 / rhw) : 1;
                  vData[vertexOffset + 0] = (m$2.m00 * x + m$2.m04 * y + m$2.m12) * rhw;
                  vData[vertexOffset + 1] = (m$2.m01 * x + m$2.m05 * y + m$2.m13) * rhw;
                  vData[vertexOffset + 2] = (m$2.m02 * x + m$2.m06 * y + m$2.m14) * rhw;
                  vData[vertexOffset + 3] = vert.u;
                  vData[vertexOffset + 4] = vert.v;
                  vertexOffset += stride;
                }
              },
              updateUVs: function updateUVs(sprite) {
                var renderData = sprite.renderData;
                renderData.vertDirty = true;
                sprite.markForUpdateRenderData();
              },
              updateColorLate: function updateColorLate(sprite) {
                var renderData = sprite.renderData;
                var vData = renderData.chunk.vb;
                var stride = renderData.floatStride;
                var vertexCount = renderData.vertexCount;
                var colorOffset = 5;
                var color = sprite.color;
                var colorR = color.r / 255;
                var colorG = color.g / 255;
                var colorB = color.b / 255;
                var colorA = sprite.node._uiProps.opacity;

                for (var i = 0; i < vertexCount; i++) {
                  vData[colorOffset] = colorR;
                  vData[colorOffset + 1] = colorG;
                  vData[colorOffset + 2] = colorB;
                  vData[colorOffset + 3] = colorA;
                  colorOffset += stride;
                }
              },
              updateColor: function updateColor(sprite) {}
            };

            var QUAD_INDICES$4 = Uint16Array.from([0, 1, 2, 1, 3, 2]);
            var simple = {
              createData: function createData(sprite) {
                var renderData = sprite.requestRenderData();
                renderData.dataLength = 4;
                renderData.resize(4, 6);
                renderData.vertexRow = 2;
                renderData.vertexCol = 2;
                renderData.chunk.setIndexBuffer(QUAD_INDICES$4);
                return renderData;
              },
              updateRenderData: function updateRenderData(sprite) {
                var frame = sprite.spriteFrame;
                dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
                this.updateUVs(sprite);
                var renderData = sprite.renderData;

                if (renderData && frame) {
                  if (renderData.vertDirty) {
                    this.updateVertexData(sprite);
                  }

                  renderData.updateRenderData(sprite, frame);
                }
              },
              updateWorldVerts: function updateWorldVerts(sprite, chunk) {
                var renderData = sprite.renderData;
                var vData = chunk.vb;
                var dataList = renderData.data;
                var node = sprite.node;
                var m = node.worldMatrix;
                var stride = renderData.floatStride;
                var offset = 0;
                var length = dataList.length;

                for (var i = 0; i < length; i++) {
                  var curData = dataList[i];
                  var x = curData.x;
                  var y = curData.y;
                  var rhw = m.m03 * x + m.m07 * y + m.m15;
                  rhw = rhw ? Math.abs(1 / rhw) : 1;
                  offset = i * stride;
                  vData[offset + 0] = (m.m00 * x + m.m04 * y + m.m12) * rhw;
                  vData[offset + 1] = (m.m01 * x + m.m05 * y + m.m13) * rhw;
                  vData[offset + 2] = (m.m02 * x + m.m06 * y + m.m14) * rhw;
                }
              },
              fillBuffers: function fillBuffers(sprite, renderer) {
                if (sprite === null) {
                  return;
                }

                var renderData = sprite.renderData;
                var chunk = renderData.chunk;

                if (sprite.node.hasChangedFlags || renderData.vertDirty) {
                  this.updateWorldVerts(sprite, chunk);
                  renderData.vertDirty = false;
                }

                var bid = chunk.bufferId;
                var vidOrigin = chunk.vertexOffset;
                var meshBuffer = chunk.meshBuffer;
                var ib = chunk.meshBuffer.iData;
                var indexOffset = meshBuffer.indexOffset;

                for (var curRow = 0; curRow < renderData.vertexRow - 1; curRow++) {
                  for (var curCol = 0; curCol < renderData.vertexCol - 1; curCol++) {
                    var vid = vidOrigin + curRow * renderData.vertexCol + curCol;
                    ib[indexOffset++] = vid;
                    ib[indexOffset++] = vid + 1;
                    ib[indexOffset++] = vid + renderData.vertexCol;
                    ib[indexOffset++] = vid + 1;
                    ib[indexOffset++] = vid + 1 + renderData.vertexCol;
                    ib[indexOffset++] = vid + renderData.vertexCol;
                    meshBuffer.indexOffset += 6;
                  }
                }
              },
              updateVertexData: function updateVertexData(sprite) {
                var renderData = sprite.renderData;

                if (!renderData) {
                  return;
                }

                var uiTrans = sprite.node._uiProps.uiTransformComp;
                var dataList = renderData.data;
                var cw = uiTrans.width;
                var ch = uiTrans.height;
                var appX = uiTrans.anchorX * cw;
                var appY = uiTrans.anchorY * ch;
                var l = 0;
                var b = 0;
                var r = 0;
                var t = 0;

                if (sprite.trim) {
                  l = -appX;
                  b = -appY;
                  r = cw - appX;
                  t = ch - appY;
                } else {
                  var frame = sprite.spriteFrame;
                  var originSize = frame.originalSize;
                  var ow = originSize.width;
                  var oh = originSize.height;
                  var scaleX = cw / ow;
                  var scaleY = ch / oh;
                  var trimmedBorder = frame.trimmedBorder;
                  l = trimmedBorder.x * scaleX - appX;
                  b = trimmedBorder.z * scaleY - appY;
                  r = cw + trimmedBorder.y * scaleX - appX;
                  t = ch + trimmedBorder.w * scaleY - appY;
                }

                dataList[0].x = l;
                dataList[0].y = b;
                dataList[1].x = r;
                dataList[1].y = b;
                dataList[2].x = l;
                dataList[2].y = t;
                dataList[3].x = r;
                dataList[3].y = t;
                renderData.vertDirty = true;
              },
              updateUVs: function updateUVs(sprite) {
                if (!sprite.spriteFrame) return;
                var renderData = sprite.renderData;
                var vData = renderData.chunk.vb;
                var uv = sprite.spriteFrame.uv;
                vData[3] = uv[0];
                vData[4] = uv[1];
                vData[12] = uv[2];
                vData[13] = uv[3];
                vData[21] = uv[4];
                vData[22] = uv[5];
                vData[30] = uv[6];
                vData[31] = uv[7];
              },
              updateColor: function updateColor(sprite) {
                var renderData = sprite.renderData;
                var vData = renderData.chunk.vb;
                var colorOffset = 5;
                var color = sprite.color;
                var colorR = color.r / 255;
                var colorG = color.g / 255;
                var colorB = color.b / 255;
                var colorA = color.a / 255;

                for (var i = 0; i < 4; i++, colorOffset += renderData.floatStride) {
                  vData[colorOffset] = colorR;
                  vData[colorOffset + 1] = colorG;
                  vData[colorOffset + 2] = colorB;
                  vData[colorOffset + 3] = colorA;
                }
              }
            };

            var m$3 = new Mat4();
            var tempRenderData = [];

            for (var i$1 = 0; i$1 < 4; i$1++) {
              tempRenderData.push({
                x: 0,
                y: 0,
                z: 0,
                u: 0,
                v: 0,
                color: new Color$1()
              });
            }

            var sliced = {
              createData: function createData(sprite) {
                var renderData = sprite.requestRenderData();
                renderData.dataLength = 16;
                renderData.resize(16, 54);
                renderData.vertexRow = 4;
                renderData.vertexCol = 4;
                this.QUAD_INDICES = new Uint16Array(54);
                this.createQuadIndices(4, 4);
                renderData.chunk.setIndexBuffer(this.QUAD_INDICES);
                return renderData;
              },
              createQuadIndices: function createQuadIndices(vertexRow, vertexCol) {
                var offset = 0;

                for (var curRow = 0; curRow < vertexRow - 1; curRow++) {
                  for (var curCol = 0; curCol < vertexCol - 1; curCol++) {
                    var vid = curRow * vertexCol + curCol;
                    this.QUAD_INDICES[offset++] = vid;
                    this.QUAD_INDICES[offset++] = vid + 1;
                    this.QUAD_INDICES[offset++] = vid + vertexCol;
                    this.QUAD_INDICES[offset++] = vid + 1;
                    this.QUAD_INDICES[offset++] = vid + 1 + vertexCol;
                    this.QUAD_INDICES[offset++] = vid + vertexCol;
                  }
                }
              },
              updateRenderData: function updateRenderData(sprite) {
                var frame = sprite.spriteFrame;
                dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
                this.updateUVs(sprite);
                var renderData = sprite.renderData;

                if (renderData && frame) {
                  var vertDirty = renderData.vertDirty;

                  if (vertDirty) {
                    this.updateVertexData(sprite);
                  }

                  renderData.updateRenderData(sprite, frame);
                }
              },
              updateVertexData: function updateVertexData(sprite) {
                var renderData = sprite.renderData;
                var dataList = renderData.data;
                var uiTrans = sprite.node._uiProps.uiTransformComp;
                var width = uiTrans.width;
                var height = uiTrans.height;
                var appX = uiTrans.anchorX * width;
                var appY = uiTrans.anchorY * height;
                var frame = sprite.spriteFrame;
                var leftWidth = frame.insetLeft;
                var rightWidth = frame.insetRight;
                var topHeight = frame.insetTop;
                var bottomHeight = frame.insetBottom;
                var sizableWidth = width - leftWidth - rightWidth;
                var sizableHeight = height - topHeight - bottomHeight;
                var xScale = width / (leftWidth + rightWidth);
                var yScale = height / (topHeight + bottomHeight);
                xScale = Number.isNaN(xScale) || xScale > 1 ? 1 : xScale;
                yScale = Number.isNaN(yScale) || yScale > 1 ? 1 : yScale;
                sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
                sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
                tempRenderData[0].x = -appX;
                tempRenderData[0].y = -appY;
                tempRenderData[1].x = leftWidth * xScale - appX;
                tempRenderData[1].y = bottomHeight * yScale - appY;
                tempRenderData[2].x = tempRenderData[1].x + sizableWidth;
                tempRenderData[2].y = tempRenderData[1].y + sizableHeight;
                tempRenderData[3].x = width - appX;
                tempRenderData[3].y = height - appY;

                for (var curRow = 0; curRow < renderData.vertexRow; curRow++) {
                  for (var curCol = 0; curCol < renderData.vertexCol; curCol++) {
                    var curIndex = curRow * renderData.vertexCol + curCol;

                    if (curIndex < renderData.dataLength && curRow < tempRenderData.length && curCol < tempRenderData.length) {
                      dataList[curIndex].x = tempRenderData[curCol].x;
                      dataList[curIndex].y = tempRenderData[curRow].y;
                    }
                  }
                }
              },
              fillBuffers: function fillBuffers(sprite, renderer) {
                var renderData = sprite.renderData;
                var chunk = renderData.chunk;

                if (sprite.node.hasChangedFlags || renderData.vertDirty) {
                  this.updateWorldVertexData(sprite, chunk);
                  renderData.vertDirty = false;
                }

                var bid = chunk.bufferId;
                var vid = chunk.vertexOffset;
                var meshBuffer = chunk.meshBuffer;
                var ib = chunk.meshBuffer.iData;
                var indexOffset = meshBuffer.indexOffset;

                for (var r = 0; r < 3; ++r) {
                  for (var c = 0; c < 3; ++c) {
                    var start = vid + r * 4 + c;
                    ib[indexOffset++] = start;
                    ib[indexOffset++] = start + 1;
                    ib[indexOffset++] = start + 4;
                    ib[indexOffset++] = start + 1;
                    ib[indexOffset++] = start + 5;
                    ib[indexOffset++] = start + 4;
                  }
                }

                meshBuffer.indexOffset = indexOffset;
              },
              updateWorldVertexData: function updateWorldVertexData(sprite, chunk) {
                var node = sprite.node;
                node.getWorldMatrix(m$3);
                var renderData = sprite.renderData;
                var stride = renderData.floatStride;
                var dataList = renderData.data;
                var vData = chunk.vb;
                var offset = 0;

                for (var row = 0; row < 4; ++row) {
                  var rowD = dataList[row * 4];

                  for (var col = 0; col < 4; ++col) {
                    var colD = dataList[col];
                    var x = colD.x;
                    var y = rowD.y;
                    var rhw = m$3.m03 * x + m$3.m07 * y + m$3.m15;
                    rhw = rhw ? Math.abs(1 / rhw) : 1;
                    offset = (row * 4 + col) * stride;
                    vData[offset + 0] = (m$3.m00 * x + m$3.m04 * y + m$3.m12) * rhw;
                    vData[offset + 1] = (m$3.m01 * x + m$3.m05 * y + m$3.m13) * rhw;
                    vData[offset + 2] = (m$3.m02 * x + m$3.m06 * y + m$3.m14) * rhw;
                  }
                }
              },
              updateUVs: function updateUVs(sprite) {
                if (!sprite.spriteFrame) return;
                var renderData = sprite.renderData;
                var vData = renderData.chunk.vb;
                var stride = renderData.floatStride;
                var uv = sprite.spriteFrame.uvSliced;
                var uvOffset = 3;

                for (var _i = 0; _i < 16; _i++) {
                  vData[uvOffset] = uv[_i].u;
                  vData[uvOffset + 1] = uv[_i].v;
                  uvOffset += stride;
                }
              },
              updateColor: function updateColor(sprite) {
                var renderData = sprite.renderData;
                var vData = renderData.chunk.vb;
                var stride = renderData.floatStride;
                var colorOffset = 5;
                var color = sprite.color;
                var colorR = color.r / 255;
                var colorG = color.g / 255;
                var colorB = color.b / 255;
                var colorA = sprite.node._uiProps.opacity;

                for (var _i2 = 0; _i2 < 16; _i2++) {
                  vData[colorOffset] = colorR;
                  vData[colorOffset + 1] = colorG;
                  vData[colorOffset + 2] = colorB;
                  vData[colorOffset + 3] = colorA;
                  colorOffset += stride;
                }
              }
            };

            var m$4 = new Mat4();
            var origin;
            var leftInner;
            var rightInner;
            var rightOuter;
            var bottomInner;
            var topInner;
            var topOuter;
            var tempRenderDataLength = 0;
            var tempRenderData$1 = [];
            var QUAD_INDICES$5;

            function has9SlicedOffsetVertexCount(spriteFrame) {
              if (spriteFrame) {
                if (spriteFrame.insetTop > 0 || spriteFrame.insetBottom > 0 || spriteFrame.insetLeft > 0 || spriteFrame.insetRight > 0) {
                  return 2;
                }
              }

              return 0;
            }

            var tiled = {
              createData: function createData(sprite) {
                return sprite.requestRenderData();
              },
              updateRenderData: function updateRenderData(sprite) {
                var renderData = sprite.renderData;
                var frame = sprite.spriteFrame;

                if (!frame || !renderData) {
                  return;
                }

                if (!renderData.vertDirty) {
                  return;
                }

                var uiTrans = sprite.node._uiProps.uiTransformComp;
                var contentWidth = Math.abs(uiTrans.width);
                var contentHeight = Math.abs(uiTrans.height);
                var rect = frame.getRect();
                var leftWidth = frame.insetLeft;
                var rightWidth = frame.insetRight;
                var centerWidth = rect.width - leftWidth - rightWidth;
                var topHeight = frame.insetTop;
                var bottomHeight = frame.insetBottom;
                var centerHeight = rect.height - topHeight - bottomHeight;
                var sizableWidth = contentWidth - leftWidth - rightWidth;
                var sizableHeight = contentHeight - topHeight - bottomHeight;
                sizableWidth = sizableWidth > 0 ? sizableWidth : 0;
                sizableHeight = sizableHeight > 0 ? sizableHeight : 0;
                var hRepeat = centerWidth === 0 ? sizableWidth : sizableWidth / centerWidth;
                var vRepeat = centerHeight === 0 ? sizableHeight : sizableHeight / centerHeight;
                var offsetVertexCount = has9SlicedOffsetVertexCount(frame);
                var row = Math.ceil(vRepeat + offsetVertexCount);
                var col = Math.ceil(hRepeat + offsetVertexCount);
                renderData.dataLength = row * 2 * (col * 2);
                this.updateVerts(sprite, sizableWidth, sizableHeight, row, col);

                if (renderData.vertexCount !== row * col * 4) {
                  sprite.renderEntity.colorDirty = true;
                }

                renderData.resize(row * col * 4, row * col * 6);

                renderData.updateRenderData(sprite, frame);
              },
              createQuadIndices: function createQuadIndices(indexCount) {
                if (indexCount % 6 !== 0) {
                  console.error('illegal index count!');
                  return;
                }

                var quadCount = indexCount / 6;
                QUAD_INDICES$5 = null;
                QUAD_INDICES$5 = new Uint16Array(indexCount);
                var offset = 0;

                for (var i = 0; i < quadCount; i++) {
                  QUAD_INDICES$5[offset++] = 0 + i * 4;
                  QUAD_INDICES$5[offset++] = 1 + i * 4;
                  QUAD_INDICES$5[offset++] = 2 + i * 4;
                  QUAD_INDICES$5[offset++] = 1 + i * 4;
                  QUAD_INDICES$5[offset++] = 3 + i * 4;
                  QUAD_INDICES$5[offset++] = 2 + i * 4;
                }
              },
              updateUVs: function updateUVs(sprite) {
                var renderData = sprite.renderData;
                renderData.vertDirty = true;
                sprite.markForUpdateRenderData();
              },
              fillBuffers: function fillBuffers(sprite, renderer) {
                var node = sprite.node;
                var renderData = sprite.renderData;
                var chunk = renderData.chunk;

                if (node.hasChangedFlags || renderData.vertDirty) {
                  this.updateWorldVertexAndUVData(sprite, chunk);
                  renderData.vertDirty = false;
                }

                this.updateColorLate(sprite);
                var bid = chunk.bufferId;
                var vid = chunk.vertexOffset;
                var meshBuffer = chunk.meshBuffer;
                var ib = chunk.meshBuffer.iData;
                var indexOffset = meshBuffer.indexOffset;

                for (var i = 0; i < renderData.indexCount; i += 6) {
                  ib[indexOffset++] = vid;
                  ib[indexOffset++] = vid + 1;
                  ib[indexOffset++] = vid + 2;
                  ib[indexOffset++] = vid + 1;
                  ib[indexOffset++] = vid + 3;
                  ib[indexOffset++] = vid + 2;
                  vid += 4;
                  meshBuffer.indexOffset += 6;
                }

                meshBuffer.setDirty();
              },
              updateWorldUVData: function updateWorldUVData(sprite) {
                var renderData = sprite.renderData;
                var stride = renderData.floatStride;
                var dataList = renderData.data;
                var vData = renderData.chunk.vb;

                for (var i = 0; i < dataList.length; i++) {
                  var offset = i * stride;
                  vData[offset + 3] = dataList[i].u;
                  vData[offset + 4] = dataList[i].v;
                }
              },
              updateWorldVertexAndUVData: function updateWorldVertexAndUVData(sprite, chunk) {
                var node = sprite.node;
                node.getWorldMatrix(m$4);
                var renderData = sprite.renderData;
                var stride = renderData.floatStride;
                var dataList = renderData.data;
                var vData = chunk.vb;
                var length = dataList.length;

                for (var i = 0; i < length; i++) {
                  var x = dataList[i].x;
                  var y = dataList[i].y;
                  var z = dataList[i].z;
                  var rhw = m$4.m03 * x + m$4.m07 * y + m$4.m11 * z + m$4.m15;
                  rhw = rhw ? Math.abs(1 / rhw) : 1;
                  var offset = i * stride;
                  vData[offset] = (m$4.m00 * x + m$4.m04 * y + m$4.m08 * z + m$4.m12) * rhw;
                  vData[offset + 1] = (m$4.m01 * x + m$4.m05 * y + m$4.m09 * z + m$4.m13) * rhw;
                  vData[offset + 2] = (m$4.m02 * x + m$4.m06 * y + m$4.m10 * z + m$4.m14) * rhw;
                }

                this.updateWorldUVData(sprite);
              },
              updateVerts: function updateVerts(sprite, sizableWidth, sizableHeight, row, col) {
                var uiTrans = sprite.node._uiProps.uiTransformComp;
                var renderData = sprite.renderData;
                var dataList = renderData.data;
                var frame = sprite.spriteFrame;
                var rect = frame.rect;
                var contentWidth = Math.abs(uiTrans.width);
                var contentHeight = Math.abs(uiTrans.height);
                var appx = uiTrans.anchorX * contentWidth;
                var appy = uiTrans.anchorY * contentHeight;
                var leftWidth = frame.insetLeft;
                var rightWidth = frame.insetRight;
                var centerWidth = rect.width - leftWidth - rightWidth;
                var topHeight = frame.insetTop;
                var bottomHeight = frame.insetBottom;
                var centerHeight = rect.height - topHeight - bottomHeight;
                var xScale = uiTrans.width / (leftWidth + rightWidth) > 1 ? 1 : uiTrans.width / (leftWidth + rightWidth);
                var yScale = uiTrans.height / (topHeight + bottomHeight) > 1 ? 1 : uiTrans.height / (topHeight + bottomHeight);
                var offsetWidth = 0;
                var offsetHeight = 0;

                if (centerWidth > 0) {
                  offsetWidth = Math.floor(sizableWidth * 1000) / 1000 % centerWidth === 0 ? centerWidth : sizableWidth % centerWidth;
                } else {
                  offsetWidth = sizableWidth;
                }

                if (centerHeight > 0) {
                  offsetHeight = Math.floor(sizableHeight * 1000) / 1000 % centerHeight === 0 ? centerHeight : sizableHeight % centerHeight;
                } else {
                  offsetHeight = sizableHeight;
                }

                tempRenderDataLength = Math.max(row + 1, col + 1);

                for (var i = 0; i < tempRenderDataLength; i++) {
                  tempRenderData$1.push({
                    x: 0,
                    y: 0,
                    z: 0,
                    u: 0,
                    v: 0,
                    color: new Color$1()
                  });
                }

                var offsetVertexCount = has9SlicedOffsetVertexCount(frame);

                if (offsetVertexCount === 0) {
                  for (var _i = 0; _i < tempRenderDataLength; _i++) {
                    if (_i >= col) {
                      tempRenderData$1[_i].x = contentWidth - appx;
                    } else {
                      tempRenderData$1[_i].x = -appx + _i * centerWidth;
                    }

                    if (_i >= row) {
                      tempRenderData$1[_i].y = contentHeight - appy;
                    } else {
                      tempRenderData$1[_i].y = -appy + _i * centerHeight;
                    }
                  }
                } else {
                  for (var _i2 = 0; _i2 < tempRenderDataLength; _i2++) {
                    if (_i2 === 0) {
                      tempRenderData$1[_i2].x = -appx;
                    } else if (_i2 === 1) {
                      tempRenderData$1[_i2].x = -appx + leftWidth * xScale;
                    } else if (_i2 > 1 && _i2 < col - 1) {
                      if (centerWidth > 0) {
                        tempRenderData$1[_i2].x = -appx + leftWidth * xScale + centerWidth * (_i2 - 1);
                      } else {
                        tempRenderData$1[_i2].x = leftWidth + sizableWidth - appx;
                      }
                    } else if (_i2 === col - 1) {
                      tempRenderData$1[_i2].x = -appx + leftWidth * xScale + offsetWidth + centerWidth * (_i2 - 2);
                    } else if (_i2 >= col) {
                      tempRenderData$1[_i2].x = Math.min(leftWidth + sizableWidth + rightWidth, contentWidth) - appx;
                    }

                    if (_i2 === 0) {
                      tempRenderData$1[_i2].y = -appy;
                    } else if (_i2 === 1) {
                      tempRenderData$1[_i2].y = -appy + bottomHeight * yScale;
                    } else if (_i2 > 1 && _i2 < row - 1) {
                      if (centerHeight > 0) {
                        tempRenderData$1[_i2].y = -appy + bottomHeight * yScale + centerHeight * (_i2 - 1);
                      } else {
                        tempRenderData$1[_i2].y = bottomHeight + sizableHeight - appy;
                      }
                    } else if (_i2 === row - 1) {
                      tempRenderData$1[_i2].y = -appy + bottomHeight * yScale + offsetHeight + centerHeight * (_i2 - 2);
                    } else if (_i2 >= row) {
                      tempRenderData$1[_i2].y = Math.min(bottomHeight + sizableHeight + topHeight, contentHeight) - appy;
                    }
                  }
                }

                var x = 0;
                var x1 = 0;
                var y = 0;
                var y1 = 0;

                for (var yIndex = 0; yIndex < row; ++yIndex) {
                  y = tempRenderData$1[yIndex].y;
                  y1 = tempRenderData$1[yIndex + 1].y;

                  for (var xIndex = 0; xIndex < col; ++xIndex) {
                    x = tempRenderData$1[xIndex].x;
                    x1 = tempRenderData$1[xIndex + 1].x;
                    var curIndex = 4 * (yIndex * col + xIndex);
                    dataList[curIndex].x = x;
                    dataList[curIndex].y = y;
                    dataList[curIndex + 1].x = x1;
                    dataList[curIndex + 1].y = y;
                    dataList[curIndex + 2].x = x;
                    dataList[curIndex + 2].y = y1;
                    dataList[curIndex + 3].x = x1;
                    dataList[curIndex + 3].y = y1;
                  }
                }

                var rotated = frame.rotated;
                var uv = frame.uv;
                var uvSliced = frame.uvSliced;
                origin = uvSliced[0];
                leftInner = uvSliced[1];
                rightInner = uvSliced[2];
                rightOuter = uvSliced[3];
                bottomInner = uvSliced[4];
                topInner = uvSliced[8];
                topOuter = uvSliced[12];
                var coefU = 0;
                var coefV = 0;
                var hRepeat = centerWidth === 0 ? sizableWidth : sizableWidth / centerWidth;
                var vRepeat = centerHeight === 0 ? sizableHeight : sizableHeight / centerHeight;
                var tempXVerts = [];
                var tempYVerts = [];

                for (var yIndexUV = 0; yIndexUV < row; ++yIndexUV) {
                  if (sizableHeight > centerHeight) {
                    var curYRectCount = offsetVertexCount > 0 ? yIndexUV : yIndexUV + 1;

                    if (sizableHeight >= curYRectCount * centerHeight) {
                      coefV = 1;
                    } else {
                      coefV = vRepeat % 1;
                    }
                  } else {
                    coefV = vRepeat;
                  }

                  for (var xIndexUV = 0; xIndexUV < col; ++xIndexUV) {
                    if (sizableWidth > centerWidth) {
                      var curXRectCount = offsetVertexCount > 0 ? xIndexUV : xIndexUV + 1;

                      if (sizableWidth >= curXRectCount * centerWidth) {
                        coefU = 1;
                      } else {
                        coefU = hRepeat % 1;
                      }
                    } else {
                      coefU = hRepeat;
                    }

                    if (rotated) {
                      if (offsetVertexCount === 0) {
                        tempXVerts[0] = bottomInner.u;
                        tempXVerts[1] = bottomInner.u;
                        tempXVerts[2] = bottomInner.u + (topInner.u - bottomInner.u) * coefV;
                        tempYVerts[0] = leftInner.v;
                        tempYVerts[1] = leftInner.v + (rightInner.v - leftInner.v) * coefU;
                        tempYVerts[2] = leftInner.v;
                      } else {
                        if (yIndexUV === 0) {
                          tempXVerts[0] = origin.u;
                          tempXVerts[1] = origin.u;
                          tempXVerts[2] = bottomInner.u;
                        } else if (yIndexUV < row - 1) {
                          tempXVerts[0] = bottomInner.u;
                          tempXVerts[1] = bottomInner.u;
                          tempXVerts[2] = bottomInner.u + (topInner.u - bottomInner.u) * coefV;
                        } else if (yIndexUV === row - 1) {
                          tempXVerts[0] = topInner.u;
                          tempXVerts[1] = topInner.u;
                          tempXVerts[2] = topOuter.u;
                        }

                        if (xIndexUV === 0) {
                          tempYVerts[0] = origin.v;
                          tempYVerts[1] = leftInner.v;
                          tempYVerts[2] = origin.v;
                        } else if (xIndexUV < col - 1) {
                          tempYVerts[0] = leftInner.v;
                          tempYVerts[1] = leftInner.v + (rightInner.v - leftInner.v) * coefU;
                          tempYVerts[2] = leftInner.v;
                        } else if (xIndexUV === col - 1) {
                          tempYVerts[0] = rightInner.v;
                          tempYVerts[1] = rightOuter.v;
                          tempYVerts[2] = rightInner.v;
                        }
                      }

                      tempXVerts[3] = tempXVerts[2];
                      tempYVerts[3] = tempYVerts[1];
                    } else {
                      if (offsetVertexCount === 0) {
                        tempXVerts[0] = leftInner.u;
                        tempXVerts[1] = leftInner.u + (rightInner.u - leftInner.u) * coefU;
                        tempXVerts[2] = leftInner.u;
                        tempYVerts[0] = bottomInner.v;
                        tempYVerts[1] = bottomInner.v;
                        tempYVerts[2] = bottomInner.v + (topInner.v - bottomInner.v) * coefV;
                      } else {
                        if (xIndexUV === 0) {
                          tempXVerts[0] = origin.u;
                          tempXVerts[1] = leftInner.u;
                          tempXVerts[2] = origin.u;
                        } else if (xIndexUV < col - 1) {
                          tempXVerts[0] = leftInner.u;
                          tempXVerts[1] = leftInner.u + (rightInner.u - leftInner.u) * coefU;
                          tempXVerts[2] = leftInner.u;
                        } else if (xIndexUV === col - 1) {
                          tempXVerts[0] = rightInner.u;
                          tempXVerts[1] = rightOuter.u;
                          tempXVerts[2] = rightInner.u;
                        }

                        if (yIndexUV === 0) {
                          tempYVerts[0] = origin.v;
                          tempYVerts[1] = origin.v;
                          tempYVerts[2] = bottomInner.v;
                        } else if (yIndexUV < row - 1) {
                          tempYVerts[0] = bottomInner.v;
                          tempYVerts[1] = bottomInner.v;
                          tempYVerts[2] = bottomInner.v + (topInner.v - bottomInner.v) * coefV;
                        } else if (yIndexUV === row - 1) {
                          tempYVerts[0] = topInner.v;
                          tempYVerts[1] = topInner.v;
                          tempYVerts[2] = topOuter.v;
                        }
                      }

                      tempXVerts[3] = tempXVerts[1];
                      tempYVerts[3] = tempYVerts[2];
                    }

                    var _curIndex = 4 * (yIndexUV * col + xIndexUV);

                    dataList[_curIndex].u = tempXVerts[0];
                    dataList[_curIndex].v = tempYVerts[0];
                    dataList[_curIndex + 1].u = tempXVerts[1];
                    dataList[_curIndex + 1].v = tempYVerts[1];
                    dataList[_curIndex + 2].u = tempXVerts[2];
                    dataList[_curIndex + 2].v = tempYVerts[2];
                    dataList[_curIndex + 3].u = tempXVerts[3];
                    dataList[_curIndex + 3].v = tempYVerts[3];
                  }
                }
              },
              updateColorLate: function updateColorLate(sprite) {
                var renderData = sprite.renderData;
                var vData = renderData.chunk.vb;
                var stride = renderData.floatStride;
                var vertexCount = renderData.vertexCount;
                var colorOffset = 5;
                var color = sprite.color;
                var colorR = color.r / 255;
                var colorG = color.g / 255;
                var colorB = color.b / 255;
                var colorA = sprite.node._uiProps.opacity;

                for (var i = 0; i < vertexCount; i++) {
                  vData[colorOffset] = colorR;
                  vData[colorOffset + 1] = colorG;
                  vData[colorOffset + 2] = colorB;
                  vData[colorOffset + 3] = colorA;
                  colorOffset += stride;
                }
              },
              updateColor: function updateColor(sprite) {}
            };

            var SpriteType$1 = Sprite.Type;
            var FillType$2 = Sprite.FillType;
            var spriteAssembler = exports('spriteAssembler', {
              getAssembler: function getAssembler(spriteComp) {
                var util = simple;
                var comp = spriteComp;

                switch (comp.type) {
                  case SpriteType$1.SLICED:
                    util = sliced;
                    break;

                  case SpriteType$1.TILED:
                    util = tiled;
                    break;

                  case SpriteType$1.FILLED:
                    if (comp.fillType === FillType$2.RADIAL) {
                      util = radialFilled;
                    } else {
                      util = barFilled;
                    }

                    break;
                }

                return util;
              }
            });
            Sprite.Assembler = spriteAssembler;

            var mouseEvents = [Input.EventType.MOUSE_DOWN, Input.EventType.MOUSE_MOVE, Input.EventType.MOUSE_UP, Input.EventType.MOUSE_WHEEL];
            var touchEvents = [Input.EventType.TOUCH_START, Input.EventType.TOUCH_MOVE, Input.EventType.TOUCH_END, Input.EventType.TOUCH_CANCEL];

            var PointerEventDispatcher = function () {
              function PointerEventDispatcher() {
                this.priority = EventDispatcherPriority.UI;
                this._isListDirty = false;
                this._inDispatchCount = 0;
                this._pointerEventProcessorList = [];
                this._processorListToAdd = [];
                this._processorListToRemove = [];

                input._registerEventDispatcher(this);

                NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.ADD_POINTER_EVENT_PROCESSOR, this.addPointerEventProcessor, this);
                NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this.removePointerEventProcessor, this);
                NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.MARK_LIST_DIRTY, this._markListDirty, this);
              }

              var _proto = PointerEventDispatcher.prototype;

              _proto.dispatchEvent = function dispatchEvent(event) {
                var eventType = event.type;

                if (touchEvents.includes(eventType)) {
                  return this.dispatchEventTouch(event);
                } else if (mouseEvents.includes(eventType)) {
                  return this.dispatchEventMouse(event);
                }

                return true;
              };

              _proto.addPointerEventProcessor = function addPointerEventProcessor(pointerEventProcessor) {
                if (this._inDispatchCount === 0) {
                  if (!this._pointerEventProcessorList.includes(pointerEventProcessor)) {
                    this._pointerEventProcessorList.push(pointerEventProcessor);

                    this._isListDirty = true;
                  }
                } else if (!this._processorListToAdd.includes(pointerEventProcessor)) {
                  this._processorListToAdd.push(pointerEventProcessor);
                }

                remove(this._processorListToRemove, pointerEventProcessor);
              };

              _proto.removePointerEventProcessor = function removePointerEventProcessor(pointerEventProcessor) {
                if (this._inDispatchCount === 0) {
                  remove(this._pointerEventProcessorList, pointerEventProcessor);
                  this._isListDirty = true;
                } else if (!this._processorListToRemove.includes(pointerEventProcessor)) {
                  this._processorListToRemove.push(pointerEventProcessor);
                }

                remove(this._processorListToAdd, pointerEventProcessor);
              };

              _proto.dispatchEventMouse = function dispatchEventMouse(eventMouse) {
                this._inDispatchCount++;

                this._sortPointerEventProcessorList();

                var pointerEventProcessorList = this._pointerEventProcessorList;
                var length = pointerEventProcessorList.length;
                var dispatchToNextEventDispatcher = true;

                for (var i = 0; i < length; ++i) {
                  var pointerEventProcessor = pointerEventProcessorList[i];

                  if (pointerEventProcessor.isEnabled && pointerEventProcessor.shouldHandleEventMouse && pointerEventProcessor._handleEventMouse(eventMouse)) {
                    dispatchToNextEventDispatcher = false;

                    if (!eventMouse.preventSwallow) {
                      break;
                    } else {
                      eventMouse.preventSwallow = false;
                    }
                  }
                }

                if (--this._inDispatchCount <= 0) {
                  this._updatePointerEventProcessorList();
                }

                return dispatchToNextEventDispatcher;
              };

              _proto.dispatchEventTouch = function dispatchEventTouch(eventTouch) {
                this._inDispatchCount++;

                this._sortPointerEventProcessorList();

                var pointerEventProcessorList = this._pointerEventProcessorList;
                var length = pointerEventProcessorList.length;
                var touch = eventTouch.touch;
                var dispatchToNextEventDispatcher = true;

                for (var i = 0; i < length; ++i) {
                  var pointerEventProcessor = pointerEventProcessorList[i];

                  if (pointerEventProcessor.isEnabled && pointerEventProcessor.shouldHandleEventTouch) {
                    if (eventTouch.type === InputEventType.TOUCH_START) {
                      if (pointerEventProcessor._handleEventTouch(eventTouch)) {
                        pointerEventProcessor.claimedTouchIdList.push(touch.getID());
                        dispatchToNextEventDispatcher = false;

                        if (!eventTouch.preventSwallow) {
                          break;
                        } else {
                          eventTouch.preventSwallow = false;
                        }
                      }
                    } else if (pointerEventProcessor.claimedTouchIdList.length > 0) {
                      var index = pointerEventProcessor.claimedTouchIdList.indexOf(touch.getID());

                      if (index !== -1) {
                        pointerEventProcessor._handleEventTouch(eventTouch);

                        if (eventTouch.type === InputEventType.TOUCH_END || eventTouch.type === InputEventType.TOUCH_CANCEL) {
                          removeAt(pointerEventProcessor.claimedTouchIdList, index);
                        }

                        dispatchToNextEventDispatcher = false;

                        if (!eventTouch.preventSwallow) {
                          break;
                        } else {
                          eventTouch.preventSwallow = false;
                        }
                      }
                    }
                  }
                }

                if (--this._inDispatchCount <= 0) {
                  this._updatePointerEventProcessorList();
                }

                return dispatchToNextEventDispatcher;
              };

              _proto._updatePointerEventProcessorList = function _updatePointerEventProcessorList() {
                var listToAdd = this._processorListToAdd;
                var addLength = listToAdd.length;

                for (var i = 0; i < addLength; ++i) {
                  this.addPointerEventProcessor(listToAdd[i]);
                }

                listToAdd.length = 0;
                var listToRemove = this._processorListToRemove;
                var removeLength = listToRemove.length;

                for (var _i = 0; _i < removeLength; ++_i) {
                  this.removePointerEventProcessor(listToRemove[_i]);
                }

                listToRemove.length = 0;
              };

              _proto._sortPointerEventProcessorList = function _sortPointerEventProcessorList() {
                if (!this._isListDirty) {
                  return;
                }

                var pointerEventProcessorList = this._pointerEventProcessorList;
                var length = pointerEventProcessorList.length;

                for (var i = 0; i < length; ++i) {
                  var pointerEventProcessor = pointerEventProcessorList[i];
                  var node = pointerEventProcessor.node;

                  if (node._uiProps) {
                    var trans = node._uiProps.uiTransformComp;
                    pointerEventProcessor.cachedCameraPriority = trans.cameraPriority;
                  }
                }

                pointerEventProcessorList.sort(this._sortByPriority);
                this._isListDirty = false;
              };

              _proto._sortByPriority = function _sortByPriority(p1, p2) {
                var node1 = p1.node;
                var node2 = p2.node;

                if (!p2 || !node2 || !node2.activeInHierarchy || !node2._uiProps.uiTransformComp) {
                  return -1;
                } else if (!p1 || !node1 || !node1.activeInHierarchy || !node1._uiProps.uiTransformComp) {
                  return 1;
                }

                if (p1.cachedCameraPriority !== p2.cachedCameraPriority) {
                  return p2.cachedCameraPriority - p1.cachedCameraPriority;
                }

                var n1 = node1;
                var n2 = node2;
                var ex = false;

                while (((_n1$parent = n1.parent) === null || _n1$parent === void 0 ? void 0 : _n1$parent._id) !== ((_n2$parent = n2.parent) === null || _n2$parent === void 0 ? void 0 : _n2$parent._id)) {
                  var _n1$parent, _n2$parent, _n, _n$parent, _n2, _n2$parent2;

                  n1 = ((_n = n1) === null || _n === void 0 ? void 0 : (_n$parent = _n.parent) === null || _n$parent === void 0 ? void 0 : _n$parent.parent) === null ? (ex = true) && node2 : n1 && n1.parent;
                  n2 = ((_n2 = n2) === null || _n2 === void 0 ? void 0 : (_n2$parent2 = _n2.parent) === null || _n2$parent2 === void 0 ? void 0 : _n2$parent2.parent) === null ? (ex = true) && node1 : n2 && n2.parent;
                }

                if (n1._id === n2._id) {
                  if (n1._id === node2._id) {
                    return -1;
                  }

                  if (n1._id === node1._id) {
                    return 1;
                  }
                }

                var priority1 = n1 ? n1.getSiblingIndex() : 0;
                var priority2 = n2 ? n2.getSiblingIndex() : 0;
                return ex ? priority1 - priority2 : priority2 - priority1;
              };

              _proto._markListDirty = function _markListDirty() {
                this._isListDirty = true;
              };

              return PointerEventDispatcher;
            }();

            var pointerEventDispatcher = new PointerEventDispatcher();

            var _dsInfo = new DescriptorSetInfo(null);

            var m4_1 = new Mat4();
            var Batcher2D = function () {
              function Batcher2D(_root) {
                var _this = this;

                this.device = void 0;
                this._screens = [];
                this._staticVBBuffer = null;
                this._bufferAccessors = new Map();
                this._drawBatchPool = void 0;
                this._batches = void 0;
                this._currBID = -1;
                this._indexStart = 0;
                this._emptyMaterial = new Material();
                this._currRenderData = null;
                this._currMaterial = this._emptyMaterial;
                this._currTexture = null;
                this._currSampler = null;
                this._currStaticRoot = null;
                this._currComponent = null;
                this._currTransform = null;
                this._currTextureHash = 0;
                this._currSamplerHash = 0;
                this._currLayer = 0;
                this._currDepthStencilStateStage = null;
                this._currIsStatic = false;
                this._currHash = 0;
                this._currIsMiddleware = false;
                this._middlewareEnableBatch = false;
                this._middlewareBuffer = null;
                this._middlewareIndexStart = 0;
                this._middlewareIndexCount = 0;
                this._pOpacity = 1;
                this._opacityDirty = 0;
                this._descriptorSetCache = new DescriptorSetCache();
                this._meshDataArray = [];
                this._maskClearModel = null;
                this._maskClearMtl = null;
                this._maskModelMesh = null;
                this._root = _root;
                this.device = _root.device;
                this._batches = new CachedArray(64);
                this._drawBatchPool = new Pool(function () {
                  return new DrawBatch2D();
                }, 128, function (obj) {
                  return obj.destroy(_this);
                });
              }

              var _proto = Batcher2D.prototype;

              _proto.initialize = function initialize() {
                return true;
              };

              _proto.destroy = function destroy() {
                for (var i = 0; i < this._batches.length; i++) {
                  if (this._batches.array[i]) {
                    this._batches.array[i].destroy(this);
                  }
                }

                this._batches.destroy();

                for (var _iterator = _createForOfIteratorHelperLoose(this._bufferAccessors.values()), _step; !(_step = _iterator()).done;) {
                  var accessor = _step.value;
                  accessor.destroy();
                }

                this._bufferAccessors.clear();

                if (this._drawBatchPool) {
                  this._drawBatchPool.destroy();
                }

                this._descriptorSetCache.destroy();

                StencilManager.sharedManager.destroy();

                if (this._maskClearModel && this._maskModelMesh) {
                  legacyCC.director.root.destroyModel(this._maskClearModel);

                  this._maskModelMesh.destroy();
                }

                if (this._maskClearMtl) {
                  this._maskClearMtl.destroy();
                }
              };

              _proto.syncRootNodesToNative = function syncRootNodesToNative() {
              };

              _proto.addScreen = function addScreen(comp) {
                this._screens.push(comp);

                this._screens.sort(this._screenSort);
              };

              _proto.removeScreen = function removeScreen(comp) {
                var idx = this._screens.indexOf(comp);

                if (idx === -1) {
                  return;
                }

                this._screens.splice(idx, 1);
              };

              _proto.sortScreens = function sortScreens() {
                this._screens.sort(this._screenSort);
              };

              _proto.getFirstRenderCamera = function getFirstRenderCamera(node) {
                if (node.scene && node.scene.renderScene) {
                  var cameras = node.scene.renderScene.cameras;

                  for (var i = 0; i < cameras.length; i++) {
                    var camera = cameras[i];

                    if (camera.visibility & node.layer) {
                      return camera;
                    }
                  }
                }

                return null;
              };

              _proto.update = function update() {

                var screens = this._screens;
                var offset = 0;

                for (var i = 0; i < screens.length; ++i) {
                  var screen = screens[i];

                  var _scene = screen._getRenderScene();

                  if (!screen.enabledInHierarchy || !_scene) {
                    continue;
                  }

                  this._opacityDirty = 0;
                  this._pOpacity = 1;
                  this.walk(screen.node);
                  this.autoMergeBatches(this._currComponent);
                  this.resetRenderStates();
                  var batchPriority = 0;

                  if (this._batches.length > offset) {
                    for (; offset < this._batches.length; ++offset) {
                      var batch = this._batches.array[offset];

                      if (batch.model) {
                        var subModels = batch.model.subModels;

                        for (var j = 0; j < subModels.length; j++) {
                          subModels[j].priority = batchPriority++;
                        }
                      } else {
                        batch.descriptorSet = this._descriptorSetCache.getDescriptorSet(batch);
                      }

                      _scene.addBatch(batch);
                    }
                  }
                }
              };

              _proto.uploadBuffers = function uploadBuffers() {
                if (this._batches.length > 0) {
                  var length = this._meshDataArray.length;

                  for (var i = 0; i < length; i++) {
                    this._meshDataArray[i].uploadBuffers();
                  }

                  for (var _iterator3 = _createForOfIteratorHelperLoose(this._bufferAccessors.values()), _step3; !(_step3 = _iterator3()).done;) {
                    var accessor = _step3.value;
                    accessor.uploadBuffers();
                    accessor.reset();
                  }

                  this._descriptorSetCache.update();
                }
              };

              _proto.reset = function reset() {
                {
                  for (var i = 0; i < this._batches.length; ++i) {
                    var batch = this._batches.array[i];

                    if (batch.isStatic) {
                      continue;
                    }

                    batch.clear();

                    this._drawBatchPool.free(batch);
                  }

                  for (var _iterator4 = _createForOfIteratorHelperLoose(this._bufferAccessors.values()), _step4; !(_step4 = _iterator4()).done;) {
                    var accessor = _step4.value;
                    accessor.reset();
                  }

                  var length = this._meshDataArray.length;

                  for (var _i = 0; _i < length; _i++) {
                    this._meshDataArray[_i].freeIAPool();
                  }

                  this._meshDataArray.length = 0;
                  this._staticVBBuffer = null;
                  this._currBID = -1;
                  this._indexStart = 0;
                  this._currHash = 0;
                  this._currLayer = 0;
                  this._currRenderData = null;
                  this._currMaterial = this._emptyMaterial;
                  this._currTexture = null;
                  this._currSampler = null;
                  this._currComponent = null;
                  this._currTransform = null;

                  this._batches.clear();

                  StencilManager.sharedManager.reset();
                }
              };

              _proto.switchBufferAccessor = function switchBufferAccessor(attributes) {
                if (attributes === void 0) {
                  attributes = vfmtPosUvColor;
                }

                var strideBytes = attributes === vfmtPosUvColor ? 36 : getAttributeStride(attributes);

                if (!this._staticVBBuffer || this._staticVBBuffer.vertexFormatBytes !== strideBytes) {
                  var accessor = this._bufferAccessors.get(strideBytes);

                  if (!accessor) {
                    accessor = new StaticVBAccessor(this.device, attributes);

                    this._bufferAccessors.set(strideBytes, accessor);
                  }

                  this._staticVBBuffer = accessor;
                  this._currBID = -1;
                }

                return this._staticVBBuffer;
              };

              _proto.registerBufferAccessor = function registerBufferAccessor(key, accessor) {
                this._bufferAccessors.set(key, accessor);
              };

              _proto.updateBuffer = function updateBuffer(attributes, bid) {
                var accessor = this.switchBufferAccessor(attributes);

                if (this._currBID !== bid) {
                  this._currBID = bid;
                  this._indexStart = accessor.getMeshBuffer(bid).indexOffset;
                }
              };

              _proto.commitComp = function commitComp(comp, renderData, frame, assembler, transform) {
                var dataHash = 0;
                var mat;
                var bufferID = -1;

                if (renderData && renderData.chunk) {
                  if (!renderData.isValid()) return;
                  dataHash = renderData.dataHash;
                  mat = renderData.material;
                  bufferID = renderData.chunk.bufferId;
                }

                if (comp.stencilStage === Stage.ENTER_LEVEL || comp.stencilStage === Stage.ENTER_LEVEL_INVERTED) {
                  this._insertMaskBatch(comp);
                } else {
                  comp.stencilStage = StencilManager.sharedManager.stage;
                }

                var depthStencilStateStage = comp.stencilStage;

                if (this._currHash !== dataHash || dataHash === 0 || this._currMaterial !== mat || this._currDepthStencilStateStage !== depthStencilStateStage) {
                  this.autoMergeBatches(this._currComponent);

                  if (renderData && !renderData._isMeshBuffer) {
                    this.updateBuffer(renderData.vertexFormat, bufferID);
                  }

                  this._currRenderData = renderData;
                  this._currHash = renderData ? renderData.dataHash : 0;
                  this._currComponent = comp;
                  this._currTransform = transform;
                  this._currMaterial = comp.getRenderMaterial(0);
                  this._currDepthStencilStateStage = depthStencilStateStage;
                  this._currLayer = comp.node.layer;

                  if (frame) {
                    {
                      assert(frame.isValid, 'frame should not be invalid, it may have been released');
                    }

                    this._currTexture = frame.getGFXTexture();
                    this._currSampler = frame.getGFXSampler();
                    this._currTextureHash = frame.getHash();
                    this._currSamplerHash = this._currSampler.hash;
                  } else {
                    this._currTexture = null;
                    this._currSampler = null;
                    this._currTextureHash = 0;
                    this._currSamplerHash = 0;
                  }
                }

                assembler.fillBuffers(comp, this);
              };

              _proto.commitIA = function commitIA(renderComp, ia, tex, mat, transform) {
                if (this._currMaterial !== this._emptyMaterial) {
                  this.autoMergeBatches(this._currComponent);
                  this.resetRenderStates();
                }

                var depthStencil;
                var dssHash = 0;

                if (renderComp) {
                  renderComp.stencilStage = StencilManager.sharedManager.stage;

                  if (renderComp.customMaterial !== null) {
                    depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage, mat);
                  } else {
                    depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage);
                  }

                  dssHash = StencilManager.sharedManager.getStencilHash(renderComp.stencilStage);
                }

                var curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
                curDrawBatch.visFlags = renderComp.node.layer;
                curDrawBatch.inputAssembler = ia;
                curDrawBatch.useLocalData = transform || null;

                if (tex) {
                  curDrawBatch.texture = tex.getGFXTexture();
                  curDrawBatch.sampler = tex.getGFXSampler();
                  curDrawBatch.textureHash = tex.getHash();
                  curDrawBatch.samplerHash = curDrawBatch.sampler.hash;
                }

                curDrawBatch.fillPasses(mat || null, depthStencil, dssHash, null);

                this._batches.push(curDrawBatch);
              };

              _proto.commitMiddleware = function commitMiddleware(comp, meshBuffer, indexOffset, indexCount, tex, mat, enableBatch) {
                var texture = tex.getGFXTexture();

                if (enableBatch && this._middlewareEnableBatch && this._middlewareBuffer === meshBuffer && this._currTexture === texture && this._currMaterial.hash === mat.hash && this._middlewareIndexStart + this._middlewareIndexCount === indexOffset && this._currLayer === comp.node.layer) {
                  this._middlewareIndexCount += indexCount;
                } else {
                  this.autoMergeBatches(this._currComponent);
                  this.resetRenderStates();
                  this._currComponent = comp;
                  this._currTexture = texture;
                  this._currSampler = tex.getGFXSampler();
                  this._currTextureHash = tex.getHash();
                  this._currLayer = comp.node.layer;
                  this._currSamplerHash = this._currSampler.hash;
                  this._currHash = 0;
                  this._currTransform = enableBatch ? null : comp.node;
                  this._middlewareEnableBatch = enableBatch;
                  this._middlewareBuffer = meshBuffer;
                  this._currMaterial = mat;
                  this._middlewareIndexStart = indexOffset;
                  this._middlewareIndexCount = indexCount;
                }

                this._currIsMiddleware = true;
              };

              _proto.commitModel = function commitModel(comp, model, mat) {
                if (this._currMaterial !== this._emptyMaterial) {
                  this.autoMergeBatches(this._currComponent);
                  this.resetRenderStates();
                }

                var depthStencil;
                var dssHash = 0;

                if (mat) {
                  if (comp.stencilStage === Stage.ENTER_LEVEL || comp.stencilStage === Stage.ENTER_LEVEL_INVERTED) {
                    this._insertMaskBatch(comp);
                  } else {
                    comp.stencilStage = StencilManager.sharedManager.stage;
                  }

                  depthStencil = StencilManager.sharedManager.getStencilStage(comp.stencilStage, mat);
                  dssHash = StencilManager.sharedManager.getStencilHash(comp.stencilStage);
                }

                var stamp = legacyCC.director.getTotalFrames();

                if (model) {
                  model.updateTransform(stamp);
                  model.updateUBOs(stamp);
                }

                for (var i = 0; i < model.subModels.length; i++) {
                  var curDrawBatch = this._drawBatchPool.alloc();

                  var subModel = model.subModels[i];
                  curDrawBatch.visFlags = comp.node.layer;
                  curDrawBatch.model = model;
                  curDrawBatch.texture = null;
                  curDrawBatch.sampler = null;
                  curDrawBatch.useLocalData = null;

                  if (!depthStencil) {
                    depthStencil = null;
                  }

                  curDrawBatch.fillPasses(mat, depthStencil, dssHash, subModel.patches);
                  curDrawBatch.inputAssembler = subModel.inputAssembler;
                  curDrawBatch.model.visFlags = curDrawBatch.visFlags;
                  curDrawBatch.descriptorSet = subModel.descriptorSet;

                  this._batches.push(curDrawBatch);
                }
              };

              _proto.setupStaticBatch = function setupStaticBatch(staticComp, bufferAccessor) {
                this.finishMergeBatches();
                this._staticVBBuffer = bufferAccessor;
                this.currStaticRoot = staticComp;
              };

              _proto.endStaticBatch = function endStaticBatch() {
                this.finishMergeBatches();
                this.currStaticRoot = null;
                this._staticVBBuffer = null;
                this.switchBufferAccessor();
              };

              _proto.commitStaticBatch = function commitStaticBatch(comp) {
                this._batches.concat(comp.drawBatchList);

                this.finishMergeBatches();
              };

              _proto.autoMergeBatches = function autoMergeBatches(renderComp) {
                if (this._currIsMiddleware) {
                  this.mergeBatchesForMiddleware(renderComp);
                  return;
                }

                var mat = this._currMaterial;

                if (!mat) {
                  return;
                }

                var ia;
                var rd = this._currRenderData;
                var accessor = this._staticVBBuffer;

                if (rd && rd._isMeshBuffer) {
                  ia = rd.requestIA(this.device);

                  if (this._meshDataArray.indexOf(rd) === -1) {
                    this._meshDataArray.push(rd);
                  }
                } else if (accessor) {
                  var bid = this._currBID;
                  var buf = accessor.getMeshBuffer(bid);

                  if (!buf) {
                    return;
                  }

                  var indexCount = buf.indexOffset - this._indexStart;
                  if (indexCount <= 0) return;
                  assertIsTrue(this._indexStart < buf.indexOffset);
                  buf.setDirty();
                  ia = buf.requireFreeIA(this.device);
                  ia.firstIndex = this._indexStart;
                  ia.indexCount = indexCount;
                  this._indexStart = buf.indexOffset;
                }

                this._currBID = -1;

                if (!ia) {
                  return;
                }

                var depthStencil;
                var dssHash = 0;

                if (renderComp) {
                  if (renderComp.customMaterial !== null) {
                    depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage, mat);
                  } else {
                    depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage);
                  }

                  dssHash = StencilManager.sharedManager.getStencilHash(renderComp.stencilStage);
                }

                var curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
                curDrawBatch.visFlags = this._currLayer;
                curDrawBatch.texture = this._currTexture;
                curDrawBatch.sampler = this._currSampler;
                curDrawBatch.inputAssembler = ia;
                curDrawBatch.useLocalData = this._currTransform;
                curDrawBatch.textureHash = this._currTextureHash;
                curDrawBatch.samplerHash = this._currSamplerHash;
                curDrawBatch.fillPasses(mat, depthStencil, dssHash, null);

                this._batches.push(curDrawBatch);
              };

              _proto.mergeBatchesForMiddleware = function mergeBatchesForMiddleware(renderComp) {
                var depthStencil;
                var dssHash = 0;
                renderComp.stencilStage = StencilManager.sharedManager.stage;

                if (renderComp.customMaterial !== null) {
                  depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage, this._currMaterial);
                } else {
                  depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage);
                }

                dssHash = StencilManager.sharedManager.getStencilHash(renderComp.stencilStage);
                var curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
                curDrawBatch.visFlags = renderComp.node.layer;

                var ia = this._middlewareBuffer.requireFreeIA(this.device);

                ia.firstIndex = this._middlewareIndexStart;
                ia.indexCount = this._middlewareIndexCount;
                curDrawBatch.inputAssembler = ia;
                curDrawBatch.useLocalData = this._currTransform;
                curDrawBatch.texture = this._currTexture;
                curDrawBatch.sampler = this._currSampler;
                curDrawBatch.textureHash = this._currTextureHash;
                curDrawBatch.samplerHash = this._currSamplerHash;
                curDrawBatch.fillPasses(this._currMaterial || null, depthStencil, dssHash, null);

                this._batches.push(curDrawBatch);

                this._currIsMiddleware = false;
                this._middlewareBuffer = null;
              };

              _proto.forceMergeBatches = function forceMergeBatches(material, frame, renderComp) {
                this._currMaterial = material;

                if (frame) {
                  this._currTexture = frame.getGFXTexture();
                  this._currSampler = frame.getGFXSampler();
                  this._currTextureHash = frame.getHash();
                  this._currSamplerHash = this._currSampler.hash;
                } else {
                  this._currTexture = this._currSampler = null;
                  this._currTextureHash = this._currSamplerHash = 0;
                }

                this._currLayer = renderComp.node.layer;
                this.autoMergeBatches(renderComp);
              };

              _proto.resetRenderStates = function resetRenderStates() {
                this._currMaterial = this._emptyMaterial;
                this._currRenderData = null;
                this._currTexture = null;
                this._currComponent = null;
                this._currTransform = null;
                this._currTextureHash = 0;
                this._currSamplerHash = 0;
                this._currLayer = 0;
              };

              _proto.finishMergeBatches = function finishMergeBatches() {
                this.autoMergeBatches();
                this.resetRenderStates();
              };

              _proto.flushMaterial = function flushMaterial(mat) {
                this._currMaterial = mat;
              };

              _proto.walk = function walk(node, level) {
                if (level === void 0) {
                  level = 0;
                }

                if (!node.activeInHierarchy) {
                  return;
                }

                var children = node.children;
                var uiProps = node._uiProps;
                var render = uiProps.uiComp;
                var parentOpacity = this._pOpacity;
                var opacity = parentOpacity;
                var selfOpacity = render && render.color ? render.color.a / 255 : 1;
                this._pOpacity = opacity *= selfOpacity * uiProps.localOpacity;
                uiProps._opacity = opacity;

                if (!approx(opacity, 0, EPSILON$2)) {
                  if (uiProps.colorDirty) {
                    this._opacityDirty++;
                  }

                  if (render && render.enabledInHierarchy) {
                    render.fillBuffers(this);
                  }

                  if (this._opacityDirty && render && !render.useVertexOpacity && render.renderData && render.renderData.vertexCount > 0) {
                    updateOpacity(render.renderData, opacity);
                    var buffer = render.renderData.getMeshBuffer();

                    if (buffer) {
                      buffer.setDirty();
                    }
                  }

                  if (children.length > 0 && !node._static) {
                    for (var i = 0; i < children.length; ++i) {
                      var child = children[i];
                      this.walk(child, level);
                    }
                  }

                  if (uiProps.colorDirty) {
                    this._opacityDirty--;
                    uiProps.colorDirty = false;
                  }
                }

                this._pOpacity = parentOpacity;

                if (render && render.enabledInHierarchy) {
                  render.postUpdateAssembler(this);

                  if ((render.stencilStage === Stage.ENTER_LEVEL || render.stencilStage === Stage.ENTER_LEVEL_INVERTED) && StencilManager.sharedManager.getMaskStackSize() > 0) {
                    this.autoMergeBatches(this._currComponent);
                    this.resetRenderStates();
                    StencilManager.sharedManager.exitMask();
                  }
                }

                level += 1;
              };

              _proto._screenSort = function _screenSort(a, b) {
                return a.node.getSiblingIndex() - b.node.getSiblingIndex();
              };

              _proto._releaseDescriptorSetCache = function _releaseDescriptorSetCache(textureHash, sampler) {

                {
                  this._descriptorSetCache.releaseDescriptorSetCache(textureHash);
                }
              };

              _proto._createClearModel = function _createClearModel() {
                if (!this._maskClearModel) {
                  this._maskClearMtl = builtinResMgr.get('default-clear-stencil');
                  this._maskClearModel = legacyCC.director.root.createModel(Model);
                  var stride = getAttributeStride(vfmt);
                  var gfxDevice = deviceManager.gfxDevice;
                  var vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 4 * stride, stride));
                  var vb = new Float32Array([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]);
                  vertexBuffer.update(vb);
                  var indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 6 * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));
                  var ib = new Uint16Array([0, 1, 2, 2, 1, 3]);
                  indexBuffer.update(ib);
                  this._maskModelMesh = new RenderingSubMesh([vertexBuffer], vfmt, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
                  this._maskModelMesh.subMeshIdx = 0;

                  this._maskClearModel.initSubModel(0, this._maskModelMesh, this._maskClearMtl);
                }
              };

              _proto._insertMaskBatch = function _insertMaskBatch(comp) {
                this.autoMergeBatches(this._currComponent);
                this.resetRenderStates();

                this._createClearModel();

                this._maskClearModel.node = this._maskClearModel.transform = comp.node;
                var _stencilManager = StencilManager.sharedManager;

                _stencilManager.pushMask(1);

                var stage = _stencilManager.clear(comp);

                var depthStencil;
                var dssHash = 0;
                var mat = this._maskClearMtl;

                if (mat) {
                  depthStencil = _stencilManager.getStencilStage(stage, mat);
                  dssHash = _stencilManager.getStencilHash(stage);
                }

                var model = this._maskClearModel;
                var stamp = legacyCC.director.getTotalFrames();

                if (model) {
                  model.updateTransform(stamp);
                  model.updateUBOs(stamp);
                }

                for (var i = 0; i < model.subModels.length; i++) {
                  var curDrawBatch = this._drawBatchPool.alloc();

                  var subModel = model.subModels[i];
                  curDrawBatch.visFlags = comp.node.layer;
                  curDrawBatch.model = model;
                  curDrawBatch.texture = null;
                  curDrawBatch.sampler = null;
                  curDrawBatch.useLocalData = null;

                  if (!depthStencil) {
                    depthStencil = null;
                  }

                  curDrawBatch.fillPasses(mat, depthStencil, dssHash, subModel.patches);
                  curDrawBatch.inputAssembler = subModel.inputAssembler;
                  curDrawBatch.model.visFlags = curDrawBatch.visFlags;
                  curDrawBatch.descriptorSet = subModel.descriptorSet;

                  this._batches.push(curDrawBatch);
                }

                _stencilManager.enableMask();
              };

              _proto.syncMeshBuffersToNative = function syncMeshBuffersToNative(accId, buffers) {
              };

              _createClass(Batcher2D, [{
                key: "nativeObj",
                get: function get() {
                  return this._nativeObj;
                }
              }, {
                key: "currBufferAccessor",
                get: function get() {
                  if (this._staticVBBuffer) return this._staticVBBuffer;
                  this._staticVBBuffer = this.switchBufferAccessor();
                  return this._staticVBBuffer;
                }
              }, {
                key: "batches",
                get: function get() {
                  return this._batches;
                }
              }, {
                key: "currStaticRoot",
                set: function set(value) {
                  this._currStaticRoot = value;
                }
              }, {
                key: "currIsStatic",
                set: function set(value) {
                  this._currIsStatic = value;
                }
              }]);

              return Batcher2D;
            }();

            var LocalDescriptorSet = function () {
              function LocalDescriptorSet() {
                this._descriptorSet = null;
                this._transform = null;
                this._textureHash = 0;
                this._samplerHash = 0;
                this._localBuffer = null;
                this._transformUpdate = true;
                var device = deviceManager.gfxDevice;
                this._localData = new Float32Array(UBOLocal.COUNT);
                this._localBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOLocal.SIZE, UBOLocal.SIZE));
              }

              var _proto2 = LocalDescriptorSet.prototype;

              _proto2.initialize = function initialize(batch) {
                var device = deviceManager.gfxDevice;
                this._transform = batch.useLocalData;
                this._textureHash = batch.textureHash;
                this._samplerHash = batch.samplerHash;
                _dsInfo.layout = batch.passes[0].localSetLayout;
                this._descriptorSet = device.createDescriptorSet(_dsInfo);

                this._descriptorSet.bindBuffer(UBOLocal.BINDING, this._localBuffer);

                var binding = ModelLocalBindings.SAMPLER_SPRITE;

                this._descriptorSet.bindTexture(binding, batch.texture);

                this._descriptorSet.bindSampler(binding, batch.sampler);

                this._descriptorSet.update();

                this._transformUpdate = true;
              };

              _proto2.updateTransform = function updateTransform(transform) {
                if (transform === this._transform) return;
                this._transform = transform;
                this._transformUpdate = true;
                this.uploadLocalData();
              };

              _proto2.equals = function equals(transform, textureHash, samplerHash) {
                return this._transform === transform && this._textureHash === textureHash && this._samplerHash === samplerHash;
              };

              _proto2.reset = function reset() {
                this._transform = null;
                this._textureHash = 0;
                this._samplerHash = 0;
              };

              _proto2.destroy = function destroy() {
                if (this._localBuffer) {
                  this._localBuffer.destroy();

                  this._localBuffer = null;
                }

                if (this._descriptorSet) {
                  this._descriptorSet.destroy();

                  this._descriptorSet = null;
                }

                this._localData = null;
              };

              _proto2.isValid = function isValid() {
                return this._transform && this._transform.isValid;
              };

              _proto2.uploadLocalData = function uploadLocalData() {
                var node = this._transform;

                if (node.hasChangedFlags || node.isTransformDirty()) {
                  node.updateWorldTransform();
                  this._transformUpdate = true;
                }

                if (this._transformUpdate) {
                  var worldMatrix = node.worldMatrix;
                  Mat4.toArray(this._localData, worldMatrix, UBOLocal.MAT_WORLD_OFFSET);
                  Mat4.inverseTranspose(m4_1, worldMatrix);

                  {
                    var det = Mat4.determinant(m4_1);
                    var factor = 1.0 / Math.sqrt(det);
                    Mat4.multiplyScalar(m4_1, m4_1, factor);
                  }

                  Mat4.toArray(this._localData, m4_1, UBOLocal.MAT_WORLD_IT_OFFSET);

                  this._localBuffer.update(this._localData);

                  this._transformUpdate = false;
                }
              };

              _createClass(LocalDescriptorSet, [{
                key: "descriptorSet",
                get: function get() {
                  return this._descriptorSet;
                }
              }]);

              return LocalDescriptorSet;
            }();

            var DescriptorSetCache = function () {
              function DescriptorSetCache() {
                this._descriptorSetCache = new Map();
                this._dsCacheHashByTexture = new Map();
                this._localDescriptorSetCache = [];
                this._localCachePool = void 0;
                this._localCachePool = new Pool(function () {
                  return new LocalDescriptorSet();
                }, 16, function (obj) {
                  return obj.destroy();
                });
              }

              var _proto3 = DescriptorSetCache.prototype;

              _proto3.getDescriptorSet = function getDescriptorSet(batch) {
                var root = legacyCC.director.root;
                var hash;

                if (batch.useLocalData) {
                  var caches = this._localDescriptorSetCache;

                  for (var i = 0, len = caches.length; i < len; i++) {
                    var cache = caches[i];

                    if (cache.equals(batch.useLocalData, batch.textureHash, batch.samplerHash)) {
                      return cache.descriptorSet;
                    }
                  }

                  var localDs = this._localCachePool.alloc();

                  localDs.initialize(batch);

                  this._localDescriptorSetCache.push(localDs);

                  return localDs.descriptorSet;
                } else {
                  hash = batch.textureHash ^ batch.samplerHash;

                  if (this._descriptorSetCache.has(hash)) {
                    return this._descriptorSetCache.get(hash);
                  } else {
                    _dsInfo.layout = batch.passes[0].localSetLayout;
                    var descriptorSet = deviceManager.gfxDevice.createDescriptorSet(_dsInfo);
                    var binding = ModelLocalBindings.SAMPLER_SPRITE;
                    descriptorSet.bindTexture(binding, batch.texture);
                    descriptorSet.bindSampler(binding, batch.sampler);
                    descriptorSet.update();

                    this._descriptorSetCache.set(hash, descriptorSet);

                    this._dsCacheHashByTexture.set(batch.textureHash, hash);

                    return descriptorSet;
                  }
                }
              };

              _proto3.update = function update() {
                var caches = this._localDescriptorSetCache;
                var length = caches.length;

                if (length === 0) {
                  return;
                }

                var uselessArray = [];

                for (var i = 0; i < length; i++) {
                  var value = caches[i];

                  if (value.isValid()) {
                    value.uploadLocalData();
                  } else {
                    value.reset();
                    var pos = caches.indexOf(value);
                    uselessArray.push(pos);
                  }
                }

                for (var _i2 = uselessArray.length - 1; _i2 >= 0; _i2--) {
                  var index = uselessArray[_i2];
                  var localDs = caches[index];
                  caches.splice(index, 1);

                  this._localCachePool.free(localDs);
                }
              };

              _proto3.reset = function reset() {
                var caches = this._localDescriptorSetCache;
                var length = caches.length;

                for (var i = 0; i < length; i++) {
                  var value = caches[i];

                  this._localCachePool.free(value);
                }

                this._localDescriptorSetCache.length = 0;
              };

              _proto3.releaseDescriptorSetCache = function releaseDescriptorSetCache(textureHash) {
                var key = this._dsCacheHashByTexture.get(textureHash);

                if (key && this._descriptorSetCache.has(key)) {
                  this._descriptorSetCache.get(key).destroy();

                  this._descriptorSetCache["delete"](key);

                  this._dsCacheHashByTexture["delete"](textureHash);
                }
              };

              _proto3.destroy = function destroy() {
                for (var _iterator5 = _createForOfIteratorHelperLoose(this._descriptorSetCache.values()), _step5; !(_step5 = _iterator5()).done;) {
                  var value = _step5.value;
                  value.destroy();
                }

                this._descriptorSetCache.clear();

                this._dsCacheHashByTexture.clear();

                this._localDescriptorSetCache.length = 0;

                this._localCachePool.destroy();
              };

              return DescriptorSetCache;
            }();

            legacyCC.internal.Batcher2D = Batcher2D;

            var ccdocument = ccwindow.document;
            var _canvasContext = null;

            var _intervalId = -1;

            var _testString = "BES bswy:->@123\u4E01\u3041\u1101";

            var _fontFaces = Object.create(null);

            var _loadingFonts = [];
            var _timeout = 3000;

            var useNativeCheck = function () {
              var nativeCheck;
              return function () {
                if (nativeCheck === undefined) {
                  if ('FontFace' in ccwindow) {
                    var match = /Gecko.*Firefox\/(\d+)/.exec(ccwindow.navigator.userAgent);
                    var safari10Match = /OS X.*Version\/10\..*Safari/.exec(ccwindow.navigator.userAgent) && /Apple/.exec(ccwindow.navigator.vendor);

                    if (match) {
                      nativeCheck = parseInt(match[1], 10) > 42;
                    } else if (safari10Match) {
                      nativeCheck = false;
                    } else {
                      nativeCheck = true;
                    }
                  } else {
                    nativeCheck = false;
                  }
                }

                return nativeCheck;
              };
            }();

            function checkFontLoaded() {
              var allFontsLoaded = true;
              var now = Date.now();

              for (var i = _loadingFonts.length - 1; i >= 0; i--) {
                var fontLoadHandle = _loadingFonts[i];
                var fontFamily = fontLoadHandle.fontFamilyName;

                if (now - fontLoadHandle.startTime > _timeout) {
                  warnID(4933, fontFamily);
                  fontLoadHandle.onComplete(null, fontFamily);

                  _loadingFonts.splice(i, 1);

                  continue;
                }

                var oldWidth = fontLoadHandle.refWidth;
                var fontDesc = "40px " + fontFamily;
                _canvasContext.font = fontDesc;
                var newWidth = safeMeasureText(_canvasContext, _testString, fontDesc);

                if (oldWidth !== newWidth) {
                  _loadingFonts.splice(i, 1);

                  fontLoadHandle.onComplete(null, fontFamily);
                } else {
                  allFontsLoaded = false;
                }
              }

              if (allFontsLoaded) {
                clearInterval(_intervalId);
                _intervalId = -1;
              }
            }

            function nativeCheckFontLoaded(start, font, callback) {
              var loader = new Promise(function (resolve, reject) {
                var check = function check() {
                  var now = Date.now();

                  if (now - start >= _timeout) {
                    reject();
                  } else {
                    ccdocument.fonts.load("40px " + font).then(function (fonts) {
                      if (fonts.length >= 1) {
                        resolve();
                      } else {
                        setTimeout(check, 100);
                      }
                    }, function () {
                      reject();
                    });
                  }
                };

                check();
              });
              var timeoutId = null;
              var timer = new Promise(function (resolve, reject) {
                timeoutId = setTimeout(reject, _timeout);
              });
              Promise.race([timer, loader]).then(function () {
                if (timeoutId) {
                  clearTimeout(timeoutId);
                  timeoutId = null;
                }

                callback(null, font);
              }, function () {
                warnID(4933, font);
                callback(null, font);
              });
            }

            function loadFont(url, options, onComplete) {
              var fontFamilyName = getFontFamily(url);

              if (_fontFaces[fontFamilyName]) {
                onComplete(null, fontFamilyName);
                return;
              }

              if (!_canvasContext) {
                var labelCanvas = ccdocument.createElement('canvas');
                labelCanvas.width = 100;
                labelCanvas.height = 100;
                _canvasContext = labelCanvas.getContext('2d');
              }

              var fontDesc = "40px " + fontFamilyName;
              var refWidth = safeMeasureText(_canvasContext, _testString, fontDesc);
              var fontStyle = ccdocument.createElement('style');
              fontStyle.type = 'text/css';
              var fontStr = '';

              if (Number.isNaN(fontFamilyName)) {
                fontStr += "@font-face { font-family:" + fontFamilyName + "; src:";
              } else {
                fontStr += "@font-face { font-family:\"" + fontFamilyName + "\"; src:";
              }

              fontStr += "url(\"" + url + "\");";
              fontStyle.textContent = fontStr + "}";
              ccdocument.body.appendChild(fontStyle);
              var preloadDiv = ccdocument.createElement('div');
              var divStyle = preloadDiv.style;
              divStyle.fontFamily = fontFamilyName;
              preloadDiv.innerHTML = '.';
              divStyle.position = 'absolute';
              divStyle.left = '-100px';
              divStyle.top = '-100px';
              ccdocument.body.appendChild(preloadDiv);

              if (useNativeCheck()) {
                nativeCheckFontLoaded(Date.now(), fontFamilyName, onComplete);
              } else {
                var fontLoadHandle = {
                  fontFamilyName: fontFamilyName,
                  refWidth: refWidth,
                  onComplete: onComplete,
                  startTime: Date.now()
                };

                _loadingFonts.push(fontLoadHandle);

                if (_intervalId === -1) {
                  _intervalId = setInterval(checkFontLoaded, 100);
                }
              }

              _fontFaces[fontFamilyName] = fontStyle;
            }
            function getFontFamily(fontHandle) {
              var ttfIndex = fontHandle.lastIndexOf('.ttf');

              if (ttfIndex === -1) {
                return fontHandle;
              }

              var slashPos = fontHandle.lastIndexOf('/');
              var fontFamilyName;

              if (slashPos === -1) {
                fontFamilyName = fontHandle.substring(0, ttfIndex) + "_LABEL";
              } else {
                fontFamilyName = fontHandle.substring(slashPos + 1, ttfIndex) + "_LABEL";
              }

              if (fontFamilyName.indexOf(' ') !== -1) {
                fontFamilyName = "\"" + fontFamilyName + "\"";
              }

              return fontFamilyName;
            }

            function createFont(id, data, options, onComplete) {
              var out = new TTFFont();
              out._nativeUrl = id;
              out._nativeAsset = data;
              onComplete(null, out);
            }

            downloader.register({
              '.font': loadFont,
              '.eot': loadFont,
              '.ttf': loadFont,
              '.woff': loadFont,
              '.svg': loadFont,
              '.ttc': loadFont
            });
            factory.register({
              '.font': createFont,
              '.eot': createFont,
              '.ttf': createFont,
              '.woff': createFont,
              '.svg': createFont,
              '.ttc': createFont
            });

            legacyCC.UI = {
              MeshBuffer: MeshBuffer,
              spriteAssembler: spriteAssembler,
              graphicsAssembler: graphicsAssemblerManager,
              labelAssembler: labelAssembler,
              RenderData: RenderData,
              MeshRenderData: MeshRenderData
            };

            var SortingLayer = {
              "default": 0
            };
            game.on(Game.EVENT_POST_SUBSYSTEM_INIT, function () {
              SortingLayers.init();
            });
            var SortingLayers = exports('SortingLayers', function () {
              function SortingLayers() {}

              SortingLayers.getSortingPriority = function getSortingPriority(layer, order) {
                if (layer === void 0) {
                  layer = 0;
                }

                if (order === void 0) {
                  order = 0;
                }

                return (layer + (1 << 15) << 16 | order + (1 << 15)) >>> 0;
              };

              SortingLayers.getLayerIndex = function getLayerIndex(layer) {
                if (layer === void 0) {
                  layer = 0;
                }

                var index = 0;

                if (this.indexMap.has(layer)) {
                  index = this.indexMap.get(layer);
                } else {
                  errorID(2105);
                }

                return index;
              };

              SortingLayers.getLayerIndexByName = function getLayerIndexByName(name) {
                var id = this.getLayerByName(name);
                return this.getLayerIndex(id);
              };

              SortingLayers.getLayerName = function getLayerName(layer) {
                if (layer === void 0) {
                  layer = 0;
                }

                var name = '';

                if (this.nameMap.has(layer)) {
                  name = this.nameMap.get(layer);
                } else {
                  errorID(2105);
                }

                return name;
              };

              SortingLayers.getLayerByName = function getLayerByName(name) {
                var count = this.nameMap.size;
                var keyIterator = this.nameMap.keys();
                var key = 0;

                for (var i = 0; i < count; i++) {
                  key = keyIterator.next().value;
                  if (this.nameMap.get(key) === name) return key;
                }

                errorID(2106);
                return 0;
              };

              SortingLayers.isLayerValid = function isLayerValid(id) {
                if (this.indexMap.has(id)) {
                  return true;
                } else {
                  errorID(2105);
                  return false;
                }
              };

              SortingLayers.getBuiltinLayers = function getBuiltinLayers() {
                return [{
                  id: 0,
                  name: 'default',
                  value: 0
                }];
              };

              SortingLayers.init = function init() {
                var sortingLayers = settings.querySettings(Settings.Category.ENGINE, 'sortingLayers');

                if (!sortingLayers || sortingLayers.length === 0) {
                  sortingLayers = this.getBuiltinLayers();
                }

                SortingLayers.resetState();

                for (var i = 0; i < sortingLayers.length; i++) {
                  var layer = sortingLayers[i];
                  SortingLayers.setLayer(layer.id, layer.name, layer.value);
                  SortingLayers.Enum[layer.name] = layer.id;
                }

                Enum.update(SortingLayers.Enum);
                Enum.sortList(SortingLayers.Enum, function (a, b) {
                  return SortingLayers.getLayerIndex(a.value) - SortingLayers.getLayerIndex(b.value);
                });
              };

              SortingLayers.setLayer = function setLayer(layer, layerName, layerIndex) {
                this.nameMap.set(layer, layerName);
                this.indexMap.set(layer, layerIndex);
              };

              SortingLayers.resetState = function resetState() {
                var oldItem = Object.keys(SortingLayers.Enum);

                for (var i = 0; i < oldItem.length; i++) {
                  delete SortingLayers.Enum[SortingLayers.Enum[oldItem[i]]];
                  delete SortingLayers.Enum[oldItem[i]];
                }

                SortingLayers.indexMap.clear();
                SortingLayers.nameMap.clear();
              };

              return SortingLayers;
            }());
            SortingLayers.nameMap = new Map();
            SortingLayers.indexMap = new Map();
            SortingLayers.Enum = Enum(SortingLayer);

            var _dec$o, _dec2$j, _class$o, _class2$j, _initializer$h, _initializer2$d;
            var MAX_INT16 = (1 << 15) - 1;
            var MIN_INT16 = -1 << 15;
            var Sorting = exports('Sorting', (_dec$o = ccclass$p('cc.Sorting'), _dec2$j = type$8(SortingLayers.Enum), _dec$o(_class$o = disallowMultiple(_class$o = (_class2$j = function (_Component) {
              _inheritsLoose(Sorting, _Component);

              function Sorting() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._sortingLayer = _initializer$h && _initializer$h();
                _this._sortingOrder = _initializer2$d && _initializer2$d();
                _this._modelRenderer = null;
                return _this;
              }

              var _proto = Sorting.prototype;

              _proto.__preload = function __preload() {
                this._modelRenderer = this.getComponent('cc.ModelRenderer');

                if (!this._modelRenderer) {
                  warnID(16301, this.node.name);
                }

                this._updateSortingPriority();
              };

              _proto._updateSortingPriority = function _updateSortingPriority() {
                var sortingLayerValue = SortingLayers.getLayerIndex(this._sortingLayer);
                var sortingPriority = SortingLayers.getSortingPriority(sortingLayerValue, this._sortingOrder);

                if (this._modelRenderer && this._modelRenderer.isValid) {
                  this._modelRenderer.priority = sortingPriority;
                }
              };

              _createClass(Sorting, [{
                key: "sortingLayer",
                get: function get() {
                  return this._sortingLayer;
                },
                set: function set(val) {
                  if (val === this._sortingLayer || !SortingLayers.isLayerValid(val)) return;
                  this._sortingLayer = val;

                  this._updateSortingPriority();
                }
              }, {
                key: "sortingOrder",
                get: function get() {
                  return this._sortingOrder;
                },
                set: function set(val) {
                  if (val === this._sortingOrder) return;
                  this._sortingOrder = clamp$1(val, MIN_INT16, MAX_INT16);

                  this._updateSortingPriority();
                }
              }]);

              return Sorting;
            }(Component), (_applyDecoratedDescriptor(_class2$j.prototype, "sortingLayer", [_dec2$j], Object.getOwnPropertyDescriptor(_class2$j.prototype, "sortingLayer"), _class2$j.prototype), _initializer$h = applyDecoratedInitializer(_class2$j.prototype, "_sortingLayer", [serializable$j], function () {
              return SortingLayers.Enum["default"];
            }), _initializer2$d = applyDecoratedInitializer(_class2$j.prototype, "_sortingOrder", [serializable$j], function () {
              return 0;
            })), _class2$j)) || _class$o) || _class$o));

            function checkMaterialisSame(comp1, comp2) {
              var matNum = comp1.sharedMaterials.length;

              if (matNum !== comp2.sharedMaterials.length) {
                return false;
              }

              for (var i = 0; i < matNum; i++) {
                if (comp1.getRenderMaterial(i) !== comp2.getRenderMaterial(i)) {
                  return false;
                }
              }

              return true;
            }

            var BatchingUtility = exports('BatchingUtility', function () {
              function BatchingUtility() {}

              BatchingUtility.batchStaticModel = function batchStaticModel(staticModelRoot, batchedRoot) {
                var models = staticModelRoot.getComponentsInChildren(MeshRenderer);

                if (models.length < 2) {
                  console.error('the number of static models to batch is less than 2,it needn\'t batch.');
                  return false;
                }

                for (var i = 1; i < models.length; i++) {
                  if (!models[0].mesh.validateMergingMesh(models[i].mesh)) {
                    console.error("the meshes of " + models[0].node.name + " and " + models[i].node.name + " can't be merged");
                    return false;
                  }

                  if (!checkMaterialisSame(models[0], models[i])) {
                    console.error("the materials of " + models[0].node.name + " and " + models[i].node.name + " can't be merged");
                    return false;
                  }
                }

                var batchedMesh = new Mesh();
                var worldMat = new Mat4();
                var rootWorldMatInv = new Mat4();
                staticModelRoot.getWorldMatrix(rootWorldMatInv);
                Mat4.invert(rootWorldMatInv, rootWorldMatInv);

                for (var _i = 0; _i < models.length; _i++) {
                  var comp = models[_i];
                  comp.node.getWorldMatrix(worldMat);
                  Mat4.multiply(worldMat, rootWorldMatInv, worldMat);
                  batchedMesh.merge(models[_i].mesh, worldMat);
                  comp.enabled = false;
                }

                var batchedModel = batchedRoot.addComponent(MeshRenderer);
                batchedModel.mesh = batchedMesh;
                batchedModel.sharedMaterials = models[0].sharedMaterials;
                return true;
              };

              BatchingUtility.unbatchStaticModel = function unbatchStaticModel(staticModelRoot, batchedRoot) {
                var models = staticModelRoot.getComponentsInChildren(MeshRenderer);

                for (var i = 0; i < models.length; i++) {
                  var comp = models[i];
                  comp.enabled = true;
                }

                var batchedModel = batchedRoot.getComponent(MeshRenderer);

                if (batchedModel) {
                  if (batchedModel.mesh) {
                    batchedModel.mesh.destroyRenderingMesh();
                  }

                  batchedModel.destroy();
                }

                return true;
              };

              return BatchingUtility;
            }());

            var _dec$p, _dec2$k, _dec3$d, _class$p, _class2$k, _initializer$i, _initializer2$e, _initializer3$a;
            var Skeleton = exports('Skeleton', (_dec$p = ccclass$p('cc.Skeleton'), _dec2$k = type$8([CCString]), _dec3$d = type$8([Mat4]), _dec$p(_class$p = (_class2$k = function (_Asset) {
              _inheritsLoose(Skeleton, _Asset);

              function Skeleton() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;
                _this._joints = _initializer$i && _initializer$i();
                _this._bindposes = _initializer2$e && _initializer2$e();
                _this._hash = _initializer3$a && _initializer3$a();
                _this._invBindposes = null;
                return _this;
              }

              var _proto = Skeleton.prototype;

              _proto.destroy = function destroy() {
                var _cclegacy$director$ro, _cclegacy$director$ro2;

                (_cclegacy$director$ro = legacyCC.director.root) === null || _cclegacy$director$ro === void 0 ? void 0 : (_cclegacy$director$ro2 = _cclegacy$director$ro.dataPoolManager) === null || _cclegacy$director$ro2 === void 0 ? void 0 : _cclegacy$director$ro2.releaseSkeleton(this);
                return _Asset.prototype.destroy.call(this);
              };

              _proto.validate = function validate() {
                return this.joints.length > 0 && this.bindposes.length > 0;
              };

              _createClass(Skeleton, [{
                key: "joints",
                get: function get() {
                  return this._joints;
                },
                set: function set(value) {
                  this._joints = value;
                }
              }, {
                key: "bindposes",
                get: function get() {
                  return this._bindposes;
                },
                set: function set(value) {
                  this._bindposes = value;
                }
              }, {
                key: "inverseBindposes",
                get: function get() {
                  if (!this._invBindposes) {
                    this._invBindposes = [];

                    for (var i = 0; i < this._bindposes.length; i++) {
                      var inv = new Mat4();
                      Mat4.invert(inv, this._bindposes[i]);

                      this._invBindposes.push(inv);
                    }
                  }

                  return this._invBindposes;
                }
              }, {
                key: "hash",
                get: function get() {
                  if (!this._hash) {
                    var str = '';

                    for (var i = 0; i < this._bindposes.length; i++) {
                      var ibm = this._bindposes[i];
                      str += ibm.m00.toPrecision(2) + " " + ibm.m01.toPrecision(2) + " " + ibm.m02.toPrecision(2) + " " + ibm.m03.toPrecision(2) + " " + ibm.m04.toPrecision(2) + " " + ibm.m05.toPrecision(2) + " " + ibm.m06.toPrecision(2) + " " + ibm.m07.toPrecision(2) + " " + ibm.m08.toPrecision(2) + " " + ibm.m09.toPrecision(2) + " " + ibm.m10.toPrecision(2) + " " + ibm.m11.toPrecision(2) + " " + ibm.m12.toPrecision(2) + " " + ibm.m13.toPrecision(2) + " " + ibm.m14.toPrecision(2) + " " + ibm.m15.toPrecision(2) + "\n";
                    }

                    this._hash = murmurhash2_32_gc(str, 666);
                  }

                  return this._hash;
                }
              }]);

              return Skeleton;
            }(Asset), (_initializer$i = applyDecoratedInitializer(_class2$k.prototype, "_joints", [_dec2$k], function () {
              return [];
            }), _initializer2$e = applyDecoratedInitializer(_class2$k.prototype, "_bindposes", [_dec3$d], function () {
              return [];
            }), _initializer3$a = applyDecoratedInitializer(_class2$k.prototype, "_hash", [serializable$j], function () {
              return 0;
            })), _class2$k)) || _class$p));
            legacyCC.Skeleton = Skeleton;

            var _dec$q, _class$q, _class2$l, _initializer$j, _initializer2$f, _initializer3$b, _dec2$l, _dec3$e, _dec4$7, _class4, _class5, _initializer4$9, _initializer5$7, _initializer6$6, _initializer7$4, _initializer8$4, _class6, _temp$9;

            var _color_tmp = new Vec3();

            var PhotometricTerm = Enum({
              LUMINOUS_FLUX: 0,
              LUMINANCE: 1
            });
            var StaticLightSettings = (_dec$q = ccclass$p('cc.StaticLightSettings'), _dec$q(_class$q = (_class2$l = function () {
              function StaticLightSettings() {
                this._baked = _initializer$j && _initializer$j();
                this._editorOnly = _initializer2$f && _initializer2$f();
                this._castShadow = _initializer3$b && _initializer3$b();
              }

              _createClass(StaticLightSettings, [{
                key: "editorOnly",
                get: function get() {
                  return this._editorOnly;
                },
                set: function set(val) {
                  this._editorOnly = val;
                }
              }, {
                key: "baked",
                get: function get() {
                  return this._baked;
                },
                set: function set(val) {
                  this._baked = val;
                }
              }, {
                key: "castShadow",
                get: function get() {
                  return this._castShadow;
                },
                set: function set(val) {
                  this._castShadow = val;
                }
              }]);

              return StaticLightSettings;
            }(), (_initializer$j = applyDecoratedInitializer(_class2$l.prototype, "_baked", [serializable$j], function () {
              return false;
            }), _initializer2$f = applyDecoratedInitializer(_class2$l.prototype, "_editorOnly", [serializable$j], function () {
              return false;
            }), _initializer3$b = applyDecoratedInitializer(_class2$l.prototype, "_castShadow", [serializable$j], function () {
              return false;
            })), _class2$l)) || _class$q);
            var Light = exports('Light', (_dec2$l = ccclass$p('cc.Light'), _dec3$e = type$8(StaticLightSettings), _dec4$7 = type$8(Layers.BitMask), _dec2$l(_class4 = (_class5 = (_temp$9 = _class6 = function (_Component) {
              _inheritsLoose(Light, _Component);

              function Light() {
                var _this;

                _this = _Component.call(this) || this;
                _this._color = _initializer4$9 && _initializer4$9();
                _this._useColorTemperature = _initializer5$7 && _initializer5$7();
                _this._colorTemperature = _initializer6$6 && _initializer6$6();
                _this._staticSettings = _initializer7$4 && _initializer7$4();
                _this._visibility = _initializer8$4 && _initializer8$4();
                _this._type = LightType.UNKNOWN;
                _this._lightType = void 0;
                _this._light = null;
                _this._lightType = Light$1;
                return _this;
              }

              var _proto = Light.prototype;

              _proto.onLoad = function onLoad() {
                this._createLight();
              };

              _proto.onEnable = function onEnable() {
                this._attachToScene();
              };

              _proto.onDisable = function onDisable() {
                this._detachFromScene();
              };

              _proto.onDestroy = function onDestroy() {
                this._destroyLight();
              };

              _proto._createLight = function _createLight() {
                if (!this._light) {
                  this._light = legacyCC.director.root.createLight(this._lightType);
                }

                this.color = this._color;
                this.useColorTemperature = this._useColorTemperature;
                this.colorTemperature = this._colorTemperature;
                this._light.node = this.node;
                this._light.baked = this.baked;
                this._light.visibility = this.visibility;
              };

              _proto._destroyLight = function _destroyLight() {
                if (this._light) {
                  legacyCC.director.root.recycleLight(this._light);
                  this._light = null;
                }
              };

              _proto._attachToScene = function _attachToScene() {
                this._detachFromScene();

                if (this._light && !this._light.scene && this.node.scene) {
                  var renderScene = this._getRenderScene();

                  switch (this._type) {
                    case LightType.DIRECTIONAL:
                      renderScene.addDirectionalLight(this._light);
                      renderScene.setMainLight(this._light);
                      break;

                    case LightType.SPHERE:
                      renderScene.addSphereLight(this._light);
                      break;

                    case LightType.SPOT:
                      renderScene.addSpotLight(this._light);
                      break;
                  }
                }
              };

              _proto._detachFromScene = function _detachFromScene() {
                if (this._light && this._light.scene) {
                  var renderScene = this._light.scene;

                  switch (this._type) {
                    case LightType.DIRECTIONAL:
                      renderScene.removeDirectionalLight(this._light);
                      renderScene.unsetMainLight(this._light);
                      break;

                    case LightType.SPHERE:
                      renderScene.removeSphereLight(this._light);
                      break;

                    case LightType.SPOT:
                      renderScene.removeSpotLight(this._light);
                      break;
                  }
                }
              };

              _proto._onUpdateReceiveDirLight = function _onUpdateReceiveDirLight() {};

              _createClass(Light, [{
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(val) {
                  this._color = val;

                  if (this._light) {
                    _color_tmp.x = val.r / 255.0;
                    _color_tmp.y = val.g / 255.0;
                    _color_tmp.z = val.b / 255.0;
                    this._light.color = _color_tmp;
                  }
                }
              }, {
                key: "useColorTemperature",
                get: function get() {
                  return this._useColorTemperature;
                },
                set: function set(enable) {
                  this._useColorTemperature = enable;

                  if (this._light) {
                    this._light.useColorTemperature = enable;
                  }
                }
              }, {
                key: "colorTemperature",
                get: function get() {
                  return this._colorTemperature;
                },
                set: function set(val) {
                  this._colorTemperature = val;

                  if (this._light) {
                    this._light.colorTemperature = val;
                  }
                }
              }, {
                key: "staticSettings",
                get: function get() {
                  return this._staticSettings;
                },
                set: function set(val) {
                  this._staticSettings = val;
                }
              }, {
                key: "type",
                get: function get() {
                  return this._type;
                }
              }, {
                key: "baked",
                get: function get() {
                  return this.staticSettings.baked;
                },
                set: function set(val) {
                  this.staticSettings.baked = val;

                  if (this._light !== null) {
                    this._light.baked = val;
                  }
                }
              }, {
                key: "visibility",
                get: function get() {
                  return this._visibility;
                },
                set: function set(vis) {
                  this._visibility = vis;

                  if (this._light) {
                    this._light.visibility = vis;
                  }

                  this._onUpdateReceiveDirLight();
                }
              }]);

              return Light;
            }(Component), _class6.Type = LightType, _class6.PhotometricTerm = PhotometricTerm, _temp$9), (_initializer4$9 = applyDecoratedInitializer(_class5.prototype, "_color", [serializable$j], function () {
              return Color$1.WHITE.clone();
            }), _initializer5$7 = applyDecoratedInitializer(_class5.prototype, "_useColorTemperature", [serializable$j], function () {
              return false;
            }), _initializer6$6 = applyDecoratedInitializer(_class5.prototype, "_colorTemperature", [serializable$j], function () {
              return 6550;
            }), _initializer7$4 = applyDecoratedInitializer(_class5.prototype, "_staticSettings", [serializable$j], function () {
              return new StaticLightSettings();
            }), _initializer8$4 = applyDecoratedInitializer(_class5.prototype, "_visibility", [serializable$j], function () {
              return CAMERA_DEFAULT_MASK;
            }), _applyDecoratedDescriptor(_class5.prototype, "staticSettings", [_dec3$e], Object.getOwnPropertyDescriptor(_class5.prototype, "staticSettings"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "visibility", [_dec4$7], Object.getOwnPropertyDescriptor(_class5.prototype, "visibility"), _class5.prototype)), _class5)) || _class4));

            var _dec$r, _dec2$m, _dec3$f, _dec4$8, _dec5$4, _dec6$4, _dec7$4, _dec8$1, _dec9$1, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _dec33, _dec34, _dec35, _dec36, _dec37, _dec38, _class$r, _class2$m, _initializer$k, _initializer2$g, _initializer3$c, _initializer4$a, _initializer5$8, _initializer6$7, _initializer7$5, _initializer8$5, _initializer9$4, _initializer10$4, _initializer11$3, _initializer12$3, _initializer13$3, _initializer14$2, _initializer15$2, _initializer16$2, _initializer17$2, _initializer18$1, _initializer19$1;
            var ccclass$1 = ccclass$p,
                property = property$2,
                serializable$1 = serializable$j,
                formerlySerializedAs = formerlySerializedAs$3,
                type$1 = type$8;
            var DirectionalLight = exports('DirectionalLight', (_dec$r = ccclass$1('cc.DirectionalLight'), _dec2$m = formerlySerializedAs('_illuminance'), _dec3$f = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 1
              }
            }), _dec4$8 = type$1(CCBoolean), _dec5$4 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 5
              }
            }), _dec6$4 = type$1(PCFType), _dec7$4 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 6
              }
            }), _dec8$1 = type$1(CCFloat), _dec9$1 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 7
              }
            }), _dec10 = type$1(CCFloat), _dec11 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 8
              }
            }), _dec12 = type$1(CCFloat), _dec13 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 9
              }
            }), _dec14 = type$1(CCFloat), _dec15 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 22
              }
            }), _dec16 = type$1(CCFloat), _dec17 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 10
              }
            }), _dec18 = type$1(CSMLevel), _dec19 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 11
              }
            }), _dec20 = type$1(CCBoolean), _dec21 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 12
              }
            }), _dec22 = type$1(CCFloat), _dec23 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 13
              }
            }), _dec24 = type$1(CSMOptimizationMode), _dec25 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 14
              }
            }), _dec26 = type$1(CCBoolean), _dec27 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 15
              }
            }), _dec28 = type$1(CCFloat), _dec29 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 16
              }
            }), _dec30 = type$1(CCFloat), _dec31 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 17
              }
            }), _dec32 = type$1(CCFloat), _dec33 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 19
              }
            }), _dec34 = type$1(CCBoolean), _dec35 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 20
              }
            }), _dec36 = type$1(CCBoolean), _dec37 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 21
              }
            }), _dec38 = type$1(CCFloat), _dec$r(_class$r = (_class2$m = function (_Light) {
              _inheritsLoose(DirectionalLight, _Light);

              function DirectionalLight() {
                var _this;

                _this = _Light.call(this) || this;
                _this._illuminanceHDR = _initializer$k && _initializer$k();
                _this._illuminanceLDR = _initializer2$g && _initializer2$g();
                _this._shadowEnabled = _initializer3$c && _initializer3$c();
                _this._shadowPcf = _initializer4$a && _initializer4$a();
                _this._shadowBias = _initializer5$8 && _initializer5$8();
                _this._shadowNormalBias = _initializer6$7 && _initializer6$7();
                _this._shadowSaturation = _initializer7$5 && _initializer7$5();
                _this._shadowDistance = _initializer8$5 && _initializer8$5();
                _this._shadowInvisibleOcclusionRange = _initializer9$4 && _initializer9$4();
                _this._csmLevel = _initializer10$4 && _initializer10$4();
                _this._csmLayerLambda = _initializer11$3 && _initializer11$3();
                _this._csmOptimizationMode = _initializer12$3 && _initializer12$3();
                _this._csmAdvancedOptions = _initializer13$3 && _initializer13$3();
                _this._csmLayersTransition = _initializer14$2 && _initializer14$2();
                _this._csmTransitionRange = _initializer15$2 && _initializer15$2();
                _this._shadowFixedArea = _initializer16$2 && _initializer16$2();
                _this._shadowNear = _initializer17$2 && _initializer17$2();
                _this._shadowFar = _initializer18$1 && _initializer18$1();
                _this._shadowOrthoSize = _initializer19$1 && _initializer19$1();
                _this._lightType = DirectionalLight$1;
                var highQualityMode = settings.querySettings(Settings.Category.RENDERING, 'highQualityMode');

                if (highQualityMode) {
                  _this._shadowPcf = PCFType.SOFT_2X;
                  _this._shadowDistance = 50;
                  _this.enableCSM = true;
                  _this.staticSettings.castShadow = true;
                }

                return _this;
              }

              var _proto = DirectionalLight.prototype;

              _proto._createLight = function _createLight() {
                _Light.prototype._createLight.call(this);

                this._type = LightType.DIRECTIONAL;

                if (this._light) {
                  var dirLight = this._light;
                  dirLight.illuminanceHDR = this._illuminanceHDR;
                  dirLight.illuminanceLDR = this._illuminanceLDR;
                  dirLight.shadowEnabled = this._shadowEnabled;
                  dirLight.shadowPcf = this._shadowPcf;
                  dirLight.shadowBias = this._shadowBias;
                  dirLight.shadowNormalBias = this._shadowNormalBias;
                  dirLight.shadowSaturation = this._shadowSaturation;
                  dirLight.shadowDistance = this._shadowDistance;
                  dirLight.shadowInvisibleOcclusionRange = this._shadowInvisibleOcclusionRange;
                  dirLight.shadowFixedArea = this._shadowFixedArea;
                  dirLight.shadowNear = this._shadowNear;
                  dirLight.shadowFar = this._shadowFar;
                  dirLight.shadowOrthoSize = this._shadowOrthoSize;
                  dirLight.csmLevel = this._csmLevel;
                  dirLight.csmLayerLambda = this._csmLayerLambda;
                  dirLight.csmOptimizationMode = this._csmOptimizationMode;
                  dirLight.csmLayersTransition = this._csmLayersTransition;
                  dirLight.csmTransitionRange = this._csmTransitionRange;
                }
              };

              _proto._onUpdateReceiveDirLight = function _onUpdateReceiveDirLight() {
                if (!this._light) {
                  return;
                }

                _Light.prototype._onUpdateReceiveDirLight.call(this);

                var scene = director.getScene();

                if (!scene || !scene.renderScene) {
                  return;
                }

                if (scene.renderScene.mainLight !== this._light) {
                  return;
                }

                var models = scene.renderScene.models;

                for (var i = 0; i < models.length; i++) {
                  var model = models[i];
                  if (!model.node) continue;
                  var meshRender = model.node.getComponent(MeshRenderer);
                  if (!meshRender) continue;
                  meshRender.onUpdateReceiveDirLight(this._visibility);
                }
              };

              _createClass(DirectionalLight, [{
                key: "illuminance",
                get: function get() {
                  var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                  if (isHDR) {
                    return this._illuminanceHDR;
                  } else {
                    return this._illuminanceLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                  if (isHDR) {
                    this._illuminanceHDR = val;
                    this._light && (this._light.illuminanceHDR = this._illuminanceHDR);
                  } else {
                    this._illuminanceLDR = val;
                    this._light && (this._light.illuminanceLDR = this._illuminanceLDR);
                  }
                }
              }, {
                key: "shadowEnabled",
                get: function get() {
                  return this._shadowEnabled;
                },
                set: function set(val) {
                  this._shadowEnabled = val;

                  if (this._light) {
                    this._light.shadowEnabled = this._shadowEnabled;
                  }
                }
              }, {
                key: "shadowPcf",
                get: function get() {
                  return this._shadowPcf;
                },
                set: function set(val) {
                  this._shadowPcf = val;

                  if (this._light) {
                    this._light.shadowPcf = this._shadowPcf;
                  }
                }
              }, {
                key: "shadowBias",
                get: function get() {
                  return this._shadowBias;
                },
                set: function set(val) {
                  this._shadowBias = val;

                  if (this._light) {
                    this._light.shadowBias = this._shadowBias;
                  }
                }
              }, {
                key: "shadowNormalBias",
                get: function get() {
                  return this._shadowNormalBias;
                },
                set: function set(val) {
                  this._shadowNormalBias = val;

                  if (this._light) {
                    this._light.shadowNormalBias = this._shadowNormalBias;
                  }
                }
              }, {
                key: "shadowSaturation",
                get: function get() {
                  return this._shadowSaturation;
                },
                set: function set(val) {
                  this._shadowSaturation = clamp$1(val, 0.0, 1.0);

                  if (this._light) {
                    this._light.shadowSaturation = this._shadowSaturation;
                  }
                }
              }, {
                key: "shadowDistance",
                get: function get() {
                  return this._shadowDistance;
                },
                set: function set(val) {
                  this._shadowDistance = Math.min(val, Shadows.MAX_FAR);

                  if (this._shadowDistance / 0.1 < 10.0) {
                    warnID(15003, this._shadowDistance);
                  }

                  if (this._light) {
                    this._light.shadowDistance = this._shadowDistance;
                    this._light.csmNeedUpdate = true;
                  }
                }
              }, {
                key: "shadowInvisibleOcclusionRange",
                get: function get() {
                  return this._shadowInvisibleOcclusionRange;
                },
                set: function set(val) {
                  this._shadowInvisibleOcclusionRange = Math.min(val, Shadows.MAX_FAR);

                  if (this._light) {
                    this._light.shadowInvisibleOcclusionRange = this._shadowInvisibleOcclusionRange;
                  }
                }
              }, {
                key: "csmLevel",
                get: function get() {
                  return this._csmLevel;
                },
                set: function set(val) {
                  this._csmLevel = val;

                  if (this._light) {
                    this._light.csmLevel = this._csmLevel;
                    this._light.csmNeedUpdate = true;
                  }
                }
              }, {
                key: "enableCSM",
                get: function get() {
                  return this._csmLevel > CSMLevel.LEVEL_1;
                },
                set: function set(val) {
                  this._csmLevel = val ? CSMLevel.LEVEL_4 : CSMLevel.LEVEL_1;

                  if (this._light) {
                    this._light.csmLevel = this._csmLevel;
                    this._light.csmNeedUpdate = true;
                  }
                }
              }, {
                key: "csmLayerLambda",
                get: function get() {
                  return this._csmLayerLambda;
                },
                set: function set(val) {
                  this._csmLayerLambda = val;

                  if (this._light) {
                    this._light.csmLayerLambda = this._csmLayerLambda;
                    this._light.csmNeedUpdate = true;
                  }
                }
              }, {
                key: "csmOptimizationMode",
                get: function get() {
                  return this._csmOptimizationMode;
                },
                set: function set(val) {
                  this._csmOptimizationMode = val;

                  if (this._light) {
                    this._light.csmOptimizationMode = this._csmOptimizationMode;
                  }
                }
              }, {
                key: "shadowFixedArea",
                get: function get() {
                  return this._shadowFixedArea;
                },
                set: function set(val) {
                  this._shadowFixedArea = val;

                  if (this._light) {
                    this._light.shadowFixedArea = this._shadowFixedArea;
                  }
                }
              }, {
                key: "shadowNear",
                get: function get() {
                  return this._shadowNear;
                },
                set: function set(val) {
                  this._shadowNear = val;

                  if (this._light) {
                    this._light.shadowNear = this._shadowNear;
                  }
                }
              }, {
                key: "shadowFar",
                get: function get() {
                  return this._shadowFar;
                },
                set: function set(val) {
                  this._shadowFar = Math.min(val, Shadows.MAX_FAR);

                  if (this._light) {
                    this._light.shadowFar = this._shadowFar;
                  }
                }
              }, {
                key: "shadowOrthoSize",
                get: function get() {
                  return this._shadowOrthoSize;
                },
                set: function set(val) {
                  this._shadowOrthoSize = val;

                  if (this._light) {
                    this._light.shadowOrthoSize = this._shadowOrthoSize;
                  }
                }
              }, {
                key: "csmAdvancedOptions",
                get: function get() {
                  return this._csmAdvancedOptions;
                },
                set: function set(val) {
                  this._csmAdvancedOptions = val;
                }
              }, {
                key: "csmLayersTransition",
                get: function get() {
                  return this._csmLayersTransition;
                },
                set: function set(val) {
                  this._csmLayersTransition = val;

                  if (this._light) {
                    this._light.csmLayersTransition = val;
                  }
                }
              }, {
                key: "csmTransitionRange",
                get: function get() {
                  return this._csmTransitionRange;
                },
                set: function set(val) {
                  this._csmTransitionRange = val;

                  if (this._light) {
                    this._light.csmTransitionRange = val;
                  }
                }
              }]);

              return DirectionalLight;
            }(Light), (_initializer$k = applyDecoratedInitializer(_class2$m.prototype, "_illuminanceHDR", [property, _dec2$m], function () {
              return 65000;
            }), _initializer2$g = applyDecoratedInitializer(_class2$m.prototype, "_illuminanceLDR", [serializable$1], function () {
              return 65000 * Camera$1.standardExposureValue;
            }), _initializer3$c = applyDecoratedInitializer(_class2$m.prototype, "_shadowEnabled", [serializable$1], function () {
              return false;
            }), _initializer4$a = applyDecoratedInitializer(_class2$m.prototype, "_shadowPcf", [serializable$1], function () {
              return PCFType.HARD;
            }), _initializer5$8 = applyDecoratedInitializer(_class2$m.prototype, "_shadowBias", [serializable$1], function () {
              return 0.00001;
            }), _initializer6$7 = applyDecoratedInitializer(_class2$m.prototype, "_shadowNormalBias", [serializable$1], function () {
              return 0.0;
            }), _initializer7$5 = applyDecoratedInitializer(_class2$m.prototype, "_shadowSaturation", [serializable$1], function () {
              return 1.0;
            }), _initializer8$5 = applyDecoratedInitializer(_class2$m.prototype, "_shadowDistance", [serializable$1], function () {
              return 50;
            }), _initializer9$4 = applyDecoratedInitializer(_class2$m.prototype, "_shadowInvisibleOcclusionRange", [serializable$1], function () {
              return 200;
            }), _initializer10$4 = applyDecoratedInitializer(_class2$m.prototype, "_csmLevel", [serializable$1], function () {
              return CSMLevel.LEVEL_4;
            }), _initializer11$3 = applyDecoratedInitializer(_class2$m.prototype, "_csmLayerLambda", [serializable$1], function () {
              return 0.75;
            }), _initializer12$3 = applyDecoratedInitializer(_class2$m.prototype, "_csmOptimizationMode", [serializable$1], function () {
              return CSMOptimizationMode.RemoveDuplicates;
            }), _initializer13$3 = applyDecoratedInitializer(_class2$m.prototype, "_csmAdvancedOptions", [serializable$1], function () {
              return false;
            }), _initializer14$2 = applyDecoratedInitializer(_class2$m.prototype, "_csmLayersTransition", [serializable$1], function () {
              return false;
            }), _initializer15$2 = applyDecoratedInitializer(_class2$m.prototype, "_csmTransitionRange", [serializable$1], function () {
              return 0.05;
            }), _initializer16$2 = applyDecoratedInitializer(_class2$m.prototype, "_shadowFixedArea", [serializable$1], function () {
              return false;
            }), _initializer17$2 = applyDecoratedInitializer(_class2$m.prototype, "_shadowNear", [serializable$1], function () {
              return 0.1;
            }), _initializer18$1 = applyDecoratedInitializer(_class2$m.prototype, "_shadowFar", [serializable$1], function () {
              return 10.0;
            }), _initializer19$1 = applyDecoratedInitializer(_class2$m.prototype, "_shadowOrthoSize", [serializable$1], function () {
              return 5;
            }), _applyDecoratedDescriptor(_class2$m.prototype, "shadowEnabled", [_dec3$f, _dec4$8], Object.getOwnPropertyDescriptor(_class2$m.prototype, "shadowEnabled"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "shadowPcf", [_dec5$4, _dec6$4], Object.getOwnPropertyDescriptor(_class2$m.prototype, "shadowPcf"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "shadowBias", [_dec7$4, _dec8$1], Object.getOwnPropertyDescriptor(_class2$m.prototype, "shadowBias"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "shadowNormalBias", [_dec9$1, _dec10], Object.getOwnPropertyDescriptor(_class2$m.prototype, "shadowNormalBias"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "shadowSaturation", [_dec11, _dec12], Object.getOwnPropertyDescriptor(_class2$m.prototype, "shadowSaturation"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "shadowDistance", [_dec13, _dec14], Object.getOwnPropertyDescriptor(_class2$m.prototype, "shadowDistance"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "shadowInvisibleOcclusionRange", [_dec15, _dec16], Object.getOwnPropertyDescriptor(_class2$m.prototype, "shadowInvisibleOcclusionRange"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "csmLevel", [_dec17, _dec18], Object.getOwnPropertyDescriptor(_class2$m.prototype, "csmLevel"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "enableCSM", [_dec19, _dec20], Object.getOwnPropertyDescriptor(_class2$m.prototype, "enableCSM"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "csmLayerLambda", [_dec21, _dec22], Object.getOwnPropertyDescriptor(_class2$m.prototype, "csmLayerLambda"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "csmOptimizationMode", [_dec23, _dec24], Object.getOwnPropertyDescriptor(_class2$m.prototype, "csmOptimizationMode"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "shadowFixedArea", [_dec25, _dec26], Object.getOwnPropertyDescriptor(_class2$m.prototype, "shadowFixedArea"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "shadowNear", [_dec27, _dec28], Object.getOwnPropertyDescriptor(_class2$m.prototype, "shadowNear"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "shadowFar", [_dec29, _dec30], Object.getOwnPropertyDescriptor(_class2$m.prototype, "shadowFar"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "shadowOrthoSize", [_dec31, _dec32], Object.getOwnPropertyDescriptor(_class2$m.prototype, "shadowOrthoSize"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "csmAdvancedOptions", [_dec33, _dec34], Object.getOwnPropertyDescriptor(_class2$m.prototype, "csmAdvancedOptions"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "csmLayersTransition", [_dec35, _dec36], Object.getOwnPropertyDescriptor(_class2$m.prototype, "csmLayersTransition"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "csmTransitionRange", [_dec37, _dec38], Object.getOwnPropertyDescriptor(_class2$m.prototype, "csmTransitionRange"), _class2$m.prototype)), _class2$m)) || _class$r));

            var _dec$s, _dec2$n, _dec3$g, _class$s, _class2$n, _initializer$l, _initializer2$h, _initializer3$d, _initializer4$b, _initializer5$9;
            var SphereLight = exports('SphereLight', (_dec$s = ccclass$p('cc.SphereLight'), _dec2$n = formerlySerializedAs$3('_luminance'), _dec3$g = type$8(PhotometricTerm), _dec$s(_class$s = (_class2$n = function (_Light) {
              _inheritsLoose(SphereLight, _Light);

              function SphereLight() {
                var _this;

                _this = _Light.call(this) || this;
                _this._size = _initializer$l && _initializer$l();
                _this._luminanceHDR = _initializer2$h && _initializer2$h();
                _this._luminanceLDR = _initializer3$d && _initializer3$d();
                _this._term = _initializer4$b && _initializer4$b();
                _this._range = _initializer5$9 && _initializer5$9();
                _this._lightType = SphereLight$1;
                return _this;
              }

              var _proto = SphereLight.prototype;

              _proto._createLight = function _createLight() {
                _Light.prototype._createLight.call(this);

                this._type = LightType.SPHERE;
                this.size = this._size;
                this.range = this._range;

                if (this._light) {
                  this._light.luminanceHDR = this._luminanceHDR;
                  this._light.luminanceLDR = this._luminanceLDR;
                }
              };

              _createClass(SphereLight, [{
                key: "luminousFlux",
                get: function get() {
                  var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                  if (isHDR) {
                    return this._luminanceHDR * nt2lm(this._size);
                  } else {
                    return this._luminanceLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
                  var result = 0;

                  if (isHDR) {
                    this._luminanceHDR = val / nt2lm(this._size);
                    result = this._luminanceHDR;
                  } else {
                    this._luminanceLDR = val;
                    result = this._luminanceLDR;
                  }

                  this._light && (this._light.luminance = result);
                }
              }, {
                key: "luminance",
                get: function get() {
                  var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                  if (isHDR) {
                    return this._luminanceHDR;
                  } else {
                    return this._luminanceLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                  if (isHDR) {
                    this._luminanceHDR = val;
                    this._light && (this._light.luminanceHDR = this._luminanceHDR);
                  } else {
                    this._luminanceLDR = val;
                    this._light && (this._light.luminanceLDR = this._luminanceLDR);
                  }
                }
              }, {
                key: "term",
                get: function get() {
                  return this._term;
                },
                set: function set(val) {
                  this._term = val;
                }
              }, {
                key: "size",
                get: function get() {
                  return this._size;
                },
                set: function set(val) {
                  this._size = val;

                  if (this._light) {
                    this._light.size = val;
                  }
                }
              }, {
                key: "range",
                get: function get() {
                  return this._range;
                },
                set: function set(val) {
                  this._range = val;

                  if (this._light) {
                    this._light.range = val;
                  }
                }
              }]);

              return SphereLight;
            }(Light), (_initializer$l = applyDecoratedInitializer(_class2$n.prototype, "_size", [serializable$j], function () {
              return 0.15;
            }), _initializer2$h = applyDecoratedInitializer(_class2$n.prototype, "_luminanceHDR", [serializable$j, _dec2$n], function () {
              return 1700 / nt2lm(0.15);
            }), _initializer3$d = applyDecoratedInitializer(_class2$n.prototype, "_luminanceLDR", [serializable$j], function () {
              return 1700 / nt2lm(0.15) * Camera$1.standardExposureValue * Camera$1.standardLightMeterScale;
            }), _initializer4$b = applyDecoratedInitializer(_class2$n.prototype, "_term", [serializable$j], function () {
              return PhotometricTerm.LUMINOUS_FLUX;
            }), _initializer5$9 = applyDecoratedInitializer(_class2$n.prototype, "_range", [serializable$j], function () {
              return 1;
            }), _applyDecoratedDescriptor(_class2$n.prototype, "term", [_dec3$g], Object.getOwnPropertyDescriptor(_class2$n.prototype, "term"), _class2$n.prototype)), _class2$n)) || _class$s));

            var _dec$t, _dec2$o, _dec3$h, _dec4$9, _dec5$5, _dec6$5, _dec7$5, _dec8$2, _dec9$2, _dec10$1, _dec11$1, _class$t, _class2$o, _initializer$m, _initializer2$i, _initializer3$e, _initializer4$c, _initializer5$a, _initializer6$8, _initializer7$6, _initializer8$6, _initializer9$5, _initializer10$5;
            var ccclass$2 = ccclass$p,
                type$2 = type$8,
                serializable$2 = serializable$j,
                formerlySerializedAs$1 = formerlySerializedAs$3,
                property$1 = property$2;
            var SpotLight = exports('SpotLight', (_dec$t = ccclass$2('cc.SpotLight'), _dec2$o = formerlySerializedAs$1('_luminance'), _dec3$h = type$2(PhotometricTerm), _dec4$9 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 1
              }
            }), _dec5$5 = type$2(CCBoolean), _dec6$5 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 2
              }
            }), _dec7$5 = type$2(PCFType), _dec8$2 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 3
              }
            }), _dec9$2 = type$2(CCFloat), _dec10$1 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 4
              }
            }), _dec11$1 = type$2(CCFloat), _dec$t(_class$t = (_class2$o = function (_Light) {
              _inheritsLoose(SpotLight, _Light);

              function SpotLight() {
                var _this;

                _this = _Light.call(this) || this;
                _this._size = _initializer$m && _initializer$m();
                _this._luminanceHDR = _initializer2$i && _initializer2$i();
                _this._luminanceLDR = _initializer3$e && _initializer3$e();
                _this._term = _initializer4$c && _initializer4$c();
                _this._range = _initializer5$a && _initializer5$a();
                _this._spotAngle = _initializer6$8 && _initializer6$8();
                _this._shadowEnabled = _initializer7$6 && _initializer7$6();
                _this._shadowPcf = _initializer8$6 && _initializer8$6();
                _this._shadowBias = _initializer9$5 && _initializer9$5();
                _this._shadowNormalBias = _initializer10$5 && _initializer10$5();
                _this._lightType = SpotLight$1;
                return _this;
              }

              var _proto = SpotLight.prototype;

              _proto._createLight = function _createLight() {
                _Light.prototype._createLight.call(this);

                this._type = LightType.SPOT;
                this.size = this._size;
                this.range = this._range;
                this.spotAngle = this._spotAngle;

                if (this._light) {
                  var spotLight = this._light;
                  spotLight.luminanceHDR = this._luminanceHDR;
                  spotLight.luminanceLDR = this._luminanceLDR;
                  spotLight.shadowEnabled = this._shadowEnabled;
                  spotLight.shadowPcf = this._shadowPcf;
                  spotLight.shadowBias = this._shadowBias;
                  spotLight.shadowNormalBias = this._shadowNormalBias;
                }
              };

              _createClass(SpotLight, [{
                key: "luminousFlux",
                get: function get() {
                  var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                  if (isHDR) {
                    return this._luminanceHDR * nt2lm(this._size);
                  } else {
                    return this._luminanceLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
                  var result = 0;

                  if (isHDR) {
                    this._luminanceHDR = val / nt2lm(this._size);
                    result = this._luminanceHDR;
                  } else {
                    this._luminanceLDR = val;
                    result = this._luminanceLDR;
                  }

                  this._light && (this._light.luminance = result);
                }
              }, {
                key: "luminance",
                get: function get() {
                  var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                  if (isHDR) {
                    return this._luminanceHDR;
                  } else {
                    return this._luminanceLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                  if (isHDR) {
                    this._luminanceHDR = val;
                    this._light && (this._light.luminanceHDR = this._luminanceHDR);
                  } else {
                    this._luminanceLDR = val;
                    this._light && (this._light.luminanceLDR = this._luminanceLDR);
                  }
                }
              }, {
                key: "term",
                get: function get() {
                  return this._term;
                },
                set: function set(val) {
                  this._term = val;
                }
              }, {
                key: "size",
                get: function get() {
                  return this._size;
                },
                set: function set(val) {
                  this._size = val;

                  if (this._light) {
                    this._light.size = val;
                  }
                }
              }, {
                key: "range",
                get: function get() {
                  return this._range;
                },
                set: function set(val) {
                  this._range = val;

                  if (this._light) {
                    this._light.range = val;
                  }
                }
              }, {
                key: "spotAngle",
                get: function get() {
                  return this._spotAngle;
                },
                set: function set(val) {
                  this._spotAngle = val;

                  if (this._light) {
                    this._light.spotAngle = toRadian(val);
                  }
                }
              }, {
                key: "shadowEnabled",
                get: function get() {
                  return this._shadowEnabled;
                },
                set: function set(val) {
                  this._shadowEnabled = val;

                  if (this._light) {
                    this._light.shadowEnabled = val;
                  }
                }
              }, {
                key: "shadowPcf",
                get: function get() {
                  return this._shadowPcf;
                },
                set: function set(val) {
                  this._shadowPcf = val;

                  if (this._light) {
                    this._light.shadowPcf = val;
                  }
                }
              }, {
                key: "shadowBias",
                get: function get() {
                  return this._shadowBias;
                },
                set: function set(val) {
                  this._shadowBias = val;

                  if (this._light) {
                    this._light.shadowBias = val;
                  }
                }
              }, {
                key: "shadowNormalBias",
                get: function get() {
                  return this._shadowNormalBias;
                },
                set: function set(val) {
                  this._shadowNormalBias = val;

                  if (this._light) {
                    this._light.shadowNormalBias = val;
                  }
                }
              }]);

              return SpotLight;
            }(Light), (_initializer$m = applyDecoratedInitializer(_class2$o.prototype, "_size", [serializable$2], function () {
              return 0.15;
            }), _initializer2$i = applyDecoratedInitializer(_class2$o.prototype, "_luminanceHDR", [serializable$2, _dec2$o], function () {
              return 1700 / nt2lm(0.15);
            }), _initializer3$e = applyDecoratedInitializer(_class2$o.prototype, "_luminanceLDR", [serializable$2], function () {
              return 1700 / nt2lm(0.15) * Camera$1.standardExposureValue * Camera$1.standardLightMeterScale;
            }), _initializer4$c = applyDecoratedInitializer(_class2$o.prototype, "_term", [serializable$2], function () {
              return PhotometricTerm.LUMINOUS_FLUX;
            }), _initializer5$a = applyDecoratedInitializer(_class2$o.prototype, "_range", [serializable$2], function () {
              return 1;
            }), _initializer6$8 = applyDecoratedInitializer(_class2$o.prototype, "_spotAngle", [serializable$2], function () {
              return 60;
            }), _initializer7$6 = applyDecoratedInitializer(_class2$o.prototype, "_shadowEnabled", [serializable$2], function () {
              return false;
            }), _initializer8$6 = applyDecoratedInitializer(_class2$o.prototype, "_shadowPcf", [serializable$2], function () {
              return PCFType.HARD;
            }), _initializer9$5 = applyDecoratedInitializer(_class2$o.prototype, "_shadowBias", [serializable$2], function () {
              return 0.00001;
            }), _initializer10$5 = applyDecoratedInitializer(_class2$o.prototype, "_shadowNormalBias", [serializable$2], function () {
              return 0.0;
            }), _applyDecoratedDescriptor(_class2$o.prototype, "term", [_dec3$h], Object.getOwnPropertyDescriptor(_class2$o.prototype, "term"), _class2$o.prototype), _applyDecoratedDescriptor(_class2$o.prototype, "shadowEnabled", [_dec4$9, _dec5$5], Object.getOwnPropertyDescriptor(_class2$o.prototype, "shadowEnabled"), _class2$o.prototype), _applyDecoratedDescriptor(_class2$o.prototype, "shadowPcf", [_dec6$5, _dec7$5], Object.getOwnPropertyDescriptor(_class2$o.prototype, "shadowPcf"), _class2$o.prototype), _applyDecoratedDescriptor(_class2$o.prototype, "shadowBias", [_dec8$2, _dec9$2], Object.getOwnPropertyDescriptor(_class2$o.prototype, "shadowBias"), _class2$o.prototype), _applyDecoratedDescriptor(_class2$o.prototype, "shadowNormalBias", [_dec10$1, _dec11$1], Object.getOwnPropertyDescriptor(_class2$o.prototype, "shadowNormalBias"), _class2$o.prototype)), _class2$o)) || _class$t));

            var BAKE_SKELETON_CURVE_SYMBOL = Symbol('BakeNodeCurves');

            var SkelAnimDataHub = exports('SkelAnimDataHub', function () {
              function SkelAnimDataHub() {}

              SkelAnimDataHub.getOrExtract = function getOrExtract(clip) {
                var data = SkelAnimDataHub.pool.get(clip);

                if (!data || data.samples !== clip.sample) {
                  if (data) {
                    legacyCC.director.root.dataPoolManager.releaseAnimationClip(clip);
                  }

                  var frames = Math.ceil(clip.sample * clip.duration) + 1;
                  var step = clip.sample;
                  data = clip[BAKE_SKELETON_CURVE_SYMBOL](0, step, frames);
                  SkelAnimDataHub.pool.set(clip, data);
                }

                return data;
              };

              SkelAnimDataHub.destroy = function destroy(clip) {
                SkelAnimDataHub.pool["delete"](clip);
              };

              return SkelAnimDataHub;
            }());
            SkelAnimDataHub.pool = new Map();

            var m4_1$1 = new Mat4();
            function getPathFromRoot(target, root) {
              var node = target;
              var path = '';

              while (node !== null && node !== root) {
                path = node.name + "/" + path;
                node = node.parent;
              }

              return path.slice(0, -1);
            }
            function getWorldTransformUntilRoot(target, root, outMatrix) {
              Mat4.identity(outMatrix);

              while (target !== root) {
                Mat4.fromRTS(m4_1$1, target.rotation, target.position, target.scale);
                Mat4.multiply(outMatrix, m4_1$1, outMatrix);
                target = target.parent;
              }

              return outMatrix;
            }

            var jointTextureSamplerInfo = new SamplerInfo(Filter.POINT, Filter.POINT, Filter.NONE, Address.CLAMP, Address.CLAMP, Address.CLAMP);

            var uploadJointData = uploadJointDataLBS;
            var MINIMUM_JOINT_TEXTURE_SIZE =  480;
            function selectJointsMediumFormat(device) {
              if (device.getFormatFeatures(Format.RGBA32F) & FormatFeatureBit.SAMPLED_TEXTURE) {
                return Format.RGBA32F;
              }

              return Format.RGBA8;
            }

            function uploadJointDataLBS(out, base, mat, firstBone) {
              out[base + 0] = mat.m00;
              out[base + 1] = mat.m01;
              out[base + 2] = mat.m02;
              out[base + 3] = mat.m12;
              out[base + 4] = mat.m04;
              out[base + 5] = mat.m05;
              out[base + 6] = mat.m06;
              out[base + 7] = mat.m13;
              out[base + 8] = mat.m08;
              out[base + 9] = mat.m09;
              out[base + 10] = mat.m10;
              out[base + 11] = mat.m14;
            }

            var dq_0 = new Quat();
            var dq_1 = new Quat();
            var v3_1$1 = new Vec3();
            var qt_1 = new Quat();
            var v3_2 = new Vec3();

            function roundUpTextureSize(targetLength, formatSize) {
              var formatScale = 4 / Math.sqrt(formatSize);
              return Math.ceil(Math.max(MINIMUM_JOINT_TEXTURE_SIZE * formatScale, targetLength) / 12) * 12;
            }
            var v3_3 = new Vec3();
            var v3_4 = new Vec3();
            var v3_min = new Vec3();
            var v3_max = new Vec3();
            var m4_1$2 = new Mat4();
            var m4_2 = new Mat4();
            var ab_1 = new AABB();
            var Inf = Number.MAX_SAFE_INTEGER;
            var JointTexturePool = function () {
              function JointTexturePool(device) {
                this._device = void 0;
                this._pool = void 0;
                this._textureBuffers = new Map();
                this._formatSize = void 0;
                this._pixelsPerJoint = void 0;
                this._customPool = void 0;
                this._chunkIdxMap = new Map();
                this._device = device;
                var format = selectJointsMediumFormat(this._device);
                this._formatSize = FormatInfos[format].size;
                this._pixelsPerJoint = 48 / this._formatSize;
                this._pool = new TextureBufferPool(device);

                this._pool.initialize({
                  format: format,
                  roundUpFn: roundUpTextureSize
                });

                this._customPool = new TextureBufferPool(device);

                this._customPool.initialize({
                  format: format,
                  roundUpFn: roundUpTextureSize
                });
              }

              var _proto = JointTexturePool.prototype;

              _proto.clear = function clear() {
                this._pool.destroy();

                this._textureBuffers.clear();
              };

              _proto.registerCustomTextureLayouts = function registerCustomTextureLayouts(layouts) {
                for (var i = 0; i < layouts.length; i++) {
                  var layout = layouts[i];
                  var textureLength = layout.textureLength;

                  if (!(this._device.getFormatFeatures(Format.RGBA32F) & FormatFeatureBit.SAMPLED_TEXTURE)) {
                    textureLength *= 2;
                  }

                  var chunkIdx = this._customPool.createChunk(textureLength);

                  for (var j = 0; j < layout.contents.length; j++) {
                    var content = layout.contents[j];
                    var skeleton = content.skeleton;

                    this._chunkIdxMap.set(skeleton, chunkIdx);

                    for (var k = 0; k < content.clips.length; k++) {
                      var clip = content.clips[k];

                      this._chunkIdxMap.set(skeleton ^ clip, chunkIdx);
                    }
                  }
                }
              };

              _proto.getDefaultPoseTexture = function getDefaultPoseTexture(skeleton, mesh, skinningRoot) {
                var hash = skeleton.hash ^ 0;
                var texture = this._textureBuffers.get(hash) || null;

                if (texture && texture.bounds.has(mesh.hash)) {
                  texture.refCount++;
                  return texture;
                }

                var joints = skeleton.joints,
                    bindposes = skeleton.bindposes;
                var textureBuffer = null;
                var buildTexture = false;
                var jointCount = joints.length;

                if (!texture) {
                  var bufSize = jointCount * 12;

                  var customChunkIdx = this._chunkIdxMap.get(hash);

                  var handle = customChunkIdx !== undefined ? this._customPool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT, customChunkIdx) : this._pool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT);

                  if (!handle) {
                    return texture;
                  }

                  texture = {
                    pixelOffset: handle.start / this._formatSize,
                    refCount: 1,
                    bounds: new Map(),
                    skeletonHash: skeleton.hash,
                    clipHash: 0,
                    readyToBeDeleted: false,
                    handle: handle
                  };
                  textureBuffer = new Float32Array(bufSize);
                  buildTexture = true;
                } else {
                  texture.refCount++;
                }

                Vec3.set(v3_min, Inf, Inf, Inf);
                Vec3.set(v3_max, -Inf, -Inf, -Inf);
                var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);

                for (var j = 0, offset = 0; j < jointCount; j++, offset += 12) {
                  var node = skinningRoot.getChildByPath(joints[j]);
                  var mat = node ? getWorldTransformUntilRoot(node, skinningRoot, m4_1$2) : skeleton.inverseBindposes[j];
                  var bound = boneSpaceBounds[j];

                  if (bound) {
                    AABB.transform(ab_1, bound, mat);
                    ab_1.getBoundary(v3_3, v3_4);
                    Vec3.min(v3_min, v3_min, v3_3);
                    Vec3.max(v3_max, v3_max, v3_4);
                  }

                  if (buildTexture) {
                    if (node) {
                      Mat4.multiply(mat, mat, bindposes[j]);
                    }

                    uploadJointData(textureBuffer, offset, node ? mat : Mat4.IDENTITY);
                  }
                }

                var bounds = [new AABB()];
                texture.bounds.set(mesh.hash, bounds);
                AABB.fromPoints(bounds[0], v3_min, v3_max);

                if (buildTexture) {
                  this._pool.update(texture.handle, textureBuffer.buffer);

                  this._textureBuffers.set(hash, texture);
                }

                return texture;
              };

              _proto.getSequencePoseTexture = function getSequencePoseTexture(skeleton, clip, mesh, skinningRoot) {
                var hash = skeleton.hash ^ clip.hash;
                var texture = this._textureBuffers.get(hash) || null;

                if (texture && texture.bounds.has(mesh.hash)) {
                  texture.refCount++;
                  return texture;
                }

                var joints = skeleton.joints,
                    bindposes = skeleton.bindposes;
                var clipData = SkelAnimDataHub.getOrExtract(clip);
                var frames = clipData.frames;
                var textureBuffer = null;
                var buildTexture = false;
                var jointCount = joints.length;

                if (!texture) {
                  var bufSize = jointCount * 12 * frames;

                  var customChunkIdx = this._chunkIdxMap.get(hash);

                  var handle = customChunkIdx !== undefined ? this._customPool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT, customChunkIdx) : this._pool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT);

                  if (!handle) {
                    return null;
                  }

                  var animInfos = this._createAnimInfos(skeleton, clip, skinningRoot);

                  texture = {
                    pixelOffset: handle.start / this._formatSize,
                    refCount: 1,
                    bounds: new Map(),
                    skeletonHash: skeleton.hash,
                    clipHash: clip.hash,
                    readyToBeDeleted: false,
                    handle: handle,
                    animInfos: animInfos
                  };
                  textureBuffer = new Float32Array(bufSize);
                  buildTexture = true;
                } else {
                  texture.refCount++;
                }

                var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);
                var bounds = [];
                texture.bounds.set(mesh.hash, bounds);

                for (var f = 0; f < frames; f++) {
                  bounds.push(new AABB(Inf, Inf, Inf, -Inf, -Inf, -Inf));
                }

                for (var _f = 0, offset = 0; _f < frames; _f++) {
                  var bound = bounds[_f];

                  for (var j = 0; j < jointCount; j++, offset += 12) {
                    var _j = texture.animInfos[j],
                        curveData = _j.curveData,
                        downstream = _j.downstream,
                        bindposeIdx = _j.bindposeIdx,
                        bindposeCorrection = _j.bindposeCorrection;
                    var mat = void 0;
                    var transformValid = true;

                    if (curveData && downstream) {
                      mat = Mat4.multiply(m4_1$2, curveData[_f], downstream);
                    } else if (curveData) {
                      mat = curveData[_f];
                    } else if (downstream) {
                      mat = downstream;
                    } else {
                      mat = skeleton.inverseBindposes[bindposeIdx];
                      transformValid = false;
                    }

                    var boneSpaceBound = boneSpaceBounds[j];

                    if (boneSpaceBound) {
                      var transform = bindposeCorrection ? Mat4.multiply(m4_2, mat, bindposeCorrection) : mat;
                      AABB.transform(ab_1, boneSpaceBound, transform);
                      ab_1.getBoundary(v3_3, v3_4);
                      Vec3.min(bound.center, bound.center, v3_3);
                      Vec3.max(bound.halfExtents, bound.halfExtents, v3_4);
                    }

                    if (buildTexture) {
                      if (transformValid) {
                        Mat4.multiply(m4_1$2, mat, bindposes[bindposeIdx]);
                      }

                      uploadJointData(textureBuffer, offset, transformValid ? m4_1$2 : Mat4.IDENTITY);
                    }
                  }

                  AABB.fromPoints(bound, bound.center, bound.halfExtents);
                }

                if (buildTexture) {
                  this._pool.update(texture.handle, textureBuffer.buffer);

                  this._textureBuffers.set(hash, texture);
                }

                return texture;
              };

              _proto.releaseHandle = function releaseHandle(handle) {
                if (handle.refCount > 0) {
                  handle.refCount--;
                }

                if (!handle.refCount && handle.readyToBeDeleted) {
                  var hash = handle.skeletonHash ^ handle.clipHash;

                  var customChunkIdx = this._chunkIdxMap.get(hash);

                  (customChunkIdx !== undefined ? this._customPool : this._pool).free(handle.handle);

                  if (this._textureBuffers.get(hash) === handle) {
                    this._textureBuffers["delete"](hash);
                  }
                }
              };

              _proto.releaseSkeleton = function releaseSkeleton(skeleton) {
                var it = this._textureBuffers.values();

                var res = it.next();

                while (!res.done) {
                  var handle = res.value;

                  if (handle.skeletonHash === skeleton.hash) {
                    handle.readyToBeDeleted = true;

                    if (handle.refCount) {
                      this._textureBuffers["delete"](handle.skeletonHash ^ handle.clipHash);
                    } else {
                      this.releaseHandle(handle);
                    }
                  }

                  res = it.next();
                }
              };

              _proto.releaseAnimationClip = function releaseAnimationClip(clip) {
                var it = this._textureBuffers.values();

                var res = it.next();

                while (!res.done) {
                  var handle = res.value;

                  if (handle.clipHash === clip.hash) {
                    handle.readyToBeDeleted = true;

                    if (handle.refCount) {
                      this._textureBuffers["delete"](handle.skeletonHash ^ handle.clipHash);
                    } else {
                      this.releaseHandle(handle);
                    }
                  }

                  res = it.next();
                }
              };

              _proto._createAnimInfos = function _createAnimInfos(skeleton, clip, skinningRoot) {
                var animInfos = [];
                var joints = skeleton.joints,
                    bindposes = skeleton.bindposes;
                var jointCount = joints.length;
                var clipData = SkelAnimDataHub.getOrExtract(clip);

                for (var j = 0; j < jointCount; j++) {
                  var animPath = joints[j];
                  var source = clipData.joints[animPath];
                  var animNode = skinningRoot.getChildByPath(animPath);
                  var downstream = void 0;
                  var correctionPath = void 0;

                  while (!source) {
                    var idx = animPath.lastIndexOf('/');
                    animPath = animPath.substring(0, idx);
                    source = clipData.joints[animPath];

                    if (animNode) {
                      if (!downstream) {
                        downstream = new Mat4();
                      }

                      Mat4.fromRTS(m4_1$2, animNode.rotation, animNode.position, animNode.scale);
                      Mat4.multiply(downstream, m4_1$2, downstream);
                      animNode = animNode.parent;
                    } else {
                      correctionPath = animPath;
                    }

                    if (idx < 0) {
                      break;
                    }
                  }

                  var bindposeIdx = j;
                  var bindposeCorrection = void 0;

                  if (correctionPath !== undefined && source) {
                    bindposeIdx = j - 1;

                    for (var t = 0; t < jointCount; t++) {
                      if (joints[t] === correctionPath) {
                        bindposeIdx = t;
                        bindposeCorrection = new Mat4();
                        Mat4.multiply(bindposeCorrection, bindposes[t], skeleton.inverseBindposes[j]);
                        break;
                      }
                    }
                  }

                  animInfos.push({
                    curveData: source && source.transforms,
                    downstream: downstream,
                    bindposeIdx: bindposeIdx,
                    bindposeCorrection: bindposeCorrection
                  });
                }

                return animInfos;
              };

              _createClass(JointTexturePool, [{
                key: "pixelsPerJoint",
                get: function get() {
                  return this._pixelsPerJoint;
                }
              }]);

              return JointTexturePool;
            }();
            var JointAnimationInfo = function () {
              function JointAnimationInfo(device) {
                this._pool = new Map();
                this._device = void 0;
                this._device = device;
              }

              var _proto2 = JointAnimationInfo.prototype;

              _proto2.getData = function getData(nodeID) {
                if (nodeID === void 0) {
                  nodeID = '-1';
                }

                var res = this._pool.get(nodeID);

                if (res) {
                  return res;
                }

                var buffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOSkinningAnimation.SIZE, UBOSkinningAnimation.SIZE));

                var data = new Float32Array([0, 0, 0, 0]);
                buffer.update(data);
                var info = {
                  buffer: buffer,
                  data: data,
                  dirty: false,
                  dirtyForJSB: new Uint8Array([0]),
                  currentClip: null
                };

                this._pool.set(nodeID, info);

                return info;
              };

              _proto2.destroy = function destroy(nodeID) {
                var info = this._pool.get(nodeID);

                if (!info) {
                  return;
                }

                info.buffer.destroy();

                this._pool["delete"](nodeID);
              };

              _proto2.switchClip = function switchClip(info, clip) {
                info.currentClip = clip;
                info.data[0] = 0;
                info.buffer.update(info.data);
                info.dirty = false;

                return info;
              };

              _proto2.clear = function clear() {
                for (var _iterator = _createForOfIteratorHelperLoose(this._pool.values()), _step; !(_step = _iterator()).done;) {
                  var info = _step.value;
                  info.buffer.destroy();
                }

                this._pool.clear();
              };

              return JointAnimationInfo;
            }();

            var stack = [];
            var pool$1 = new Map();
            function getWorldMatrix(transform, stamp) {
              var i = 0;
              var res = Mat4.IDENTITY;

              while (transform) {
                if (transform.stamp === stamp || transform.stamp + 1 === stamp && !transform.node.hasChangedFlags) {
                  res = transform.world;
                  transform.stamp = stamp;
                  break;
                }

                transform.stamp = stamp;
                stack[i++] = transform;
                transform = transform.parent;
              }

              while (i > 0) {
                transform = stack[--i];
                stack[i] = null;
                var node = transform.node;
                Mat4.fromRTS(transform.local, node.rotation, node.position, node.scale);
                res = Mat4.multiply(transform.world, res, transform.local);
              }

              return res;
            }
            function getTransform(node, root) {
              var joint = null;
              var i = 0;

              while (node !== root) {
                var id = node.uuid;

                if (pool$1.has(id)) {
                  joint = pool$1.get(id);
                  break;
                } else {
                  joint = {
                    node: node,
                    local: new Mat4(),
                    world: new Mat4(),
                    stamp: -1,
                    parent: null
                  };
                  pool$1.set(id, joint);
                }

                stack[i++] = joint;
                node = node.parent;
                joint = null;
              }

              var child;

              while (i > 0) {
                child = stack[--i];
                stack[i] = null;
                child.parent = joint;
                joint = child;
              }

              return joint;
            }
            function deleteTransform(node) {
              var transform = pool$1.get(node.uuid) || null;

              while (transform) {
                pool$1["delete"](transform.node.uuid);
                transform = transform.parent;
              }
            }

            var uniformPatches = [{
              name: 'CC_USE_SKINNING',
              value: true
            }, {
              name: 'CC_USE_REAL_TIME_JOINT_TEXTURE',
              value: false
            }];
            var texturePatches = [{
              name: 'CC_USE_SKINNING',
              value: true
            }, {
              name: 'CC_USE_REAL_TIME_JOINT_TEXTURE',
              value: true
            }];

            function getRelevantBuffers(outIndices, outBuffers, jointMaps, targetJoint) {
              for (var i = 0; i < jointMaps.length; i++) {
                var idxMap = jointMaps[i];
                var index = -1;

                for (var j = 0; j < idxMap.length; j++) {
                  if (idxMap[j] === targetJoint) {
                    index = j;
                    break;
                  }
                }

                if (index >= 0) {
                  outBuffers.push(i);
                  outIndices.push(index);
                }
              }
            }

            var v3_min$1 = new Vec3();
            var v3_max$1 = new Vec3();
            var v3_1$2 = new Vec3();
            var v3_2$1 = new Vec3();
            var m4_1$3 = new Mat4();
            var ab_1$1 = new AABB();

            var RealTimeJointTexture = function RealTimeJointTexture() {
              this._format = PixelFormat.RGBA32F;
              this._textures = [];
              this._buffers = [];
            };

            RealTimeJointTexture.WIDTH = 256;
            RealTimeJointTexture.HEIGHT = 3;
            var SkinningModel = function (_MorphModel) {
              _inheritsLoose(SkinningModel, _MorphModel);

              function SkinningModel() {
                var _this;

                _this = _MorphModel.call(this) || this;
                _this._buffers = [];
                _this._dataArray = [];
                _this._joints = [];
                _this._bufferIndices = null;
                _this._realTimeJointTexture = new RealTimeJointTexture();
                _this._realTimeTextureMode = false;
                _this.type = ModelType.SKINNING;
                return _this;
              }

              var _proto = SkinningModel.prototype;

              _proto.destroy = function destroy() {
                this.bindSkeleton();

                if (this._buffers.length) {
                  for (var i = 0; i < this._buffers.length; i++) {
                    this._buffers[i].destroy();
                  }

                  this._buffers.length = 0;
                }

                this._dataArray.length = 0;

                this._realTimeJointTexture._textures.forEach(function (tex) {
                  tex.destroy();
                });

                this._realTimeJointTexture._textures.length = 0;
                this._realTimeJointTexture._buffers.length = 0;

                _MorphModel.prototype.destroy.call(this);
              };

              _proto.uploadAnimation = function uploadAnimation() {};

              _proto.bindSkeleton = function bindSkeleton(skeleton, skinningRoot, mesh) {
                if (skeleton === void 0) {
                  skeleton = null;
                }

                if (skinningRoot === void 0) {
                  skinningRoot = null;
                }

                if (mesh === void 0) {
                  mesh = null;
                }

                for (var i = 0; i < this._joints.length; i++) {
                  deleteTransform(this._joints[i].target);
                }

                this._bufferIndices = null;
                this._joints.length = 0;

                if (!skeleton || !skinningRoot || !mesh) {
                  return;
                }

                this._realTimeTextureMode = false;

                if (UBOSkinning.JOINT_UNIFORM_CAPACITY < skeleton.joints.length) {
                  this._realTimeTextureMode = true;
                }

                this.transform = skinningRoot;
                var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);
                var jointMaps = mesh.struct.jointMaps;

                this._ensureEnoughBuffers(jointMaps && jointMaps.length || 1);

                this._bufferIndices = mesh.jointBufferIndices;

                this._initRealTimeJointTexture();

                for (var index = 0; index < skeleton.joints.length; index++) {
                  var bound = boneSpaceBounds[index];
                  var target = skinningRoot.getChildByPath(skeleton.joints[index]);

                  if (!bound || !target) {
                    continue;
                  }

                  var transform = getTransform(target, skinningRoot);
                  var bindpose = skeleton.bindposes[index];
                  var indices = [];
                  var buffers = [];

                  if (!jointMaps) {
                    indices.push(index);
                    buffers.push(0);
                  } else {
                    getRelevantBuffers(indices, buffers, jointMaps, index);
                  }

                  this._joints.push({
                    indices: indices,
                    buffers: buffers,
                    bound: bound,
                    target: target,
                    bindpose: bindpose,
                    transform: transform
                  });
                }
              };

              _proto.updateTransform = function updateTransform(stamp) {
                var root = this.transform;

                if (root.hasChangedFlags || root.isTransformDirty()) {
                  root.updateWorldTransform();
                  this._localDataUpdated = true;
                }

                Vec3.set(v3_min$1, Infinity, Infinity, Infinity);
                Vec3.set(v3_max$1, -Infinity, -Infinity, -Infinity);

                for (var i = 0; i < this._joints.length; i++) {
                  var _this$_joints$i = this._joints[i],
                      bound = _this$_joints$i.bound,
                      transform = _this$_joints$i.transform;
                  var worldMatrix = getWorldMatrix(transform, stamp);
                  AABB.transform(ab_1$1, bound, worldMatrix);
                  ab_1$1.getBoundary(v3_1$2, v3_2$1);
                  Vec3.min(v3_min$1, v3_min$1, v3_1$2);
                  Vec3.max(v3_max$1, v3_max$1, v3_2$1);
                }

                var worldBounds = this._worldBounds;

                if (this._modelBounds && worldBounds) {
                  AABB.fromPoints(this._modelBounds, v3_min$1, v3_max$1);

                  this._modelBounds.transform(root._mat, root._pos, root._rot, root._scale, this._worldBounds);
                }
              };

              _proto.updateUBOs = function updateUBOs(stamp) {
                _MorphModel.prototype.updateUBOs.call(this, stamp);

                for (var i = 0; i < this._joints.length; i++) {
                  var _this$_joints$i2 = this._joints[i],
                      indices = _this$_joints$i2.indices,
                      buffers = _this$_joints$i2.buffers,
                      transform = _this$_joints$i2.transform,
                      bindpose = _this$_joints$i2.bindpose;
                  Mat4.multiply(m4_1$3, transform.world, bindpose);

                  for (var b = 0; b < buffers.length; b++) {
                    uploadJointData(this._dataArray[buffers[b]], indices[b] * 12, m4_1$3);
                  }
                }

                if (this._realTimeTextureMode) {
                  this._updateRealTimeJointTextureBuffer();
                } else {
                  for (var _b = 0; _b < this._buffers.length; _b++) {
                    this._buffers[_b].update(this._dataArray[_b]);
                  }
                }

                return true;
              };

              _proto.initSubModel = function initSubModel(idx, subMeshData, mat) {
                var original = subMeshData.vertexBuffers;
                var iaInfo = subMeshData.iaInfo;
                iaInfo.vertexBuffers = subMeshData.jointMappedBuffers;

                _MorphModel.prototype.initSubModel.call(this, idx, subMeshData, mat);

                iaInfo.vertexBuffers = original;
              };

              _proto.getMacroPatches = function getMacroPatches(subModelIndex) {
                var superMacroPatches = _MorphModel.prototype.getMacroPatches.call(this, subModelIndex);

                var myPatches = uniformPatches;

                if (this._realTimeTextureMode) {
                  myPatches = texturePatches;
                }

                if (superMacroPatches) {
                  return myPatches.concat(superMacroPatches);
                }

                return myPatches;
              };

              _proto._updateLocalDescriptors = function _updateLocalDescriptors(submodelIdx, descriptorSet) {
                _MorphModel.prototype._updateLocalDescriptors.call(this, submodelIdx, descriptorSet);

                var idx = this._bufferIndices[submodelIdx];

                if (this._realTimeTextureMode) {
                  this._bindRealTimeJointTexture(idx, descriptorSet);
                } else {
                  var buffer = this._buffers[idx];

                  if (buffer) {
                    descriptorSet.bindBuffer(UBOSkinning.BINDING, buffer);
                  }
                }
              };

              _proto._updateInstancedAttributes = function _updateInstancedAttributes(attributes, subModel) {
                var pass = subModel.passes[0];

                if (pass.batchingScheme !== BatchingSchemes.NONE) {
                  warnID(3936, this.node.getPathInHierarchy());
                }

                _MorphModel.prototype._updateInstancedAttributes.call(this, attributes, subModel);
              };

              _proto._ensureEnoughBuffers = function _ensureEnoughBuffers(count) {
                if (this._buffers.length) {
                  for (var i = 0; i < this._buffers.length; i++) {
                    this._buffers[i].destroy();
                  }

                  this._buffers.length = 0;
                }

                if (this._dataArray.length) this._dataArray.length = 0;

                if (!this._realTimeTextureMode) {
                  for (var _i = 0; _i < count; _i++) {
                    this._buffers[_i] = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOSkinning.SIZE, UBOSkinning.SIZE));
                    var maxJoints = UBOSkinning.JOINT_UNIFORM_CAPACITY;
                    this._dataArray[_i] = new Float32Array(12 * maxJoints);
                  }
                } else {
                  for (var _i2 = 0; _i2 < count; _i2++) {
                    var _maxJoints = RealTimeJointTexture.WIDTH;
                    this._dataArray[_i2] = new Float32Array(12 * _maxJoints);
                  }
                }
              };

              _proto._initRealTimeJointTexture = function _initRealTimeJointTexture() {
                if (this._realTimeJointTexture._textures.length) {
                  this._realTimeJointTexture._textures.forEach(function (tex) {
                    tex.destroy();
                  });

                  this._realTimeJointTexture._textures.length = 0;
                }

                this._realTimeJointTexture._buffers.length = 0;
                if (!this._realTimeTextureMode) return;
                var gfxDevice = director.root.device;
                var width = RealTimeJointTexture.WIDTH;
                var height = RealTimeJointTexture.HEIGHT;
                var hasFeatureFloatTexture = gfxDevice.getFormatFeatures(Format.RGBA32F) & FormatFeatureBit.SAMPLED_TEXTURE;

                if (hasFeatureFloatTexture === 0) {
                  this._realTimeJointTexture._format = PixelFormat.RGBA8888;
                  width = 4 * RealTimeJointTexture.WIDTH;
                }

                var textures = this._realTimeJointTexture._textures;
                var buffers = this._realTimeJointTexture._buffers;
                var pixelFormat = this._realTimeJointTexture._format;

                for (var i = 0; i < this._dataArray.length; i++) {
                  buffers[i] = new Float32Array(4 * RealTimeJointTexture.HEIGHT * RealTimeJointTexture.WIDTH);
                  var arrayBuffer = buffers[i];
                  var updateView = pixelFormat === PixelFormat.RGBA32F ? arrayBuffer : new Uint8Array(arrayBuffer.buffer);
                  var image = new ImageAsset({
                    width: width,
                    height: height,
                    _data: updateView,
                    _compressed: false,
                    format: pixelFormat
                  });
                  var texture = new Texture2D();
                  texture.setFilters(Texture2D.Filter.NEAREST, Texture2D.Filter.NEAREST);
                  texture.setMipFilter(Texture2D.Filter.NONE);
                  texture.setWrapMode(Texture2D.WrapMode.CLAMP_TO_EDGE, Texture2D.WrapMode.CLAMP_TO_EDGE, Texture2D.WrapMode.CLAMP_TO_EDGE);
                  texture.image = image;
                  textures[i] = texture;
                }
              };

              _proto._bindRealTimeJointTexture = function _bindRealTimeJointTexture(idx, descriptorSet) {
                if (!this._realTimeTextureMode) return;
                var jointTexture = this._realTimeJointTexture._textures[idx];

                if (jointTexture) {
                  var gfxTexture = jointTexture.getGFXTexture();
                  var sampler = jointTexture.getGFXSampler();
                  descriptorSet.bindTexture(UNIFORM_REALTIME_JOINT_TEXTURE_BINDING, gfxTexture);
                  descriptorSet.bindSampler(UNIFORM_REALTIME_JOINT_TEXTURE_BINDING, sampler);
                }
              };

              _proto._updateRealTimeJointTextureBuffer = function _updateRealTimeJointTextureBuffer() {
                if (!this._realTimeTextureMode) return;
                var textures = this._realTimeJointTexture._textures;
                var buffers = this._realTimeJointTexture._buffers;

                for (var idx = 0; idx < textures.length; idx++) {
                  var arrayBuffer = buffers[idx];
                  var src = this._dataArray[idx];
                  var count = src.length / 12;
                  var idxSrc = 0;
                  var idxDst = 0;

                  for (var i = 0; i < count; i++) {
                    idxDst = 4 * i;
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    idxDst = 4 * (i + RealTimeJointTexture.WIDTH);
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    idxDst = 4 * (i + 2 * RealTimeJointTexture.WIDTH);
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                  }

                  var pixelFormat = this._realTimeJointTexture._format;
                  var updateView = pixelFormat === PixelFormat.RGBA32F ? arrayBuffer : new Uint8Array(arrayBuffer.buffer);
                  textures[idx].uploadData(updateView);
                }
              };

              return SkinningModel;
            }(MorphModel);

            var myPatches = [{
              name: 'CC_USE_SKINNING',
              value: true
            }, {
              name: 'CC_USE_BAKED_ANIMATION',
              value: true
            }];
            var BakedSkinningModel = function (_MorphModel) {
              _inheritsLoose(BakedSkinningModel, _MorphModel);

              function BakedSkinningModel() {
                var _this;

                _this = _MorphModel.call(this) || this;
                _this.uploadedAnim = undefined;
                _this._jointsMedium = void 0;
                _this._skeleton = null;
                _this._mesh = null;
                _this._dataPoolManager = void 0;
                _this._instAnimInfoIdx = -1;
                _this.type = ModelType.BAKED_SKINNING;
                _this._dataPoolManager = legacyCC.director.root.dataPoolManager;
                var jointTextureInfo = new Float32Array(4);

                var animInfo = _this._dataPoolManager.jointAnimationInfo.getData();

                _this._jointsMedium = {
                  buffer: null,
                  jointTextureInfo: jointTextureInfo,
                  animInfo: animInfo,
                  texture: null,
                  boundsInfo: null
                };
                return _this;
              }

              var _proto = BakedSkinningModel.prototype;

              _proto.destroy = function destroy() {
                this.uploadedAnim = undefined;
                this._jointsMedium.boundsInfo = null;

                if (this._jointsMedium.buffer) {
                  this._jointsMedium.buffer.destroy();

                  this._jointsMedium.buffer = null;
                }

                this._applyJointTexture();

                _MorphModel.prototype.destroy.call(this);
              };

              _proto.bindSkeleton = function bindSkeleton(skeleton, skinningRoot, mesh) {
                if (skeleton === void 0) {
                  skeleton = null;
                }

                if (skinningRoot === void 0) {
                  skinningRoot = null;
                }

                if (mesh === void 0) {
                  mesh = null;
                }

                this._skeleton = skeleton;
                this._mesh = mesh;

                if (!skeleton || !skinningRoot || !mesh) {
                  return;
                }

                this.transform = skinningRoot;
                var resMgr = this._dataPoolManager;
                this._jointsMedium.animInfo = resMgr.jointAnimationInfo.getData(skinningRoot.uuid);

                if (!this._jointsMedium.buffer) {
                  this._jointsMedium.buffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, UBOSkinningTexture.SIZE, UBOSkinningTexture.SIZE));
                }
              };

              _proto.updateTransform = function updateTransform(stamp) {
                _MorphModel.prototype.updateTransform.call(this, stamp);

                if (!this.uploadedAnim) {
                  return;
                }

                var _this$_jointsMedium = this._jointsMedium,
                    animInfo = _this$_jointsMedium.animInfo,
                    boundsInfo = _this$_jointsMedium.boundsInfo;
                var skelBound = boundsInfo[animInfo.data[0]];
                var worldBounds = this._worldBounds;

                if (worldBounds && skelBound) {
                  var node = this.transform;
                  skelBound.transform(node._mat, node._pos, node._rot, node._scale, worldBounds);
                }
              };

              _proto.updateUBOs = function updateUBOs(stamp) {
                _MorphModel.prototype.updateUBOs.call(this, stamp);

                var info = this._jointsMedium.animInfo;
                var hasNonInstancingPass = false;
                var idx = this._instAnimInfoIdx;

                for (var i = 0; i < this._subModels.length; i++) {
                  var subModel = this._subModels[i];

                  if (idx >= 0) {
                    var view = subModel.instancedAttributeBlock.views[idx];
                    view[0] = info.data[0];
                  } else {
                    hasNonInstancingPass = true;
                  }
                }

                if (hasNonInstancingPass && info.dirty) {
                  info.buffer.update(info.data);
                  info.dirty = false;
                }

                return true;
              };

              _proto.getMacroPatches = function getMacroPatches(subModelIndex) {
                var patches = _MorphModel.prototype.getMacroPatches.call(this, subModelIndex);

                return patches ? patches.concat(myPatches) : myPatches;
              };

              _proto.uploadAnimation = function uploadAnimation(anim) {
                if (!this._skeleton || !this._mesh || this.uploadedAnim === anim) {
                  return;
                }

                this.uploadedAnim = anim;
                var resMgr = this._dataPoolManager;
                var texture = null;

                if (anim) {
                  texture = resMgr.jointTexturePool.getSequencePoseTexture(this._skeleton, anim, this._mesh, this.transform);
                  this._jointsMedium.boundsInfo = texture && texture.bounds.get(this._mesh.hash);
                  this._modelBounds = null;
                } else {
                  texture = resMgr.jointTexturePool.getDefaultPoseTexture(this._skeleton, this._mesh, this.transform);
                  this._jointsMedium.boundsInfo = null;
                  this._modelBounds = texture && texture.bounds.get(this._mesh.hash)[0];
                }

                this._applyJointTexture(texture);
              };

              _proto._applyJointTexture = function _applyJointTexture(texture) {
                if (texture === void 0) {
                  texture = null;
                }

                var oldTex = this._jointsMedium.texture;

                if (oldTex && oldTex !== texture) {
                  this._dataPoolManager.jointTexturePool.releaseHandle(oldTex);
                }

                this._jointsMedium.texture = texture;

                if (!texture) {
                  return;
                }

                var _this$_jointsMedium2 = this._jointsMedium,
                    buffer = _this$_jointsMedium2.buffer,
                    jointTextureInfo = _this$_jointsMedium2.jointTextureInfo;
                jointTextureInfo[0] = texture.handle.texture.width;
                jointTextureInfo[1] = this._skeleton.joints.length;
                jointTextureInfo[2] = texture.pixelOffset + 0.1;
                jointTextureInfo[3] = 1 / jointTextureInfo[0];
                this.updateInstancedJointTextureInfo();

                if (buffer) {
                  buffer.update(jointTextureInfo);
                }

                var tex = texture.handle.texture;

                for (var i = 0; i < this._subModels.length; ++i) {
                  var descriptorSet = this._subModels[i].descriptorSet;
                  descriptorSet.bindTexture(UNIFORM_JOINT_TEXTURE_BINDING, tex);
                }
              };

              _proto._updateLocalDescriptors = function _updateLocalDescriptors(submodelIdx, descriptorSet) {
                _MorphModel.prototype._updateLocalDescriptors.call(this, submodelIdx, descriptorSet);

                var _this$_jointsMedium3 = this._jointsMedium,
                    buffer = _this$_jointsMedium3.buffer,
                    texture = _this$_jointsMedium3.texture,
                    animInfo = _this$_jointsMedium3.animInfo;
                descriptorSet.bindBuffer(UBOSkinningTexture.BINDING, buffer);
                descriptorSet.bindBuffer(UBOSkinningAnimation.BINDING, animInfo.buffer);

                if (texture) {
                  var sampler = this._device.getSampler(jointTextureSamplerInfo);

                  descriptorSet.bindTexture(UNIFORM_JOINT_TEXTURE_BINDING, texture.handle.texture);
                  descriptorSet.bindSampler(UNIFORM_JOINT_TEXTURE_BINDING, sampler);
                }
              };

              _proto._updateInstancedAttributes = function _updateInstancedAttributes(attributes, subModel) {
                _MorphModel.prototype._updateInstancedAttributes.call(this, attributes, subModel);

                this._instAnimInfoIdx = subModel.getInstancedAttributeIndex(INST_JOINT_ANIM_INFO);
                this.updateInstancedJointTextureInfo();
              };

              _proto.updateInstancedJointTextureInfo = function updateInstancedJointTextureInfo() {
                var _this$_jointsMedium4 = this._jointsMedium,
                    jointTextureInfo = _this$_jointsMedium4.jointTextureInfo,
                    animInfo = _this$_jointsMedium4.animInfo;
                var idx = this._instAnimInfoIdx;

                for (var i = 0; i < this._subModels.length; i++) {
                  var subModel = this._subModels[i];
                  var views = subModel.instancedAttributeBlock.views;

                  if (idx >= 0 && views.length > 0) {
                    var view = views[idx];
                    view[0] = animInfo.data[0];
                    view[1] = jointTextureInfo[1];
                    view[2] = jointTextureInfo[2];
                  }
                }
              };

              return BakedSkinningModel;
            }(MorphModel);

            var _dec$u, _dec2$p, _dec3$i, _dec4$a, _dec5$6, _dec6$6, _class$u, _class2$p, _initializer$n, _initializer2$j;
            var SkinnedMeshRenderer = exports('SkinnedMeshRenderer', (_dec$u = ccclass$p('cc.SkinnedMeshRenderer'), _dec2$p = executionOrder(100), _dec3$i = type$8(Skeleton), _dec4$a = type$8(Node), _dec5$6 = type$8(Skeleton), _dec6$6 = type$8(Node), _dec$u(_class$u = _dec2$p(_class$u = (_class2$p = function (_MeshRenderer) {
              _inheritsLoose(SkinnedMeshRenderer, _MeshRenderer);

              function SkinnedMeshRenderer() {
                var _this;

                _this = _MeshRenderer.call(this) || this;
                _this._skeleton = _initializer$n && _initializer$n();
                _this._skinningRoot = _initializer2$j && _initializer2$j();
                _this._clip = null;
                _this.associatedAnimation = null;
                _this._modelType = BakedSkinningModel;
                return _this;
              }

              var _proto = SkinnedMeshRenderer.prototype;

              _proto.onLoad = function onLoad() {
                _MeshRenderer.prototype.onLoad.call(this);

                this._tryBindAnimation();
              };

              _proto.onDestroy = function onDestroy() {
                if (this.associatedAnimation) {
                  this.associatedAnimation.notifySkinnedMeshRemoved(this);
                  assertIsTrue(this.associatedAnimation === null);
                }

                _MeshRenderer.prototype.onDestroy.call(this);
              };

              _proto.uploadAnimation = function uploadAnimation(clip) {
                this._clip = clip;

                if (this.model && this.model.uploadAnimation) {
                  this.model.uploadAnimation(clip);
                }
              };

              _proto.setUseBakedAnimation = function setUseBakedAnimation(val, force) {
                if (val === void 0) {
                  val = true;
                }

                if (force === void 0) {
                  force = false;
                }

                var modelType = val ? BakedSkinningModel : SkinningModel;

                if (!force && this._modelType === modelType) {
                  return;
                }

                this._modelType = modelType;

                if (this._model) {
                  legacyCC.director.root.destroyModel(this._model);
                  this._model = null;
                  this._models.length = 0;

                  this._updateModels();

                  this._updateCastShadow();

                  this._updateReceiveShadow();

                  this._updateUseLightProbe();

                  if (this.enabledInHierarchy) {
                    this._attachToScene();
                  }
                }
              };

              _proto.setMaterial = function setMaterial(material, index) {
                _MeshRenderer.prototype.setMaterial.call(this, material, index);

                if (this._modelType === SkinningModel) {
                  this.getMaterialInstance(index);
                }
              };

              _proto._updateModelParams = function _updateModelParams() {
                this._update();

                _MeshRenderer.prototype._updateModelParams.call(this);
              };

              _proto._tryBindAnimation = function _tryBindAnimation() {
                var skinningRoot = this._skinningRoot;

                if (!skinningRoot) {
                  return;
                }

                var skinningRootIsParent = false;

                for (var current = this.node; current; current = current.parent) {
                  if (current === skinningRoot) {
                    skinningRootIsParent = true;
                    break;
                  }
                }

                if (!skinningRootIsParent) {
                  return;
                }

                var animation = skinningRoot.getComponent('cc.SkeletalAnimation');

                if (animation) {
                  animation.notifySkinnedMeshAdded(this);
                } else {
                  this.setUseBakedAnimation(false);
                }
              };

              _proto._update = function _update() {
                if (this.model) {
                  this.model.bindSkeleton(this._skeleton, this._skinningRoot, this._mesh);

                  if (this.model.uploadAnimation) {
                    this.model.uploadAnimation(this._clip);
                  }
                }
              };

              _createClass(SkinnedMeshRenderer, [{
                key: "skeleton",
                get: function get() {
                  return this._skeleton;
                },
                set: function set(val) {
                  if (val === this._skeleton) {
                    return;
                  }

                  this._skeleton = val;

                  this._update();
                }
              }, {
                key: "skinningRoot",
                get: function get() {
                  return this._skinningRoot;
                },
                set: function set(value) {
                  if (value === this._skinningRoot) {
                    return;
                  }

                  this._skinningRoot = value;

                  this._tryBindAnimation();

                  this._update();
                }
              }, {
                key: "model",
                get: function get() {
                  return this._model;
                }
              }]);

              return SkinnedMeshRenderer;
            }(MeshRenderer), (_initializer$n = applyDecoratedInitializer(_class2$p.prototype, "_skeleton", [_dec3$i], function () {
              return null;
            }), _initializer2$j = applyDecoratedInitializer(_class2$p.prototype, "_skinningRoot", [_dec4$a], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$p.prototype, "skeleton", [_dec5$6], Object.getOwnPropertyDescriptor(_class2$p.prototype, "skeleton"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "skinningRoot", [_dec6$6], Object.getOwnPropertyDescriptor(_class2$p.prototype, "skinningRoot"), _class2$p.prototype)), _class2$p)) || _class$u) || _class$u));

            var _dec$v, _dec2$q, _dec3$j, _dec4$b, _dec5$7, _class$v, _class2$q, _initializer$o, _initializer2$k, _initializer3$f, _initializer4$d, _initializer5$b, _initializer6$9, _dec6$7, _dec7$6, _dec8$3, _dec9$3, _class4$1, _class5$1, _initializer7$7, _initializer8$7, _initializer9$6;

            var repeat = function repeat(n) {
              return n - Math.floor(n);
            };

            var batch_id = new Attribute(AttributeName.ATTR_BATCH_ID, Format.R32F);
            var batch_uv = new Attribute(AttributeName.ATTR_BATCH_UV, Format.RG32F);
            var batch_extras_size = FormatInfos[batch_id.format].size + FormatInfos[batch_uv.format].size;
            var SkinnedMeshUnit = exports('SkinnedMeshUnit', (_dec$v = ccclass$p('cc.SkinnedMeshUnit'), _dec2$q = type$8(Mesh), _dec3$j = type$8(Skeleton), _dec4$b = type$8(Material), _dec5$7 = type$8(SkinnedMeshRenderer), _dec$v(_class$v = (_class2$q = function () {
              function SkinnedMeshUnit() {
                this.mesh = _initializer$o && _initializer$o();
                this.skeleton = _initializer2$k && _initializer2$k();
                this.material = _initializer3$f && _initializer3$f();
                this._localTransform = _initializer4$d && _initializer4$d();
                this._offset = _initializer5$b && _initializer5$b();
                this._size = _initializer6$9 && _initializer6$9();
              }

              _createClass(SkinnedMeshUnit, [{
                key: "offset",
                get: function get() {
                  return this._offset;
                },
                set: function set(offset) {
                  Vec2.copy(this._offset, offset);
                }
              }, {
                key: "size",
                get: function get() {
                  return this._size;
                },
                set: function set(size) {
                  Vec2.copy(this._size, size);
                }
              }, {
                key: "copyFrom",
                get: function get() {
                  return null;
                },
                set: function set(comp) {
                  if (!comp) {
                    return;
                  }

                  this.mesh = comp.mesh;
                  this.skeleton = comp.skeleton;
                  this.material = comp.getSharedMaterial(0);

                  if (comp.skinningRoot) {
                    getWorldTransformUntilRoot(comp.node, comp.skinningRoot, this._localTransform);
                  }
                }
              }]);

              return SkinnedMeshUnit;
            }(), (_initializer$o = applyDecoratedInitializer(_class2$q.prototype, "mesh", [_dec2$q], function () {
              return null;
            }), _initializer2$k = applyDecoratedInitializer(_class2$q.prototype, "skeleton", [_dec3$j], function () {
              return null;
            }), _initializer3$f = applyDecoratedInitializer(_class2$q.prototype, "material", [_dec4$b], function () {
              return null;
            }), _initializer4$d = applyDecoratedInitializer(_class2$q.prototype, "_localTransform", [serializable$j], function () {
              return new Mat4();
            }), _initializer5$b = applyDecoratedInitializer(_class2$q.prototype, "_offset", [serializable$j], function () {
              return new Vec2(0, 0);
            }), _initializer6$9 = applyDecoratedInitializer(_class2$q.prototype, "_size", [serializable$j], function () {
              return new Vec2(1, 1);
            }), _applyDecoratedDescriptor(_class2$q.prototype, "copyFrom", [_dec5$7], Object.getOwnPropertyDescriptor(_class2$q.prototype, "copyFrom"), _class2$q.prototype)), _class2$q)) || _class$v));
            var m4_local = new Mat4();
            var m4_1$4 = new Mat4();
            var v3_1$3 = new Vec3();
            var SkinnedMeshBatchRenderer = exports('SkinnedMeshBatchRenderer', (_dec6$7 = ccclass$p('cc.SkinnedMeshBatchRenderer'), _dec7$6 = executionOrder(100), _dec8$3 = type$8([CCString]), _dec9$3 = type$8([SkinnedMeshUnit]), _dec6$7(_class4$1 = _dec7$6(_class4$1 = (_class5$1 = function (_SkinnedMeshRenderer) {
              _inheritsLoose(SkinnedMeshBatchRenderer, _SkinnedMeshRenderer);

              function SkinnedMeshBatchRenderer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _SkinnedMeshRenderer.call.apply(_SkinnedMeshRenderer, [this].concat(args)) || this;
                _this.atlasSize = _initializer7$7 && _initializer7$7();
                _this.batchableTextureNames = _initializer8$7 && _initializer8$7();
                _this.units = _initializer9$6 && _initializer9$6();
                _this._textures = {};
                _this._batchMaterial = null;
                return _this;
              }

              var _proto = SkinnedMeshBatchRenderer.prototype;

              _proto.onLoad = function onLoad() {
                _SkinnedMeshRenderer.prototype.onLoad.call(this);

                this.cook();
              };

              _proto.onDestroy = function onDestroy() {
                for (var tex in this._textures) {
                  this._textures[tex].destroy();
                }

                this._textures = {};

                if (this._mesh) {
                  this._mesh.destroy();

                  this._mesh = null;
                }

                _SkinnedMeshRenderer.prototype.onDestroy.call(this);
              };

              _proto._onMaterialModified = function _onMaterialModified(idx, material) {
                this.cookMaterials();

                _SkinnedMeshRenderer.prototype._onMaterialModified.call(this, idx, this.getMaterialInstance(idx));
              };

              _proto.cook = function cook() {
                this.cookMaterials();
                this.cookSkeletons();
                this.cookMeshes();
              };

              _proto.cookMaterials = function cookMaterials() {
                var _this2 = this;

                if (!this._batchMaterial) {
                  this._batchMaterial = this.getSharedMaterial(0);
                }

                var mat = this.getMaterialInstance(0);

                if (!mat || !this._batchMaterial || !this._batchMaterial.effectAsset) {
                  console.warn('incomplete batch material!');
                  return;
                }

                mat.copy(this._batchMaterial);
                this.resizeAtlases();
                var tech = mat.effectAsset.techniques[mat.technique];

                var _loop = function _loop(i) {
                  var pass = tech.passes[i];

                  if (!pass.properties) {
                    return "continue";
                  }

                  var _loop2 = function _loop2(prop) {
                    if (pass.properties[prop].type >= Type$1.SAMPLER1D) {
                      var tex = null;

                      if (_this2.batchableTextureNames.find(function (n) {
                        return n === prop;
                      })) {
                        tex = _this2._textures[prop];

                        if (!tex) {
                          tex = _this2.createTexture(prop);
                        }

                        _this2.cookTextures(tex, prop, i);
                      } else {
                        _this2.units.some(function (u) {
                          return tex = u.material && u.material.getProperty(prop, i);
                        });
                      }

                      if (tex) {
                        mat.setProperty(prop, tex, i);
                      }
                    } else {
                      var value = [];

                      for (var u = 0; u < _this2.units.length; u++) {
                        var unit = _this2.units[u];

                        if (!unit.material) {
                          continue;
                        }

                        value.push(unit.material.getProperty(prop.slice(0, -3), i));
                      }

                      mat.setProperty(prop, value, i);
                    }
                  };

                  for (var prop in pass.properties) {
                    _loop2(prop);
                  }
                };

                for (var i = 0; i < tech.passes.length; i++) {
                  var _ret = _loop(i);

                  if (_ret === "continue") continue;
                }
              };

              _proto.cookSkeletons = function cookSkeletons() {

                if (!this._skinningRoot) {
                  console.warn('no skinning root specified!');
                  return;
                }

                var joints = [];
                var bindposes = [];

                for (var u = 0; u < this.units.length; u++) {
                  var unit = this.units[u];

                  if (!unit || !unit.skeleton) {
                    continue;
                  }

                  var partial = unit.skeleton;
                  Mat4.invert(m4_local, unit._localTransform);

                  var _loop3 = function _loop3(i) {
                    var path = partial.joints[i];
                    var idx = joints.findIndex(function (p) {
                      return p === path;
                    });

                    if (idx >= 0) {

                      return "continue";
                    }

                    joints.push(path);
                    bindposes.push(Mat4.multiply(new Mat4(), partial.bindposes[i] || Mat4.IDENTITY, m4_local));
                  };

                  for (var i = 0; i < partial.joints.length; i++) {
                    var _ret2 = _loop3(i);

                    if (_ret2 === "continue") continue;
                  }
                }

                var idxMap = Array.from(Array(joints.length).keys()).sort(function (a, b) {
                  if (joints[a] > joints[b]) {
                    return 1;
                  }

                  if (joints[a] < joints[b]) {
                    return -1;
                  }

                  return 0;
                });
                var skeleton = new Skeleton();
                skeleton.joints = joints.map(function (_, idx, arr) {
                  return arr[idxMap[idx]];
                });
                skeleton.bindposes = bindposes.map(function (_, idx, arr) {
                  return arr[idxMap[idx]];
                });

                if (this._skeleton) {
                  this._skeleton.destroy();
                }

                this.skeleton = skeleton;
              };

              _proto.cookMeshes = function cookMeshes() {
                var _this4 = this;

                var isValid = false;

                for (var u = 0; u < this.units.length; u++) {
                  var unit = this.units[u];

                  if (unit.mesh) {
                    isValid = true;
                    break;
                  }
                }

                if (!isValid || !this._skinningRoot) {
                  return;
                }

                if (this._mesh) {
                  this._mesh.destroyRenderingMesh();
                } else {
                  this._mesh = new Mesh();
                }

                var posOffset = 0;
                var posFormat = Format.UNKNOWN;
                var normalOffset = 0;
                var normalFormat = Format.UNKNOWN;
                var tangentOffset = 0;
                var tangentFormat = Format.UNKNOWN;
                var uvOffset = 0;
                var uvFormat = Format.UNKNOWN;
                var jointOffset = 0;
                var jointFormat = Format.UNKNOWN;
                var jointIndexMap = new Array(this.units.length);
                var unitLen = this.units.length;

                for (var i = 0; i < unitLen; i++) {
                  var _unit = this.units[i];

                  if (!_unit || !_unit.skeleton) {
                    continue;
                  }

                  jointIndexMap[i] = _unit.skeleton.joints.map(function (j) {
                    return _this4._skeleton.joints.findIndex(function (ref) {
                      return j === ref;
                    });
                  });
                }

                var _loop4 = function _loop4(_i) {
                  var unit = _this4.units[_i];

                  if (!unit || !unit.mesh || !unit.mesh.data) {
                    return "continue";
                  }

                  var newMesh = _this4._createUnitMesh(_i, unit.mesh);

                  var dataView = new DataView(newMesh.data.buffer);
                  Mat4.inverseTranspose(m4_local, unit._localTransform);
                  var offset = unit.offset;
                  var size = unit.size;

                  var _loop5 = function _loop5(b) {
                    var bundle = newMesh.struct.vertexBundles[b];
                    posOffset = bundle.view.offset;
                    posFormat = Format.UNKNOWN;

                    for (var a = 0; a < bundle.attributes.length; a++) {
                      var attr = bundle.attributes[a];

                      if (attr.name === AttributeName.ATTR_POSITION) {
                        posFormat = attr.format;
                        break;
                      }

                      posOffset += FormatInfos[attr.format].size;
                    }

                    if (posFormat) {
                      var pos = readBuffer(dataView, posFormat, posOffset, bundle.view.length, bundle.view.stride);

                      for (var j = 0; j < pos.length; j += 3) {
                        Vec3.fromArray(v3_1$3, pos, j);
                        Vec3.transformMat4(v3_1$3, v3_1$3, unit._localTransform);
                        Vec3.toArray(pos, v3_1$3, j);
                      }

                      writeBuffer(dataView, pos, posFormat, posOffset, bundle.view.stride);
                    }

                    normalOffset = bundle.view.offset;
                    normalFormat = Format.UNKNOWN;

                    for (var _a = 0; _a < bundle.attributes.length; _a++) {
                      var _attr = bundle.attributes[_a];

                      if (_attr.name === AttributeName.ATTR_NORMAL) {
                        normalFormat = _attr.format;
                        break;
                      }

                      normalOffset += FormatInfos[_attr.format].size;
                    }

                    if (normalFormat) {
                      var normal = readBuffer(dataView, normalFormat, normalOffset, bundle.view.length, bundle.view.stride);

                      for (var _j = 0; _j < normal.length; _j += 3) {
                        Vec3.fromArray(v3_1$3, normal, _j);
                        Vec3.transformMat4Normal(v3_1$3, v3_1$3, m4_local);
                        Vec3.toArray(normal, v3_1$3, _j);
                      }

                      writeBuffer(dataView, normal, normalFormat, normalOffset, bundle.view.stride);
                    }

                    tangentOffset = bundle.view.offset;
                    tangentFormat = Format.UNKNOWN;

                    for (var _a2 = 0; _a2 < bundle.attributes.length; _a2++) {
                      var _attr2 = bundle.attributes[_a2];

                      if (_attr2.name === AttributeName.ATTR_TANGENT) {
                        tangentFormat = _attr2.format;
                        break;
                      }

                      tangentOffset += FormatInfos[_attr2.format].size;
                    }

                    if (tangentFormat) {
                      var tangent = readBuffer(dataView, tangentFormat, tangentOffset, bundle.view.length, bundle.view.stride);

                      for (var _j2 = 0; _j2 < tangent.length; _j2 += 3) {
                        Vec3.fromArray(v3_1$3, tangent, _j2);
                        Vec3.transformMat4Normal(v3_1$3, v3_1$3, m4_local);
                        Vec3.toArray(tangent, v3_1$3, _j2);
                      }

                      writeBuffer(dataView, tangent, tangentFormat, tangentOffset, bundle.view.stride);
                    }

                    uvOffset = bundle.view.offset;
                    uvFormat = Format.UNKNOWN;

                    for (var _a3 = 0; _a3 < bundle.attributes.length; _a3++) {
                      var _attr3 = bundle.attributes[_a3];

                      if (_attr3.name === AttributeName.ATTR_BATCH_UV) {
                        uvFormat = _attr3.format;
                        break;
                      }

                      uvOffset += FormatInfos[_attr3.format].size;
                    }

                    if (uvFormat) {
                      mapBuffer(dataView, function (cur, idx) {
                        cur = repeat(cur);
                        var comp = idx === 0 ? 'x' : 'y';
                        return cur * size[comp] + offset[comp];
                      }, uvFormat, uvOffset, bundle.view.length, bundle.view.stride, dataView);
                    }

                    var idxMap = jointIndexMap[_i];

                    if (!idxMap) {
                      return "continue";
                    }

                    jointOffset = bundle.view.offset;
                    jointFormat = Format.UNKNOWN;

                    for (var _a4 = 0; _a4 < bundle.attributes.length; _a4++) {
                      var _attr4 = bundle.attributes[_a4];

                      if (_attr4.name === AttributeName.ATTR_JOINTS) {
                        jointFormat = _attr4.format;
                        break;
                      }

                      jointOffset += FormatInfos[_attr4.format].size;
                    }

                    if (jointFormat) {
                      mapBuffer(dataView, function (cur) {
                        return idxMap[cur];
                      }, jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
                    }
                  };

                  for (var b = 0; b < newMesh.struct.vertexBundles.length; b++) {
                    var _ret4 = _loop5(b);

                    if (_ret4 === "continue") continue;
                  }

                  _this4._mesh.merge(newMesh);
                };

                for (var _i = 0; _i < unitLen; _i++) {
                  var _ret3 = _loop4(_i);

                  if (_ret3 === "continue") continue;
                }

                this._onMeshChanged(this._mesh);

                this._updateModels();
              };

              _proto.cookTextures = function cookTextures(target, prop, passIdx) {
                var texImages = [];
                var texImageRegions = [];
                var texBuffers = [];
                var texBufferRegions = [];

                for (var u = 0; u < this.units.length; u++) {
                  var unit = this.units[u];

                  if (!unit.material) {
                    continue;
                  }

                  var partial = unit.material.getProperty(prop, passIdx);

                  if (partial && partial.image && partial.image.data) {
                    var region = new BufferTextureCopy();
                    region.texOffset.x = unit.offset.x * this.atlasSize;
                    region.texOffset.y = unit.offset.y * this.atlasSize;
                    region.texExtent.width = unit.size.x * this.atlasSize;
                    region.texExtent.height = unit.size.y * this.atlasSize;
                    var data = partial.image.data;

                    if (!ArrayBuffer.isView(data)) {
                      texImages.push(data);
                      texImageRegions.push(region);
                    } else {
                      texBuffers.push(data);
                      texBufferRegions.push(region);
                    }
                  }
                }

                var gfxTex = target.getGFXTexture();
                var _ref = legacyCC.director.root,
                    device = _ref.device;

                if (texBuffers.length > 0) {
                  device.copyBuffersToTexture(texBuffers, gfxTex, texBufferRegions);
                }

                if (texImages.length > 0) {
                  device.copyTexImagesToTexture(texImages, gfxTex, texImageRegions);
                }
              };

              _proto.createTexture = function createTexture(prop) {
                var tex = new Texture2D();
                tex.setFilters(Filter$1.LINEAR, Filter$1.LINEAR);
                tex.setMipFilter(Filter$1.NEAREST);
                tex.reset({
                  width: this.atlasSize,
                  height: this.atlasSize,
                  format: PixelFormat.RGBA8888
                });
                this._textures[prop] = tex;
                return tex;
              };

              _proto.resizeAtlases = function resizeAtlases() {
                for (var prop in this._textures) {
                  var tex = this._textures[prop];
                  tex.reset({
                    width: this.atlasSize,
                    height: this.atlasSize,
                    format: PixelFormat.RGBA8888
                  });
                }
              };

              _proto._createUnitMesh = function _createUnitMesh(unitIdx, mesh) {
                var newMeshStruct = JSON.parse(JSON.stringify(mesh.struct));
                var modifiedBundles = {};

                for (var p = 0; p < mesh.struct.primitives.length; p++) {
                  var primitive = mesh.struct.primitives[p];
                  var uvOffset = 0;
                  var uvFormat = Format.UNKNOWN;
                  var bundleIdx = 0;

                  for (; bundleIdx < primitive.vertexBundelIndices.length; bundleIdx++) {
                    var bundle = mesh.struct.vertexBundles[primitive.vertexBundelIndices[bundleIdx]];
                    uvOffset = bundle.view.offset;
                    uvFormat = Format.UNKNOWN;

                    for (var a = 0; a < bundle.attributes.length; a++) {
                      var attr = bundle.attributes[a];

                      if (attr.name === AttributeName.ATTR_TEX_COORD) {
                        uvFormat = attr.format;
                        break;
                      }

                      uvOffset += FormatInfos[attr.format].size;
                    }

                    if (uvFormat) {
                      break;
                    }
                  }

                  if (modifiedBundles[bundleIdx] !== undefined) {
                    continue;
                  }

                  modifiedBundles[bundleIdx] = [uvFormat, uvOffset];
                  var newBundle = newMeshStruct.vertexBundles[bundleIdx];
                  newBundle.attributes.push(batch_id);
                  newBundle.attributes.push(batch_uv);
                  newBundle.view.offset = 0;
                  newBundle.view.length += newBundle.view.count * batch_extras_size;
                  newBundle.view.stride += batch_extras_size;
                }

                var totalLength = 0;

                for (var b = 0; b < newMeshStruct.vertexBundles.length; b++) {
                  totalLength += newMeshStruct.vertexBundles[b].view.length;
                }

                for (var _p = 0; _p < newMeshStruct.primitives.length; _p++) {
                  var pm = newMeshStruct.primitives[_p];

                  if (pm.indexView) {
                    pm.indexView.offset = totalLength;
                    totalLength += pm.indexView.length;
                  }
                }

                var newMeshData = new Uint8Array(totalLength);
                var oldMeshData = mesh.data;
                var newDataView = new DataView(newMeshData.buffer);
                var oldDataView = new DataView(oldMeshData.buffer);
                var isLittleEndian = legacyCC.sys.isLittleEndian;

                for (var _b in modifiedBundles) {
                  var _newBundle = newMeshStruct.vertexBundles[_b];
                  var oldBundle = mesh.struct.vertexBundles[_b];
                  var _modifiedBundles$_b = modifiedBundles[_b],
                      _uvFormat = _modifiedBundles$_b[0],
                      _uvOffset = _modifiedBundles$_b[1];
                  var uvs = readBuffer(oldDataView, _uvFormat, _uvOffset, oldBundle.view.length, oldBundle.view.stride);
                  var oldView = oldBundle.view;
                  var newView = _newBundle.view;
                  var oldStride = oldView.stride;
                  var newStride = newView.stride;
                  var oldOffset = oldView.offset;
                  var newOffset = newView.offset;

                  for (var j = 0; j < newView.count; j++) {
                    var srcVertex = oldMeshData.subarray(oldOffset, oldOffset + oldStride);
                    newMeshData.set(srcVertex, newOffset);
                    newDataView.setFloat32(newOffset + oldStride, unitIdx);
                    newDataView.setFloat32(newOffset + oldStride + 4, uvs[j * 2], isLittleEndian);
                    newDataView.setFloat32(newOffset + oldStride + 8, uvs[j * 2 + 1], isLittleEndian);
                    newOffset += newStride;
                    oldOffset += oldStride;
                  }
                }

                for (var k = 0; k < newMeshStruct.primitives.length; k++) {
                  var oldPrimitive = mesh.struct.primitives[k];
                  var newPrimitive = newMeshStruct.primitives[k];

                  if (oldPrimitive.indexView && newPrimitive.indexView) {
                    var _oldStride = oldPrimitive.indexView.stride;
                    var _newStride = newPrimitive.indexView.stride;
                    var _oldOffset = oldPrimitive.indexView.offset;
                    var _newOffset = newPrimitive.indexView.offset;

                    for (var _j3 = 0; _j3 < newPrimitive.indexView.count; _j3++) {
                      var srcIndices = oldMeshData.subarray(_oldOffset, _oldOffset + _oldStride);
                      newMeshData.set(srcIndices, _newOffset);
                      _newOffset += _newStride;
                      _oldOffset += _oldStride;
                    }
                  }
                }

                var newMesh = new Mesh();
                newMesh.reset({
                  struct: newMeshStruct,
                  data: newMeshData
                });
                return newMesh;
              };

              _createClass(SkinnedMeshBatchRenderer, [{
                key: "mesh",
                get: function get() {
                  return _SkinnedMeshRenderer.prototype.mesh;
                },
                set: function set(val) {
                  this.mesh = val;
                }
              }, {
                key: "skeleton",
                get: function get() {
                  return _SkinnedMeshRenderer.prototype.skeleton;
                },
                set: function set(val) {
                  this.skeleton = val;
                }
              }]);

              return SkinnedMeshBatchRenderer;
            }(SkinnedMeshRenderer), (_initializer7$7 = applyDecoratedInitializer(_class5$1.prototype, "atlasSize", [serializable$j], function () {
              return 1024;
            }), _initializer8$7 = applyDecoratedInitializer(_class5$1.prototype, "batchableTextureNames", [_dec8$3, serializable$j], function () {
              return [];
            }), _initializer9$6 = applyDecoratedInitializer(_class5$1.prototype, "units", [_dec9$3, serializable$j], function () {
              return [];
            }), _applyDecoratedDescriptor(_class5$1.prototype, "mesh", [override$1], Object.getOwnPropertyDescriptor(_class5$1.prototype, "mesh"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "skeleton", [override$1], Object.getOwnPropertyDescriptor(_class5$1.prototype, "skeleton"), _class5$1.prototype)), _class5$1)) || _class4$1) || _class4$1));

            var _dec$w, _dec2$r, _dec3$k, _dec4$c, _dec5$8, _class$w, _class2$r, _initializer$p, _initializer2$l, _dec6$8, _dec7$7, _dec8$4, _class4$2, _class5$2, _initializer3$g, _initializer4$e, _initializer5$c;
            var DEFAULT_SCREEN_OCCUPATION = [0.25, 0.125, 0.01];
            var LOD = exports('LOD', (_dec$w = ccclass$p('cc.LOD'), _dec2$r = type$8([MeshRenderer]), _dec3$k = type$8(CCFloat), _dec4$c = type$8([MeshRenderer]), _dec5$8 = type$8([CCInteger]), _dec$w(_class$w = (_class2$r = function () {
              function LOD() {
                this._screenUsagePercentage = _initializer$p && _initializer$p();
                this._renderers = _initializer2$l && _initializer2$l();
                this._LODData = new LODData();
                this._modelAddedCallback = void 0;
                this._LODData.screenUsagePercentage = this._screenUsagePercentage;
                this._modelAddedCallback = null;
              }

              var _proto = LOD.prototype;

              _proto.insertRenderer = function insertRenderer(index, renderer) {
                if (index < 0 || index > this._renderers.length) {
                  index = this._renderers.length;
                }

                this._renderers.splice(index, 0, renderer);

                var modelAdded = false;

                if (renderer.model) {
                  modelAdded = true;

                  this._LODData.addModel(renderer.model);
                }

                if (this._modelAddedCallback && modelAdded) {
                  this._modelAddedCallback();
                }

                return renderer;
              };

              _proto.deleteRenderer = function deleteRenderer(index) {
                var _renders$;

                var renders = this._renderers.splice(index, 1);

                var model = renders.length > 0 ? (_renders$ = renders[0]) === null || _renders$ === void 0 ? void 0 : _renders$.model : null;

                if (model) {
                  this._LODData.eraseModel(model);
                }

                return renders[0];
              };

              _proto.getRenderer = function getRenderer(index) {
                return this._renderers[index] || null;
              };

              _proto.setRenderer = function setRenderer(index, renderer) {
                if (index < 0 || index >= this.rendererCount) {
                  console.error('setRenderer to LOD error, index out of range');
                  return;
                }

                this.deleteRenderer(index);
                this.insertRenderer(index, renderer);
              };

              _createClass(LOD, [{
                key: "screenUsagePercentage",
                get: function get() {
                  return this._screenUsagePercentage;
                },
                set: function set(val) {
                  this._screenUsagePercentage = val;
                  this._LODData.screenUsagePercentage = val;
                }
              }, {
                key: "renderers",
                get: function get() {
                  return this._renderers;
                },
                set: function set(meshList) {
                  if (meshList === this._renderers) return;
                  var modelAdded = false;
                  this._renderers.length = 0;

                  this._LODData.clearModels();

                  for (var i = 0; i < meshList.length; i++) {
                    var _meshList$i;

                    this._renderers[i] = meshList[i];
                    var model = (_meshList$i = meshList[i]) === null || _meshList$i === void 0 ? void 0 : _meshList$i.model;

                    if (model) {
                      modelAdded = true;

                      this._LODData.addModel(model);
                    }
                  }

                  if (this._modelAddedCallback && modelAdded) {
                    this._modelAddedCallback();
                  }
                }
              }, {
                key: "triangleCount",
                get: function get() {
                  var tris = [];

                  this._renderers.forEach(function (meshRenderer) {
                    var count = 0;

                    if (meshRenderer && meshRenderer.mesh) {
                      var primitives = meshRenderer.mesh.struct.primitives;
                      primitives === null || primitives === void 0 ? void 0 : primitives.forEach(function (subMesh) {
                        if (subMesh && subMesh.indexView) {
                          count += subMesh.indexView.count;
                        }
                      });
                    }

                    tris.push(count / 3);
                  });

                  return tris;
                }
              }, {
                key: "rendererCount",
                get: function get() {
                  return this._renderers.length;
                }
              }, {
                key: "lodData",
                get: function get() {
                  return this._LODData;
                }
              }, {
                key: "modelAddedCallback",
                set: function set(callback) {
                  this._modelAddedCallback = callback;
                }
              }]);

              return LOD;
            }(), (_initializer$p = applyDecoratedInitializer(_class2$r.prototype, "_screenUsagePercentage", [serializable$j], function () {
              return 1.0;
            }), _initializer2$l = applyDecoratedInitializer(_class2$r.prototype, "_renderers", [_dec2$r, serializable$j], function () {
              return [];
            }), _applyDecoratedDescriptor(_class2$r.prototype, "screenUsagePercentage", [_dec3$k], Object.getOwnPropertyDescriptor(_class2$r.prototype, "screenUsagePercentage"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "renderers", [_dec4$c], Object.getOwnPropertyDescriptor(_class2$r.prototype, "renderers"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "triangleCount", [_dec5$8], Object.getOwnPropertyDescriptor(_class2$r.prototype, "triangleCount"), _class2$r.prototype)), _class2$r)) || _class$w));
            var LODGroup = exports('LODGroup', (_dec6$8 = ccclass$p('cc.LODGroup'), _dec7$7 = type$8(CCFloat), _dec8$4 = type$8([LOD]), _dec6$8(_class4$2 = (_class5$2 = function (_Component) {
              _inheritsLoose(LODGroup, _Component);

              function LODGroup() {
                var _this;

                _this = _Component.call(this) || this;
                _this._localBoundaryCenter = _initializer3$g && _initializer3$g();
                _this._objectSize = _initializer4$e && _initializer4$e();
                _this._LODs = _initializer5$c && _initializer5$c();
                _this._lodGroup = new LODGroup$1();
                _this._eventRegistered = false;
                return _this;
              }

              var _proto2 = LODGroup.prototype;

              _proto2.onLodModelAddedCallback = function onLodModelAddedCallback() {
                if (this.objectSize === 0) {
                  this.recalculateBounds();
                }
              };

              _proto2.insertLOD = function insertLOD(index, screenUsagePercentage, lod) {
                if (index < 0 || index > this.lodCount) {
                  index = this.lodCount;
                }

                if (!lod) {
                  lod = new LOD();
                }

                lod.modelAddedCallback = this.onLodModelAddedCallback.bind(this);

                if (!screenUsagePercentage) {
                  var preLod = this.getLOD(index - 1);
                  var nextLod = this.getLOD(index);

                  if (preLod && nextLod) {
                    screenUsagePercentage = (preLod.screenUsagePercentage + nextLod.screenUsagePercentage) / 2;
                  } else if (preLod && !nextLod) {
                    screenUsagePercentage = preLod.screenUsagePercentage / 2;

                    if (screenUsagePercentage > 0.01) {
                      screenUsagePercentage = 0.01;
                    }
                  } else if (nextLod && !preLod) {
                    screenUsagePercentage = nextLod.screenUsagePercentage;
                    var curNextLOD = this.getLOD(index + 1);
                    nextLod.screenUsagePercentage = (screenUsagePercentage + (curNextLOD ? curNextLOD.screenUsagePercentage : 0)) / 2;
                  } else {
                    screenUsagePercentage = DEFAULT_SCREEN_OCCUPATION[0];
                  }
                }

                lod.screenUsagePercentage = screenUsagePercentage;

                this._LODs.splice(index, 0, lod);

                this._lodGroup.insertLOD(index, lod.lodData);

                this._updateDataToScene();

                if (this.node) {
                  this._emitChangeNode(this.node);
                }

                return lod;
              };

              _proto2.eraseLOD = function eraseLOD(index) {
                if (index < 0 || index >= this.lodCount) {
                  console.warn('eraseLOD error, index out of range');
                  return null;
                }

                var lod = this._LODs[index];

                if (!lod) {
                  console.warn('eraseLOD error, LOD not exist at specified index.');
                  return null;
                }

                this._LODs.splice(index, 1);

                this._lodGroup.eraseLOD(index);

                this._updateDataToScene();

                this._emitChangeNode(this.node);

                return lod;
              };

              _proto2.getLOD = function getLOD(index) {
                if (index < 0 || index >= this.lodCount) {
                  console.warn('getLOD error, index out of range');
                  return null;
                }

                return this._LODs[index];
              };

              _proto2.setLOD = function setLOD(index, lod) {
                if (index < 0 || index >= this.lodCount) {
                  console.warn('setLOD error, index out of range');
                  return;
                }

                this._LODs[index] = lod;
                lod.modelAddedCallback = this.onLodModelAddedCallback.bind(this);
                this.lodGroup.updateLOD(index, lod.lodData);

                this._updateDataToScene();
              };

              _proto2.recalculateBounds = function recalculateBounds() {
                function getTransformedBoundary(c, e, transform) {
                  var minPos;
                  var maxPos;
                  var pts = new Array(new Vec3(c.x - e.x, c.y - e.y, c.z - e.z), new Vec3(c.x - e.x, c.y + e.y, c.z - e.z), new Vec3(c.x + e.x, c.y + e.y, c.z - e.z), new Vec3(c.x + e.x, c.y - e.y, c.z - e.z), new Vec3(c.x - e.x, c.y - e.y, c.z + e.z), new Vec3(c.x - e.x, c.y + e.y, c.z + e.z), new Vec3(c.x + e.x, c.y + e.y, c.z + e.z), new Vec3(c.x + e.x, c.y - e.y, c.z + e.z));
                  minPos = pts[0].transformMat4(transform);
                  maxPos = minPos.clone();

                  for (var i = 1; i < 8; ++i) {
                    var pt = pts[i].transformMat4(transform);
                    minPos = Vec3.min(minPos, minPos, pt);
                    maxPos = Vec3.max(maxPos, maxPos, pt);
                  }

                  return [minPos, maxPos];
                }

                var minPos = new Vec3();
                var maxPos = new Vec3();
                var boundsMin = null;
                var boundsMax = new Vec3();

                for (var i = 0; i < this.lodCount; ++i) {
                  var lod = this.getLOD(i);

                  if (lod) {
                    for (var j = 0; j < lod.rendererCount; ++j) {
                      var _renderer$model, _renderer$model2;

                      var renderer = lod.getRenderer(j);

                      if (!renderer) {
                        continue;
                      }

                      (_renderer$model = renderer.model) === null || _renderer$model === void 0 ? void 0 : _renderer$model.updateWorldBound();
                      var worldBounds = (_renderer$model2 = renderer.model) === null || _renderer$model2 === void 0 ? void 0 : _renderer$model2.worldBounds;

                      if (worldBounds) {

                        worldBounds.getBoundary(minPos, maxPos);

                        if (boundsMin) {
                          Vec3.min(boundsMin, boundsMin, minPos);
                          Vec3.max(boundsMax, boundsMax, maxPos);
                        } else {
                          boundsMin = minPos.clone();
                          boundsMax = maxPos.clone();
                        }
                      }
                    }
                  }
                }

                if (boundsMin) {
                  var boundsMin2 = boundsMin;
                  var c = new Vec3((boundsMax.x + boundsMin2.x) * 0.5, (boundsMax.y + boundsMin2.y) * 0.5, (boundsMax.z + boundsMin2.z) * 0.5);
                  var e = new Vec3((boundsMax.x - boundsMin2.x) * 0.5, (boundsMax.y - boundsMin2.y) * 0.5, (boundsMax.z - boundsMin2.z) * 0.5);

                  var _getTransformedBounda = getTransformedBoundary(c, e, this.node.worldMatrix.clone().invert()),
                      _minPos = _getTransformedBounda[0],
                      _maxPos = _getTransformedBounda[1];

                  c.set((_maxPos.x + _minPos.x) * 0.5, (_maxPos.y + _minPos.y) * 0.5, (_maxPos.z + _minPos.z) * 0.5);
                  e.set((_maxPos.x - _minPos.x) * 0.5, (_maxPos.y - _minPos.y) * 0.5, (_maxPos.z - _minPos.z) * 0.5);
                  this.localBoundaryCenter = c;
                  this.objectSize = Math.max(e.x, e.y, e.z) * 2.0;
                } else {
                  this.localBoundaryCenter = new Vec3(0, 0, 0);
                  this.objectSize = 0;
                }

                this._emitChangeNode(this.node);
              };

              _proto2.resetObjectSize = function resetObjectSize() {
                if (this.objectSize === 1.0) return;

                if (this.objectSize === 0) {
                  this.objectSize = 1.0;
                }

                var scale = 1.0 / this.objectSize;
                this.objectSize = 1.0;

                for (var i = 0; i < this.lodCount; ++i) {
                  var lod = this.getLOD(i);

                  if (lod) {
                    lod.screenUsagePercentage *= scale;
                  }
                }

                this._emitChangeNode(this.node);
              };

              _proto2.forceLOD = function forceLOD(lodLevel) {
                this.lodGroup.lockLODLevels(lodLevel < 0 ? [] : [lodLevel]);
              };

              _proto2.onLoad = function onLoad() {
                this._lodGroup.node = this.node;
                this._lodGroup.objectSize = this._objectSize;
                this._lodGroup.localBoundaryCenter = this._localBoundaryCenter;

                if (!this._eventRegistered) {
                  this.node.on(NodeEventType.COMPONENT_REMOVED, this._onRemove, this);
                  this._eventRegistered = true;
                }

                this._constructLOD();
              };

              _proto2._onRemove = function _onRemove(comp) {
                if (comp === this) {
                  this.onDisable();
                }
              };

              _proto2._constructLOD = function _constructLOD() {
                if (this.lodCount < 1) {
                  var size = DEFAULT_SCREEN_OCCUPATION.length;

                  for (var i = 0; i < size; i++) {
                    this.insertLOD(i, DEFAULT_SCREEN_OCCUPATION[i]);
                  }
                }
              };

              _proto2.onRestore = function onRestore() {
                this._constructLOD();

                if (this.enabledInHierarchy) {
                  this._attachToScene();
                }
              };

              _proto2.onEnable = function onEnable() {
                var _this2 = this;

                this._attachToScene();

                if (this.objectSize === 0) {
                  this.recalculateBounds();
                }

                if (this.lodCount > 0 && this._lodGroup.lodCount < 1) {
                  this._LODs.forEach(function (lod, index) {
                    lod.lodData.screenUsagePercentage = lod.screenUsagePercentage;
                    var renderers = lod.renderers;

                    if (renderers !== null && renderers.length > 0) {
                      for (var i = 0; i < renderers.length; i++) {
                        var lodInstance = lod.lodData;
                        var renderer = renderers[i];

                        if (lodInstance && renderer && renderer.model) {
                          lodInstance.addModel(renderer.model);
                        }
                      }
                    }

                    _this2._lodGroup.insertLOD(index, lod.lodData);
                  });
                }
              };

              _proto2.onDisable = function onDisable() {
                this._detachFromScene();
              };

              _proto2._attachToScene = function _attachToScene() {
                if (this.node && this.node.scene) {
                  var renderScene = this._getRenderScene();

                  if (this._lodGroup.scene) {
                    this._detachFromScene();
                  }

                  renderScene.addLODGroup(this._lodGroup);
                }
              };

              _proto2._detachFromScene = function _detachFromScene() {
                if (this._lodGroup.scene) {
                  this._lodGroup.scene.removeLODGroup(this._lodGroup);
                }
              };

              _proto2._emitChangeNode = function _emitChangeNode(node) {
              };

              _proto2._updateDataToScene = function _updateDataToScene() {
                this._detachFromScene();

                this._attachToScene();
              };

              _createClass(LODGroup, [{
                key: "localBoundaryCenter",
                get: function get() {
                  return this._localBoundaryCenter.clone();
                },
                set: function set(val) {
                  this._localBoundaryCenter.set(val);

                  this._lodGroup.localBoundaryCenter = val;
                }
              }, {
                key: "lodCount",
                get: function get() {
                  return this._LODs.length;
                }
              }, {
                key: "objectSize",
                get: function get() {
                  return this._objectSize;
                },
                set: function set(val) {
                  this._objectSize = val;
                  this._lodGroup.objectSize = val;
                }
              }, {
                key: "LODs",
                get: function get() {
                  return this._LODs;
                },
                set: function set(valArray) {
                  var _this3 = this;

                  if (valArray === this._LODs) {
                    this._updateDataToScene();

                    return;
                  }

                  this._LODs.length = 0;
                  this.lodGroup.clearLODs();
                  valArray.forEach(function (lod, index) {
                    _this3.lodGroup.insertLOD(index, lod.lodData);

                    _this3._LODs[index] = lod;
                    lod.modelAddedCallback = _this3.onLodModelAddedCallback.bind(_this3);
                  });

                  this._updateDataToScene();
                }
              }, {
                key: "lodGroup",
                get: function get() {
                  return this._lodGroup;
                }
              }]);

              return LODGroup;
            }(Component), (_initializer3$g = applyDecoratedInitializer(_class5$2.prototype, "_localBoundaryCenter", [serializable$j], function () {
              return new Vec3(0, 0, 0);
            }), _initializer4$e = applyDecoratedInitializer(_class5$2.prototype, "_objectSize", [serializable$j], function () {
              return 0;
            }), _initializer5$c = applyDecoratedInitializer(_class5$2.prototype, "_LODs", [serializable$j], function () {
              return [];
            }), _applyDecoratedDescriptor(_class5$2.prototype, "objectSize", [_dec7$7], Object.getOwnPropertyDescriptor(_class5$2.prototype, "objectSize"), _class5$2.prototype), _applyDecoratedDescriptor(_class5$2.prototype, "LODs", [_dec8$4], Object.getOwnPropertyDescriptor(_class5$2.prototype, "LODs"), _class5$2.prototype)), _class5$2)) || _class4$2));

            function wireframe(indices) {
              var offsets = [[0, 1], [1, 2], [2, 0]];
              var lines = [];
              var lineIDs = {};

              for (var i = 0; i < indices.length; i += 3) {
                for (var k = 0; k < 3; ++k) {
                  var i1 = indices[i + offsets[k][0]];
                  var i2 = indices[i + offsets[k][1]];
                  var id = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;

                  if (lineIDs[id] === undefined) {
                    lineIDs[id] = 0;
                    lines.push(i1, i2);
                  }
                }
              }

              return lines;
            }
            function invWinding(indices) {
              var newIB = [];

              for (var i = 0; i < indices.length; i += 3) {
                newIB.push(indices[i], indices[i + 2], indices[i + 1]);
              }

              return newIB;
            }
            function toWavefrontOBJ(primitive, scale) {
              if (scale === void 0) {
                scale = 1;
              }

              if (!primitive.indices || !primitive.uvs || !primitive.normals || primitive.primitiveMode !== undefined && primitive.primitiveMode !== PrimitiveMode.TRIANGLE_LIST) {
                return '';
              }

              var v = primitive.positions;
              var t = primitive.uvs;
              var n = primitive.normals;
              var IB = primitive.indices;

              var V = function V(i) {
                return IB[i] + 1 + "/" + (IB[i] + 1) + "/" + (IB[i] + 1);
              };

              var content = '';

              for (var i = 0; i < v.length; i += 3) {
                content += "v " + v[i] * scale + " " + v[i + 1] * scale + " " + v[i + 2] * scale + "\n";
              }

              for (var _i = 0; _i < t.length; _i += 2) {
                content += "vt " + t[_i] + " " + t[_i + 1] + "\n";
              }

              for (var _i2 = 0; _i2 < n.length; _i2 += 3) {
                content += "vn " + n[_i2] + " " + n[_i2 + 1] + " " + n[_i2 + 2] + "\n";
              }

              for (var _i3 = 0; _i3 < IB.length; _i3 += 3) {
                content += "f " + V(_i3) + " " + V(_i3 + 1) + " " + V(_i3 + 2) + "\n";
              }

              return content;
            }
            function normals(positions, nms, length) {
              if (length === void 0) {
                length = 1;
              }

              var verts = new Array(2 * positions.length);

              for (var i = 0; i < positions.length / 3; ++i) {
                var i3 = 3 * i;
                var i6 = 6 * i;
                verts[i6 + 0] = positions[i3 + 0];
                verts[i6 + 1] = positions[i3 + 1];
                verts[i6 + 2] = positions[i3 + 2];
                verts[i6 + 3] = positions[i3 + 0] + nms[i3 + 0] * length;
                verts[i6 + 4] = positions[i3 + 1] + nms[i3 + 1] * length;
                verts[i6 + 5] = positions[i3 + 2] + nms[i3 + 2] * length;
              }

              return verts;
            }

            function applyDefaultGeometryOptions(options) {
              options = options || {};

              if (options.includeNormal === undefined) {
                options.includeNormal = true;
              }

              if (options.includeUV === undefined) {
                options.includeUV = true;
              }

              return options;
            }

            function box(options) {
              options = options || {};
              var ws = options.widthSegments || 1;
              var hs = options.heightSegments || 1;
              var ls = options.lengthSegments || 1;
              var hw = (options.width || 1) / 2;
              var hh = (options.height || 1) / 2;
              var hl = (options.length || 1) / 2;
              var corners = [Vec3.set(c0, -hw, -hh, hl), Vec3.set(c1, hw, -hh, hl), Vec3.set(c2, hw, hh, hl), Vec3.set(c3, -hw, hh, hl), Vec3.set(c4, hw, -hh, -hl), Vec3.set(c5, -hw, -hh, -hl), Vec3.set(c6, -hw, hh, -hl), Vec3.set(c7, hw, hh, -hl)];
              var faceAxes = [[2, 3, 1], [4, 5, 7], [7, 6, 2], [1, 0, 4], [1, 4, 2], [5, 0, 6]];
              var faceNormals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];
              var faceTangents = [[-1, 0, 0, 1], [-1, 0, 0, 1], [-1, 0, 0, 1], [-1, 0, 0, 1], [0, 0, -1, 1], [0, 0, 1, 1]];
              var positions = [];
              var normals = [];
              var uvs = [];
              var tangents = [];
              var indices = [];
              var minPos = new Vec3(-hw, -hh, -hl);
              var maxPos = new Vec3(hw, hh, hl);
              var boundingRadius = Math.sqrt(hw * hw + hh * hh + hl * hl);

              function _buildPlane(side, uSegments, vSegments) {
                var u;
                var v;
                var ix;
                var iy;
                var offset = positions.length / 3;
                var faceAxe = faceAxes[side];
                var faceNormal = faceNormals[side];
                var faceTangent = faceTangents[side];

                for (iy = 0; iy <= vSegments; iy++) {
                  for (ix = 0; ix <= uSegments; ix++) {
                    u = ix / uSegments;
                    v = iy / vSegments;
                    Vec3.lerp(temp1, corners[faceAxe[0]], corners[faceAxe[1]], u);
                    Vec3.lerp(temp2, corners[faceAxe[0]], corners[faceAxe[2]], v);
                    Vec3.subtract(temp3, temp2, corners[faceAxe[0]]);
                    Vec3.add(r, temp1, temp3);
                    positions.push(r.x, r.y, r.z);
                    normals.push(faceNormal[0], faceNormal[1], faceNormal[2]);
                    uvs.push(u, v);
                    tangents.push(faceTangent[0], faceTangent[1], faceTangent[2], faceTangent[3]);

                    if (ix < uSegments && iy < vSegments) {
                      var useg1 = uSegments + 1;
                      var a = ix + iy * useg1;
                      var b = ix + (iy + 1) * useg1;
                      var c = ix + 1 + (iy + 1) * useg1;
                      var d = ix + 1 + iy * useg1;
                      indices.push(offset + a, offset + d, offset + b);
                      indices.push(offset + b, offset + d, offset + c);
                    }
                  }
                }
              }

              _buildPlane(0, ws, hs);

              _buildPlane(4, ls, hs);

              _buildPlane(1, ws, hs);

              _buildPlane(5, ls, hs);

              _buildPlane(3, ws, ls);

              _buildPlane(2, ws, ls);

              return {
                positions: positions,
                normals: normals,
                uvs: uvs,
                tangents: tangents,
                indices: indices,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
              };
            }
            var temp1 = new Vec3();
            var temp2 = new Vec3();
            var temp3 = new Vec3();
            var r = new Vec3();
            var c0 = new Vec3();
            var c1 = new Vec3();
            var c2 = new Vec3();
            var c3 = new Vec3();
            var c4 = new Vec3();
            var c5 = new Vec3();
            var c6 = new Vec3();
            var c7 = new Vec3();

            var temp1$1 = new Vec3(0, 0, 0);
            var temp2$1 = new Vec3(0, 0, 0);
            function cylinder(radiusTop, radiusBottom, height, opts) {
              if (radiusTop === void 0) {
                radiusTop = 0.5;
              }

              if (radiusBottom === void 0) {
                radiusBottom = 0.5;
              }

              if (height === void 0) {
                height = 2;
              }

              if (opts === void 0) {
                opts = {};
              }

              var halfHeight = height * 0.5;
              var radialSegments = opts.radialSegments || 32;
              var heightSegments = opts.heightSegments || 1;
              var capped = opts.capped !== undefined ? opts.capped : true;
              var arc = opts.arc || 2.0 * Math.PI;
              var cntCap = 0;

              if (!capped) {
                if (radiusTop > 0) {
                  cntCap++;
                }

                if (radiusBottom > 0) {
                  cntCap++;
                }
              }

              var vertCount = (radialSegments + 1) * (heightSegments + 1);

              if (capped) {
                vertCount += (radialSegments + 1) * cntCap + radialSegments * cntCap;
              }

              var indexCount = radialSegments * heightSegments * 2 * 3;

              if (capped) {
                indexCount += radialSegments * cntCap * 3;
              }

              var indices = new Array(indexCount);
              var positions = new Array(vertCount * 3);
              var normals = new Array(vertCount * 3);
              var uvs = new Array(vertCount * 2);
              var maxRadius = Math.max(radiusTop, radiusBottom);
              var minPos = new Vec3(-maxRadius, -halfHeight, -maxRadius);
              var maxPos = new Vec3(maxRadius, halfHeight, maxRadius);
              var boundingRadius = Math.sqrt(maxRadius * maxRadius + halfHeight * halfHeight);
              var index = 0;
              var indexOffset = 0;
              generateTorso();

              if (capped) {
                if (radiusBottom > 0) {
                  generateCap(false);
                }

                if (radiusTop > 0) {
                  generateCap(true);
                }
              }

              return {
                positions: positions,
                normals: normals,
                uvs: uvs,
                indices: indices,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
              };

              function generateTorso() {
                var indexArray = [];
                var r = radiusTop - radiusBottom;
                var slope = r * r / height * Math.sign(r);

                for (var y = 0; y <= heightSegments; y++) {
                  var indexRow = [];
                  var v = y / heightSegments;
                  var radius = v * r + radiusBottom;

                  for (var x = 0; x <= radialSegments; ++x) {
                    var u = x / radialSegments;
                    var theta = u * arc;
                    var sinTheta = Math.sin(theta);
                    var cosTheta = Math.cos(theta);
                    positions[3 * index] = radius * sinTheta;
                    positions[3 * index + 1] = v * height - halfHeight;
                    positions[3 * index + 2] = radius * cosTheta;
                    Vec3.normalize(temp1$1, Vec3.set(temp2$1, sinTheta, -slope, cosTheta));
                    normals[3 * index] = temp1$1.x;
                    normals[3 * index + 1] = temp1$1.y;
                    normals[3 * index + 2] = temp1$1.z;
                    uvs[2 * index] = (1 - u) * 2 % 1;
                    uvs[2 * index + 1] = v;
                    indexRow.push(index);
                    ++index;
                  }

                  indexArray.push(indexRow);
                }

                for (var _y = 0; _y < heightSegments; ++_y) {
                  for (var _x = 0; _x < radialSegments; ++_x) {
                    var i1 = indexArray[_y][_x];
                    var i2 = indexArray[_y + 1][_x];
                    var i3 = indexArray[_y + 1][_x + 1];
                    var i4 = indexArray[_y][_x + 1];
                    indices[indexOffset] = i1;
                    ++indexOffset;
                    indices[indexOffset] = i4;
                    ++indexOffset;
                    indices[indexOffset] = i2;
                    ++indexOffset;
                    indices[indexOffset] = i4;
                    ++indexOffset;
                    indices[indexOffset] = i3;
                    ++indexOffset;
                    indices[indexOffset] = i2;
                    ++indexOffset;
                  }
                }
              }

              function generateCap(top) {
                var radius = top ? radiusTop : radiusBottom;
                var sign = top ? 1 : -1;
                var centerIndexStart = index;

                for (var x = 1; x <= radialSegments; ++x) {
                  positions[3 * index] = 0;
                  positions[3 * index + 1] = halfHeight * sign;
                  positions[3 * index + 2] = 0;
                  normals[3 * index] = 0;
                  normals[3 * index + 1] = sign;
                  normals[3 * index + 2] = 0;
                  uvs[2 * index] = 0.5;
                  uvs[2 * index + 1] = 0.5;
                  ++index;
                }

                var centerIndexEnd = index;

                for (var _x2 = 0; _x2 <= radialSegments; ++_x2) {
                  var u = _x2 / radialSegments;
                  var theta = u * arc;
                  var cosTheta = Math.cos(theta);
                  var sinTheta = Math.sin(theta);
                  positions[3 * index] = radius * sinTheta;
                  positions[3 * index + 1] = halfHeight * sign;
                  positions[3 * index + 2] = radius * cosTheta;
                  normals[3 * index] = 0;
                  normals[3 * index + 1] = sign;
                  normals[3 * index + 2] = 0;
                  uvs[2 * index] = 0.5 - sinTheta * 0.5 * sign;
                  uvs[2 * index + 1] = 0.5 + cosTheta * 0.5;
                  ++index;
                }

                for (var _x3 = 0; _x3 < radialSegments; ++_x3) {
                  var c = centerIndexStart + _x3;
                  var i = centerIndexEnd + _x3;

                  if (top) {
                    indices[indexOffset] = i + 1;
                    ++indexOffset;
                    indices[indexOffset] = c;
                    ++indexOffset;
                    indices[indexOffset] = i;
                    ++indexOffset;
                  } else {
                    indices[indexOffset] = c;
                    ++indexOffset;
                    indices[indexOffset] = i + 1;
                    ++indexOffset;
                    indices[indexOffset] = i;
                    ++indexOffset;
                  }
                }
              }
            }

            function cone(radius, height, opts) {
              if (radius === void 0) {
                radius = 0.5;
              }

              if (height === void 0) {
                height = 1;
              }

              if (opts === void 0) {
                opts = {};
              }

              return cylinder(0, radius, height, opts);
            }

            function applyDefaultPlaneOptions(options) {
              options = applyDefaultGeometryOptions(options);
              options.width = options.width || 10;
              options.length = options.length || 10;
              options.widthSegments = options.widthSegments || 10;
              options.lengthSegments = options.lengthSegments || 10;
              return options;
            }

            var temp1$2 = new Vec3(0, 0, 0);
            var temp2$2 = new Vec3(0, 0, 0);
            var temp3$1 = new Vec3(0, 0, 0);
            var r$1 = new Vec3(0, 0, 0);
            var c00 = new Vec3(0, 0, 0);
            var c10 = new Vec3(0, 0, 0);
            var c01 = new Vec3(0, 0, 0);
            function plane(options) {
              var normalizedOptions = applyDefaultPlaneOptions(options);
              var width = normalizedOptions.width,
                  length = normalizedOptions.length,
                  uSegments = normalizedOptions.widthSegments,
                  vSegments = normalizedOptions.lengthSegments;
              var hw = width * 0.5;
              var hl = length * 0.5;
              var positions = [];
              var uvs = [];
              var indices = [];
              var minPos = new Vec3(-hw, 0, -hl);
              var maxPos = new Vec3(hw, 0, hl);
              var boundingRadius = Math.sqrt(width * width + length * length);
              Vec3.set(c00, -hw, 0, hl);
              Vec3.set(c10, hw, 0, hl);
              Vec3.set(c01, -hw, 0, -hl);

              for (var y = 0; y <= vSegments; y++) {
                for (var x = 0; x <= uSegments; x++) {
                  var u = x / uSegments;
                  var v = y / vSegments;
                  Vec3.lerp(temp1$2, c00, c10, u);
                  Vec3.lerp(temp2$2, c00, c01, v);
                  Vec3.subtract(temp3$1, temp2$2, c00);
                  Vec3.add(r$1, temp1$2, temp3$1);
                  positions.push(r$1.x, r$1.y, r$1.z);

                  if (normalizedOptions.includeUV) {
                    uvs.push(u, v);
                  }

                  if (x < uSegments && y < vSegments) {
                    var useg1 = uSegments + 1;
                    var a = x + y * useg1;
                    var b = x + (y + 1) * useg1;
                    var c = x + 1 + (y + 1) * useg1;
                    var d = x + 1 + y * useg1;
                    indices.push(a, d, b);
                    indices.push(d, c, b);
                  }
                }
              }

              var result = {
                positions: positions,
                indices: indices,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
              };

              if (normalizedOptions.includeNormal) {
                var nVertex = (vSegments + 1) * (uSegments + 1);
                var normals = new Array(3 * nVertex);
                result.normals = normals;

                for (var i = 0; i < nVertex; ++i) {
                  normals[i * 3 + 0] = 0;
                  normals[i * 3 + 1] = 1;
                  normals[i * 3 + 2] = 0;
                }
              }

              if (normalizedOptions.includeUV) {
                result.uvs = uvs;
              }

              return result;
            }

            function quad(options) {
              var normalizedOptions = applyDefaultGeometryOptions(options);
              var result = {
                positions: [-0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0, 0.5, -0.5, 0],
                indices: [0, 3, 1, 3, 2, 1],
                minPos: {
                  x: -0.5,
                  y: -0.5,
                  z: 0
                },
                maxPos: {
                  x: 0.5,
                  y: 0.5,
                  z: 0
                },
                boundingRadius: Math.sqrt(0.5 * 0.5 + 0.5 * 0.5)
              };

              if (normalizedOptions.includeNormal !== false) {
                result.normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
              }

              if (normalizedOptions.includeUV !== false) {
                result.uvs = [0, 0, 0, 1, 1, 1, 1, 0];
              }

              return result;
            }

            function sphere(radius, opts) {
              if (radius === void 0) {
                radius = 0.5;
              }

              if (opts === void 0) {
                opts = {};
              }

              var segments = opts.segments !== undefined ? opts.segments : 32;
              var positions = [];
              var normals = [];
              var uvs = [];
              var indices = [];
              var minPos = new Vec3(-radius, -radius, -radius);
              var maxPos = new Vec3(radius, radius, radius);
              var boundingRadius = radius;

              for (var lat = 0; lat <= segments; ++lat) {
                var theta = lat * Math.PI / segments;
                var sinTheta = Math.sin(theta);
                var cosTheta = -Math.cos(theta);

                for (var lon = 0; lon <= segments; ++lon) {
                  var phi = lon * 2 * Math.PI / segments - Math.PI / 2.0;
                  var sinPhi = Math.sin(phi);
                  var cosPhi = Math.cos(phi);
                  var x = sinPhi * sinTheta;
                  var y = cosTheta;
                  var z = cosPhi * sinTheta;
                  var u = lon / segments;
                  var v = lat / segments;
                  positions.push(x * radius, y * radius, z * radius);
                  normals.push(x, y, z);
                  uvs.push(u, v);

                  if (lat < segments && lon < segments) {
                    var seg1 = segments + 1;
                    var a = seg1 * lat + lon;
                    var b = seg1 * (lat + 1) + lon;
                    var c = seg1 * (lat + 1) + lon + 1;
                    var d = seg1 * lat + lon + 1;
                    indices.push(a, d, b);
                    indices.push(d, c, b);
                  }
                }
              }

              return {
                positions: positions,
                indices: indices,
                normals: normals,
                uvs: uvs,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
              };
            }

            function torus(radius, tube, opts) {
              if (radius === void 0) {
                radius = 0.4;
              }

              if (tube === void 0) {
                tube = 0.1;
              }

              if (opts === void 0) {
                opts = {};
              }

              var radialSegments = opts.radialSegments || 32;
              var tubularSegments = opts.tubularSegments || 32;
              var arc = opts.arc || 2.0 * Math.PI;
              var positions = [];
              var normals = [];
              var uvs = [];
              var indices = [];
              var minPos = new Vec3(-radius - tube, -tube, -radius - tube);
              var maxPos = new Vec3(radius + tube, tube, radius + tube);
              var boundingRadius = radius + tube;

              for (var j = 0; j <= radialSegments; j++) {
                for (var i = 0; i <= tubularSegments; i++) {
                  var u = i / tubularSegments;
                  var v = j / radialSegments;
                  var u1 = u * arc;
                  var v1 = v * Math.PI * 2;
                  var x = (radius + tube * Math.cos(v1)) * Math.sin(u1);
                  var y = tube * Math.sin(v1);
                  var z = (radius + tube * Math.cos(v1)) * Math.cos(u1);
                  var nx = Math.sin(u1) * Math.cos(v1);
                  var ny = Math.sin(v1);
                  var nz = Math.cos(u1) * Math.cos(v1);
                  positions.push(x, y, z);
                  normals.push(nx, ny, nz);
                  uvs.push(u, v);

                  if (i < tubularSegments && j < radialSegments) {
                    var seg1 = tubularSegments + 1;
                    var a = seg1 * j + i;
                    var b = seg1 * (j + 1) + i;
                    var c = seg1 * (j + 1) + i + 1;
                    var d = seg1 * j + i + 1;
                    indices.push(a, d, b);
                    indices.push(d, c, b);
                  }
                }
              }

              return {
                positions: positions,
                normals: normals,
                uvs: uvs,
                indices: indices,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
              };
            }

            var temp1$3 = new Vec3(0, 0, 0);
            var temp2$3 = new Vec3(0, 0, 0);
            function capsule(radiusTop, radiusBottom, height, opts) {
              if (radiusTop === void 0) {
                radiusTop = 0.5;
              }

              if (radiusBottom === void 0) {
                radiusBottom = 0.5;
              }

              if (height === void 0) {
                height = 2;
              }

              if (opts === void 0) {
                opts = {};
              }

              var torsoHeight = height - radiusTop - radiusBottom;
              var sides = opts.sides || 32;
              var heightSegments = opts.heightSegments || 32;
              var bottomProp = radiusBottom / height;
              var torProp = torsoHeight / height;
              var topProp = radiusTop / height;
              var bottomSegments = Math.floor(heightSegments * bottomProp);
              var topSegments = Math.floor(heightSegments * topProp);
              var torSegments = Math.floor(heightSegments * torProp);
              var topOffset = torsoHeight + radiusBottom - height / 2;
              var torOffset = radiusBottom - height / 2;
              var bottomOffset = radiusBottom - height / 2;
              var arc = opts.arc || 2.0 * Math.PI;
              var positions = [];
              var normals = [];
              var uvs = [];
              var indices = [];
              var maxRadius = Math.max(radiusTop, radiusBottom);
              var minPos = new Vec3(-maxRadius, -height / 2, -maxRadius);
              var maxPos = new Vec3(maxRadius, height / 2, maxRadius);
              var boundingRadius = height / 2;
              var index = 0;
              var indexArray = [];
              generateBottom();
              generateTorso();
              generateTop();
              return {
                positions: positions,
                normals: normals,
                uvs: uvs,
                indices: indices,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
              };

              function generateTorso() {
                var slope = (radiusTop - radiusBottom) / torsoHeight;

                for (var y = 0; y <= torSegments; y++) {
                  var indexRow = [];
                  var lat = y / torSegments;
                  var radius = lat * (radiusTop - radiusBottom) + radiusBottom;

                  for (var x = 0; x <= sides; ++x) {
                    var u = x / sides;
                    var v = lat * torProp + bottomProp;
                    var theta = u * arc - arc / 4;
                    var sinTheta = Math.sin(theta);
                    var cosTheta = Math.cos(theta);
                    positions.push(radius * sinTheta);
                    positions.push(lat * torsoHeight + torOffset);
                    positions.push(radius * cosTheta);
                    Vec3.normalize(temp1$3, Vec3.set(temp2$3, sinTheta, -slope, cosTheta));
                    normals.push(temp1$3.x);
                    normals.push(temp1$3.y);
                    normals.push(temp1$3.z);
                    uvs.push(u, v);
                    indexRow.push(index);
                    ++index;
                  }

                  indexArray.push(indexRow);
                }

                for (var _y = 0; _y < torSegments; ++_y) {
                  for (var _x = 0; _x < sides; ++_x) {
                    var i1 = indexArray[_y][_x];
                    var i2 = indexArray[_y + 1][_x];
                    var i3 = indexArray[_y + 1][_x + 1];
                    var i4 = indexArray[_y][_x + 1];
                    indices.push(i1);
                    indices.push(i4);
                    indices.push(i2);
                    indices.push(i4);
                    indices.push(i3);
                    indices.push(i2);
                  }
                }
              }

              function generateBottom() {
                for (var lat = 0; lat <= bottomSegments; ++lat) {
                  var theta = lat * Math.PI / bottomSegments / 2;
                  var sinTheta = Math.sin(theta);
                  var cosTheta = -Math.cos(theta);

                  for (var lon = 0; lon <= sides; ++lon) {
                    var phi = lon * 2 * Math.PI / sides - Math.PI / 2.0;
                    var sinPhi = Math.sin(phi);
                    var cosPhi = Math.cos(phi);
                    var x = sinPhi * sinTheta;
                    var y = cosTheta;
                    var z = cosPhi * sinTheta;
                    var u = lon / sides;
                    var v = lat / heightSegments;
                    positions.push(x * radiusBottom, y * radiusBottom + bottomOffset, z * radiusBottom);
                    normals.push(x, y, z);
                    uvs.push(u, v);

                    if (lat < bottomSegments && lon < sides) {
                      var seg1 = sides + 1;
                      var a = seg1 * lat + lon;
                      var b = seg1 * (lat + 1) + lon;
                      var c = seg1 * (lat + 1) + lon + 1;
                      var d = seg1 * lat + lon + 1;
                      indices.push(a, d, b);
                      indices.push(d, c, b);
                    }

                    ++index;
                  }
                }
              }

              function generateTop() {
                for (var lat = 0; lat <= topSegments; ++lat) {
                  var theta = lat * Math.PI / topSegments / 2 + Math.PI / 2;
                  var sinTheta = Math.sin(theta);
                  var cosTheta = -Math.cos(theta);

                  for (var lon = 0; lon <= sides; ++lon) {
                    var phi = lon * 2 * Math.PI / sides - Math.PI / 2.0;
                    var sinPhi = Math.sin(phi);
                    var cosPhi = Math.cos(phi);
                    var x = sinPhi * sinTheta;
                    var y = cosTheta;
                    var z = cosPhi * sinTheta;
                    var u = lon / sides;
                    var v = lat / heightSegments + (1 - topProp);
                    positions.push(x * radiusTop, y * radiusTop + topOffset, z * radiusTop);
                    normals.push(x, y, z);
                    uvs.push(u, v);

                    if (lat < topSegments && lon < sides) {
                      var seg1 = sides + 1;
                      var a = seg1 * lat + lon + indexArray[torSegments][sides] + 1;
                      var b = seg1 * (lat + 1) + lon + indexArray[torSegments][sides] + 1;
                      var c = seg1 * (lat + 1) + lon + 1 + indexArray[torSegments][sides] + 1;
                      var d = seg1 * lat + lon + 1 + indexArray[torSegments][sides] + 1;
                      indices.push(a, d, b);
                      indices.push(d, c, b);
                    }
                  }
                }
              }
            }

            function applyDefaultCircleOptions(options) {
              options = applyDefaultGeometryOptions(options);
              options.segments = 64;
              return options;
            }

            function circle(options) {
              var normalizedOptions = applyDefaultCircleOptions(options);
              var segments = normalizedOptions.segments;
              var positions = new Array(3 * (segments + 1));
              positions[0] = 0;
              positions[1] = 0;
              positions[2] = 0;
              var indices = new Array(1 + segments * 2);
              indices[0] = 0;
              var step = Math.PI * 2 / segments;

              for (var iSegment = 0; iSegment < segments; ++iSegment) {
                var angle = step * iSegment;
                var x = Math.cos(angle);
                var y = Math.sin(angle);
                var p = (iSegment + 1) * 3;
                positions[p + 0] = x;
                positions[p + 1] = y;
                positions[p + 2] = 0;
                var i = iSegment * 2;
                indices[1 + i] = iSegment + 1;
                indices[1 + (i + 1)] = iSegment + 2;
              }

              if (segments > 0) {
                indices[indices.length - 1] = 1;
              }

              var result = {
                positions: positions,
                indices: indices,
                minPos: {
                  x: 1,
                  y: 1,
                  z: 0
                },
                maxPos: {
                  x: -1,
                  y: -1,
                  z: 0
                },
                boundingRadius: 1,
                primitiveMode: PrimitiveMode.TRIANGLE_FAN
              };
              return result;
            }

            function translate(geometry, offset) {
              var x = offset.x || 0;
              var y = offset.y || 0;
              var z = offset.z || 0;
              var nVertex = Math.floor(geometry.positions.length / 3);

              for (var iVertex = 0; iVertex < nVertex; ++iVertex) {
                var iX = iVertex * 3;
                var iY = iVertex * 3 + 1;
                var iZ = iVertex * 3 + 2;
                geometry.positions[iX] += x;
                geometry.positions[iY] += y;
                geometry.positions[iZ] += z;
              }

              if (geometry.minPos) {
                geometry.minPos.x += x;
                geometry.minPos.y += y;
                geometry.minPos.z += z;
              }

              if (geometry.maxPos) {
                geometry.maxPos.x += x;
                geometry.maxPos.y += y;
                geometry.maxPos.z += z;
              }

              return geometry;
            }
            function scale(geometry, value) {
              var _value$x, _value$y, _value$z;

              var x = (_value$x = value.x) !== null && _value$x !== void 0 ? _value$x : 1.0;
              var y = (_value$y = value.y) !== null && _value$y !== void 0 ? _value$y : 1.0;
              var z = (_value$z = value.z) !== null && _value$z !== void 0 ? _value$z : 1.0;
              var nVertex = Math.floor(geometry.positions.length / 3);

              for (var iVertex = 0; iVertex < nVertex; ++iVertex) {
                var iX = iVertex * 3;
                var iY = iVertex * 3 + 1;
                var iZ = iVertex * 3 + 2;
                geometry.positions[iX] *= x;
                geometry.positions[iY] *= y;
                geometry.positions[iZ] *= z;
              }

              var minPos = geometry.minPos,
                  maxPos = geometry.maxPos;

              if (minPos) {
                minPos.x *= x;
                minPos.y *= y;
                minPos.z *= z;
              }

              if (maxPos) {
                maxPos.x *= x;
                maxPos.y *= y;
                maxPos.z *= z;
              }

              if (minPos && maxPos) {
                if (x < 0) {
                  var tmp = minPos.x;
                  minPos.x = maxPos.x;
                  maxPos.x = tmp;
                }

                if (y < 0) {
                  var _tmp = minPos.y;
                  minPos.y = maxPos.y;
                  maxPos.y = _tmp;
                }

                if (z < 0) {
                  var _tmp2 = minPos.z;
                  minPos.z = maxPos.z;
                  maxPos.z = _tmp2;
                }
              }

              if (typeof geometry.boundingRadius !== 'undefined') {
                geometry.boundingRadius *= Math.max(Math.max(Math.abs(x), Math.abs(y)), Math.abs(z));
              }

              return geometry;
            }
            function wireframed(geometry) {
              var indices = geometry.indices;

              if (!indices) {
                return geometry;
              }

              if (geometry.primitiveMode && geometry.primitiveMode !== PrimitiveMode.TRIANGLE_LIST) {
                return geometry;
              }

              var offsets = [[0, 1], [1, 2], [2, 0]];
              var lines = [];
              var lineIDs = {};

              for (var i = 0; i < indices.length; i += 3) {
                for (var k = 0; k < 3; ++k) {
                  var i1 = indices[i + offsets[k][0]];
                  var i2 = indices[i + offsets[k][1]];
                  var id = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;

                  if (lineIDs[id] === undefined) {
                    lineIDs[id] = 0;
                    lines.push(i1, i2);
                  }
                }
              }

              geometry.indices = lines;
              geometry.primitiveMode = PrimitiveMode.LINE_LIST;
              return geometry;
            }

            var primitives = /*#__PURE__*/Object.freeze({
                __proto__: null,
                box: box,
                cone: cone,
                cylinder: cylinder,
                plane: plane,
                quad: quad,
                sphere: sphere,
                torus: torus,
                capsule: capsule,
                circle: circle,
                translate: translate,
                scale: scale,
                wireframed: wireframed,
                wireframe: wireframe,
                invWinding: invWinding,
                toWavefrontOBJ: toWavefrontOBJ,
                normals: normals,
                applyDefaultGeometryOptions: applyDefaultGeometryOptions
            });
            exports('primitives', primitives);

            function setWrap(object, wrapper) {
              object.__cc_wrapper__ = wrapper;
            }
            function getWrap(object) {
              return object.__cc_wrapper__;
            }
            function maxComponent(v) {
              return Math.max(v.x, Math.max(v.y, v.z));
            }
            var VEC3_0 = new Vec3();
            var TriggerEventObject = {
              type: 'onTriggerEnter',
              selfCollider: null,
              otherCollider: null,
              impl: null
            };
            var CollisionEventObject = {
              type: 'onCollisionEnter',
              selfCollider: null,
              otherCollider: null,
              contacts: [],
              impl: null
            };
            function shrinkPositions(buffer) {
              var pos = [];

              if (buffer.length >= 3) {
                pos[0] = buffer[0], pos[1] = buffer[1], pos[2] = buffer[2];
                var len = buffer.length;

                for (var i = 3; i < len; i += 3) {
                  var p0 = buffer[i];
                  var p1 = buffer[i + 1];
                  var p2 = buffer[i + 2];
                  var len2 = pos.length;
                  var isNew = true;

                  for (var j = 0; j < len2; j += 3) {
                    if (equals$1(p0, pos[j]) && equals$1(p1, pos[j + 1]) && equals$1(p2, pos[j + 2])) {
                      isNew = false;
                      break;
                    }
                  }

                  if (isNew) {
                    pos.push(p0);
                    pos.push(p1);
                    pos.push(p2);
                  }
                }
              }

              return pos;
            }
            function absolute(v) {
              v.x = Math.abs(v.x);
              v.y = Math.abs(v.y);
              v.z = Math.abs(v.z);
              return v;
            }

            var util = /*#__PURE__*/Object.freeze({
                __proto__: null,
                setWrap: setWrap,
                getWrap: getWrap,
                maxComponent: maxComponent,
                VEC3_0: VEC3_0,
                TriggerEventObject: TriggerEventObject,
                CollisionEventObject: CollisionEventObject,
                shrinkPositions: shrinkPositions,
                absolute: absolute,
                cylinder: cylinder
            });

            var _dec$x, _dec2$s, _dec3$l, _dec4$d, _dec5$9, _dec6$9, _dec7$8, _dec8$5, _dec9$4, _class$x, _class2$s, _initializer$q, _initializer2$m, _initializer3$h, _initializer4$f, _initializer5$d, _initializer6$a, _initializer7$8, _initializer8$8, _initializer9$7, _initializer10$6, _class3$8, _temp$a;
            var ProbeResolution;

            (function (ProbeResolution) {
              ProbeResolution[ProbeResolution["Low_256x256"] = 256] = "Low_256x256";
              ProbeResolution[ProbeResolution["Medium_512x512"] = 512] = "Medium_512x512";
              ProbeResolution[ProbeResolution["High_768x768"] = 768] = "High_768x768";
            })(ProbeResolution || (ProbeResolution = {}));

            var ReflectionProbe = exports('ReflectionProbe', (_dec$x = ccclass$p('cc.ReflectionProbe'), _dec2$s = type$8(Vec3), _dec3$l = type$8(Enum(ProbeType)), _dec4$d = type$8(Enum(ProbeResolution)), _dec5$9 = type$8(Enum(ProbeClearFlag)), _dec6$9 = type$8(Color$1), _dec7$8 = type$8(Layers.BitMask), _dec8$5 = type$8(Camera), _dec9$4 = type$8(CCBoolean), _dec$x(_class$x = (_class2$s = (_temp$a = _class3$8 = function (_Component) {
              _inheritsLoose(ReflectionProbe, _Component);

              function ReflectionProbe() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._lastSize = new Vec3();
                _this._resolution = _initializer$q && _initializer$q();
                _this._clearFlag = _initializer2$m && _initializer2$m();
                _this._backgroundColor = _initializer3$h && _initializer3$h();
                _this._visibility = _initializer4$f && _initializer4$f();
                _this._probeType = _initializer5$d && _initializer5$d();
                _this._cubemap = _initializer6$a && _initializer6$a();
                _this._size = _initializer7$8 && _initializer7$8();
                _this._sourceCamera = _initializer8$8 && _initializer8$8();
                _this._probeId = _initializer9$7 && _initializer9$7();
                _this._fastBake = _initializer10$6 && _initializer10$6();
                _this._probe = null;
                _this._previewSphere = null;
                _this._previewPlane = null;
                _this._sourceCameraPos = new Vec3(0, 0, 0);
                return _this;
              }

              var _proto = ReflectionProbe.prototype;

              _proto.onLoad = function onLoad() {
                this._createProbe();

                ReflectionProbeManager.probeManager.registerEvent();
              };

              _proto.onEnable = function onEnable() {
                if (this._probe) {
                  var probe = ReflectionProbeManager.probeManager.getProbeById(this._probeId);

                  if (probe !== null && probe !== this._probe) {
                    this._probeId = ReflectionProbeManager.probeManager.getNewReflectionProbeId();

                    this._probe.updateProbeId(this._probeId);
                  }

                  ReflectionProbeManager.probeManager.register(this._probe);
                  ReflectionProbeManager.probeManager.onUpdateProbes(true);

                  this._probe.enable();
                }
              };

              _proto.onDisable = function onDisable() {
                if (this._probe) {
                  ReflectionProbeManager.probeManager.unregister(this._probe);

                  this._probe.disable();
                }
              };

              _proto.start = function start() {
                if (this._sourceCamera && this.probeType === ProbeType.PLANAR) {
                  this.probe.renderPlanarReflection(this.sourceCamera.camera);
                  ReflectionProbeManager.probeManager.filterModelsForPlanarReflection();
                }

                ReflectionProbeManager.probeManager.updateProbeData();
              };

              _proto.onDestroy = function onDestroy() {
                if (this.probe) {
                  this.probe.destroy();
                }
              };

              _proto.update = function update(dt) {
                if (!this.probe) return;

                if (this.probeType === ProbeType.PLANAR && this.sourceCamera) {
                  if (this.sourceCamera.node.hasChangedFlags & TransformBit.TRS || !this._sourceCameraPos.equals(this.sourceCamera.node.getWorldPosition())) {
                    this._sourceCameraPos = this.sourceCamera.node.getWorldPosition();
                    this.probe.renderPlanarReflection(this.sourceCamera.camera);
                  }
                }
              };

              _proto.clearBakedCubemap = function clearBakedCubemap() {
                this.cubemap = null;
                ReflectionProbeManager.probeManager.updateBakedCubemap(this.probe);
                ReflectionProbeManager.probeManager.updatePreviewSphere(this.probe);
              };

              _proto._createProbe = function _createProbe() {
                if (this._probeId === -1 || ReflectionProbeManager.probeManager.exists(this._probeId)) {
                  this._probeId = ReflectionProbeManager.probeManager.getNewReflectionProbeId();
                }

                this._probe = new ReflectionProbe$1(this._probeId);

                if (this._probe) {
                  var cameraNode = new Node('ReflectionProbeCamera');
                  cameraNode.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;
                  this.node.scene.addChild(cameraNode);

                  this._probe.initialize(this.node, cameraNode);

                  if (this.enabled) {
                    ReflectionProbeManager.probeManager.register(this._probe);
                  }

                  this._probe.resolution = this._resolution;
                  this._probe.clearFlag = this._clearFlag;
                  this._probe.backgroundColor = this._backgroundColor;
                  this._probe.visibility = this._visibility;
                  this._probe.probeType = this._probeType;
                  this._probe.size = this._size;
                  this._probe.cubemap = this._cubemap;
                }
              };

              _createClass(ReflectionProbe, [{
                key: "size",
                get: function get() {
                  return this._size;
                },
                set: function set(value) {
                  this._size.set(value);

                  absolute(this._size);
                  this.probe.size = this._size;

                  if (this.probe) {
                    ReflectionProbeManager.probeManager.onUpdateProbes(true);
                    ReflectionProbeManager.probeManager.updateProbeData();
                  }
                }
              }, {
                key: "probeType",
                get: function get() {
                  return this._probeType;
                },
                set: function set(value) {
                  this.probe.probeType = value;

                  if (value !== this._probeType) {
                    var lastSize = this._size.clone();

                    var lastSizeIsNoExist = Vec3.equals(this._lastSize, Vec3.ZERO);
                    this._probeType = value;

                    if (this._probeType === ProbeType.CUBE) {
                      if (lastSizeIsNoExist) {
                        this._size.set(ReflectionProbe.DEFAULT_CUBE_SIZE);
                      }

                      this.probe.switchProbeType(value, null);

                      ReflectionProbeManager.probeManager.clearPlanarReflectionMap(this.probe);
                    } else {
                      if (lastSizeIsNoExist) {
                        this._size.set(ReflectionProbe.DEFAULT_PLANER_SIZE);
                      }

                      if (!this._sourceCamera) {
                        console.warn('the reflection camera is invalid, please set the reflection camera');
                      } else {
                        this.probe.switchProbeType(value, this._sourceCamera.camera);
                      }
                    }

                    if (!lastSizeIsNoExist) {
                      this._size.set(this._lastSize);
                    }

                    this._lastSize.set(lastSize);

                    this.size = this._size;
                  }
                }
              }, {
                key: "resolution",
                get: function get() {
                  return this._resolution;
                },
                set: function set(value) {
                  this._resolution = value;
                  this.probe.resolution = value;
                }
              }, {
                key: "clearFlag",
                get: function get() {
                  return this._clearFlag;
                },
                set: function set(value) {
                  this._clearFlag = value;
                  this.probe.clearFlag = this._clearFlag;
                }
              }, {
                key: "backgroundColor",
                get: function get() {
                  return this._backgroundColor;
                },
                set: function set(val) {
                  this._backgroundColor = val;
                  this.probe.backgroundColor = this._backgroundColor;
                }
              }, {
                key: "visibility",
                get: function get() {
                  return this._visibility;
                },
                set: function set(val) {
                  this._visibility = val;
                  this.probe.visibility = this._visibility;
                }
              }, {
                key: "sourceCamera",
                get: function get() {
                  return this._sourceCamera;
                },
                set: function set(camera) {
                  this._sourceCamera = camera;

                  if (camera) {
                    this.visibility = camera.visibility;
                    this.clearFlag = camera.clearFlags;
                    this.backgroundColor = camera.clearColor;

                    if (this.probeType === ProbeType.PLANAR) {
                      this.probe.switchProbeType(this.probeType, camera.camera);
                    }
                  }
                }
              }, {
                key: "fastBake",
                get: function get() {
                  return this._fastBake;
                },
                set: function set(val) {
                  this._fastBake = val;
                }
              }, {
                key: "cubemap",
                set: function set(val) {
                  this._cubemap = val;
                  this.probe.cubemap = val;
                  ReflectionProbeManager.probeManager.onUpdateProbes(true);
                }
              }, {
                key: "probe",
                get: function get() {
                  return this._probe;
                }
              }, {
                key: "previewSphere",
                get: function get() {
                  return this._previewSphere;
                },
                set: function set(val) {
                  this._previewSphere = val;

                  if (this.probe) {
                    this.probe.previewSphere = val;

                    if (this._previewSphere) {
                      ReflectionProbeManager.probeManager.updatePreviewSphere(this.probe);
                    }
                  }
                }
              }, {
                key: "previewPlane",
                get: function get() {
                  return this._previewPlane;
                },
                set: function set(val) {
                  this._previewPlane = val;

                  if (this.probe) {
                    this.probe.previewPlane = val;

                    if (this._previewPlane) {
                      ReflectionProbeManager.probeManager.updatePreviewPlane(this.probe);
                    }
                  }
                }
              }]);

              return ReflectionProbe;
            }(Component), _class3$8.DEFAULT_CUBE_SIZE = new Vec3(1, 1, 1), _class3$8.DEFAULT_PLANER_SIZE = new Vec3(5, 0.5, 5), _temp$a), (_initializer$q = applyDecoratedInitializer(_class2$s.prototype, "_resolution", [serializable$j], function () {
              return 256;
            }), _initializer2$m = applyDecoratedInitializer(_class2$s.prototype, "_clearFlag", [serializable$j], function () {
              return ProbeClearFlag.SKYBOX;
            }), _initializer3$h = applyDecoratedInitializer(_class2$s.prototype, "_backgroundColor", [serializable$j], function () {
              return new Color$1(0, 0, 0, 255);
            }), _initializer4$f = applyDecoratedInitializer(_class2$s.prototype, "_visibility", [serializable$j], function () {
              return CAMERA_DEFAULT_MASK;
            }), _initializer5$d = applyDecoratedInitializer(_class2$s.prototype, "_probeType", [serializable$j], function () {
              return ProbeType.CUBE;
            }), _initializer6$a = applyDecoratedInitializer(_class2$s.prototype, "_cubemap", [serializable$j], function () {
              return null;
            }), _initializer7$8 = applyDecoratedInitializer(_class2$s.prototype, "_size", [serializable$j], function () {
              return new Vec3(1, 1, 1);
            }), _initializer8$8 = applyDecoratedInitializer(_class2$s.prototype, "_sourceCamera", [serializable$j], function () {
              return null;
            }), _initializer9$7 = applyDecoratedInitializer(_class2$s.prototype, "_probeId", [serializable$j], function () {
              return -1;
            }), _initializer10$6 = applyDecoratedInitializer(_class2$s.prototype, "_fastBake", [serializable$j], function () {
              return false;
            }), _applyDecoratedDescriptor(_class2$s.prototype, "size", [_dec2$s], Object.getOwnPropertyDescriptor(_class2$s.prototype, "size"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "probeType", [_dec3$l], Object.getOwnPropertyDescriptor(_class2$s.prototype, "probeType"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "resolution", [_dec4$d], Object.getOwnPropertyDescriptor(_class2$s.prototype, "resolution"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "clearFlag", [_dec5$9], Object.getOwnPropertyDescriptor(_class2$s.prototype, "clearFlag"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "backgroundColor", [_dec6$9], Object.getOwnPropertyDescriptor(_class2$s.prototype, "backgroundColor"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "visibility", [_dec7$8], Object.getOwnPropertyDescriptor(_class2$s.prototype, "visibility"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "sourceCamera", [_dec8$5], Object.getOwnPropertyDescriptor(_class2$s.prototype, "sourceCamera"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "fastBake", [_dec9$4], Object.getOwnPropertyDescriptor(_class2$s.prototype, "fastBake"), _class2$s.prototype)), _class2$s)) || _class$x));

            legacyCC.utils = utils;

            var CLASS_NAME_PREFIX_ANIM = 'cc.animation.';
            var createEvalSymbol = Symbol('CreateEval');

            var _dec$y, _class$y, _class2$t, _initializer$r, _initializer2$n, _initializer3$i, _initializer4$g;
            var EmbeddedPlayer = (_dec$y = ccclass$p(CLASS_NAME_PREFIX_ANIM + "EmbeddedPlayer"), _dec$y(_class$y = (_class2$t = function (_EditorExtendable) {
              _inheritsLoose(EmbeddedPlayer, _EditorExtendable);

              function EmbeddedPlayer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _EditorExtendable.call.apply(_EditorExtendable, [this].concat(args)) || this;
                _this.begin = _initializer$r && _initializer$r();
                _this.end = _initializer2$n && _initializer2$n();
                _this.reconciledSpeed = _initializer3$i && _initializer3$i();
                _this.playable = _initializer4$g && _initializer4$g();
                return _this;
              }

              return EmbeddedPlayer;
            }(EditorExtendable), (_initializer$r = applyDecoratedInitializer(_class2$t.prototype, "begin", [serializable$j], function () {
              return 0.0;
            }), _initializer2$n = applyDecoratedInitializer(_class2$t.prototype, "end", [serializable$j], function () {
              return 0.0;
            }), _initializer3$i = applyDecoratedInitializer(_class2$t.prototype, "reconciledSpeed", [serializable$j], function () {
              return false;
            }), _initializer4$g = applyDecoratedInitializer(_class2$t.prototype, "playable", [serializable$j], function () {
              return null;
            })), _class2$t)) || _class$y);
            var EmbeddedPlayable = function EmbeddedPlayable() {};
            var EmbeddedPlayableState = function () {
              function EmbeddedPlayableState(randomAccess) {
                this._randomAccess = randomAccess;
              }

              var _proto = EmbeddedPlayableState.prototype;

              _proto.setTime = function setTime(_time) {};

              _createClass(EmbeddedPlayableState, [{
                key: "randomAccess",
                get: function get() {
                  return this._randomAccess;
                }
              }]);

              return EmbeddedPlayableState;
            }();

            var Playable = function () {
              function Playable() {
                this._isPlaying = false;
                this._isPaused = false;
                this._stepOnce = false;
              }

              var _proto = Playable.prototype;

              _proto.play = function play() {
                if (this._isPlaying) {
                  if (this._isPaused) {
                    this._isPaused = false;
                    this.onResume();
                  } else {
                    this.onError(getError(3912));
                  }
                } else {
                  this._isPlaying = true;
                  this.onPlay();
                }
              };

              _proto.stop = function stop() {
                if (this._isPlaying) {
                  this._isPlaying = false;
                  this.onStop();
                  this._isPaused = false;
                }
              };

              _proto.pause = function pause() {
                if (this._isPlaying && !this._isPaused) {
                  this._isPaused = true;
                  this.onPause();
                }
              };

              _proto.resume = function resume() {
                if (this._isPlaying && this._isPaused) {
                  this._isPaused = false;
                  this.onResume();
                }
              };

              _proto.step = function step() {
                this.pause();
                this._stepOnce = true;

                if (!this._isPlaying) {
                  this.play();
                }
              };

              _proto.update = function update(deltaTime) {};

              _proto.onPlay = function onPlay() {};

              _proto.onPause = function onPause() {};

              _proto.onResume = function onResume() {};

              _proto.onStop = function onStop() {};

              _proto.onError = function onError(message) {};

              _createClass(Playable, [{
                key: "isPlaying",
                get: function get() {
                  return this._isPlaying;
                }
              }, {
                key: "isPaused",
                get: function get() {
                  return this._isPaused;
                }
              }, {
                key: "isMotionless",
                get: function get() {
                  return !this.isPlaying || this.isPaused;
                }
              }]);

              return Playable;
            }();

            var WrapMode;

            (function (WrapMode) {
              WrapMode[WrapMode["Default"] = WrapModeMask.Default] = "Default";
              WrapMode[WrapMode["Normal"] = WrapModeMask.Normal] = "Normal";
              WrapMode[WrapMode["Reverse"] = WrapModeMask.Reverse] = "Reverse";
              WrapMode[WrapMode["Loop"] = WrapModeMask.Loop] = "Loop";
              WrapMode[WrapMode["LoopReverse"] = WrapModeMask.Loop | WrapModeMask.Reverse] = "LoopReverse";
              WrapMode[WrapMode["PingPong"] = WrapModeMask.PingPong] = "PingPong";
              WrapMode[WrapMode["PingPongReverse"] = WrapModeMask.PingPong | WrapModeMask.Reverse] = "PingPongReverse";
            })(WrapMode || (WrapMode = {}));

            ccenum(WrapMode);
            var WrappedInfo = function () {
              function WrappedInfo(info) {
                this.ratio = 0;
                this.time = 0;
                this.direction = 1;
                this.stopped = true;
                this.iterations = 0;
                this.frameIndex = undefined;

                if (info) {
                  this.set(info);
                }
              }

              var _proto = WrappedInfo.prototype;

              _proto.set = function set(info) {
                this.ratio = info.ratio;
                this.time = info.time;
                this.direction = info.direction;
                this.stopped = info.stopped;
                this.iterations = info.iterations;
                this.frameIndex = info.frameIndex;
              };

              return WrappedInfo;
            }();
            function isLerpable(object) {
              return typeof object.lerp === 'function';
            }

            var PoseOutput = function () {
              function PoseOutput(pose) {
                this.weight = 0.0;
                this._pose = void 0;
                this._blendStateWriters = [];
                this._pose = pose;
              }

              var _proto = PoseOutput.prototype;

              _proto.destroy = function destroy() {
                for (var iBlendStateWriter = 0; iBlendStateWriter < this._blendStateWriters.length; ++iBlendStateWriter) {
                  this._pose.destroyWriter(this._blendStateWriters[iBlendStateWriter]);
                }

                this._blendStateWriters.length = 0;
              };

              _proto.createPoseWriter = function createPoseWriter(node, property, constants) {
                var writer = this._pose.createWriter(node, property, this, constants);

                this._blendStateWriters.push(writer);

                return writer;
              };

              return PoseOutput;
            }();

            function getGlobalAnimationManager() {
              var animationManager = legacyCC.director.getAnimationManager();
              return animationManager;
            }

            var EventType$1;

            (function (EventType) {
              EventType["PLAY"] = "play";
              EventType["STOP"] = "stop";
              EventType["PAUSE"] = "pause";
              EventType["RESUME"] = "resume";
              EventType["LASTFRAME"] = "lastframe";
              EventType["FINISHED"] = "finished";
            })(EventType$1 || (EventType$1 = {}));

            ccenum(EventType$1);
            var AnimationState = exports('AnimationState', function (_Playable) {
              _inheritsLoose(AnimationState, _Playable);

              function AnimationState(clip, name) {
                var _this;

                if (name === void 0) {
                  name = '';
                }

                _this = _Playable.call(this) || this;
                _this.duration = 1.0;
                _this.time = 0.0;
                _this.frameRate = 0;
                _this._targetNode = null;
                _this._curveLoaded = false;
                _this._clip = void 0;
                _this._speed = 1.0;
                _this._useSimpleProcess = false;
                _this._target = null;
                _this._wrapMode = WrapMode.Normal;
                _this._repeatCount = 1;
                _this._delay = 0.0;
                _this._delayTime = 0.0;
                _this._currentFramePlayed = false;
                _this._name = void 0;
                _this._lastIterations = NaN;
                _this._lastWrapInfo = null;
                _this._wrappedInfo = new WrappedInfo();
                _this._allowLastFrame = false;
                _this._blendStateWriterHost = {
                  weight: 0.0
                };
                _this._playbackDuration = 0.0;
                _this._invDuration = 1.0;
                _this._poseOutput = null;
                _this._weight = 1.0;
                _this._clipEval = void 0;
                _this._clipEventEval = void 0;
                _this._clipEmbeddedPlayerEval = void 0;
                _this._doNotCreateEval = false;
                _this._clip = clip;
                _this._name = name || clip && clip.name;
                _this._playbackRange = {
                  min: 0.0,
                  max: clip.duration
                };
                _this._playbackDuration = clip.duration;

                if (!clip.duration) {
                  debug("Clip " + clip.name + " has zero duration.");
                }

                return _this;
              }

              var _proto = AnimationState.prototype;

              _proto.initialize = function initialize(root, blendStateBuffer, mask) {
                if (this._curveLoaded) {
                  return;
                }

                this._curveLoaded = true;

                if (this._poseOutput) {
                  this._poseOutput.destroy();

                  this._poseOutput = null;
                }

                if (this._clipEval) {
                  this._clipEval = undefined;
                }

                if (this._clipEventEval) {
                  this._clipEventEval = undefined;
                }

                if (this._clipEmbeddedPlayerEval) {
                  this._clipEmbeddedPlayerEval.destroy();

                  this._clipEmbeddedPlayerEval = undefined;
                }

                this._targetNode = root;
                var clip = this._clip;
                this.duration = clip.duration;
                this._invDuration = 1.0 / this.duration;
                this._speed = clip.speed;
                this.wrapMode = clip.wrapMode;
                this.frameRate = clip.sample;
                this._playbackRange.min = 0.0;
                this._playbackRange.max = clip.duration;
                this._playbackDuration = clip.duration;

                if ((this.wrapMode & WrapModeMask.Loop) === WrapModeMask.Loop) {
                  this.repeatCount = Infinity;
                } else {
                  this.repeatCount = 1;
                }

                if (!this._doNotCreateEval) {
                  var _ref, _getGlobalAnimationMa, _this$_poseOutput;

                  var pose = (_ref = blendStateBuffer !== null && blendStateBuffer !== void 0 ? blendStateBuffer : (_getGlobalAnimationMa = getGlobalAnimationManager()) === null || _getGlobalAnimationMa === void 0 ? void 0 : _getGlobalAnimationMa.blendState) !== null && _ref !== void 0 ? _ref : null;

                  if (pose) {
                    this._poseOutput = new PoseOutput(pose);
                  }

                  this._clipEval = clip.createEvaluator({
                    target: root,
                    pose: (_this$_poseOutput = this._poseOutput) !== null && _this$_poseOutput !== void 0 ? _this$_poseOutput : undefined,
                    mask: mask
                  });
                }

                {
                  if (clip.containsAnyEvent()) {
                    this._clipEventEval = clip.createEventEvaluator(this._targetNode);
                  }
                }

                if (clip.containsAnyEmbeddedPlayer()) {
                  this._clipEmbeddedPlayerEval = clip.createEmbeddedPlayerEvaluator(this._targetNode);

                  this._clipEmbeddedPlayerEval.notifyHostSpeedChanged(this._speed);
                }
              };

              _proto.destroy = function destroy() {
                if (!this.isMotionless) {
                  getGlobalAnimationManager().removeAnimation(this);
                }

                if (this._poseOutput) {
                  this._poseOutput.destroy();

                  this._poseOutput = null;
                }

                this._clipEval = undefined;
              };

              _proto.emit = function emit() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                getGlobalAnimationManager().pushDelayEvent(this._emit, this, args);
              };

              _proto.on = function on(type, callback, target) {
                if (this._target && this._target.isValid) {
                  return this._target.on(type, callback, target);
                } else {
                  return null;
                }
              };

              _proto.once = function once(type, callback, target) {
                if (this._target && this._target.isValid) {
                  return this._target.once(type, callback, target);
                } else {
                  return null;
                }
              };

              _proto.off = function off(type, callback, target) {
                if (this._target && this._target.isValid) {
                  this._target.off(type, callback, target);
                }
              };

              _proto.allowLastFrameEvent = function allowLastFrameEvent(allowed) {
                this._allowLastFrame = allowed;
              };

              _proto._setEventTarget = function _setEventTarget(target) {
                this._target = target;
              };

              _proto.setTime = function setTime(time) {
                this._currentFramePlayed = false;
                this.time = time || 0.0;

                {
                  var _this$_clipEventEval;

                  var info = this.getWrappedInfo(time, this._wrappedInfo);
                  (_this$_clipEventEval = this._clipEventEval) === null || _this$_clipEventEval === void 0 ? void 0 : _this$_clipEventEval.ignore(info.ratio, info.direction);
                }
              };

              _proto.update = function update(delta) {
                if (this._delayTime > 0.0) {
                  this._delayTime -= delta;

                  if (this._delayTime > 0.0) {
                    return;
                  }
                }

                if (this._currentFramePlayed) {
                  this.time += delta * this._speed;
                } else {
                  this._currentFramePlayed = true;
                }

                this._process();
              };

              _proto.sample = function sample() {
                var info = this.getWrappedInfo(this.time, this._wrappedInfo);

                this._sampleCurves(info.time);

                {
                  this._sampleEvents(info);
                }

                this._sampleEmbeddedPlayers(info);

                return info;
              };

              _proto.onPlay = function onPlay() {
                var _this$_clipEmbeddedPl;

                this.setTime(this._getPlaybackStart());
                this._delayTime = this._delay;

                this._onReplayOrResume();

                this.emit(EventType$1.PLAY, this);
                (_this$_clipEmbeddedPl = this._clipEmbeddedPlayerEval) === null || _this$_clipEmbeddedPl === void 0 ? void 0 : _this$_clipEmbeddedPl.notifyHostPlay(this.current);
              };

              _proto.onStop = function onStop() {
                var _this$_clipEmbeddedPl2;

                if (!this.isPaused) {
                  this._onPauseOrStop();
                }

                this.emit(EventType$1.STOP, this);
                (_this$_clipEmbeddedPl2 = this._clipEmbeddedPlayerEval) === null || _this$_clipEmbeddedPl2 === void 0 ? void 0 : _this$_clipEmbeddedPl2.notifyHostStop();
              };

              _proto.onResume = function onResume() {
                var _this$_clipEmbeddedPl3;

                this._onReplayOrResume();

                this.emit(EventType$1.RESUME, this);
                (_this$_clipEmbeddedPl3 = this._clipEmbeddedPlayerEval) === null || _this$_clipEmbeddedPl3 === void 0 ? void 0 : _this$_clipEmbeddedPl3.notifyHostPlay(this.current);
              };

              _proto.onPause = function onPause() {
                var _this$_clipEmbeddedPl4;

                this._onPauseOrStop();

                this.emit(EventType$1.PAUSE, this);
                (_this$_clipEmbeddedPl4 = this._clipEmbeddedPlayerEval) === null || _this$_clipEmbeddedPl4 === void 0 ? void 0 : _this$_clipEmbeddedPl4.notifyHostPause(this.current);
              };

              _proto._sampleCurves = function _sampleCurves(time) {
                var poseOutput = this._poseOutput,
                    clipEval = this._clipEval;

                if (poseOutput) {
                  poseOutput.weight = this.weight;
                }

                if (clipEval) {
                  clipEval.evaluate(time);
                }
              };

              _proto._process = function _process() {
                if (this._useSimpleProcess) {
                  this.simpleProcess();
                } else {
                  this.process();
                }
              };

              _proto.process = function process() {
                var info = this.sample();

                if (this._allowLastFrame) {
                  var lastInfo;

                  if (!this._lastWrapInfo) {
                    lastInfo = this._lastWrapInfo = new WrappedInfo(info);
                  } else {
                    lastInfo = this._lastWrapInfo;
                  }

                  if (this.repeatCount > 1 && (info.iterations | 0) > (lastInfo.iterations | 0)) {
                    this.emit(EventType$1.LASTFRAME, this);
                  }

                  lastInfo.set(info);
                }

                if (info.stopped) {
                  this.stop();
                  this.emit(EventType$1.FINISHED, this);
                }
              };

              _proto.simpleProcess = function simpleProcess() {
                var playbackStart = this._playbackRange.min;
                var playbackDuration = this._playbackDuration;
                var time = 0.0;
                var ratio = 0.0;

                if (playbackDuration !== 0.0) {
                  time = this.time % playbackDuration;

                  if (time < 0.0) {
                    time += playbackDuration;
                  }

                  var realTime = playbackStart + time;
                  ratio = realTime * this._invDuration;
                }

                this._sampleCurves(playbackStart + time);

                if (this._clipEventEval || this._clipEmbeddedPlayerEval) {
                  var wrapInfo = this.getWrappedInfo(this.time, this._wrappedInfo);

                  {
                    this._sampleEvents(wrapInfo);
                  }

                  this._sampleEmbeddedPlayers(wrapInfo);
                }

                if (this._allowLastFrame) {
                  if (Number.isNaN(this._lastIterations)) {
                    this._lastIterations = ratio;
                  }

                  if (this.time > 0 && this._lastIterations > ratio || this.time < 0 && this._lastIterations < ratio) {
                    this.emit(EventType$1.LASTFRAME, this);
                  }

                  this._lastIterations = ratio;
                }
              };

              _proto._needReverse = function _needReverse(currentIterations) {
                var wrapMode = this.wrapMode;
                var needReverse = false;

                if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
                  var isEnd = currentIterations - (currentIterations | 0) === 0;

                  if (isEnd && currentIterations > 0) {
                    currentIterations -= 1;
                  }

                  var isOddIteration = currentIterations & 1;

                  if (isOddIteration) {
                    needReverse = !needReverse;
                  }
                }

                if ((wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse) {
                  needReverse = !needReverse;
                }

                return needReverse;
              };

              _proto.getWrappedInfo = function getWrappedInfo(time, info) {
                info = info || new WrappedInfo();
                var playbackStart = this._playbackRange.min,
                    playbackDuration = this._playbackDuration;
                var repeatCount = this.repeatCount;

                if (playbackDuration === 0.0) {
                  info.time = 0.0;
                  info.ratio = 0.0;
                  info.direction = 1.0;
                  info.stopped = !!Number.isFinite(repeatCount);
                  info.iterations = 0.0;
                  return info;
                }

                var stopped = false;
                time -= playbackStart;
                var currentIterations = time > 0 ? time / playbackDuration : -(time / playbackDuration);

                if (currentIterations >= repeatCount) {
                  currentIterations = repeatCount;
                  stopped = true;
                  var tempRatio = repeatCount - (repeatCount | 0);

                  if (tempRatio === 0) {
                    tempRatio = 1;
                  }

                  time = tempRatio * playbackDuration * (time > 0 ? 1 : -1);
                }

                if (time > playbackDuration) {
                  var tempTime = time % playbackDuration;
                  time = tempTime === 0 ? playbackDuration : tempTime;
                } else if (time < 0) {
                  time %= playbackDuration;

                  if (time !== 0) {
                    time += playbackDuration;
                  }
                }

                var needReverse = false;
                var shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;

                if (shouldWrap) {
                  needReverse = this._needReverse(currentIterations);
                }

                var direction = needReverse ? -1 : 1;

                if (this.speed < 0) {
                  direction *= -1;
                }

                if (shouldWrap && needReverse) {
                  time = playbackDuration - time;
                }

                info.time = playbackStart + time;
                info.ratio = info.time / this.duration;
                info.direction = direction;
                info.stopped = stopped;
                info.iterations = currentIterations;
                return info;
              };

              _proto._getPlaybackStart = function _getPlaybackStart() {
                return this._playbackRange.min;
              };

              _proto._sampleEvents = function _sampleEvents(wrapInfo) {
                var _this$_clipEventEval2;

                (_this$_clipEventEval2 = this._clipEventEval) === null || _this$_clipEventEval2 === void 0 ? void 0 : _this$_clipEventEval2.sample(wrapInfo.ratio, wrapInfo.direction, wrapInfo.iterations);
              };

              _proto._sampleEmbeddedPlayers = function _sampleEmbeddedPlayers(wrapInfo) {
                var _this$_clipEmbeddedPl5;

                (_this$_clipEmbeddedPl5 = this._clipEmbeddedPlayerEval) === null || _this$_clipEmbeddedPl5 === void 0 ? void 0 : _this$_clipEmbeddedPl5.evaluate(wrapInfo.time, Math.trunc(wrapInfo.iterations));
              };

              _proto._emit = function _emit(type, state) {
                if (this._target && this._target.isValid) {
                  this._target.emit(type, type, state);
                }
              };

              _proto._onReplayOrResume = function _onReplayOrResume() {
                getGlobalAnimationManager().addAnimation(this);
              };

              _proto._onPauseOrStop = function _onPauseOrStop() {
                getGlobalAnimationManager().removeAnimation(this);
              };

              _createClass(AnimationState, [{
                key: "clip",
                get: function get() {
                  return this._clip;
                }
              }, {
                key: "name",
                get: function get() {
                  return this._name;
                }
              }, {
                key: "length",
                get: function get() {
                  return this.duration;
                }
              }, {
                key: "wrapMode",
                get: function get() {
                  return this._wrapMode;
                },
                set: function set(value) {
                  var _this$_clipEventEval3;

                  this._wrapMode = value;
                  this.time = 0;

                  if (value & WrapModeMask.Loop) {
                    this.repeatCount = Infinity;
                  } else {
                    this.repeatCount = 1;
                  }

                  (_this$_clipEventEval3 = this._clipEventEval) === null || _this$_clipEventEval3 === void 0 ? void 0 : _this$_clipEventEval3.setWrapMode(value);
                }
              }, {
                key: "repeatCount",
                get: function get() {
                  return this._repeatCount;
                },
                set: function set(value) {
                  this._repeatCount = value;
                  var shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;
                  var reverse = (this.wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse;

                  if (value === Infinity && !shouldWrap && !reverse) {
                    this._useSimpleProcess = true;
                  } else {
                    this._useSimpleProcess = false;
                  }
                }
              }, {
                key: "delay",
                get: function get() {
                  return this._delay;
                },
                set: function set(value) {
                  this._delayTime = this._delay = value;
                }
              }, {
                key: "playbackRange",
                get: function get() {
                  return this._playbackRange;
                },
                set: function set(value) {
                  assertIsTrue(value.max >= value.min);
                  this._playbackRange.min = Math.max(value.min, 0);
                  this._playbackRange.max = Math.min(value.max, this.duration);
                  this._playbackDuration = this._playbackRange.max - this._playbackRange.min;
                  this.setTime(0.0);
                }
              }, {
                key: "speed",
                get: function get() {
                  return this._speed;
                },
                set: function set(value) {
                  var _this$_clipEmbeddedPl6;

                  this._speed = value;
                  (_this$_clipEmbeddedPl6 = this._clipEmbeddedPlayerEval) === null || _this$_clipEmbeddedPl6 === void 0 ? void 0 : _this$_clipEmbeddedPl6.notifyHostSpeedChanged(value);
                }
              }, {
                key: "current",
                get: function get() {
                  return this.getWrappedInfo(this.time).time;
                }
              }, {
                key: "ratio",
                get: function get() {
                  return this.duration === 0.0 ? 0.0 : this.current / this.duration;
                }
              }, {
                key: "weight",
                get: function get() {
                  return this._weight;
                },
                set: function set(value) {
                  this._weight = value;

                  if (this._poseOutput) {
                    this._poseOutput.weight = value;
                  }
                }
              }, {
                key: "curveLoaded",
                get: function get() {
                  return this._curveLoaded;
                }
              }]);

              return AnimationState;
            }(Playable));
            legacyCC.AnimationState = AnimationState;

            var _dec$z, _class$z, _class2$u, _initializer$s, _initializer2$o;
            var EmbeddedAnimationClipPlayable = (_dec$z = ccclass$p(CLASS_NAME_PREFIX_ANIM + "EmbeddedAnimationClipPlayable"), _dec$z(_class$z = (_class2$u = function (_EmbeddedPlayable) {
              _inheritsLoose(EmbeddedAnimationClipPlayable, _EmbeddedPlayable);

              function EmbeddedAnimationClipPlayable() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _EmbeddedPlayable.call.apply(_EmbeddedPlayable, [this].concat(args)) || this;
                _this.path = _initializer$s && _initializer$s();
                _this.clip = _initializer2$o && _initializer2$o();
                return _this;
              }

              var _proto = EmbeddedAnimationClipPlayable.prototype;

              _proto.instantiate = function instantiate(root) {
                var clip = this.clip,
                    path = this.path;

                if (!clip) {
                  return null;
                }

                var clipRoot = root.getChildByPath(path);

                if (!clipRoot) {
                  errorID(3938, path, root.getPathInHierarchy(), clip.name);
                  return null;
                }

                var state = new AnimationState(clip);
                state.initialize(clipRoot);
                return new EmbeddedAnimationClipPlayableState(state);
              };

              return EmbeddedAnimationClipPlayable;
            }(EmbeddedPlayable), (_initializer$s = applyDecoratedInitializer(_class2$u.prototype, "path", [serializable$j], function () {
              return '';
            }), _initializer2$o = applyDecoratedInitializer(_class2$u.prototype, "clip", [serializable$j], function () {
              return null;
            })), _class2$u)) || _class$z);

            var EmbeddedAnimationClipPlayableState = function (_EmbeddedPlayableStat) {
              _inheritsLoose(EmbeddedAnimationClipPlayableState, _EmbeddedPlayableStat);

              function EmbeddedAnimationClipPlayableState(animationState) {
                var _this2;

                _this2 = _EmbeddedPlayableStat.call(this, true) || this;
                _this2._animationState = void 0;
                _this2._animationState = animationState;
                return _this2;
              }

              var _proto2 = EmbeddedAnimationClipPlayableState.prototype;

              _proto2.destroy = function destroy() {
                this._animationState.destroy();
              };

              _proto2.play = function play() {
                this._animationState.play();
              };

              _proto2.pause = function pause() {
                this._animationState.pause();
              };

              _proto2.stop = function stop() {
                this._animationState.stop();
              };

              _proto2.setSpeed = function setSpeed(speed) {
                this._animationState.speed = speed;
              };

              _proto2.setTime = function setTime(time) {
                this._animationState.time = time;
              };

              return EmbeddedAnimationClipPlayableState;
            }(EmbeddedPlayableState);

            var _dec$A, _class$A, _class2$v, _initializer$t;
            var EmbeddedParticleSystemPlayable = (_dec$A = ccclass$p(CLASS_NAME_PREFIX_ANIM + "EmbeddedParticleSystemPlayable"), _dec$A(_class$A = (_class2$v = function (_EmbeddedPlayable) {
              _inheritsLoose(EmbeddedParticleSystemPlayable, _EmbeddedPlayable);

              function EmbeddedParticleSystemPlayable() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _EmbeddedPlayable.call.apply(_EmbeddedPlayable, [this].concat(args)) || this;
                _this.path = _initializer$t && _initializer$t();
                return _this;
              }

              var _proto = EmbeddedParticleSystemPlayable.prototype;

              _proto.instantiate = function instantiate(root) {
                var node = root.getChildByPath(this.path);

                if (!node) {
                  warn("Hierarchy path " + this.path + " does not exists.");
                  return null;
                }

                var ParticleSystemConstructor = getClassByName("cc.ParticleSystem");

                if (!ParticleSystemConstructor) {
                  warn("Particle system is required for embedded particle system player.");
                  return null;
                }

                var particleSystem = node.getComponent(ParticleSystemConstructor);

                if (!particleSystem) {
                  warn(this.path + " does not includes a particle system component.");
                  return null;
                }

                return new EmbeddedParticleSystemPlayableState(particleSystem);
              };

              return EmbeddedParticleSystemPlayable;
            }(EmbeddedPlayable), (_initializer$t = applyDecoratedInitializer(_class2$v.prototype, "path", [serializable$j], function () {
              return '';
            })), _class2$v)) || _class$A);

            var EmbeddedParticleSystemPlayableState = function (_EmbeddedPlayableStat) {
              _inheritsLoose(EmbeddedParticleSystemPlayableState, _EmbeddedPlayableStat);

              function EmbeddedParticleSystemPlayableState(particleSystem) {
                var _this2;

                _this2 = _EmbeddedPlayableStat.call(this, false) || this;
                _this2._particleSystem = void 0;
                _this2._particleSystem = particleSystem;
                return _this2;
              }

              var _proto2 = EmbeddedParticleSystemPlayableState.prototype;

              _proto2.destroy = function destroy() {};

              _proto2.play = function play() {
                this._particleSystem.play();
              };

              _proto2.pause = function pause() {
                this._particleSystem.stopEmitting();
              };

              _proto2.stop = function stop() {
                this._particleSystem.stopEmitting();
              };

              _proto2.setSpeed = function setSpeed(speed) {
                this._particleSystem.simulationSpeed = speed;
              };

              return EmbeddedParticleSystemPlayableState;
            }(EmbeddedPlayableState);

            var _dec$B, _class$B, _class2$w, _initializer$u, _dec2$t, _class4$3, _class5$3, _initializer2$p;
            function isPropertyPath(path) {
              return typeof path === 'string' || typeof path === 'number';
            }
            function isCustomPath(path, constructor) {
              return path instanceof constructor;
            }
            var HierarchyPath = (_dec$B = ccclass$p('cc.animation.HierarchyPath'), _dec$B(_class$B = (_class2$w = function () {
              function HierarchyPath(path) {
                this.path = _initializer$u && _initializer$u();
                this.path = path || '';
              }

              var _proto = HierarchyPath.prototype;

              _proto.get = function get(target) {
                if (!(target instanceof Node)) {
                  warnID(3925);
                  return null;
                }

                var result = target.getChildByPath(this.path);

                if (!result) {
                  warnID(3926, target.name, this.path);
                  return null;
                }

                return result;
              };

              return HierarchyPath;
            }(), (_initializer$u = applyDecoratedInitializer(_class2$w.prototype, "path", [serializable$j], function () {
              return '';
            })), _class2$w)) || _class$B);
            var ComponentPath = (_dec2$t = ccclass$p('cc.animation.ComponentPath'), _dec2$t(_class4$3 = (_class5$3 = function () {
              function ComponentPath(component) {
                this.component = _initializer2$p && _initializer2$p();
                this.component = component || '';
              }

              var _proto2 = ComponentPath.prototype;

              _proto2.get = function get(target) {
                if (!(target instanceof Node)) {
                  warnID(3927);
                  return null;
                }

                var result = target.getComponent(this.component);

                if (!result) {
                  warnID(3928, target.name, this.component);
                  return null;
                }

                return result;
              };

              return ComponentPath;
            }(), (_initializer2$p = applyDecoratedInitializer(_class5$3.prototype, "component", [serializable$j], function () {
              return '';
            })), _class5$3)) || _class4$3);

            var _dec$C, _class$C, _class2$x, _initializer$v, _dec2$u, _class4$4, _class5$4, _initializer2$q, _initializer3$j, _class6$1, _temp$b, _dec3$m, _class7, _class8, _initializer4$h, _dec4$e, _class10, _class11, _initializer5$e, _dec5$a, _class13, _class14, _initializer6$b;
            var normalizedFollowTag = Symbol('NormalizedFollow');
            var parseTrsPathTag = Symbol('ConvertAsTrsPath');
            var trackBindingTag = Symbol('TrackBinding');
            var TrackPath = (_dec$C = ccclass$p(CLASS_NAME_PREFIX_ANIM + "TrackPath"), _dec$C(_class$C = (_class2$x = function () {
              function TrackPath() {
                this._paths = _initializer$v && _initializer$v();
              }

              var _proto = TrackPath.prototype;

              _proto.toProperty = function toProperty(name) {
                this._paths.push(name);

                return this;
              };

              _proto.toElement = function toElement(index) {
                this._paths.push(index);

                return this;
              };

              _proto.toHierarchy = function toHierarchy(nodePath) {
                this._paths.push(new HierarchyPath(nodePath));

                return this;
              };

              _proto.toComponent = function toComponent(constructor) {
                var path = new ComponentPath(typeof constructor === 'string' ? constructor : getClassName(constructor));

                this._paths.push(path);

                return this;
              };

              _proto.toCustomized = function toCustomized(resolver) {
                this._paths.push(resolver);

                return this;
              };

              _proto.append = function append() {
                var _this$_paths;

                for (var _len = arguments.length, trackPaths = new Array(_len), _key = 0; _key < _len; _key++) {
                  trackPaths[_key] = arguments[_key];
                }

                var paths = (_this$_paths = this._paths).concat.apply(_this$_paths, trackPaths.map(function (trackPath) {
                  return trackPath._paths;
                }));

                this._paths = paths;
                return this;
              };

              _proto.isPropertyAt = function isPropertyAt(index) {
                return typeof this._paths[index] === 'string';
              };

              _proto.parsePropertyAt = function parsePropertyAt(index) {
                return this._paths[index];
              };

              _proto.isElementAt = function isElementAt(index) {
                return typeof this._paths[index] === 'number';
              };

              _proto.parseElementAt = function parseElementAt(index) {
                return this._paths[index];
              };

              _proto.isHierarchyAt = function isHierarchyAt(index) {
                return this._paths[index] instanceof HierarchyPath;
              };

              _proto.parseHierarchyAt = function parseHierarchyAt(index) {
                assertIsTrue(this.isHierarchyAt(index));
                return this._paths[index].path;
              };

              _proto.isComponentAt = function isComponentAt(index) {
                return this._paths[index] instanceof ComponentPath;
              };

              _proto.parseComponentAt = function parseComponentAt(index) {
                assertIsTrue(this.isComponentAt(index));
                return this._paths[index].component;
              };

              _proto.slice = function slice(beginIndex, endIndex) {
                var trackPath = new TrackPath();
                trackPath._paths = this._paths.slice(beginIndex, endIndex);
                return trackPath;
              };

              _proto.trace = function trace(object, beginIndex, endIndex) {
                var _beginIndex, _endIndex;

                (_beginIndex = beginIndex) !== null && _beginIndex !== void 0 ? _beginIndex : beginIndex = 0;
                (_endIndex = endIndex) !== null && _endIndex !== void 0 ? _endIndex : endIndex = this._paths.length;
                return this[normalizedFollowTag](object, beginIndex, endIndex);
              };

              _proto[parseTrsPathTag] = function () {
                var paths = this._paths;
                var nPaths = paths.length;
                var iPath = 0;
                var nodePath = '';

                for (; iPath < nPaths; ++iPath) {
                  var path = paths[iPath];

                  if (!(path instanceof HierarchyPath)) {
                    break;
                  } else if (!path.path) {
                    continue;
                  } else if (nodePath) {
                    nodePath += "/" + path.path;
                  } else {
                    nodePath = path.path;
                  }
                }

                if (iPath === nPaths) {
                  return null;
                }

                var prs;

                if (iPath !== nPaths - 1) {
                  return null;
                }

                switch (paths[iPath]) {
                  case 'position':
                  case 'scale':
                  case 'rotation':
                  case 'eulerAngles':
                    prs = paths[iPath];
                    break;

                  default:
                    return null;
                }

                return {
                  node: nodePath,
                  property: prs
                };
              };

              _proto[normalizedFollowTag] = function (root, beginIndex, endIndex) {
                var paths = this._paths;
                var result = root;

                for (var iPath = beginIndex; iPath < endIndex; ++iPath) {
                  var path = paths[iPath];

                  if (isPropertyPath(path)) {
                    if (!(path in result)) {
                      warnID(3929, path);
                      return null;
                    } else {
                      result = result[path];
                    }
                  } else {
                    result = path.get(result);
                  }

                  if (result === null) {
                    break;
                  }
                }

                return result;
              };

              _createClass(TrackPath, [{
                key: "length",
                get: function get() {
                  return this._paths.length;
                }
              }]);

              return TrackPath;
            }(), (_initializer$v = applyDecoratedInitializer(_class2$x.prototype, "_paths", [serializable$j], function () {
              return [];
            })), _class2$x)) || _class$C);
            var TrackBinding = (_dec2$u = ccclass$p(CLASS_NAME_PREFIX_ANIM + "TrackBinding"), _dec2$u(_class4$4 = uniquelyReferenced(_class4$4 = (_class5$4 = (_temp$b = _class6$1 = function () {
              function TrackBinding() {
                this.path = _initializer2$q && _initializer2$q();
                this.proxy = _initializer3$j && _initializer3$j();
              }

              var _proto2 = TrackBinding.prototype;

              _proto2.parseTrsPath = function parseTrsPath() {
                if (this.proxy) {
                  return null;
                } else {
                  return this.path[parseTrsPathTag]();
                }
              };

              _proto2.createRuntimeBinding = function createRuntimeBinding(target, poseOutput, isConstant) {
                var path = this.path,
                    proxy = this.proxy;
                var nPaths = path.length;
                var iLastPath = nPaths - 1;

                if (nPaths !== 0 && (path.isPropertyAt(iLastPath) || path.isElementAt(iLastPath)) && !proxy) {
                  var lastPropertyKey = path.isPropertyAt(iLastPath) ? path.parsePropertyAt(iLastPath) : path.parseElementAt(iLastPath);
                  var resultTarget = path[normalizedFollowTag](target, 0, nPaths - 1);

                  if (resultTarget === null) {
                    return null;
                  }

                  if (poseOutput && resultTarget instanceof Node && isTrsPropertyName(lastPropertyKey)) {
                    var blendStateWriter = poseOutput.createPoseWriter(resultTarget, lastPropertyKey, isConstant);
                    return blendStateWriter;
                  }

                  var _setValue;

                  var _getValue;

                  {
                    var animationFunction = TrackBinding._animationFunctions.get(resultTarget.constructor);

                    if (!animationFunction) {
                      animationFunction = new Map();

                      TrackBinding._animationFunctions.set(resultTarget.constructor, animationFunction);
                    }

                    var accessor = animationFunction.get(lastPropertyKey);

                    if (!accessor) {
                      accessor = {
                        setValue: Function('value', "this.target." + lastPropertyKey + " = value;"),
                        getValue: Function("return this.target." + lastPropertyKey + ";")
                      };
                      animationFunction.set(lastPropertyKey, accessor);
                    }

                    _setValue = accessor.setValue;
                    _getValue = accessor.getValue;
                  }

                  return {
                    target: resultTarget,
                    setValue: _setValue,
                    getValue: _getValue
                  };
                } else if (!proxy) {
                  errorID(3921);
                  return null;
                } else {
                  var _resultTarget = path[normalizedFollowTag](target, 0, nPaths);

                  if (_resultTarget === null) {
                    return null;
                  }

                  var runtimeProxy = proxy.forTarget(_resultTarget);

                  if (!runtimeProxy) {
                    return null;
                  }

                  var _binding = {
                    setValue: function setValue(value) {
                      runtimeProxy.set(value);
                    }
                  };
                  var proxyGet = runtimeProxy.get;

                  if (proxyGet) {
                    _binding.getValue = function () {
                      return proxyGet.call(runtimeProxy);
                    };
                  }

                  return _binding;
                }
              };

              _proto2.isMaskedOff = function isMaskedOff(mask) {
                var trsPath = this.parseTrsPath();

                if (!trsPath) {
                  return false;
                }

                var joints = mask.joints[Symbol.iterator]();

                for (var jointMaskInfoIter = joints.next(); !jointMaskInfoIter.done; jointMaskInfoIter = joints.next()) {
                  var _jointMaskInfoIter = jointMaskInfoIter,
                      jointMaskInfo = _jointMaskInfoIter.value;

                  if (jointMaskInfo.path !== trsPath.node) {
                    continue;
                  }

                  return !jointMaskInfo.enabled;
                }

                return false;
              };

              return TrackBinding;
            }(), _class6$1._animationFunctions = new WeakMap(), _temp$b), (_initializer2$q = applyDecoratedInitializer(_class5$4.prototype, "path", [serializable$j], function () {
              return new TrackPath();
            }), _initializer3$j = applyDecoratedInitializer(_class5$4.prototype, "proxy", [serializable$j], null)), _class5$4)) || _class4$4) || _class4$4);

            function isTrsPropertyName(name) {
              return name === 'position' || name === 'rotation' || name === 'scale' || name === 'eulerAngles';
            }
            var Track = (_dec3$m = ccclass$p(CLASS_NAME_PREFIX_ANIM + "Track"), _dec3$m(_class7 = (_class8 = function () {
              function Track() {
                this._binding = _initializer4$h && _initializer4$h();
              }

              var _proto3 = Track.prototype;

              _proto3.channels = function channels() {
                return [];
              };

              _proto3.range = function range() {
                var range = {
                  min: Infinity,
                  max: -Infinity
                };

                for (var _iterator = _createForOfIteratorHelperLoose(this.channels()), _step; !(_step = _iterator()).done;) {
                  var channel = _step.value;
                  range.min = Math.min(range.min, channel.curve.rangeMin);
                  range.max = Math.max(range.max, channel.curve.rangeMax);
                }

                return range;
              };

              _createClass(Track, [{
                key: "path",
                get: function get() {
                  return this._binding.path;
                },
                set: function set(value) {
                  this._binding.path = value;
                }
              }, {
                key: "proxy",
                get: function get() {
                  return this._binding.proxy;
                },
                set: function set(value) {
                  this._binding.proxy = value;
                }
              }, {
                key: trackBindingTag,
                get: function get() {
                  return this._binding;
                }
              }]);

              return Track;
            }(), (_initializer4$h = applyDecoratedInitializer(_class8.prototype, "_binding", [serializable$j], function () {
              return new TrackBinding();
            })), _class8)) || _class7);
            var Channel = (_dec4$e = ccclass$p(CLASS_NAME_PREFIX_ANIM + "Channel"), _dec4$e(_class10 = (_class11 = function () {
              function Channel(curve) {
                this.name = '';
                this._curve = _initializer5$e && _initializer5$e();
                this._curve = curve;
              }

              _createClass(Channel, [{
                key: "curve",
                get: function get() {
                  return this._curve;
                }
              }]);

              return Channel;
            }(), (_initializer5$e = applyDecoratedInitializer(_class11.prototype, "_curve", [serializable$j], null)), _class11)) || _class10);
            var SingleChannelTrack = (_dec5$a = ccclass$p(CLASS_NAME_PREFIX_ANIM + "SingleChannelTrack"), _dec5$a(_class13 = (_class14 = function (_Track) {
              _inheritsLoose(SingleChannelTrack, _Track);

              function SingleChannelTrack() {
                var _this;

                _this = _Track.call(this) || this;
                _this._channel = _initializer6$b && _initializer6$b();
                _this._channel = new Channel(_this.createCurve());
                return _this;
              }

              var _proto4 = SingleChannelTrack.prototype;

              _proto4.channels = function channels() {
                return [this._channel];
              };

              _proto4.createCurve = function createCurve() {
                throw new Error("Not impl");
              };

              _proto4[createEvalSymbol] = function (_runtimeBinding) {
                var curve = this._channel.curve;
                return new SingleChannelTrackEval(curve);
              };

              _createClass(SingleChannelTrack, [{
                key: "channel",
                get: function get() {
                  return this._channel;
                }
              }]);

              return SingleChannelTrack;
            }(Track), (_initializer6$b = applyDecoratedInitializer(_class14.prototype, "_channel", [serializable$j], null)), _class14)) || _class13);

            var SingleChannelTrackEval = function () {
              function SingleChannelTrackEval(_curve) {
                this._curve = _curve;
              }

              var _proto5 = SingleChannelTrackEval.prototype;

              _proto5.evaluate = function evaluate(time) {
                return this._curve.evaluate(time);
              };

              return SingleChannelTrackEval;
            }();

            var _dec$D, _class$D, _class2$y, _initializer$w;
            var ccclass$3 = ccclass$p,
                serializable$3 = serializable$j;
            var RealArrayTrack = (_dec$D = ccclass$3(CLASS_NAME_PREFIX_ANIM + "RealArrayTrack"), _dec$D(_class$D = (_class2$y = function (_Track) {
              _inheritsLoose(RealArrayTrack, _Track);

              function RealArrayTrack() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Track.call.apply(_Track, [this].concat(args)) || this;
                _this._channels = _initializer$w && _initializer$w();
                return _this;
              }

              var _proto = RealArrayTrack.prototype;

              _proto.channels = function channels() {
                return this._channels;
              };

              _proto[createEvalSymbol] = function () {
                return new RealArrayTrackEval(this._channels.map(function (_ref) {
                  var curve = _ref.curve;
                  return curve;
                }));
              };

              _createClass(RealArrayTrack, [{
                key: "elementCount",
                get: function get() {
                  return this._channels.length;
                },
                set: function set(value) {
                  var channels = this._channels;
                  var nChannels = channels.length;

                  if (value < nChannels) {
                    this._channels.splice(value);
                  } else if (value > nChannels) {
                    var _this$_channels;

                    (_this$_channels = this._channels).push.apply(_this$_channels, Array.from({
                      length: value - nChannels
                    }, function () {
                      return new Channel(new RealCurve());
                    }));
                  }
                }
              }]);

              return RealArrayTrack;
            }(Track), (_initializer$w = applyDecoratedInitializer(_class2$y.prototype, "_channels", [serializable$3], function () {
              return [];
            })), _class2$y)) || _class$D);
            var RealArrayTrackEval = function () {
              function RealArrayTrackEval(_curves) {
                this._curves = _curves;
                this._result = new Array(_curves.length).fill(0.0);
              }

              var _proto2 = RealArrayTrackEval.prototype;

              _proto2.evaluate = function evaluate(time, _runtimeBinding) {
                var result = this._result;
                var nElements = result.length;

                for (var iElement = 0; iElement < nElements; ++iElement) {
                  result[iElement] = this._curves[iElement].evaluate(time);
                }

                return this._result;
              };

              return RealArrayTrackEval;
            }();

            var _dec$E, _class$E, _class2$z, _initializer$x, _initializer2$r, _descriptor;
            var UniformProxyFactory = (_dec$E = ccclass$p('cc.animation.UniformProxyFactory'), _dec$E(_class$E = (_class2$z = function () {
              function UniformProxyFactory(uniformName, passIndex) {
                this.passIndex = _initializer$x && _initializer$x();
                this.uniformName = _initializer2$r && _initializer2$r();

                _initializerDefineProperty(this, "channelIndex", _descriptor, this);

                this.passIndex = passIndex || 0;
                this.uniformName = uniformName || '';
              }

              var _proto = UniformProxyFactory.prototype;

              _proto.forTarget = function forTarget(target) {
                if (!(target instanceof Material)) {
                  warnID(3940, target);
                  return undefined;
                }

                var passIndex = this.passIndex,
                    uniformName = this.uniformName,
                    channelIndex = this.channelIndex;

                if (passIndex < 0 || passIndex >= target.passes.length) {
                  warnID(3941, target.name, passIndex);
                  return undefined;
                }

                var pass = target.passes[passIndex];
                var handle = pass.getHandle(uniformName);

                if (!handle) {
                  warnID(3942, target.name, passIndex, uniformName);
                  return undefined;
                }

                var type = Pass.getTypeFromHandle(handle);

                if (type < Type$1.SAMPLER1D) {
                  var realHandle = channelIndex === undefined ? handle : pass.getHandle(uniformName, channelIndex, Type$1.FLOAT);

                  if (!realHandle) {
                    warnID(3943, target.name, passIndex, uniformName, channelIndex);
                    return undefined;
                  }

                  if (isUniformArray(pass, uniformName)) {
                    return {
                      set: function set(value) {
                        pass.setUniformArray(realHandle, value);
                      }
                    };
                  }

                  return {
                    set: function set(value) {
                      pass.setUniform(realHandle, value);
                    }
                  };
                } else {
                  var binding = Pass.getBindingFromHandle(handle);
                  var prop = pass.properties[uniformName];
                  var texName = prop && prop.value ? "" + prop.value + getStringFromType(prop.type) : getDefaultFromType(prop.type);
                  var dftTex = builtinResMgr.get(texName);

                  if (!dftTex) {
                    warn("Illegal texture default value: " + texName + ".");
                    dftTex = builtinResMgr.get('default-texture');
                  }

                  return {
                    set: function set(value) {
                      if (!value) {
                        value = dftTex;
                      }

                      var texture = value.getGFXTexture();

                      if (!texture || !texture.width || !texture.height) {
                        return;
                      }

                      pass.bindTexture(binding, texture);

                      if (value instanceof TextureBase) {
                        pass.bindSampler(binding, deviceManager.gfxDevice.getSampler(value.getSamplerInfo()));
                      }
                    }
                  };
                }
              };

              return UniformProxyFactory;
            }(), (_initializer$x = applyDecoratedInitializer(_class2$z.prototype, "passIndex", [serializable$j], function () {
              return 0;
            }), _initializer2$r = applyDecoratedInitializer(_class2$z.prototype, "uniformName", [serializable$j], function () {
              return '';
            }), _descriptor = _applyDecoratedDescriptor(_class2$z.prototype, "channelIndex", [_float], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return undefined;
              }
            })), _class2$z)) || _class$E);

            function isUniformArray(pass, name) {
              for (var _iterator = _createForOfIteratorHelperLoose(pass.shaderInfo.blocks), _step; !(_step = _iterator()).done;) {
                var block = _step.value;

                for (var _iterator2 = _createForOfIteratorHelperLoose(block.members), _step2; !(_step2 = _iterator2()).done;) {
                  var uniform = _step2.value;

                  if (uniform.name === name) {
                    return uniform.count > 1;
                  }
                }
              }

              return false;
            }

            var _dec$F, _class$F, _class2$A, _initializer$y, _initializer2$s, _dec2$v, _class4$5, _class5$5, _initializer3$k, _dec3$n, _class7$1;
            var MorphWeightValueProxy = (_dec$F = ccclass$p('cc.animation.MorphWeightValueProxy'), _dec$F(_class$F = (_class2$A = function () {
              function MorphWeightValueProxy() {
                this.subMeshIndex = _initializer$y && _initializer$y();
                this.shapeIndex = _initializer2$s && _initializer2$s();
              }

              var _proto = MorphWeightValueProxy.prototype;

              _proto.forTarget = function forTarget(target) {
                var _this = this;

                return {
                  set: function set(value) {
                    target.setWeight(value, _this.subMeshIndex, _this.shapeIndex);
                  }
                };
              };

              return MorphWeightValueProxy;
            }(), (_initializer$y = applyDecoratedInitializer(_class2$A.prototype, "subMeshIndex", [serializable$j], function () {
              return 0;
            }), _initializer2$s = applyDecoratedInitializer(_class2$A.prototype, "shapeIndex", [serializable$j], function () {
              return 0;
            })), _class2$A)) || _class$F);
            var MorphWeightsValueProxy = (_dec2$v = ccclass$p('cc.animation.MorphWeightsValueProxy'), _dec2$v(_class4$5 = (_class5$5 = function () {
              function MorphWeightsValueProxy() {
                this.subMeshIndex = _initializer3$k && _initializer3$k();
              }

              var _proto2 = MorphWeightsValueProxy.prototype;

              _proto2.forTarget = function forTarget(target) {
                var _this2 = this;

                return {
                  set: function set(value) {
                    target.setWeights(value, _this2.subMeshIndex);
                  }
                };
              };

              return MorphWeightsValueProxy;
            }(), (_initializer3$k = applyDecoratedInitializer(_class5$5.prototype, "subMeshIndex", [serializable$j], function () {
              return 0;
            })), _class5$5)) || _class4$5);
            var MorphWeightsAllValueProxy = (_dec3$n = ccclass$p('cc.animation.MorphWeightsAllValueProxy'), _dec3$n(_class7$1 = function () {
              function MorphWeightsAllValueProxy() {}

              var _proto3 = MorphWeightsAllValueProxy.prototype;

              _proto3.forTarget = function forTarget(target) {
                return {
                  set: function set(value) {
                    var _target$mesh$struct$p, _target$mesh;

                    var nSubMeshes = (_target$mesh$struct$p = (_target$mesh = target.mesh) === null || _target$mesh === void 0 ? void 0 : _target$mesh.struct.primitives.length) !== null && _target$mesh$struct$p !== void 0 ? _target$mesh$struct$p : 0;

                    for (var iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                      target.setWeights(value, iSubMesh);
                    }
                  }
                };
              };

              return MorphWeightsAllValueProxy;
            }()) || _class7$1);

            var _dec2$w, _class4$6, _class5$6, _initializer4$i, _initializer5$f, _initializer6$c;

            function makeCubicSplineValueConstructor(name, constructorX, scaleFx, scaleAndAdd) {
              var _dec, _class, _class2, _initializer, _initializer2, _initializer3;

              var tempValue = new constructorX();
              var m0 = new constructorX();
              var m1 = new constructorX();
              var CubicSplineValueClass = (_dec = ccclass$p(name), _dec(_class = (_class2 = function () {
                function CubicSplineValueClass(dataPoint, inTangent, outTangent) {
                  this.dataPoint = _initializer && _initializer();
                  this.inTangent = _initializer2 && _initializer2();
                  this.outTangent = _initializer3 && _initializer3();
                  this.dataPoint = dataPoint || new constructorX();
                  this.inTangent = inTangent || new constructorX();
                  this.outTangent = outTangent || new constructorX();
                }

                var _proto = CubicSplineValueClass.prototype;

                _proto.lerp = function lerp(to, t, dt) {
                  var p0 = this.dataPoint;
                  var p1 = to.dataPoint;
                  m0 = scaleFx(m0, this.inTangent, dt);
                  m1 = scaleFx(m1, to.outTangent, dt);
                  var t_3 = t * t * t;
                  var t_2 = t * t;
                  var f_0 = 2 * t_3 - 3 * t_2 + 1;
                  var f_1 = t_3 - 2 * t_2 + t;
                  var f_2 = -2 * t_3 + 3 * t_2;
                  var f_3 = t_3 - t_2;
                  tempValue = scaleFx(tempValue, p0, f_0);
                  tempValue = scaleAndAdd(tempValue, tempValue, m0, f_1);
                  tempValue = scaleAndAdd(tempValue, tempValue, p1, f_2);
                  tempValue = scaleAndAdd(tempValue, tempValue, m1, f_3);
                  return tempValue;
                };

                _proto.getNoLerp = function getNoLerp() {
                  return this.dataPoint;
                };

                return CubicSplineValueClass;
              }(), (_initializer = applyDecoratedInitializer(_class2.prototype, "dataPoint", [serializable$j], function () {
                return new constructorX();
              }), _initializer2 = applyDecoratedInitializer(_class2.prototype, "inTangent", [serializable$j], function () {
                return new constructorX();
              }), _initializer3 = applyDecoratedInitializer(_class2.prototype, "outTangent", [serializable$j], function () {
                return new constructorX();
              })), _class2)) || _class);

              if (constructorX === Quat) {
                var _lerp = CubicSplineValueClass.prototype.lerp;

                CubicSplineValueClass.prototype.lerp = function (to, t, dt) {
                  var result = _lerp.call(this, to, t, dt);

                  Quat.normalize(result, result);
                  return result;
                };
              }

              return CubicSplineValueClass;
            }

            var CubicSplineVec2Value = makeCubicSplineValueConstructor('cc.CubicSplineVec2Value', Vec2, Vec2.multiplyScalar, Vec2.scaleAndAdd);
            var CubicSplineVec3Value = makeCubicSplineValueConstructor('cc.CubicSplineVec3Value', Vec3, Vec3.multiplyScalar, Vec3.scaleAndAdd);
            var CubicSplineVec4Value = makeCubicSplineValueConstructor('cc.CubicSplineVec4Value', Vec4, Vec4.multiplyScalar, Vec4.scaleAndAdd);
            var CubicSplineQuatValue = makeCubicSplineValueConstructor('cc.CubicSplineQuatValue', Quat, Quat.multiplyScalar, Quat.scaleAndAdd);
            var CubicSplineNumberValue = (_dec2$w = ccclass$p('cc.CubicSplineNumberValue'), _dec2$w(_class4$6 = (_class5$6 = function () {
              function CubicSplineNumberValue(dataPoint, inTangent, outTangent) {
                this.dataPoint = _initializer4$i && _initializer4$i();
                this.inTangent = _initializer5$f && _initializer5$f();
                this.outTangent = _initializer6$c && _initializer6$c();
                this.dataPoint = dataPoint;
                this.inTangent = inTangent;
                this.outTangent = outTangent;
              }

              var _proto2 = CubicSplineNumberValue.prototype;

              _proto2.lerp = function lerp(to, t, dt) {
                var p0 = this.dataPoint;
                var p1 = to.dataPoint;
                var m0 = this.outTangent * dt;
                var m1 = to.inTangent * dt;
                var t_3 = t * t * t;
                var t_2 = t * t;
                var f_0 = 2 * t_3 - 3 * t_2 + 1;
                var f_1 = t_3 - 2 * t_2 + t;
                var f_2 = -2 * t_3 + 3 * t_2;
                var f_3 = t_3 - t_2;
                return p0 * f_0 + m0 * f_1 + p1 * f_2 + m1 * f_3;
              };

              _proto2.getNoLerp = function getNoLerp() {
                return this.dataPoint;
              };

              return CubicSplineNumberValue;
            }(), (_initializer4$i = applyDecoratedInitializer(_class5$6.prototype, "dataPoint", [serializable$j], function () {
              return 0;
            }), _initializer5$f = applyDecoratedInitializer(_class5$6.prototype, "inTangent", [serializable$j], function () {
              return 0;
            }), _initializer6$c = applyDecoratedInitializer(_class5$6.prototype, "outTangent", [serializable$j], function () {
              return 0;
            })), _class5$6)) || _class4$6);

            var _dec$G, _class$G;
            var RealTrack = (_dec$G = ccclass$p(CLASS_NAME_PREFIX_ANIM + "RealTrack"), _dec$G(_class$G = function (_SingleChannelTrack) {
              _inheritsLoose(RealTrack, _SingleChannelTrack);

              function RealTrack() {
                return _SingleChannelTrack.apply(this, arguments) || this;
              }

              var _proto = RealTrack.prototype;

              _proto.createCurve = function createCurve() {
                return new RealCurve();
              };

              return RealTrack;
            }(SingleChannelTrack)) || _class$G);

            function maskIfEmpty(curve) {
              return curve.keyFramesCount === 0 ? undefined : curve;
            }

            var _dec$H, _class$H, _class2$B, _initializer$z, _initializer2$t;
            var CHANNEL_NAMES = ['X', 'Y', 'Z', 'W'];
            var VectorTrack = (_dec$H = ccclass$p(CLASS_NAME_PREFIX_ANIM + "VectorTrack"), _dec$H(_class$H = (_class2$B = function (_Track) {
              _inheritsLoose(VectorTrack, _Track);

              function VectorTrack() {
                var _this;

                _this = _Track.call(this) || this;
                _this._channels = _initializer$z && _initializer$z();
                _this._nComponents = _initializer2$t && _initializer2$t();
                _this._channels = new Array(4);

                for (var i = 0; i < _this._channels.length; ++i) {
                  var channel = new Channel(new RealCurve());
                  channel.name = CHANNEL_NAMES[i];
                  _this._channels[i] = channel;
                }

                return _this;
              }

              var _proto = VectorTrack.prototype;

              _proto.channels = function channels() {
                return this._channels;
              };

              _proto[createEvalSymbol] = function () {
                switch (this._nComponents) {
                  default:
                  case 2:
                    return new Vec2TrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve));

                  case 3:
                    return new Vec3TrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve), maskIfEmpty(this._channels[2].curve));

                  case 4:
                    return new Vec4TrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve), maskIfEmpty(this._channels[2].curve), maskIfEmpty(this._channels[3].curve));
                }
              };

              _createClass(VectorTrack, [{
                key: "componentsCount",
                get: function get() {
                  return this._nComponents;
                },
                set: function set(value) {
                  this._nComponents = value;
                }
              }]);

              return VectorTrack;
            }(Track), (_initializer$z = applyDecoratedInitializer(_class2$B.prototype, "_channels", [serializable$j], null), _initializer2$t = applyDecoratedInitializer(_class2$B.prototype, "_nComponents", [serializable$j], function () {
              return 4;
            })), _class2$B)) || _class$H);
            var Vec2TrackEval = function () {
              function Vec2TrackEval(_x, _y) {
                this._result = new Vec2();
                this._x = _x;
                this._y = _y;
              }

              var _proto2 = Vec2TrackEval.prototype;

              _proto2.evaluate = function evaluate(time, runtimeBinding) {
                if ((!this._x || !this._y) && runtimeBinding.getValue) {
                  Vec2.copy(this._result, runtimeBinding.getValue());
                }

                if (this._x) {
                  this._result.x = this._x.evaluate(time);
                }

                if (this._y) {
                  this._result.y = this._y.evaluate(time);
                }

                return this._result;
              };

              return Vec2TrackEval;
            }();
            var Vec3TrackEval = function () {
              function Vec3TrackEval(_x, _y, _z) {
                this._result = new Vec3();
                this._x = _x;
                this._y = _y;
                this._z = _z;
              }

              var _proto3 = Vec3TrackEval.prototype;

              _proto3.evaluate = function evaluate(time, runtimeBinding) {
                if ((!this._x || !this._y || !this._z) && runtimeBinding.getValue) {
                  Vec3.copy(this._result, runtimeBinding.getValue());
                }

                if (this._x) {
                  this._result.x = this._x.evaluate(time);
                }

                if (this._y) {
                  this._result.y = this._y.evaluate(time);
                }

                if (this._z) {
                  this._result.z = this._z.evaluate(time);
                }

                return this._result;
              };

              return Vec3TrackEval;
            }();
            var Vec4TrackEval = function () {
              function Vec4TrackEval(_x, _y, _z, _w) {
                this._result = new Vec4();
                this._x = _x;
                this._y = _y;
                this._z = _z;
                this._w = _w;
              }

              var _proto4 = Vec4TrackEval.prototype;

              _proto4.evaluate = function evaluate(time, runtimeBinding) {
                if ((!this._x || !this._y || !this._z || !this._w) && runtimeBinding.getValue) {
                  Vec4.copy(this._result, runtimeBinding.getValue());
                }

                if (this._x) {
                  this._result.x = this._x.evaluate(time);
                }

                if (this._y) {
                  this._result.y = this._y.evaluate(time);
                }

                if (this._z) {
                  this._result.z = this._z.evaluate(time);
                }

                if (this._w) {
                  this._result.w = this._w.evaluate(time);
                }

                return this._result;
              };

              return Vec4TrackEval;
            }();

            var _dec$I, _class$I;
            var QuatTrack = (_dec$I = ccclass$p(CLASS_NAME_PREFIX_ANIM + "QuatTrack"), _dec$I(_class$I = function (_SingleChannelTrack) {
              _inheritsLoose(QuatTrack, _SingleChannelTrack);

              function QuatTrack() {
                return _SingleChannelTrack.apply(this, arguments) || this;
              }

              var _proto = QuatTrack.prototype;

              _proto.createCurve = function createCurve() {
                return new QuatCurve();
              };

              _proto[createEvalSymbol] = function () {
                return new QuatTrackEval(this.channels()[0].curve);
              };

              return QuatTrack;
            }(SingleChannelTrack)) || _class$I);
            var QuatTrackEval = function () {
              function QuatTrackEval(_curve) {
                this._result = new Quat();
                this._curve = _curve;
              }

              var _proto2 = QuatTrackEval.prototype;

              _proto2.evaluate = function evaluate(time) {
                this._curve.evaluate(time, this._result);

                return this._result;
              };

              return QuatTrackEval;
            }();

            var _dec$J, _class$J, _class2$C, _initializer$A;
            var CHANNEL_NAMES$1 = ['Red', 'Green', 'Blue', 'Alpha'];
            var ColorTrack = (_dec$J = ccclass$p(CLASS_NAME_PREFIX_ANIM + "ColorTrack"), _dec$J(_class$J = (_class2$C = function (_Track) {
              _inheritsLoose(ColorTrack, _Track);

              function ColorTrack() {
                var _this;

                _this = _Track.call(this) || this;
                _this._channels = _initializer$A && _initializer$A();
                _this._channels = new Array(4);

                for (var i = 0; i < _this._channels.length; ++i) {
                  var channel = new Channel(new RealCurve());
                  channel.name = CHANNEL_NAMES$1[i];
                  _this._channels[i] = channel;
                }

                return _this;
              }

              var _proto = ColorTrack.prototype;

              _proto.channels = function channels() {
                return this._channels;
              };

              _proto[createEvalSymbol] = function () {
                return new ColorTrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve), maskIfEmpty(this._channels[2].curve), maskIfEmpty(this._channels[3].curve));
              };

              return ColorTrack;
            }(Track), (_initializer$A = applyDecoratedInitializer(_class2$C.prototype, "_channels", [serializable$j], null)), _class2$C)) || _class$J);
            var ColorTrackEval = function () {
              function ColorTrackEval(_x, _y, _z, _w) {
                this._result = new Color$1();
                this._x = _x;
                this._y = _y;
                this._z = _z;
                this._w = _w;
              }

              var _proto2 = ColorTrackEval.prototype;

              _proto2.evaluate = function evaluate(time, runtimeBinding) {
                if ((!this._x || !this._y || !this._z || !this._w) && runtimeBinding.getValue) {
                  Color$1.copy(this._result, runtimeBinding.getValue());
                }

                if (this._x) {
                  this._result.r = this._x.evaluate(time);
                }

                if (this._y) {
                  this._result.g = this._y.evaluate(time);
                }

                if (this._z) {
                  this._result.b = this._z.evaluate(time);
                }

                if (this._w) {
                  this._result.a = this._w.evaluate(time);
                }

                return this._result;
              };

              return ColorTrackEval;
            }();

            var _dec$K, _class$K, _class2$D, _initializer$B;
            var CHANNEL_NAMES$2 = ['Width', 'Height'];
            var SizeTrack = (_dec$K = ccclass$p(CLASS_NAME_PREFIX_ANIM + "SizeTrack"), _dec$K(_class$K = (_class2$D = function (_Track) {
              _inheritsLoose(SizeTrack, _Track);

              function SizeTrack() {
                var _this;

                _this = _Track.call(this) || this;
                _this._channels = _initializer$B && _initializer$B();
                _this._channels = new Array(2);

                for (var i = 0; i < _this._channels.length; ++i) {
                  var channel = new Channel(new RealCurve());
                  channel.name = CHANNEL_NAMES$2[i];
                  _this._channels[i] = channel;
                }

                return _this;
              }

              var _proto = SizeTrack.prototype;

              _proto.channels = function channels() {
                return this._channels;
              };

              _proto[createEvalSymbol] = function () {
                return new SizeTrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve));
              };

              return SizeTrack;
            }(Track), (_initializer$B = applyDecoratedInitializer(_class2$D.prototype, "_channels", [serializable$j], null)), _class2$D)) || _class$K);
            var SizeTrackEval = function () {
              function SizeTrackEval(_width, _height) {
                this._result = new Size$1();
                this._width = _width;
                this._height = _height;
              }

              var _proto2 = SizeTrackEval.prototype;

              _proto2.evaluate = function evaluate(time, runtimeBinding) {
                if ((!this._width || !this._height) && runtimeBinding.getValue) {
                  var size = runtimeBinding.getValue();
                  this._result.x = size.x;
                  this._result.y = size.y;
                }

                if (this._width) {
                  this._result.width = this._width.evaluate(time);
                }

                if (this._height) {
                  this._result.height = this._height.evaluate(time);
                }

                return this._result;
              };

              return SizeTrackEval;
            }();

            var _dec$L, _class$L;
            var ObjectTrack = (_dec$L = ccclass$p(CLASS_NAME_PREFIX_ANIM + "ObjectTrack"), _dec$L(_class$L = function (_SingleChannelTrack) {
              _inheritsLoose(ObjectTrack, _SingleChannelTrack);

              function ObjectTrack() {
                return _SingleChannelTrack.apply(this, arguments) || this;
              }

              var _proto = ObjectTrack.prototype;

              _proto.createCurve = function createCurve() {
                return new ObjectCurve();
              };

              return ObjectTrack;
            }(SingleChannelTrack)) || _class$L);

            var ownerSymbol = Symbol('[[Owner]]');
            function assertsOwnedBy(mastered, owner) {
              assertIsTrue(mastered[ownerSymbol] === owner);
            }
            function own(mastered, owner) {
              {
                mastered[ownerSymbol] = owner;
              }
            }
            function markAsDangling(mastered) {
              {
                mastered[ownerSymbol] = undefined;
              }
            }

            var VariableType;

            (function (VariableType) {
              VariableType[VariableType["FLOAT"] = 0] = "FLOAT";
              VariableType[VariableType["BOOLEAN"] = 1] = "BOOLEAN";
              VariableType[VariableType["TRIGGER"] = 2] = "TRIGGER";
              VariableType[VariableType["INTEGER"] = 3] = "INTEGER";
            })(VariableType || (VariableType = {}));

            var TriggerResetMode;

            (function (TriggerResetMode) {
              TriggerResetMode[TriggerResetMode["AFTER_CONSUMED"] = 0] = "AFTER_CONSUMED";
              TriggerResetMode[TriggerResetMode["NEXT_FRAME_OR_AFTER_CONSUMED"] = 1] = "NEXT_FRAME_OR_AFTER_CONSUMED";
            })(TriggerResetMode || (TriggerResetMode = {}));

            var VarInstance = function () {
              function VarInstance(type, value) {
                this.type = void 0;
                this.resetMode = TriggerResetMode.AFTER_CONSUMED;
                this._value = void 0;
                this._refs = [];
                this.type = type;
                this._value = value;
              }

              var _proto = VarInstance.prototype;

              _proto.bind = function bind(fn, thisArg) {
                for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                  args[_key - 2] = arguments[_key];
                }

                this._refs.push({
                  fn: fn,
                  thisArg: thisArg,
                  args: args
                });

                return this._value;
              };

              _createClass(VarInstance, [{
                key: "value",
                get: function get() {
                  return this._value;
                },
                set: function set(value) {
                  this._value = value;

                  for (var _iterator = _createForOfIteratorHelperLoose(this._refs), _step; !(_step = _iterator()).done;) {
                    var _step$value = _step.value,
                        fn = _step$value.fn,
                        thisArg = _step$value.thisArg,
                        args = _step$value.args;
                    fn.call.apply(fn, [thisArg, value].concat(args));
                  }
                }
              }]);

              return VarInstance;
            }();

            var InvalidTransitionError = function (_Error) {
              _inheritsLoose(InvalidTransitionError, _Error);

              function InvalidTransitionError(type) {
                var _this;

                _this = _Error.call(this, type + " transition is invalid") || this;
                _this.name = 'TransitionRejectError';
                return _this;
              }

              return InvalidTransitionError;
            }(_wrapNativeSuper(Error));
            var VariableNotDefinedError = function (_Error2) {
              _inheritsLoose(VariableNotDefinedError, _Error2);

              function VariableNotDefinedError(name) {
                return _Error2.call(this, "Graph variable " + name + " is not defined") || this;
              }

              return VariableNotDefinedError;
            }(_wrapNativeSuper(Error));
            var VariableTypeMismatchedError = function (_Error3) {
              _inheritsLoose(VariableTypeMismatchedError, _Error3);

              function VariableTypeMismatchedError(name, expected, received) {
                return _Error3.call(this, "Expect graph variable " + name + " to have type '" + expected + "' instead of received '" + (received !== null && received !== void 0 ? received : typeof received) + "'") || this;
              }

              return VariableTypeMismatchedError;
            }(_wrapNativeSuper(Error));

            var createEval = Symbol('[[createEval]]');

            var Destroyed = CCObject.Flags.Destroyed;
            var PersistentMask = CCObject.Flags.PersistentMask;
            var objsToClearTmpVar = [];
            function instantiate(original, internalForce) {

              var clone;

              if (isCCObject(original)) {
                if (original._instantiate) {
                  legacyCC.game._isCloning = true;
                  clone = original._instantiate(null, true);
                  legacyCC.game._isCloning = false;

                  return clone;
                } else if (original instanceof legacyCC.Asset) {
                  throw new TypeError(getError(6903));
                }
              }

              legacyCC.game._isCloning = true;
              clone = doInstantiate(original);
              legacyCC.game._isCloning = false;

              return clone;
            }

            function doInstantiate(obj, parent) {

              var clone;

              if (obj._iN$t) {
                clone = obj._iN$t;
              } else if (obj.constructor) {
                var Klass = obj.constructor;
                clone = new Klass();
              } else {
                clone = Object.create(null);
              }

              enumerateObject(obj, clone, parent);

              for (var i = 0, len = objsToClearTmpVar.length; i < len; ++i) {
                objsToClearTmpVar[i]._iN$t = null;
              }

              objsToClearTmpVar.length = 0;
              return clone;
            }

            function enumerateCCClass(klass, obj, clone, parent) {
              var props = klass.__values__;

              for (var p = 0; p < props.length; p++) {
                var key = props[p];
                var value = obj[key];

                if (typeof value === 'object' && value) {
                  var initValue = clone[key];

                  if (initValue instanceof ValueType && initValue.constructor === value.constructor) {
                    initValue.set(value);
                  } else {
                    clone[key] = value._iN$t || instantiateObj(value, parent);
                  }
                } else {
                  clone[key] = value;
                }
              }
            }

            function enumerateObject(obj, clone, parent) {
              value(obj, '_iN$t', clone, true);
              objsToClearTmpVar.push(obj);
              var klass = obj.constructor;

              if (isCCClassOrFastDefined(klass)) {
                enumerateCCClass(klass, obj, clone, parent);
              } else {
                for (var key in obj) {
                  if (!obj.hasOwnProperty(key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && key !== '__type__' && key !== '__prefab') {
                    continue;
                  }

                  var value$1 = obj[key];

                  if (typeof value$1 === 'object' && value$1) {
                    if (value$1 === clone) {
                      continue;
                    }

                    clone[key] = value$1._iN$t || instantiateObj(value$1, parent);
                  } else {
                    clone[key] = value$1;
                  }
                }
              }

              if (isCCObject(obj)) {
                clone._objFlags &= PersistentMask;
              }
            }

            function instantiateObj(obj, parent) {
              if (obj instanceof ValueType) {
                return obj.clone();
              }

              if (obj instanceof legacyCC.Asset) {
                return obj;
              }

              var clone;

              if (ArrayBuffer.isView(obj)) {
                var len = obj.length;
                clone = new obj.constructor(len);
                obj._iN$t = clone;
                objsToClearTmpVar.push(obj);

                for (var i = 0; i < len; ++i) {
                  clone[i] = obj[i];
                }

                return clone;
              }

              if (Array.isArray(obj)) {
                var _len = obj.length;
                clone = new Array(_len);
                obj._iN$t = clone;
                objsToClearTmpVar.push(obj);

                for (var _i = 0; _i < _len; ++_i) {
                  var value = obj[_i];

                  if (typeof value === 'object' && value) {
                    clone[_i] = value._iN$t || instantiateObj(value, parent);
                  } else {
                    clone[_i] = value;
                  }
                }

                return clone;
              } else if (obj._objFlags & Destroyed) {
                return null;
              }

              var ctor = obj.constructor;

              if (isCCClassOrFastDefined(ctor)) {
                if (parent) {
                  if (parent instanceof legacyCC.Component) {
                    if (obj instanceof legacyCC.Node || obj instanceof legacyCC.Component) {
                      return obj;
                    }
                  } else if (parent instanceof legacyCC.Node) {
                    if (obj instanceof legacyCC.Node) {
                      if (!obj.isChildOf(parent)) {
                        return obj;
                      }
                    } else if (obj instanceof legacyCC.Component) {
                      if (obj.node && !obj.node.isChildOf(parent)) {
                        return obj;
                      }
                    }
                  }
                }

                clone = new ctor();
              } else if (ctor === Object) {
                clone = {};
              } else if (!ctor) {
                clone = Object.create(null);
              } else {
                return obj;
              }

              enumerateObject(obj, clone, parent);
              return clone;
            }

            instantiate._clone = doInstantiate;
            legacyCC.instantiate = instantiate;

            function cloneAnimationGraphEditorExtrasFrom(object) {
              var editorExtras = object[editorExtrasTag];

              if (typeof editorExtras === 'object' && editorExtras) {
                var _maybeCloneableEditor;

                var maybeCloneableEditorExtras = editorExtras;
                return (_maybeCloneableEditor = maybeCloneableEditorExtras.clone) === null || _maybeCloneableEditor === void 0 ? void 0 : _maybeCloneableEditor.call(maybeCloneableEditorExtras, object);
              }

              return undefined;
            }

            var _dec$M, _class$M, _class2$E, _initializer$C, _dec2$x, _class4$7, _class5$7, _initializer2$u;
            var outgoingsSymbol = Symbol('[[Outgoing transitions]]');
            var incomingsSymbol = Symbol('[[Incoming transitions]]');
            var ccclass$4 = ccclass$p,
                serializable$4 = serializable$j;
            var State = (_dec$M = ccclass$4('cc.animation.State'), _dec$M(_class$M = (_class2$E = function (_EditorExtendable) {
              _inheritsLoose(State, _EditorExtendable);

              function State() {
                var _this;

                _this = _EditorExtendable.call(this) || this;
                _this.name = _initializer$C && _initializer$C();
                _this[outgoingsSymbol] = [];
                _this[incomingsSymbol] = [];
                return _this;
              }

              var _proto = State.prototype;

              _proto.copyTo = function copyTo(that) {
                that.name = this.name;
                that[editorExtrasTag] = cloneAnimationGraphEditorExtrasFrom(this);
              };

              return State;
            }(EditorExtendable), (_initializer$C = applyDecoratedInitializer(_class2$E.prototype, "name", [serializable$4], function () {
              return '';
            })), _class2$E)) || _class$M);
            var InteractiveState = (_dec2$x = ccclass$4(CLASS_NAME_PREFIX_ANIM + "InteractiveState"), _dec2$x(_class4$7 = (_class5$7 = function (_State) {
              _inheritsLoose(InteractiveState, _State);

              function InteractiveState() {
                var _this2;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this2 = _State.call.apply(_State, [this].concat(args)) || this;
                _this2._components = _initializer2$u && _initializer2$u();
                return _this2;
              }

              var _proto2 = InteractiveState.prototype;

              _proto2.addComponent = function addComponent(constructor) {
                var component = new constructor();

                this._components.push(component);

                return component;
              };

              _proto2.removeComponent = function removeComponent(component) {
                remove(this._components, component);
              };

              _proto2.instantiateComponents = function instantiateComponents() {
                var instantiatedComponents = this._components.map(function (component) {
                  var instantiated = instantiate(component);
                  return instantiated;
                });

                return instantiatedComponents;
              };

              _proto2.copyTo = function copyTo(that) {
                _State.prototype.copyTo.call(this, that);

                that._components = this.instantiateComponents();
              };

              _createClass(InteractiveState, [{
                key: "components",
                get: function get() {
                  return this._components;
                }
              }]);

              return InteractiveState;
            }(State), (_initializer2$u = applyDecoratedInitializer(_class5$7.prototype, "_components", [serializable$4], function () {
              return [];
            })), _class5$7)) || _class4$7);

            var _dec$N, _class$N, _class2$F, _initializer$D, _initializer2$v, _initializer3$l, _initializer4$j;
            var MotionState = (_dec$N = ccclass$p('cc.animation.Motion'), _dec$N(_class$N = (_class2$F = function (_InteractiveState) {
              _inheritsLoose(MotionState, _InteractiveState);

              function MotionState() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _InteractiveState.call.apply(_InteractiveState, [this].concat(args)) || this;
                _this.motion = _initializer$D && _initializer$D();
                _this.speed = _initializer2$v && _initializer2$v();
                _this.speedMultiplier = _initializer3$l && _initializer3$l();
                _this.speedMultiplierEnabled = _initializer4$j && _initializer4$j();
                return _this;
              }

              var _proto = MotionState.prototype;

              _proto.copyTo = function copyTo(that) {
                var _this$motion$clone, _this$motion;

                _InteractiveState.prototype.copyTo.call(this, that);

                that.motion = (_this$motion$clone = (_this$motion = this.motion) === null || _this$motion === void 0 ? void 0 : _this$motion.clone()) !== null && _this$motion$clone !== void 0 ? _this$motion$clone : null;
                that.speed = this.speed;
                that.speedMultiplier = this.speedMultiplier;
                that.speedMultiplierEnabled = this.speedMultiplierEnabled;
                return this;
              };

              _proto._clone = function _clone() {
                var that = new MotionState();
                this.copyTo(that);
                return that;
              };

              return MotionState;
            }(InteractiveState), (_initializer$D = applyDecoratedInitializer(_class2$F.prototype, "motion", [serializable$j], function () {
              return null;
            }), _initializer2$v = applyDecoratedInitializer(_class2$F.prototype, "speed", [serializable$j], function () {
              return 1.0;
            }), _initializer3$l = applyDecoratedInitializer(_class2$F.prototype, "speedMultiplier", [serializable$j], function () {
              return '';
            }), _initializer4$j = applyDecoratedInitializer(_class2$F.prototype, "speedMultiplierEnabled", [serializable$j], function () {
              return false;
            })), _class2$F)) || _class$N);

            var onAfterDeserializedTag = Symbol('[[OnAfterDeserialized]]');

            var _dec$O, _class$O;
            var AnimationGraphLike = (_dec$O = ccclass$p(CLASS_NAME_PREFIX_ANIM + "AnimationGraphLike"), _dec$O(_class$O = function (_Asset) {
              _inheritsLoose(AnimationGraphLike, _Asset);

              function AnimationGraphLike() {
                return _Asset.apply(this, arguments) || this;
              }

              return AnimationGraphLike;
            }(Asset)) || _class$O);

            var _dec$P, _class$P, _class2$G, _initializer$E, _initializer2$w, _initializer3$m, _dec2$y, _class4$8, _class5$8, _initializer4$k, _initializer5$g, _initializer6$d, _initializer7$9, _initializer8$9, _initializer9$8, _initializer10$7, _dec3$o, _class7$2, _dec4$f, _class8$1, _class9, _initializer11$4, _initializer12$4, _initializer13$4, _dec5$b, _class11$1, _class12, _initializer14$3, _initializer15$3, _initializer16$3, _initializer17$3, _initializer18$2, _dec6$a, _class14$1, _class15, _initializer19$2, _dec7$9, _class17, _class18, _initializer20$1, _initializer21, _initializer22, _initializer23, _dec8$6, _class20, _class21, _initializer24, _initializer25, _dec9$5, _class23, _class24, _initializer26, _dec10$2, _class26, _class27, _initializer27, _initializer28;
            var Transition = (_dec$P = ccclass$p(CLASS_NAME_PREFIX_ANIM + "Transition"), _dec$P(_class$P = (_class2$G = function (_EditorExtendable) {
              _inheritsLoose(Transition, _EditorExtendable);

              function Transition(from, to, conditions) {
                var _this;

                _this = _EditorExtendable.call(this) || this;
                _this.from = _initializer$E && _initializer$E();
                _this.to = _initializer2$w && _initializer2$w();
                _this.conditions = _initializer3$m && _initializer3$m();
                _this[ownerSymbol] = void 0;
                _this.from = from;
                _this.to = to;

                if (conditions) {
                  _this.conditions = conditions;
                }

                return _this;
              }

              var _proto = Transition.prototype;

              _proto.copyTo = function copyTo(that) {
                that.conditions = this.conditions.map(function (condition) {
                  return condition.clone();
                });
              };

              return Transition;
            }(EditorExtendable), (_initializer$E = applyDecoratedInitializer(_class2$G.prototype, "from", [serializable$j], null), _initializer2$w = applyDecoratedInitializer(_class2$G.prototype, "to", [serializable$j], null), _initializer3$m = applyDecoratedInitializer(_class2$G.prototype, "conditions", [serializable$j], function () {
              return [];
            })), _class2$G)) || _class$P);
            var TransitionInterruptionSource;

            (function (TransitionInterruptionSource) {
              TransitionInterruptionSource[TransitionInterruptionSource["NONE"] = 0] = "NONE";
              TransitionInterruptionSource[TransitionInterruptionSource["CURRENT_STATE"] = 1] = "CURRENT_STATE";
              TransitionInterruptionSource[TransitionInterruptionSource["NEXT_STATE"] = 2] = "NEXT_STATE";
              TransitionInterruptionSource[TransitionInterruptionSource["CURRENT_STATE_THEN_NEXT_STATE"] = 3] = "CURRENT_STATE_THEN_NEXT_STATE";
              TransitionInterruptionSource[TransitionInterruptionSource["NEXT_STATE_THEN_CURRENT_STATE"] = 4] = "NEXT_STATE_THEN_CURRENT_STATE";
            })(TransitionInterruptionSource || (TransitionInterruptionSource = {}));

            var AnimationTransition = (_dec2$y = ccclass$p(CLASS_NAME_PREFIX_ANIM + "AnimationTransition"), _dec2$y(_class4$8 = (_class5$8 = function (_Transition) {
              _inheritsLoose(AnimationTransition, _Transition);

              function AnimationTransition() {
                var _this2;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this2 = _Transition.call.apply(_Transition, [this].concat(args)) || this;
                _this2.duration = _initializer4$k && _initializer4$k();
                _this2.relativeDuration = _initializer5$g && _initializer5$g();
                _this2.exitConditionEnabled = _initializer6$d && _initializer6$d();
                _this2.destinationStart = _initializer7$9 && _initializer7$9();
                _this2.relativeDestinationStart = _initializer8$9 && _initializer8$9();
                _this2.interruptionSource = _initializer9$8 && _initializer9$8();
                _this2._exitCondition = _initializer10$7 && _initializer10$7();
                return _this2;
              }

              var _proto2 = AnimationTransition.prototype;

              _proto2.copyTo = function copyTo(that) {
                _Transition.prototype.copyTo.call(this, that);

                that.duration = this.duration;
                that.relativeDuration = this.relativeDuration;
                that.exitConditionEnabled = this.exitConditionEnabled;
                that.exitCondition = this.exitCondition;
                that.destinationStart = this.destinationStart;
                that.relativeDestinationStart = this.relativeDestinationStart;
                that.interruptible = this.interruptible;
              };

              _createClass(AnimationTransition, [{
                key: "exitCondition",
                get: function get() {
                  return this._exitCondition;
                },
                set: function set(value) {
                  assertIsTrue(value >= 0.0);
                  this._exitCondition = value;
                }
              }, {
                key: "interruptible",
                get: function get() {
                  return this.interruptionSource !== TransitionInterruptionSource.NONE;
                },
                set: function set(value) {
                  this.interruptionSource = value ? TransitionInterruptionSource.CURRENT_STATE_THEN_NEXT_STATE : TransitionInterruptionSource.NONE;
                }
              }]);

              return AnimationTransition;
            }(Transition), (_initializer4$k = applyDecoratedInitializer(_class5$8.prototype, "duration", [serializable$j], function () {
              return 0.3;
            }), _initializer5$g = applyDecoratedInitializer(_class5$8.prototype, "relativeDuration", [serializable$j], function () {
              return false;
            }), _initializer6$d = applyDecoratedInitializer(_class5$8.prototype, "exitConditionEnabled", [serializable$j], function () {
              return true;
            }), _initializer7$9 = applyDecoratedInitializer(_class5$8.prototype, "destinationStart", [serializable$j], function () {
              return 0.0;
            }), _initializer8$9 = applyDecoratedInitializer(_class5$8.prototype, "relativeDestinationStart", [serializable$j], function () {
              return false;
            }), _initializer9$8 = applyDecoratedInitializer(_class5$8.prototype, "interruptionSource", [serializable$j], function () {
              return TransitionInterruptionSource.NONE;
            }), _initializer10$7 = applyDecoratedInitializer(_class5$8.prototype, "_exitCondition", [serializable$j], function () {
              return 1.0;
            })), _class5$8)) || _class4$8);
            function isAnimationTransition(transition) {
              return transition instanceof AnimationTransition;
            }
            var EmptyState = (_dec3$o = ccclass$p(CLASS_NAME_PREFIX_ANIM + "EmptyState"), _dec3$o(_class7$2 = function (_State) {
              _inheritsLoose(EmptyState, _State);

              function EmptyState() {
                return _State.apply(this, arguments) || this;
              }

              var _proto3 = EmptyState.prototype;

              _proto3._clone = function _clone() {
                var that = new EmptyState();
                this.copyTo(that);
                return that;
              };

              return EmptyState;
            }(State)) || _class7$2);
            var EmptyStateTransition = (_dec4$f = ccclass$p(CLASS_NAME_PREFIX_ANIM + "EmptyStateTransition"), _dec4$f(_class8$1 = (_class9 = function (_Transition2) {
              _inheritsLoose(EmptyStateTransition, _Transition2);

              function EmptyStateTransition() {
                var _this3;

                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args[_key3] = arguments[_key3];
                }

                _this3 = _Transition2.call.apply(_Transition2, [this].concat(args)) || this;
                _this3.duration = _initializer11$4 && _initializer11$4();
                _this3.destinationStart = _initializer12$4 && _initializer12$4();
                _this3.relativeDestinationStart = _initializer13$4 && _initializer13$4();
                return _this3;
              }

              var _proto4 = EmptyStateTransition.prototype;

              _proto4.copyTo = function copyTo(that) {
                _Transition2.prototype.copyTo.call(this, that);

                that.duration = this.duration;
                that.destinationStart = this.destinationStart;
                that.relativeDestinationStart = this.relativeDestinationStart;
              };

              return EmptyStateTransition;
            }(Transition), (_initializer11$4 = applyDecoratedInitializer(_class9.prototype, "duration", [serializable$j], function () {
              return 0.3;
            }), _initializer12$4 = applyDecoratedInitializer(_class9.prototype, "destinationStart", [serializable$j], function () {
              return 0.0;
            }), _initializer13$4 = applyDecoratedInitializer(_class9.prototype, "relativeDestinationStart", [serializable$j], function () {
              return false;
            })), _class9)) || _class8$1);
            var StateMachine = (_dec5$b = ccclass$p('cc.animation.StateMachine'), _dec5$b(_class11$1 = (_class12 = function (_EditorExtendable2) {
              _inheritsLoose(StateMachine, _EditorExtendable2);

              var _proto5 = StateMachine.prototype;

              _proto5.__callOnAfterDeserializeRecursive = function __callOnAfterDeserializeRecursive() {
                this[onAfterDeserializedTag]();
                var nStates = this._states.length;

                for (var iState = 0; iState < nStates; ++iState) {
                  var state = this._states[iState];

                  if (state instanceof SubStateMachine) {
                    state.stateMachine.__callOnAfterDeserializeRecursive();
                  }
                }
              };

              function StateMachine() {
                var _this4;

                _this4 = _EditorExtendable2.call(this) || this;
                _this4._states = _initializer14$3 && _initializer14$3();
                _this4._transitions = _initializer15$3 && _initializer15$3();
                _this4._entryState = _initializer16$3 && _initializer16$3();
                _this4._exitState = _initializer17$3 && _initializer17$3();
                _this4._anyState = _initializer18$2 && _initializer18$2();
                _this4._entryState = _this4._addState(new State());
                _this4._entryState.name = 'Entry';
                _this4._exitState = _this4._addState(new State());
                _this4._exitState.name = 'Exit';
                _this4._anyState = _this4._addState(new State());
                _this4._anyState.name = 'Any';
                return _this4;
              }

              _proto5[onAfterDeserializedTag] = function () {
                var _this5 = this;

                this._states.forEach(function (state) {
                  return own(state, _this5);
                });

                this._transitions.forEach(function (transition) {
                  transition.from[outgoingsSymbol].push(transition);
                  transition.to[incomingsSymbol].push(transition);
                });
              };

              _proto5[createEval] = function (context) {
                throw new Error('Method not implemented.');
              };

              _proto5.states = function states() {
                return this._states;
              };

              _proto5.transitions = function transitions() {
                return this._transitions;
              };

              _proto5.getTransitionsBetween = function getTransitionsBetween(from, to) {
                assertsOwnedBy(from, this);
                assertsOwnedBy(to, this);
                return from[outgoingsSymbol].filter(function (transition) {
                  return transition.to === to;
                });
              };

              _proto5.getOutgoings = function getOutgoings(from) {
                assertsOwnedBy(from, this);
                return from[outgoingsSymbol];
              };

              _proto5.getIncomings = function getIncomings(to) {
                assertsOwnedBy(to, this);
                return to[incomingsSymbol];
              };

              _proto5.addMotion = function addMotion() {
                return this._addState(new MotionState());
              };

              _proto5.addSubStateMachine = function addSubStateMachine() {
                return this._addState(new SubStateMachine());
              };

              _proto5.addEmpty = function addEmpty() {
                return this._addState(new EmptyState());
              };

              _proto5.remove = function remove$1(state) {
                assertsOwnedBy(state, this);

                if (state === this.entryState || state === this.exitState || state === this.anyState) {
                  return;
                }

                this.eraseTransitionsIncludes(state);
                remove(this._states, state);
                markAsDangling(state);
              };

              _proto5.connect = function connect(from, to, conditions) {
                assertsOwnedBy(from, this);
                assertsOwnedBy(to, this);

                if (to === this.entryState) {
                  throw new InvalidTransitionError('to-entry');
                }

                if (to === this.anyState) {
                  throw new InvalidTransitionError('to-any');
                }

                if (from === this.exitState) {
                  throw new InvalidTransitionError('from-exit');
                }

                var transition = from instanceof MotionState || from === this._anyState ? new AnimationTransition(from, to, conditions) : from instanceof EmptyState ? new EmptyStateTransition(from, to, conditions) : new Transition(from, to, conditions);
                own(transition, this);

                this._transitions.push(transition);

                from[outgoingsSymbol].push(transition);
                to[incomingsSymbol].push(transition);
                return transition;
              };

              _proto5.disconnect = function disconnect(from, to) {
                assertsOwnedBy(from, this);
                assertsOwnedBy(to, this);
                var oTransitions = from[outgoingsSymbol];
                var iTransitions = to[incomingsSymbol];
                var transitions = this._transitions;
                var oTransitionsToRemove = oTransitions.filter(function (oTransition) {
                  return oTransition.to === to;
                });
                var nOTransitionToRemove = oTransitionsToRemove.length;

                var _loop = function _loop(iOTransitionToRemove) {
                  var oTransition = oTransitionsToRemove[iOTransitionToRemove];
                  remove(oTransitions, oTransition);
                  assertIsTrue(remove(transitions, oTransition));
                  assertIsNonNullable(removeIf(iTransitions, function (transition) {
                    return transition === oTransition;
                  }));
                  markAsDangling(oTransition);
                };

                for (var iOTransitionToRemove = 0; iOTransitionToRemove < nOTransitionToRemove; ++iOTransitionToRemove) {
                  _loop(iOTransitionToRemove);
                }
              };

              _proto5.removeTransition = function removeTransition(removal) {
                assertIsTrue(remove(this._transitions, removal));
                assertIsNonNullable(removeIf(removal.from[outgoingsSymbol], function (transition) {
                  return transition === removal;
                }));
                assertIsNonNullable(removeIf(removal.to[incomingsSymbol], function (transition) {
                  return transition === removal;
                }));
                markAsDangling(removal);
              };

              _proto5.eraseOutgoings = function eraseOutgoings(from) {
                var _this6 = this;

                assertsOwnedBy(from, this);
                var oTransitions = from[outgoingsSymbol];

                var _loop2 = function _loop2(iOTransition) {
                  var oTransition = oTransitions[iOTransition];
                  var to = oTransition.to;
                  assertIsTrue(remove(_this6._transitions, oTransition));
                  assertIsNonNullable(removeIf(to[incomingsSymbol], function (transition) {
                    return transition === oTransition;
                  }));
                  markAsDangling(oTransition);
                };

                for (var iOTransition = 0; iOTransition < oTransitions.length; ++iOTransition) {
                  _loop2(iOTransition);
                }

                oTransitions.length = 0;
              };

              _proto5.eraseIncomings = function eraseIncomings(to) {
                var _this7 = this;

                assertsOwnedBy(to, this);
                var iTransitions = to[incomingsSymbol];

                var _loop3 = function _loop3(iITransition) {
                  var iTransition = iTransitions[iITransition];
                  var from = iTransition.from;
                  assertIsTrue(remove(_this7._transitions, iTransition));
                  assertIsNonNullable(removeIf(from[outgoingsSymbol], function (transition) {
                    return transition === iTransition;
                  }));
                  markAsDangling(iTransition);
                };

                for (var iITransition = 0; iITransition < iTransitions.length; ++iITransition) {
                  _loop3(iITransition);
                }

                iTransitions.length = 0;
              };

              _proto5.eraseTransitionsIncludes = function eraseTransitionsIncludes(state) {
                this.eraseIncomings(state);
                this.eraseOutgoings(state);
              };

              _proto5.adjustTransitionPriority = function adjustTransitionPriority(adjusting, diff) {
                var from = adjusting.from;

                if (diff === 0) {
                  return;
                }

                var outgoings = from[outgoingsSymbol];
                var iAdjusting = outgoings.indexOf(adjusting);
                assertIsTrue(iAdjusting >= 0);
                var iNew = clamp$1(iAdjusting + diff, 0, outgoings.length - 1);
                {
                  var globalTransitions = this._transitions;
                  var adjustingIndexInGlobal = globalTransitions.indexOf(adjusting);
                  assertIsTrue(adjustingIndexInGlobal >= 0);
                  var lastPlaceholder = adjustingIndexInGlobal;

                  if (iNew > iAdjusting) {
                    for (var iOutgoing = iAdjusting + 1; iOutgoing <= iNew; ++iOutgoing) {
                      var outgoing = outgoings[iOutgoing];
                      var indexInGlobal = globalTransitions.indexOf(outgoing);
                      assertIsTrue(indexInGlobal >= 0);
                      globalTransitions[lastPlaceholder] = outgoing;
                      lastPlaceholder = indexInGlobal;
                    }
                  } else if (iAdjusting > iNew) {
                    for (var _iOutgoing = iAdjusting - 1; _iOutgoing >= iNew; --_iOutgoing) {
                      var _outgoing = outgoings[_iOutgoing];

                      var _indexInGlobal = globalTransitions.indexOf(_outgoing);

                      assertIsTrue(_indexInGlobal >= 0);
                      globalTransitions[lastPlaceholder] = _outgoing;
                      lastPlaceholder = _indexInGlobal;
                    }
                  }

                  globalTransitions[lastPlaceholder] = adjusting;
                }
                {
                  shift(outgoings, iAdjusting, iNew);
                }
              };

              _proto5.copyTo = function copyTo(that) {
                var thatStatesOld = that._states.filter(function (state) {
                  switch (state) {
                    case that._entryState:
                    case that._exitState:
                    case that._anyState:
                      return true;

                    default:
                      return false;
                  }
                });

                for (var _iterator = _createForOfIteratorHelperLoose(thatStatesOld), _step; !(_step = _iterator()).done;) {
                  var thatStateOld = _step.value;
                  that.remove(thatStateOld);
                }

                var stateMap = new Map();

                for (var _iterator2 = _createForOfIteratorHelperLoose(this._states), _step2; !(_step2 = _iterator2()).done;) {
                  var state = _step2.value;

                  switch (state) {
                    case this._entryState:
                      stateMap.set(state, that._entryState);
                      break;

                    case this._exitState:
                      stateMap.set(state, that._exitState);
                      break;

                    case this._anyState:
                      stateMap.set(state, that._anyState);
                      break;

                    default:
                      if (state instanceof MotionState || state instanceof SubStateMachine || state instanceof EmptyState) {
                        var thatState = state._clone();

                        that._addState(thatState);

                        stateMap.set(state, thatState);
                      } else {
                        assertIsTrue(false);
                      }

                      break;
                  }
                }

                for (var _iterator3 = _createForOfIteratorHelperLoose(this._transitions), _step3; !(_step3 = _iterator3()).done;) {
                  var transition = _step3.value;
                  var thatFrom = stateMap.get(transition.from);
                  var thatTo = stateMap.get(transition.to);
                  assertIsTrue(thatFrom && thatTo);
                  var thatTransition = that.connect(thatFrom, thatTo);
                  thatTransition.conditions = transition.conditions.map(function (condition) {
                    return condition.clone();
                  });

                  if (thatTransition instanceof AnimationTransition) {
                    assertIsTrue(transition instanceof AnimationTransition);
                    transition.copyTo(thatTransition);
                  } else if (thatTransition instanceof EmptyStateTransition) {
                    assertIsTrue(transition instanceof EmptyStateTransition);
                    transition.copyTo(thatTransition);
                  } else {
                    transition.copyTo(thatTransition);
                  }
                }
              };

              _proto5.clone = function clone() {
                var that = new StateMachine();
                this.copyTo(that);
                return that;
              };

              _proto5._addState = function _addState(state) {
                own(state, this);

                this._states.push(state);

                return state;
              };

              _createClass(StateMachine, [{
                key: "entryState",
                get: function get() {
                  return this._entryState;
                }
              }, {
                key: "exitState",
                get: function get() {
                  return this._exitState;
                }
              }, {
                key: "anyState",
                get: function get() {
                  return this._anyState;
                }
              }]);

              return StateMachine;
            }(EditorExtendable), (_initializer14$3 = applyDecoratedInitializer(_class12.prototype, "_states", [serializable$j], function () {
              return [];
            }), _initializer15$3 = applyDecoratedInitializer(_class12.prototype, "_transitions", [serializable$j], function () {
              return [];
            }), _initializer16$3 = applyDecoratedInitializer(_class12.prototype, "_entryState", [serializable$j], null), _initializer17$3 = applyDecoratedInitializer(_class12.prototype, "_exitState", [serializable$j], null), _initializer18$2 = applyDecoratedInitializer(_class12.prototype, "_anyState", [serializable$j], null)), _class12)) || _class11$1);
            var SubStateMachine = (_dec6$a = ccclass$p('cc.animation.SubStateMachine'), _dec6$a(_class14$1 = (_class15 = function (_InteractiveState) {
              _inheritsLoose(SubStateMachine, _InteractiveState);

              function SubStateMachine() {
                var _this8;

                for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                  args[_key5] = arguments[_key5];
                }

                _this8 = _InteractiveState.call.apply(_InteractiveState, [this].concat(args)) || this;
                _this8._stateMachine = _initializer19$2 && _initializer19$2();
                return _this8;
              }

              var _proto6 = SubStateMachine.prototype;

              _proto6.copyTo = function copyTo(that) {
                _InteractiveState.prototype.copyTo.call(this, that);

                this._stateMachine.copyTo(that._stateMachine);
              };

              _proto6._clone = function _clone() {
                var that = new SubStateMachine();
                this.copyTo(that);
                return that;
              };

              _createClass(SubStateMachine, [{
                key: "stateMachine",
                get: function get() {
                  return this._stateMachine;
                }
              }]);

              return SubStateMachine;
            }(InteractiveState), (_initializer19$2 = applyDecoratedInitializer(_class15.prototype, "_stateMachine", [serializable$j], function () {
              return new StateMachine();
            })), _class15)) || _class14$1);
            var Layer = (_dec7$9 = ccclass$p('cc.animation.Layer'), _dec7$9(_class17 = (_class18 = function () {
              function Layer() {
                this[ownerSymbol] = void 0;
                this._stateMachine = _initializer20$1 && _initializer20$1();
                this.name = _initializer21 && _initializer21();
                this.weight = _initializer22 && _initializer22();
                this.mask = _initializer23 && _initializer23();
                this._stateMachine = new StateMachine();
              }

              _createClass(Layer, [{
                key: "stateMachine",
                get: function get() {
                  return this._stateMachine;
                }
              }]);

              return Layer;
            }(), (_initializer20$1 = applyDecoratedInitializer(_class18.prototype, "_stateMachine", [serializable$j], null), _initializer21 = applyDecoratedInitializer(_class18.prototype, "name", [serializable$j], function () {
              return '';
            }), _initializer22 = applyDecoratedInitializer(_class18.prototype, "weight", [serializable$j], function () {
              return 1.0;
            }), _initializer23 = applyDecoratedInitializer(_class18.prototype, "mask", [serializable$j], function () {
              return null;
            })), _class18)) || _class17);
            var LayerBlending;

            (function (LayerBlending) {
              LayerBlending[LayerBlending["override"] = 0] = "override";
              LayerBlending[LayerBlending["additive"] = 1] = "additive";
            })(LayerBlending || (LayerBlending = {}));

            var TRIGGER_VARIABLE_FLAG_VALUE_START = 0;
            var TRIGGER_VARIABLE_FLAG_VALUE_MASK = 1;
            var TRIGGER_VARIABLE_FLAG_RESET_MODE_START = 1;
            var TRIGGER_VARIABLE_FLAG_RESET_MODE_MASK = 6;
            var TRIGGER_VARIABLE_DEFAULT_FLAGS = 0;
            assertIsTrue((0 << TRIGGER_VARIABLE_FLAG_VALUE_START | TriggerResetMode.AFTER_CONSUMED << TRIGGER_VARIABLE_FLAG_RESET_MODE_START) === TRIGGER_VARIABLE_DEFAULT_FLAGS);
            var PlainVariable = (_dec8$6 = ccclass$p('cc.animation.PlainVariable'), _dec8$6(_class20 = (_class21 = function () {
              function PlainVariable(type) {
                this._type = _initializer24 && _initializer24();
                this._value = _initializer25 && _initializer25();

                if (typeof type === 'undefined') {
                  return;
                }

                this._type = type;

                switch (type) {
                  default:
                    break;

                  case VariableType.FLOAT:
                    this._value = 0;
                    break;

                  case VariableType.INTEGER:
                    this._value = 0.0;
                    break;

                  case VariableType.BOOLEAN:
                    this._value = false;
                    break;
                }
              }

              _createClass(PlainVariable, [{
                key: "type",
                get: function get() {
                  return this._type;
                }
              }, {
                key: "value",
                get: function get() {
                  return this._value;
                },
                set: function set(value) {
                  {
                    switch (this._type) {
                      default:
                        break;

                      case VariableType.FLOAT:
                        assertIsTrue(typeof value === 'number');
                        break;

                      case VariableType.INTEGER:
                        assertIsTrue(Number.isInteger(value));
                        break;

                      case VariableType.BOOLEAN:
                        assertIsTrue(typeof value === 'boolean');
                        break;
                    }
                  }

                  this._value = value;
                }
              }]);

              return PlainVariable;
            }(), (_initializer24 = applyDecoratedInitializer(_class21.prototype, "_type", [serializable$j], function () {
              return VariableType.FLOAT;
            }), _initializer25 = applyDecoratedInitializer(_class21.prototype, "_value", [serializable$j], function () {
              return 0.0;
            })), _class21)) || _class20);
            var TriggerVariable = (_dec9$5 = ccclass$p('cc.animation.TriggerVariable'), _dec9$5(_class23 = (_class24 = function () {
              function TriggerVariable() {
                this._flags = _initializer26 && _initializer26();
              }

              _createClass(TriggerVariable, [{
                key: "type",
                get: function get() {
                  return VariableType.TRIGGER;
                }
              }, {
                key: "value",
                get: function get() {
                  return !!((this._flags & TRIGGER_VARIABLE_FLAG_VALUE_MASK) >> TRIGGER_VARIABLE_FLAG_VALUE_START);
                },
                set: function set(value) {
                  if (value) {
                    this._flags |= 1 << TRIGGER_VARIABLE_FLAG_VALUE_START;
                  } else {
                    this._flags &= ~(1 << TRIGGER_VARIABLE_FLAG_VALUE_START);
                  }
                }
              }, {
                key: "resetMode",
                get: function get() {
                  return (this._flags & TRIGGER_VARIABLE_FLAG_RESET_MODE_MASK) >> TRIGGER_VARIABLE_FLAG_RESET_MODE_START;
                },
                set: function set(value) {
                  this._flags &= ~TRIGGER_VARIABLE_FLAG_RESET_MODE_MASK;
                  this._flags |= value << TRIGGER_VARIABLE_FLAG_RESET_MODE_START;
                }
              }]);

              return TriggerVariable;
            }(), (_initializer26 = applyDecoratedInitializer(_class24.prototype, "_flags", [serializable$j], function () {
              return TRIGGER_VARIABLE_DEFAULT_FLAGS;
            })), _class24)) || _class23);
            var AnimationGraph = (_dec10$2 = ccclass$p('cc.animation.AnimationGraph'), _dec10$2(_class26 = (_class27 = function (_AnimationGraphLike) {
              _inheritsLoose(AnimationGraph, _AnimationGraphLike);

              function AnimationGraph() {
                var _this9;

                _this9 = _AnimationGraphLike.call(this) || this;
                _this9._layers = _initializer27 && _initializer27();
                _this9._variables = _initializer28 && _initializer28();
                return _this9;
              }

              var _proto7 = AnimationGraph.prototype;

              _proto7.onLoaded = function onLoaded() {
                var layers = this._layers;
                var nLayers = layers.length;

                for (var iLayer = 0; iLayer < nLayers; ++iLayer) {
                  var layer = layers[iLayer];

                  layer.stateMachine.__callOnAfterDeserializeRecursive();
                }
              };

              _proto7.addLayer = function addLayer() {
                var layer = new Layer();

                this._layers.push(layer);

                return layer;
              };

              _proto7.removeLayer = function removeLayer(index) {
                removeAt(this._layers, index);
              };

              _proto7.moveLayer = function moveLayer(index, newIndex) {
                shift(this._layers, index, newIndex);
              };

              _proto7.addBoolean = function addBoolean(name, value) {
                if (value === void 0) {
                  value = false;
                }

                var variable = new PlainVariable(VariableType.BOOLEAN);
                variable.value = value;
                this._variables[name] = variable;
              };

              _proto7.addFloat = function addFloat(name, value) {
                if (value === void 0) {
                  value = 0.0;
                }

                var variable = new PlainVariable(VariableType.FLOAT);
                variable.value = value;
                this._variables[name] = variable;
              };

              _proto7.addInteger = function addInteger(name, value) {
                if (value === void 0) {
                  value = 0;
                }

                var variable = new PlainVariable(VariableType.INTEGER);
                variable.value = value;
                this._variables[name] = variable;
              };

              _proto7.addTrigger = function addTrigger(name, value, resetMode) {
                if (value === void 0) {
                  value = false;
                }

                if (resetMode === void 0) {
                  resetMode = TriggerResetMode.AFTER_CONSUMED;
                }

                var variable = new TriggerVariable();
                variable.resetMode = resetMode;
                variable.value = value;
                this._variables[name] = variable;
              };

              _proto7.removeVariable = function removeVariable(name) {
                delete this._variables[name];
              };

              _proto7.getVariable = function getVariable(name) {
                return this._variables[name];
              };

              _proto7.renameVariable = function renameVariable(name, newName) {
                var variables = this._variables;

                if (!(name in variables)) {
                  return;
                }

                if (newName in variables) {
                  return;
                }

                this._variables = Object.entries(variables).reduce(function (result, _ref) {
                  var k = _ref[0],
                      v = _ref[1];
                  result[k === name ? newName : k] = v;
                  return result;
                }, {});
              };

              _createClass(AnimationGraph, [{
                key: "layers",
                get: function get() {
                  return this._layers;
                }
              }, {
                key: "variables",
                get: function get() {
                  return Object.entries(this._variables);
                }
              }]);

              return AnimationGraph;
            }(AnimationGraphLike), (_initializer27 = applyDecoratedInitializer(_class27.prototype, "_layers", [serializable$j], function () {
              return [];
            }), _initializer28 = applyDecoratedInitializer(_class27.prototype, "_variables", [serializable$j], function () {
              return {};
            })), _class27)) || _class26);

            var RatioSampler = exports('RatioSampler', function () {
              function RatioSampler(ratios) {
                this.ratios = void 0;
                this._findRatio = void 0;
                this.ratios = ratios;
                var currRatioDif;
                var lastRatioDif;
                var canOptimize = true;
                var EPSILON = 1e-6;

                for (var i = 1, l = ratios.length; i < l; i++) {
                  currRatioDif = ratios[i] - ratios[i - 1];

                  if (i === 1) {
                    lastRatioDif = currRatioDif;
                  } else if (Math.abs(currRatioDif - lastRatioDif) > EPSILON) {
                    canOptimize = false;
                    break;
                  }
                }

                this._findRatio = canOptimize ? quickFindIndex : binarySearchEpsilon;
              }

              var _proto = RatioSampler.prototype;

              _proto.sample = function sample(ratio) {
                return this._findRatio(this.ratios, ratio);
              };

              return RatioSampler;
            }());
            legacyCC.RatioSampler = RatioSampler;
            var AnimCurve = exports('AnimCurve', function () {
              AnimCurve.Bezier = function Bezier(controlPoints) {
                return controlPoints;
              };

              function AnimCurve(propertyCurveData, duration) {
                this.types = undefined;
                this.type = null;
                this._values = [];
                this._lerp = undefined;
                this._duration = void 0;
                this._array = void 0;
                this._duration = duration;
                this._values = propertyCurveData.values;

                var getCurveType = function getCurveType(easingMethod) {
                  if (typeof easingMethod === 'string') {
                    return easingMethod;
                  } else if (Array.isArray(easingMethod)) {
                    if (easingMethod[0] === easingMethod[1] && easingMethod[2] === easingMethod[3]) {
                      return AnimCurve.Linear;
                    } else {
                      return AnimCurve.Bezier(easingMethod);
                    }
                  } else {
                    return AnimCurve.Linear;
                  }
                };

                if (propertyCurveData.easingMethod !== undefined) {
                  this.type = getCurveType(propertyCurveData.easingMethod);
                } else if (Array.isArray(propertyCurveData.easingMethods)) {
                  this.types = propertyCurveData.easingMethods.map(getCurveType);
                } else if (propertyCurveData.easingMethods !== undefined) {
                  this.types = new Array(this._values.length).fill(null);

                  for (var _i = 0, _Object$keys = Object.keys(propertyCurveData.easingMethods); _i < _Object$keys.length; _i++) {
                    var index = _Object$keys[_i];
                    this.types[index] = getCurveType(propertyCurveData.easingMethods[index]);
                  }
                } else {
                  this.type = null;
                }

                var firstValue = propertyCurveData.values[0];
                var interpolate = propertyCurveData.interpolate === undefined ? true : propertyCurveData.interpolate;

                if (interpolate) {
                  this._lerp = selectLerpFx(firstValue);
                }

                if (propertyCurveData._arrayLength !== undefined) {
                  this._array = new Array(propertyCurveData._arrayLength);
                }
              }

              var _proto2 = AnimCurve.prototype;

              _proto2.hasLerp = function hasLerp() {
                return !!this._lerp;
              };

              _proto2.valueAt = function valueAt(index) {
                if (this._array === undefined) {
                  var value = this._values[index];

                  if (value && value.getNoLerp) {
                    return value.getNoLerp();
                  } else {
                    return value;
                  }
                } else {
                  for (var i = 0; i < this._array.length; ++i) {
                    this._array[i] = this._values[this._array.length * index + i];
                  }

                  return this._array;
                }
              };

              _proto2.valueBetween = function valueBetween(ratio, from, fromRatio, to, toRatio) {
                if (this._lerp) {
                  var type = this.types ? this.types[from] : this.type;
                  var dRatio = toRatio - fromRatio;
                  var ratioBetweenFrames = (ratio - fromRatio) / dRatio;

                  if (type) {
                    ratioBetweenFrames = computeRatioByType(ratioBetweenFrames, type);
                  }

                  if (this._array === undefined) {
                    var fromVal = this._values[from];
                    var toVal = this._values[to];

                    var value = this._lerp(fromVal, toVal, ratioBetweenFrames, dRatio * this._duration);

                    return value;
                  } else {
                    for (var i = 0; i < this._array.length; ++i) {
                      var _fromVal = this._values[this._array.length * from + i];
                      var _toVal = this._values[this._array.length * to + i];
                      this._array[i] = this._lerp(_fromVal, _toVal, ratioBetweenFrames, dRatio * this._duration);
                    }

                    return this._array;
                  }
                } else if (this._array === undefined) {
                  return this.valueAt(from);
                } else {
                  for (var _i2 = 0; _i2 < this._array.length; ++_i2) {
                    this._array[_i2] = this._values[this._array.length * from + _i2];
                  }

                  return this._array;
                }
              };

              _proto2.empty = function empty() {
                return this._values.length === 0;
              };

              _proto2.constant = function constant() {
                return this._values.length === 1;
              };

              return AnimCurve;
            }());
            AnimCurve.Linear = null;
            legacyCC.AnimCurve = AnimCurve;
            var EventInfo = exports('EventInfo', function () {
              function EventInfo() {
                this.events = [];
              }

              var _proto3 = EventInfo.prototype;

              _proto3.add = function add(func, params) {
                this.events.push({
                  func: func || '',
                  params: params || []
                });
              };

              return EventInfo;
            }());
            function sampleAnimationCurve(curve, sampler, ratio) {
              var index = sampler.sample(ratio);

              if (index < 0) {
                index = ~index;

                if (index <= 0) {
                  index = 0;
                } else if (index >= sampler.ratios.length) {
                  index = sampler.ratios.length - 1;
                } else {
                  return curve.valueBetween(ratio, index - 1, sampler.ratios[index - 1], index, sampler.ratios[index]);
                }
              }

              return curve.valueAt(index);
            }
            legacyCC.sampleAnimationCurve = sampleAnimationCurve;
            function computeRatioByType(ratio, type) {
              if (typeof type === 'string') {
                var func = easing[type];

                if (func) {
                  ratio = func(ratio);
                } else {
                  errorID(3906, type);
                }
              } else if (Array.isArray(type)) {
                ratio = bezierByTime(type, ratio);
              }

              return ratio;
            }

            function quickFindIndex(ratios, ratio) {
              var length = ratios.length - 1;

              if (length === 0) {
                return 0;
              }

              var start = ratios[0];

              if (ratio < start) {
                return 0;
              }

              var end = ratios[length];

              if (ratio > end) {
                return length;
              }

              ratio = (ratio - start) / (end - start);
              var eachLength = 1 / length;
              var index = ratio / eachLength;
              var floorIndex = index | 0;
              var EPSILON = 1e-6;

              if (index - floorIndex < EPSILON) {
                return floorIndex;
              } else if (floorIndex + 1 - index < EPSILON) {
                return floorIndex + 1;
              }

              return ~(floorIndex + 1);
            }

            var selectLerpFx = function () {
              function makeValueTypeLerpFx(constructor) {
                var tempValue = new constructor();
                return function (from, to, ratio) {
                  constructor.lerp(tempValue, from, to, ratio);
                  return tempValue;
                };
              }

              function callLerpable(from, to, t, dt) {
                return from.lerp(to, t, dt);
              }

              function makeQuatSlerpFx() {
                var tempValue = new Quat();
                return function (from, to, t, dt) {
                  return Quat.slerp(tempValue, from, to, t);
                };
              }

              return function (value) {
                if (value === null) {
                  return undefined;
                }

                if (typeof value === 'number') {
                  return lerp;
                } else if (typeof value === 'object' && value.constructor) {
                  if (value instanceof Quat) {
                    return makeQuatSlerpFx();
                  } else if (value instanceof ValueType) {
                    return makeValueTypeLerpFx(value.constructor);
                  } else if (value.constructor === Number) {
                    return lerp;
                  } else if (isLerpable(value)) {
                    return callLerpable;
                  }
                }

                return undefined;
              };
            }();

            var _dec$Q, _class$Q, _class2$H, _initializer$F, _dec2$z, _class4$9, _class5$9, _initializer2$x;
            var UntypedTrackChannel = (_dec$Q = ccclass$p(CLASS_NAME_PREFIX_ANIM + "UntypedTrackChannel"), _dec$Q(_class$Q = (_class2$H = function (_Channel) {
              _inheritsLoose(UntypedTrackChannel, _Channel);

              function UntypedTrackChannel() {
                var _this;

                _this = _Channel.call(this, new RealCurve()) || this;
                _this.property = _initializer$F && _initializer$F();
                return _this;
              }

              return UntypedTrackChannel;
            }(Channel), (_initializer$F = applyDecoratedInitializer(_class2$H.prototype, "property", [serializable$j], function () {
              return '';
            })), _class2$H)) || _class$Q);
            var UntypedTrack = (_dec2$z = ccclass$p(CLASS_NAME_PREFIX_ANIM + "UntypedTrack"), _dec2$z(_class4$9 = (_class5$9 = function (_Track) {
              _inheritsLoose(UntypedTrack, _Track);

              function UntypedTrack() {
                var _this2;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this2 = _Track.call.apply(_Track, [this].concat(args)) || this;
                _this2._channels = _initializer2$x && _initializer2$x();
                return _this2;
              }

              var _proto = UntypedTrack.prototype;

              _proto.channels = function channels() {
                return this._channels;
              };

              _proto[createEvalSymbol] = function (runtimeBinding) {
                var _this3 = this;

                if (!runtimeBinding.getValue) {
                  throw new Error(getError(3930));
                }

                var trySearchCurve = function trySearchCurve(property) {
                  var _this3$_channels$find;

                  return (_this3$_channels$find = _this3._channels.find(function (channel) {
                    return channel.property === property;
                  })) === null || _this3$_channels$find === void 0 ? void 0 : _this3$_channels$find.curve;
                };

                var value = runtimeBinding.getValue();

                switch (true) {
                  default:
                    throw new Error(getError(3931));

                  case value instanceof Vec2:
                    return new Vec2TrackEval(trySearchCurve('x'), trySearchCurve('y'));

                  case value instanceof Vec3:
                    return new Vec3TrackEval(trySearchCurve('x'), trySearchCurve('y'), trySearchCurve('z'));

                  case value instanceof Vec4:
                    return new Vec4TrackEval(trySearchCurve('x'), trySearchCurve('y'), trySearchCurve('z'), trySearchCurve('w'));

                  case value instanceof Color$1:
                    return new ColorTrackEval(trySearchCurve('r'), trySearchCurve('g'), trySearchCurve('b'), trySearchCurve('a'));

                  case value instanceof Size$1:
                    return new SizeTrackEval(trySearchCurve('width'), trySearchCurve('height'));
                }
              };

              _proto.addChannel = function addChannel(property) {
                var channel = new UntypedTrackChannel();
                channel.property = property;

                this._channels.push(channel);

                return channel;
              };

              _proto.upgrade = function upgrade(refine) {
                var _this4 = this;

                var trySearchChannel = function trySearchChannel(property, outChannel) {
                  var untypedChannel = _this4.channels().find(function (channel) {
                    return channel.property === property;
                  });

                  if (untypedChannel) {
                    outChannel.name = untypedChannel.name;
                    outChannel.curve.assignSorted(Array.from(untypedChannel.curve.times()), Array.from(untypedChannel.curve.values()));
                  }
                };

                var kind = refine(this.path, this.proxy);

                switch (kind) {
                  default:
                    break;

                  case 'vec2':
                  case 'vec3':
                  case 'vec4':
                    {
                      var track = new VectorTrack();
                      track.path = this.path;
                      track.proxy = this.proxy;
                      track.componentsCount = kind === 'vec2' ? 2 : kind === 'vec3' ? 3 : 4;

                      var _track$channels = track.channels(),
                          x = _track$channels[0],
                          y = _track$channels[1],
                          z = _track$channels[2],
                          w = _track$channels[3];

                      switch (kind) {
                        case 'vec4':
                          trySearchChannel('w', w);

                        case 'vec3':
                          trySearchChannel('z', z);

                        default:
                        case 'vec2':
                          trySearchChannel('x', x);
                          trySearchChannel('y', y);
                      }

                      return track;
                    }

                  case 'color':
                    {
                      var _track = new ColorTrack();

                      var _track$channels2 = _track.channels(),
                          r = _track$channels2[0],
                          g = _track$channels2[1],
                          b = _track$channels2[2],
                          a = _track$channels2[3];

                      trySearchChannel('r', r);
                      trySearchChannel('g', g);
                      trySearchChannel('b', b);
                      trySearchChannel('a', a);
                      trySearchChannel('x', r);
                      trySearchChannel('y', g);
                      trySearchChannel('z', b);
                      trySearchChannel('w', a);
                      return _track;
                    }

                  case 'size':
                    break;
                }

                return null;
              };

              return UntypedTrack;
            }(Track), (_initializer2$x = applyDecoratedInitializer(_class5$9.prototype, "_channels", [serializable$j], function () {
              return [];
            })), _class5$9)) || _class4$9);

            var AnimationClipLegacyData = function () {
              function AnimationClipLegacyData(duration) {
                this._keys = [];
                this._curves = [];
                this._commonTargets = [];
                this._ratioSamplers = [];
                this._runtimeCurves = void 0;
                this._data = null;
                this._duration = void 0;
                this._duration = duration;
              }

              var _proto = AnimationClipLegacyData.prototype;

              _proto.getPropertyCurves = function getPropertyCurves() {
                if (!this._runtimeCurves) {
                  this._createPropertyCurves();
                }

                return this._runtimeCurves;
              };

              _proto.toTracks = function toTracks() {
                var newTracks = [];
                var legacyKeys = this.keys,
                    legacyCurves = this.curves,
                    legacyCommonTargets = this.commonTargets;

                var convertTrackPath = function convertTrackPath(track, modifiers, valueAdapter) {
                  var trackPath = new TrackPath();

                  for (var _iterator = _createForOfIteratorHelperLoose(modifiers), _step; !(_step = _iterator()).done;) {
                    var modifier = _step.value;

                    if (typeof modifier === 'string') {
                      trackPath.toProperty(modifier);
                    } else if (typeof modifier === 'number') {
                      trackPath.toElement(modifier);
                    } else if (modifier instanceof HierarchyPath) {
                      trackPath.toHierarchy(modifier.path);
                    } else if (modifier instanceof ComponentPath) {
                      trackPath.toComponent(modifier.component);
                    } else {
                      trackPath.toCustomized(modifier);
                    }
                  }

                  track.path = trackPath;
                  track.proxy = valueAdapter;
                };

                var untypedTracks = legacyCommonTargets.map(function (legacyCommonTarget) {
                  var track = new UntypedTrack();
                  convertTrackPath(track, legacyCommonTarget.modifiers, legacyCommonTarget.valueAdapter);
                  newTracks.push(track);
                  return track;
                });

                var _loop = function _loop() {
                  var _legacyCurveData$inte;

                  var legacyCurve = _step2.value;
                  var legacyCurveData = legacyCurve.data;
                  var legacyValues = legacyCurveData.values;

                  if (legacyValues.length === 0) {
                    return "continue";
                  }

                  var legacyKeysIndex = legacyCurveData.keys;
                  var times = legacyKeysIndex < 0 ? [0.0] : legacyKeys[legacyCurveData.keys];
                  var firstValue = legacyValues[0];
                  var interpolate = (_legacyCurveData$inte = legacyCurveData.interpolate) !== null && _legacyCurveData$inte !== void 0 ? _legacyCurveData$inte : true;
                  assertIsTrue(typeof legacyCurveData._arrayLength !== 'number' || typeof firstValue === 'number');
                  var legacyEasingMethodConverter = new LegacyEasingMethodConverter(legacyCurveData, times.length);

                  var installPathAndSetter = function installPathAndSetter(track) {
                    convertTrackPath(track, legacyCurve.modifiers, legacyCurve.valueAdapter);
                  };

                  var legacyCommonTargetCurve = void 0;

                  if (typeof legacyCurve.commonTarget === 'number') {
                    if (!legacyValues.every(function (value) {
                      return typeof value === 'number';
                    })) {
                      warnID(3932);
                      return "continue";
                    }

                    if (legacyCurve.valueAdapter || legacyCurve.modifiers.length !== 1 || typeof legacyCurve.modifiers[0] !== 'string') {
                      warnID(3933);
                      return "continue";
                    }

                    var _propertyName = legacyCurve.modifiers[0];
                    var untypedTrack = untypedTracks[legacyCurve.commonTarget];

                    var _untypedTrack$addChan = untypedTrack.addChannel(_propertyName),
                        curve = _untypedTrack$addChan.curve;

                    legacyCommonTargetCurve = curve;
                  }

                  var convertCurve = function convertCurve() {
                    if (typeof firstValue === 'number') {
                      if (!legacyValues.every(function (value) {
                        return typeof value === 'number';
                      })) {
                        warnID(3934);
                        return;
                      }

                      var realCurve;

                      if (legacyCommonTargetCurve) {
                        realCurve = legacyCommonTargetCurve;
                      } else {
                        var track = new RealTrack();
                        installPathAndSetter(track);
                        newTracks.push(track);
                        realCurve = track.channel.curve;
                      }

                      var interpolationMethod = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;
                      realCurve.assignSorted(times, legacyValues.map(function (value) {
                        return {
                          value: value,
                          interpolationMode: interpolationMethod
                        };
                      }));
                      legacyEasingMethodConverter.convert(realCurve);
                      return;
                    } else if (typeof firstValue === 'object') {
                      switch (true) {
                        default:
                          break;

                        case everyInstanceOf(legacyValues, Vec2):
                        case everyInstanceOf(legacyValues, Vec3):
                        case everyInstanceOf(legacyValues, Vec4):
                          {
                            var components = firstValue instanceof Vec2 ? 2 : firstValue instanceof Vec3 ? 3 : 4;

                            var _track = new VectorTrack();

                            installPathAndSetter(_track);
                            _track.componentsCount = components;

                            var _track$channels = _track.channels(),
                                x = _track$channels[0].curve,
                                y = _track$channels[1].curve,
                                z = _track$channels[2].curve,
                                w = _track$channels[3].curve;

                            var interpolationMode = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;

                            var valueToFrame = function valueToFrame(value) {
                              return {
                                value: value,
                                interpolationMode: interpolationMode
                              };
                            };

                            switch (components) {
                              case 4:
                                w.assignSorted(times, legacyValues.map(function (value) {
                                  return valueToFrame(value.w);
                                }));
                                legacyEasingMethodConverter.convert(w);

                              case 3:
                                z.assignSorted(times, legacyValues.map(function (value) {
                                  return valueToFrame(value.z);
                                }));
                                legacyEasingMethodConverter.convert(z);

                              default:
                                x.assignSorted(times, legacyValues.map(function (value) {
                                  return valueToFrame(value.x);
                                }));
                                legacyEasingMethodConverter.convert(x);
                                y.assignSorted(times, legacyValues.map(function (value) {
                                  return valueToFrame(value.y);
                                }));
                                legacyEasingMethodConverter.convert(y);
                                break;
                            }

                            newTracks.push(_track);
                            return;
                          }

                        case everyInstanceOf(legacyValues, Quat):
                          {
                            var _track2 = new QuatTrack();

                            installPathAndSetter(_track2);

                            var _interpolationMode = interpolate ? QuatInterpolationMode.SLERP : QuatInterpolationMode.CONSTANT;

                            _track2.channel.curve.assignSorted(times, legacyValues.map(function (value) {
                              return {
                                value: Quat.clone(value),
                                interpolationMode: _interpolationMode
                              };
                            }));

                            legacyEasingMethodConverter.convertQuatCurve(_track2.channel.curve);
                            newTracks.push(_track2);
                            return;
                          }

                        case everyInstanceOf(legacyValues, Color$1):
                          {
                            var _track3 = new ColorTrack();

                            installPathAndSetter(_track3);

                            var _track3$channels = _track3.channels(),
                                r = _track3$channels[0].curve,
                                g = _track3$channels[1].curve,
                                b = _track3$channels[2].curve,
                                a = _track3$channels[3].curve;

                            var _interpolationMode2 = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;

                            var _valueToFrame = function _valueToFrame(value) {
                              return {
                                value: value,
                                interpolationMode: _interpolationMode2
                              };
                            };

                            r.assignSorted(times, legacyValues.map(function (value) {
                              return _valueToFrame(value.r);
                            }));
                            legacyEasingMethodConverter.convert(r);
                            g.assignSorted(times, legacyValues.map(function (value) {
                              return _valueToFrame(value.g);
                            }));
                            legacyEasingMethodConverter.convert(g);
                            b.assignSorted(times, legacyValues.map(function (value) {
                              return _valueToFrame(value.b);
                            }));
                            legacyEasingMethodConverter.convert(b);
                            a.assignSorted(times, legacyValues.map(function (value) {
                              return _valueToFrame(value.a);
                            }));
                            legacyEasingMethodConverter.convert(a);
                            newTracks.push(_track3);
                            return;
                          }

                        case everyInstanceOf(legacyValues, Size$1):
                          {
                            var _track4 = new SizeTrack();

                            installPathAndSetter(_track4);

                            var _track4$channels = _track4.channels(),
                                width = _track4$channels[0].curve,
                                height = _track4$channels[1].curve;

                            var _interpolationMode3 = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;

                            var _valueToFrame2 = function _valueToFrame2(value) {
                              return {
                                value: value,
                                interpolationMode: _interpolationMode3
                              };
                            };

                            width.assignSorted(times, legacyValues.map(function (value) {
                              return _valueToFrame2(value.width);
                            }));
                            legacyEasingMethodConverter.convert(width);
                            height.assignSorted(times, legacyValues.map(function (value) {
                              return _valueToFrame2(value.height);
                            }));
                            legacyEasingMethodConverter.convert(height);
                            newTracks.push(_track4);
                            return;
                          }

                        case everyInstanceOf(legacyValues, CubicSplineNumberValue):
                          {
                            assertIsTrue(legacyEasingMethodConverter.nil);

                            var _track5 = new RealTrack();

                            installPathAndSetter(_track5);

                            var _interpolationMode4 = interpolate ? RealInterpolationMode.CUBIC : RealInterpolationMode.CONSTANT;

                            _track5.channel.curve.assignSorted(times, legacyValues.map(function (value) {
                              return {
                                value: value.dataPoint,
                                leftTangent: value.inTangent,
                                rightTangent: value.outTangent,
                                interpolationMode: _interpolationMode4
                              };
                            }));

                            newTracks.push(_track5);
                            return;
                          }

                        case everyInstanceOf(legacyValues, CubicSplineVec2Value):
                        case everyInstanceOf(legacyValues, CubicSplineVec3Value):
                        case everyInstanceOf(legacyValues, CubicSplineVec4Value):
                          {
                            assertIsTrue(legacyEasingMethodConverter.nil);

                            var _components = firstValue instanceof CubicSplineVec2Value ? 2 : firstValue instanceof CubicSplineVec3Value ? 3 : 4;

                            var _track6 = new VectorTrack();

                            installPathAndSetter(_track6);
                            _track6.componentsCount = _components;

                            var _track6$channels = _track6.channels(),
                                _x = _track6$channels[0],
                                _y = _track6$channels[1],
                                _z = _track6$channels[2],
                                _w = _track6$channels[3];

                            var _interpolationMode5 = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;

                            var _valueToFrame3 = function _valueToFrame3(value, inTangent, outTangent) {
                              return {
                                value: value,
                                leftTangent: inTangent,
                                rightTangent: outTangent,
                                interpolationMode: _interpolationMode5
                              };
                            };

                            switch (_components) {
                              case 4:
                                _w.curve.assignSorted(times, legacyValues.map(function (value) {
                                  return _valueToFrame3(value.dataPoint.w, value.inTangent.w, value.outTangent.w);
                                }));

                              case 3:
                                _z.curve.assignSorted(times, legacyValues.map(function (value) {
                                  return _valueToFrame3(value.dataPoint.z, value.inTangent.z, value.outTangent.z);
                                }));

                              default:
                                _x.curve.assignSorted(times, legacyValues.map(function (value) {
                                  return _valueToFrame3(value.dataPoint.y, value.inTangent.y, value.outTangent.y);
                                }));

                                _y.curve.assignSorted(times, legacyValues.map(function (value) {
                                  return _valueToFrame3(value.dataPoint.x, value.inTangent.x, value.outTangent.x);
                                }));

                                break;
                            }

                            newTracks.push(_track6);
                            return;
                          }

                        case legacyValues.every(function (value) {
                          return value instanceof CubicSplineQuatValue;
                        }):
                          {
                            warnID(3935);
                            break;
                          }
                      }
                    }

                    var objectTrack = new ObjectTrack();
                    installPathAndSetter(objectTrack);
                    objectTrack.channel.curve.assignSorted(times, legacyValues);
                    newTracks.push(objectTrack);
                  };

                  convertCurve();
                };

                for (var _iterator2 = _createForOfIteratorHelperLoose(legacyCurves), _step2; !(_step2 = _iterator2()).done;) {
                  var _ret = _loop();

                  if (_ret === "continue") continue;
                }

                return newTracks;
              };

              _proto._createPropertyCurves = function _createPropertyCurves() {
                var _this = this;

                this._ratioSamplers = this._keys.map(function (keys) {
                  return new RatioSampler(keys.map(function (key) {
                    return key / _this._duration;
                  }));
                });
                this._runtimeCurves = this._curves.map(function (targetCurve) {
                  return {
                    curve: new AnimCurve(targetCurve.data, _this._duration),
                    modifiers: targetCurve.modifiers,
                    valueAdapter: targetCurve.valueAdapter,
                    sampler: _this._ratioSamplers[targetCurve.data.keys],
                    commonTarget: targetCurve.commonTarget
                  };
                });
              };

              _createClass(AnimationClipLegacyData, [{
                key: "keys",
                get: function get() {
                  return this._keys;
                },
                set: function set(value) {
                  this._keys = value;
                }
              }, {
                key: "curves",
                get: function get() {
                  return this._curves;
                },
                set: function set(value) {
                  this._curves = value;
                  delete this._runtimeCurves;
                }
              }, {
                key: "commonTargets",
                get: function get() {
                  return this._commonTargets;
                },
                set: function set(value) {
                  this._commonTargets = value;
                }
              }, {
                key: "data",
                get: function get() {
                  return this._data;
                }
              }]);

              return AnimationClipLegacyData;
            }();

            function everyInstanceOf(array, constructor) {
              return array.every(function (element) {
                return element instanceof constructor;
              });
            }

            var LegacyEasingMethodConverter = function () {
              function LegacyEasingMethodConverter(legacyCurveData, keyframesCount) {
                this._easingMethods = void 0;
                var easingMethods = legacyCurveData.easingMethods;

                if (Array.isArray(easingMethods)) {
                  if (easingMethods.length === 0 && keyframesCount !== 0) {
                    this._easingMethods = new Array(keyframesCount).fill(null);
                  } else {
                    this._easingMethods = easingMethods;
                  }
                } else if (easingMethods === undefined) {
                  this._easingMethods = new Array(keyframesCount).fill(legacyCurveData.easingMethod);
                } else {
                  this._easingMethods = Array.from({
                    length: keyframesCount
                  }, function (_, index) {
                    var _easingMethods$index;

                    return (_easingMethods$index = easingMethods[index]) !== null && _easingMethods$index !== void 0 ? _easingMethods$index : null;
                  });
                }
              }

              var _proto2 = LegacyEasingMethodConverter.prototype;

              _proto2.convert = function convert(curve) {
                var easingMethods = this._easingMethods;

                if (!easingMethods) {
                  return;
                }

                var nKeyframes = curve.keyFramesCount;

                if (curve.keyFramesCount < 2) {
                  return;
                }

                if (Array.isArray(easingMethods)) {
                  assertIsTrue(nKeyframes === easingMethods.length);
                }

                var iLastKeyframe = nKeyframes - 1;

                for (var iKeyframe = 0; iKeyframe < iLastKeyframe; ++iKeyframe) {
                  var easingMethod = easingMethods[iKeyframe];

                  if (!easingMethod) {
                    continue;
                  }

                  if (Array.isArray(easingMethod)) {
                    timeBezierToTangents(easingMethod, curve.getKeyframeTime(iKeyframe), curve.getKeyframeValue(iKeyframe), curve.getKeyframeTime(iKeyframe + 1), curve.getKeyframeValue(iKeyframe + 1));
                  } else {
                    applyLegacyEasingMethodName(easingMethod, curve, iKeyframe);
                  }
                }
              };

              _proto2.convertQuatCurve = function convertQuatCurve(curve) {
                var easingMethods = this._easingMethods;

                if (!easingMethods) {
                  return;
                }

                var nKeyframes = curve.keyFramesCount;

                if (curve.keyFramesCount < 2) {
                  return;
                }

                if (Array.isArray(easingMethods)) {
                  assertIsTrue(nKeyframes === easingMethods.length);
                }

                var iLastKeyframe = nKeyframes - 1;

                for (var iKeyframe = 0; iKeyframe < iLastKeyframe; ++iKeyframe) {
                  var easingMethod = easingMethods[iKeyframe];

                  if (!easingMethod) {
                    continue;
                  }

                  if (Array.isArray(easingMethod)) {
                    curve.getKeyframeValue(iKeyframe).easingMethod = easingMethod.slice();
                  } else {
                    applyLegacyEasingMethodNameIntoQuatCurve(easingMethod, curve, iKeyframe);
                  }
                }
              };

              _createClass(LegacyEasingMethodConverter, [{
                key: "nil",
                get: function get() {
                  return !this._easingMethods || this._easingMethods.every(function (easingMethod) {
                    return easingMethod === null || easingMethod === undefined;
                  });
                }
              }]);

              return LegacyEasingMethodConverter;
            }();

            function applyLegacyEasingMethodName(easingMethodName, curve, keyframeIndex) {
              assertIsTrue(keyframeIndex !== curve.keyFramesCount - 1);
              assertIsTrue(easingMethodName in easingMethodNameMap);
              var keyframeValue = curve.getKeyframeValue(keyframeIndex);
              var easingMethod = easingMethodNameMap[easingMethodName];

              if (easingMethod === EasingMethod.CONSTANT) {
                keyframeValue.interpolationMode = RealInterpolationMode.CONSTANT;
              } else {
                keyframeValue.interpolationMode = RealInterpolationMode.LINEAR;
                keyframeValue.easingMethod = easingMethod;
              }
            }

            function applyLegacyEasingMethodNameIntoQuatCurve(easingMethodName, curve, keyframeIndex) {
              assertIsTrue(keyframeIndex !== curve.keyFramesCount - 1);
              assertIsTrue(easingMethodName in easingMethodNameMap);
              var keyframeValue = curve.getKeyframeValue(keyframeIndex);
              var easingMethod = easingMethodNameMap[easingMethodName];
              keyframeValue.easingMethod = easingMethod;
            }

            var easingMethodNameMap = {
              constant: EasingMethod.CONSTANT,
              linear: EasingMethod.LINEAR,
              quadIn: EasingMethod.QUAD_IN,
              quadOut: EasingMethod.QUAD_OUT,
              quadInOut: EasingMethod.QUAD_IN_OUT,
              quadOutIn: EasingMethod.QUAD_OUT_IN,
              cubicIn: EasingMethod.CUBIC_IN,
              cubicOut: EasingMethod.CUBIC_OUT,
              cubicInOut: EasingMethod.CUBIC_IN_OUT,
              cubicOutIn: EasingMethod.CUBIC_OUT_IN,
              quartIn: EasingMethod.QUART_IN,
              quartOut: EasingMethod.QUART_OUT,
              quartInOut: EasingMethod.QUART_IN_OUT,
              quartOutIn: EasingMethod.QUART_OUT_IN,
              quintIn: EasingMethod.QUINT_IN,
              quintOut: EasingMethod.QUINT_OUT,
              quintInOut: EasingMethod.QUINT_IN_OUT,
              quintOutIn: EasingMethod.QUINT_OUT_IN,
              sineIn: EasingMethod.SINE_IN,
              sineOut: EasingMethod.SINE_OUT,
              sineInOut: EasingMethod.SINE_IN_OUT,
              sineOutIn: EasingMethod.SINE_OUT_IN,
              expoIn: EasingMethod.EXPO_IN,
              expoOut: EasingMethod.EXPO_OUT,
              expoInOut: EasingMethod.EXPO_IN_OUT,
              expoOutIn: EasingMethod.EXPO_OUT_IN,
              circIn: EasingMethod.CIRC_IN,
              circOut: EasingMethod.CIRC_OUT,
              circInOut: EasingMethod.CIRC_IN_OUT,
              circOutIn: EasingMethod.CIRC_OUT_IN,
              elasticIn: EasingMethod.ELASTIC_IN,
              elasticOut: EasingMethod.ELASTIC_OUT,
              elasticInOut: EasingMethod.ELASTIC_IN_OUT,
              elasticOutIn: EasingMethod.ELASTIC_OUT_IN,
              backIn: EasingMethod.BACK_IN,
              backOut: EasingMethod.BACK_OUT,
              backInOut: EasingMethod.BACK_IN_OUT,
              backOutIn: EasingMethod.BACK_OUT_IN,
              bounceIn: EasingMethod.BOUNCE_IN,
              bounceOut: EasingMethod.BOUNCE_OUT,
              bounceInOut: EasingMethod.BOUNCE_IN_OUT,
              bounceOutIn: EasingMethod.BOUNCE_OUT_IN,
              smooth: EasingMethod.SMOOTH,
              fade: EasingMethod.FADE
            };
            function timeBezierToTangents(timeBezierPoints, previousTime, previousKeyframe, nextTime, nextKeyframe) {
              var p1X = timeBezierPoints[0],
                  p1Y = timeBezierPoints[1],
                  p2X = timeBezierPoints[2],
                  p2Y = timeBezierPoints[3];
              var previousValue = previousKeyframe.value;
              var nextValue = nextKeyframe.value;
              var dValue = nextValue - previousValue;
              var dTime = nextTime - previousTime;
              var fx = 3 * dTime;
              var fy = 3 * dValue;
              var t1x = p1X * fx;
              var t1y = p1Y * fy;
              var t2x = (1.0 - p2X) * fx;
              var t2y = (1.0 - p2Y) * fy;
              var ONE_THIRD = 1.0 / 3.0;
              var previousTangent = t1y / t1x;
              var previousTangentWeight = Math.sqrt(t1x * t1x + t1y * t1y) * ONE_THIRD;
              var nextTangent = t2y / t2x;
              var nextTangentWeight = Math.sqrt(t2x * t2x + t2y * t2y) * ONE_THIRD;
              previousKeyframe.interpolationMode = RealInterpolationMode.CUBIC;
              previousKeyframe.tangentWeightMode = ensureRightTangentWeightMode(previousKeyframe.tangentWeightMode);
              previousKeyframe.rightTangent = previousTangent;
              previousKeyframe.rightTangentWeight = previousTangentWeight;
              nextKeyframe.tangentWeightMode = ensureLeftTangentWeightMode(nextKeyframe.tangentWeightMode);
              nextKeyframe.leftTangent = nextTangent;
              nextKeyframe.leftTangentWeight = nextTangentWeight;
            }

            function ensureLeftTangentWeightMode(tangentWeightMode) {
              if (tangentWeightMode === TangentWeightMode.NONE) {
                return TangentWeightMode.LEFT;
              } else if (tangentWeightMode === TangentWeightMode.RIGHT) {
                return TangentWeightMode.BOTH;
              } else {
                return tangentWeightMode;
              }
            }

            function ensureRightTangentWeightMode(tangentWeightMode) {
              if (tangentWeightMode === TangentWeightMode.NONE) {
                return TangentWeightMode.RIGHT;
              } else if (tangentWeightMode === TangentWeightMode.LEFT) {
                return TangentWeightMode.BOTH;
              } else {
                return tangentWeightMode;
              }
            }

            var _dec$R, _class$R, _class2$I, _initializer$G, _dec2$A, _class4$a, _class5$a, _initializer2$y, _initializer3$n, _initializer4$l, _initializer5$h, _dec3$p, _class7$3, _class8$2, _initializer6$e, _initializer7$a, _dec4$g, _class10$1, _dec5$c, _class11$2, _dec6$b, _class12$1, _class13$1, _initializer8$a, _initializer9$9, _dec7$a, _class15$1, _class16, _initializer10$8, _initializer11$5, _initializer12$5, _initializer13$5;
            var ccclass$5 = ccclass$p,
                serializable$5 = serializable$j;

            function throwIfSplitMethodIsNotValid() {
              throw new Error("split() only valid in Editor.");
            }

            var ExoticAnimation = (_dec$R = ccclass$5(CLASS_NAME_PREFIX_ANIM + "ExoticAnimation"), _dec$R(_class$R = (_class2$I = function () {
              function ExoticAnimation() {
                this._nodeAnimations = _initializer$G && _initializer$G();
              }

              var _proto = ExoticAnimation.prototype;

              _proto.createEvaluator = function createEvaluator(binder) {
                return new ExoticTrsAnimationEvaluator(this._nodeAnimations, binder);
              };

              _proto.addNodeAnimation = function addNodeAnimation(path) {
                var nodeAnimation = new ExoticNodeAnimation(path);

                this._nodeAnimations.push(nodeAnimation);

                return nodeAnimation;
              };

              _proto.collectAnimatedJoints = function collectAnimatedJoints() {
                return Array.from(new Set(this._nodeAnimations.map(function (_ref) {
                  var path = _ref.path;
                  return path;
                })));
              };

              _proto.split = function split(from, to) {
                {
                  return throwIfSplitMethodIsNotValid();
                }
              };

              _proto.toHashString = function toHashString() {
                return this._nodeAnimations.map(function (nodeAnimation) {
                  return nodeAnimation.toHashString();
                }).join('\n');
              };

              return ExoticAnimation;
            }(), (_initializer$G = applyDecoratedInitializer(_class2$I.prototype, "_nodeAnimations", [serializable$5], function () {
              return [];
            })), _class2$I)) || _class$R);
            var ExoticNodeAnimation = (_dec2$A = ccclass$5(CLASS_NAME_PREFIX_ANIM + "ExoticNodeAnimation"), _dec2$A(_class4$a = (_class5$a = function () {
              function ExoticNodeAnimation(path) {
                this._path = _initializer2$y && _initializer2$y();
                this._position = _initializer3$n && _initializer3$n();
                this._rotation = _initializer4$l && _initializer4$l();
                this._scale = _initializer5$h && _initializer5$h();
                this._path = path;
              }

              var _proto2 = ExoticNodeAnimation.prototype;

              _proto2.createPosition = function createPosition(times, values) {
                this._position = new ExoticTrack(times, new ExoticVec3TrackValues(values));
              };

              _proto2.createRotation = function createRotation(times, values) {
                this._rotation = new ExoticTrack(times, new ExoticQuatTrackValues(values));
              };

              _proto2.createScale = function createScale(times, values) {
                this._scale = new ExoticTrack(times, new ExoticVec3TrackValues(values));
              };

              _proto2.createEvaluator = function createEvaluator(binder) {
                return new ExoticNodeAnimationEvaluator(this._path, this._position, this._rotation, this._scale, binder);
              };

              _proto2.split = function split(from, to, splitInfoCache) {
                {
                  return throwIfSplitMethodIsNotValid();
                }
              };

              _proto2.toHashString = function toHashString() {
                var _this$_position$toHas, _this$_position, _this$_scale$toHashSt, _this$_scale, _this$_rotation$toHas, _this$_rotation;

                return this._path + "\n" + ((_this$_position$toHas = (_this$_position = this._position) === null || _this$_position === void 0 ? void 0 : _this$_position.toHashString()) !== null && _this$_position$toHas !== void 0 ? _this$_position$toHas : '') + ((_this$_scale$toHashSt = (_this$_scale = this._scale) === null || _this$_scale === void 0 ? void 0 : _this$_scale.toHashString()) !== null && _this$_scale$toHashSt !== void 0 ? _this$_scale$toHashSt : '') + ((_this$_rotation$toHas = (_this$_rotation = this._rotation) === null || _this$_rotation === void 0 ? void 0 : _this$_rotation.toHashString()) !== null && _this$_rotation$toHas !== void 0 ? _this$_rotation$toHas : '');
              };

              _createClass(ExoticNodeAnimation, [{
                key: "path",
                get: function get() {
                  return this._path;
                }
              }]);

              return ExoticNodeAnimation;
            }(), (_initializer2$y = applyDecoratedInitializer(_class5$a.prototype, "_path", [serializable$5], function () {
              return '';
            }), _initializer3$n = applyDecoratedInitializer(_class5$a.prototype, "_position", [serializable$5], function () {
              return null;
            }), _initializer4$l = applyDecoratedInitializer(_class5$a.prototype, "_rotation", [serializable$5], function () {
              return null;
            }), _initializer5$h = applyDecoratedInitializer(_class5$a.prototype, "_scale", [serializable$5], function () {
              return null;
            })), _class5$a)) || _class4$a);

            function floatToHashString(value) {
              return value.toPrecision(2);
            }

            function floatArrayToHashString(values) {
              return values.map(floatToHashString).join(' ');
            }

            var ExoticVectorLikeTrackValues = (_dec3$p = ccclass$5(CLASS_NAME_PREFIX_ANIM + "ExoticVectorLikeTrackValues"), _dec3$p(_class7$3 = (_class8$2 = function () {
              function ExoticVectorLikeTrackValues(values) {
                this._values = _initializer6$e && _initializer6$e();
                this._isQuantized = _initializer7$a && _initializer7$a();
                this._values = values;
                this._isQuantized = false;
              }

              var _proto3 = ExoticVectorLikeTrackValues.prototype;

              _proto3.quantize = function quantize(type) {
                assertIsTrue(!this._isQuantized);
                this._values = _quantize(this._values, type);
                this._isQuantized = true;
              };

              _proto3.toHashString = function toHashString() {
                var isQuantized = this._isQuantized,
                    values = this._values;
                return isQuantized + " " + (isQuantized ? values.toHashString() : floatArrayToHashString(values));
              };

              _createClass(ExoticVectorLikeTrackValues, [{
                key: "precision",
                get: function get() {
                  return this._isQuantized ? this._values.originalPrecision : getFloatArrayPrecision(this._values);
                }
              }]);

              return ExoticVectorLikeTrackValues;
            }(), (_initializer6$e = applyDecoratedInitializer(_class8$2.prototype, "_values", [serializable$5], null), _initializer7$a = applyDecoratedInitializer(_class8$2.prototype, "_isQuantized", [serializable$5], null)), _class8$2)) || _class7$3);
            var ExoticVec3TrackValues = (_dec4$g = ccclass$5(CLASS_NAME_PREFIX_ANIM + "ExoticVec3TrackValues"), _dec4$g(_class10$1 = function (_ExoticVectorLikeTrac) {
              _inheritsLoose(ExoticVec3TrackValues, _ExoticVectorLikeTrac);

              function ExoticVec3TrackValues() {
                return _ExoticVectorLikeTrac.apply(this, arguments) || this;
              }

              ExoticVec3TrackValues.imitate = function imitate(values, model) {
                var trackValues = new ExoticVec3TrackValues(values);

                if (model._isQuantized) {
                  trackValues.quantize(model._values.quantizationType);
                }

                return trackValues;
              };

              var _proto4 = ExoticVec3TrackValues.prototype;

              _proto4.get = function get(index, resultValue) {
                var values = this._values,
                    isQuantized = this._isQuantized;

                if (isQuantized) {
                  loadVec3FromQuantized(values, index, resultValue);
                } else {
                  Vec3.fromArray(resultValue, values, index * 3);
                }
              };

              _proto4.lerp = function lerp(prevIndex, nextIndex, ratio, prevValue, nextValue, resultValue) {
                var values = this._values,
                    isQuantized = this._isQuantized;

                if (isQuantized) {
                  loadVec3FromQuantized(values, prevIndex, prevValue);
                  loadVec3FromQuantized(values, nextIndex, nextValue);
                } else {
                  Vec3.fromArray(prevValue, values, prevIndex * 3);
                  Vec3.fromArray(nextValue, values, nextIndex * 3);
                }

                Vec3.lerp(resultValue, prevValue, nextValue, ratio);
              };

              return ExoticVec3TrackValues;
            }(ExoticVectorLikeTrackValues)) || _class10$1);
            var ExoticQuatTrackValues = (_dec5$c = ccclass$5(CLASS_NAME_PREFIX_ANIM + "ExoticQuatTrackValues"), _dec5$c(_class11$2 = function (_ExoticVectorLikeTrac2) {
              _inheritsLoose(ExoticQuatTrackValues, _ExoticVectorLikeTrac2);

              function ExoticQuatTrackValues() {
                return _ExoticVectorLikeTrac2.apply(this, arguments) || this;
              }

              ExoticQuatTrackValues.imitate = function imitate(values, model) {
                var trackValues = new ExoticQuatTrackValues(values);

                if (model._isQuantized) {
                  trackValues.quantize(model._values.quantizationType);
                }

                return trackValues;
              };

              var _proto5 = ExoticQuatTrackValues.prototype;

              _proto5.get = function get(index, resultValue) {
                var values = this._values,
                    isQuantized = this._isQuantized;

                if (isQuantized) {
                  loadQuatFromQuantized(values, index, resultValue);
                } else {
                  Quat.fromArray(resultValue, values, index * 4);
                }
              };

              _proto5.lerp = function lerp(prevIndex, nextIndex, ratio, prevValue, nextValue, resultValue) {
                var values = this._values,
                    isQuantized = this._isQuantized;

                if (isQuantized) {
                  loadQuatFromQuantized(values, prevIndex, prevValue);
                  loadQuatFromQuantized(values, nextIndex, nextValue);
                } else {
                  Quat.fromArray(prevValue, values, prevIndex * 4);
                  Quat.fromArray(nextValue, values, nextIndex * 4);
                }

                Quat.slerp(resultValue, prevValue, nextValue, ratio);
              };

              return ExoticQuatTrackValues;
            }(ExoticVectorLikeTrackValues)) || _class11$2);
            var ExoticTrack = (_dec6$b = ccclass$5(CLASS_NAME_PREFIX_ANIM + "ExoticTrack"), _dec6$b(_class12$1 = (_class13$1 = function () {
              function ExoticTrack(times, values) {
                this.times = _initializer8$a && _initializer8$a();
                this.values = _initializer9$9 && _initializer9$9();
                this.times = times;
                this.values = values;
              }

              var _proto6 = ExoticTrack.prototype;

              _proto6.toHashString = function toHashString() {
                var times = this.times,
                    values = this.values;
                return "times: " + floatArrayToHashString(times) + "; values: " + values.toHashString();
              };

              return ExoticTrack;
            }(), (_initializer8$a = applyDecoratedInitializer(_class13$1.prototype, "times", [serializable$5], null), _initializer9$9 = applyDecoratedInitializer(_class13$1.prototype, "values", [serializable$5], null)), _class13$1)) || _class12$1);

            var SplitInfo = function () {
              function SplitInfo() {
                this._reset();
              }

              var _proto7 = SplitInfo.prototype;

              _proto7.transformTime = function transformTime(input) {
                return input - this._timeOffset;
              };

              _proto7.calculate = function calculate(times, from, to) {
                this._reset();

                var nKeyframes = times.length;

                if (!nKeyframes) {
                  return;
                }

                var firstTime = times[0];
                var lastTime = times[nKeyframes - 1];
                var fromClamped = clamp$1(from, firstTime, lastTime);
                var toClamped = clamp$1(to, firstTime, lastTime);
                this._timeOffset = fromClamped;

                var _searchRange = searchRange(times, fromClamped, toClamped),
                    fromIndex = _searchRange.fromIndex,
                    fromRatio = _searchRange.fromRatio,
                    toIndex = _searchRange.toIndex,
                    toRatio = _searchRange.toRatio;

                assertIsTrue(toIndex >= fromIndex);
                var fromJust = !fromRatio;
                var toJust = !toRatio;

                if (fromIndex === toIndex && fromRatio === toRatio) {
                  if (!fromJust) {
                    this.preLerpIndex = fromIndex;
                    this.preLerpRatio = fromRatio;
                  } else {
                    this.directKeyframesBegin = fromIndex;
                    this.directKeyframesEnd = fromIndex + 1;
                  }

                  return;
                }

                if (!fromJust) {
                  this.preLerpIndex = fromIndex;
                  this.preLerpRatio = fromRatio;
                }

                this.directKeyframesBegin = fromJust ? fromIndex : fromIndex + 1;
                this.directKeyframesEnd = toIndex + 1;

                if (!toJust) {
                  this.postLerpIndex = toIndex;
                  this.postLerpRatio = toRatio;
                }
              };

              _proto7._reset = function _reset() {
                this.preLerpIndex = -1;
                this.preLerpRatio = 0.0;
                this.directKeyframesBegin = 0;
                this.directKeyframesEnd = 0;
                this.postLerpIndex = -1;
                this.postLerpRatio = 0.0;
                this._timeOffset = 0.0;
              };

              _createClass(SplitInfo, [{
                key: "keyframesCount",
                get: function get() {
                  var preLerpIndex = this.preLerpIndex,
                      directKeyframesBegin = this.directKeyframesBegin,
                      directKeyframesEnd = this.directKeyframesEnd,
                      postLerpIndex = this.postLerpIndex;
                  return 0 + (preLerpIndex < 0 ? 0 : 1) + (directKeyframesEnd - directKeyframesBegin) + (postLerpIndex < 0 ? 0 : 1);
                }
              }]);

              return SplitInfo;
            }();

            function searchRange(values, from, to) {
              var nValues = values.length;
              assertIsTrue(nValues !== 0);
              assertIsTrue(to >= from && from >= values[0] && to <= values[nValues - 1]);

              var _binarySearchRatio = binarySearchRatio(values, from),
                  fromIndex = _binarySearchRatio.index,
                  fromRatio = _binarySearchRatio.ratio;

              var _binarySearchRatio2 = binarySearchRatio(values, to),
                  toIndex = _binarySearchRatio2.index,
                  toRatio = _binarySearchRatio2.ratio;

              return {
                fromIndex: fromIndex,
                fromRatio: fromRatio,
                toIndex: toIndex,
                toRatio: toRatio
              };
            }

            function binarySearchRatio(values, value) {
              var nValues = values.length;
              assertIsTrue(values.length !== 0);
              var resultIndex = 0;
              var resultRatio = 0.0;
              var index0 = binarySearchEpsilon(values, value);

              if (index0 >= 0) {
                resultIndex = index0;
              } else {
                var iNext = ~index0;
                assertIsTrue(iNext !== 0 && iNext !== nValues && nValues > 1);
                var iPrev = iNext - 1;
                resultIndex = iPrev;
                var next = values[iNext];
                var prev = values[iPrev];
                resultRatio = (value - prev) / (next - prev);
              }

              return {
                index: resultIndex,
                ratio: resultRatio
              };
            }

            var ExoticTrsAnimationEvaluator = function () {
              function ExoticTrsAnimationEvaluator(nodeAnimations, binder) {
                this._nodeEvaluations = void 0;
                this._nodeEvaluations = nodeAnimations.map(function (nodeAnimation) {
                  return nodeAnimation.createEvaluator(binder);
                });
              }

              var _proto8 = ExoticTrsAnimationEvaluator.prototype;

              _proto8.evaluate = function evaluate(time) {
                this._nodeEvaluations.forEach(function (nodeEvaluator) {
                  nodeEvaluator.evaluate(time);
                });
              };

              return ExoticTrsAnimationEvaluator;
            }();

            var ExoticNodeAnimationEvaluator = function () {
              function ExoticNodeAnimationEvaluator(path, position, rotation, scale, binder) {
                this._position = null;
                this._rotation = null;
                this._scale = null;

                if (position) {
                  this._position = createExoticTrackEvaluationRecord(position.times, position.values, Vec3, path, 'position', binder);
                }

                if (rotation) {
                  this._rotation = createExoticTrackEvaluationRecord(rotation.times, rotation.values, Quat, path, 'rotation', binder);
                }

                if (scale) {
                  this._scale = createExoticTrackEvaluationRecord(scale.times, scale.values, Vec3, path, 'scale', binder);
                }
              }

              var _proto9 = ExoticNodeAnimationEvaluator.prototype;

              _proto9.evaluate = function evaluate(time) {
                if (this._position) {
                  var _value = this._position.evaluator.evaluate(time);

                  this._position.runtimeBinding.setValue(_value);
                }

                if (this._rotation) {
                  var _value2 = this._rotation.evaluator.evaluate(time);

                  this._rotation.runtimeBinding.setValue(_value2);
                }

                if (this._scale) {
                  var _value3 = this._scale.evaluator.evaluate(time);

                  this._scale.runtimeBinding.setValue(_value3);
                }
              };

              return ExoticNodeAnimationEvaluator;
            }();

            var ExoticTrackEvaluator = function () {
              function ExoticTrackEvaluator(times, values, ValueConstructor) {
                this._times = void 0;
                this._inputSampleResultCache = {
                  just: false,
                  index: -1,
                  nextIndex: -1,
                  ratio: 0.0
                };
                this._values = void 0;
                this._prevValue = void 0;
                this._nextValue = void 0;
                this._resultValue = void 0;
                this._times = times;
                this._values = values;
                this._prevValue = new ValueConstructor();
                this._nextValue = new ValueConstructor();
                this._resultValue = new ValueConstructor();
              }

              var _proto10 = ExoticTrackEvaluator.prototype;

              _proto10.evaluate = function evaluate(time) {
                var times = this._times,
                    values = this._values,
                    resultValue = this._resultValue;
                var nFrames = times.length;

                if (nFrames === 0) {
                  return resultValue;
                }

                var inputSampleResult = sampleInput(times, time, this._inputSampleResultCache);

                if (inputSampleResult.just) {
                  values.get(inputSampleResult.index, resultValue);
                } else {
                  values.lerp(inputSampleResult.index, inputSampleResult.nextIndex, inputSampleResult.ratio, this._prevValue, this._nextValue, resultValue);
                }

                return resultValue;
              };

              return ExoticTrackEvaluator;
            }();

            function sampleInput(values, time, result) {
              var nFrames = values.length;
              assertIsTrue(nFrames !== 0);
              var firstTime = values[0];
              var lastTime = values[nFrames - 1];

              if (time < firstTime) {
                result.just = true;
                result.index = 0;
              } else if (time > lastTime) {
                result.just = true;
                result.index = nFrames - 1;
              } else {
                var _index2 = binarySearchEpsilon(values, time);

                if (_index2 >= 0) {
                  result.just = true;
                  result.index = _index2;
                } else {
                  var _nextIndex = ~_index2;

                  assertIsTrue(_nextIndex !== 0 && _nextIndex !== nFrames && nFrames > 1);

                  var _prevIndex = _nextIndex - 1;

                  var prevTime = values[_prevIndex];
                  var nextTime = values[_nextIndex];

                  var _ratio = (time - values[_prevIndex]) / (nextTime - prevTime);

                  result.just = false;
                  result.index = _prevIndex;
                  result.nextIndex = _nextIndex;
                  result.ratio = _ratio;
                }
              }

              return result;
            }

            var QUANTIZATION_TYPE_TO_ARRAY_VIEW_CONSTRUCTOR_MAP = {
              uint8: Uint8Array,
              uint16: Uint16Array
            };
            var FloatPrecision;

            (function (FloatPrecision) {
              FloatPrecision[FloatPrecision["FLOAT_32"] = 0] = "FLOAT_32";
              FloatPrecision[FloatPrecision["FLOAT_64"] = 1] = "FLOAT_64";
            })(FloatPrecision || (FloatPrecision = {}));

            function getFloatArrayPrecision(array) {
              switch (array.BYTES_PER_ELEMENT) {
                default:
                  assertIsTrue(false);

                case 4:
                  return FloatPrecision.FLOAT_32;

                case 8:
                  return FloatPrecision.FLOAT_64;
              }
            }

            var QuantizedFloatArray = (_dec7$a = ccclass$5(CLASS_NAME_PREFIX_ANIM + "QuantizedFloatArray"), _dec7$a(_class15$1 = (_class16 = function () {
              function QuantizedFloatArray(originalPrecision, values, extent, min) {
                if (min === void 0) {
                  min = 0.0;
                }

                this.originalPrecision = _initializer10$8 && _initializer10$8();
                this.min = _initializer11$5 && _initializer11$5();
                this.extent = _initializer12$5 && _initializer12$5();
                this.values = _initializer13$5 && _initializer13$5();
                this.originalPrecision = originalPrecision;
                this.values = values;
                this.extent = extent;
                this.min = min;
              }

              var _proto11 = QuantizedFloatArray.prototype;

              _proto11.toHashString = function toHashString() {
                var originalPrecision = this.originalPrecision,
                    min = this.min,
                    extent = this.extent,
                    values = this.values;
                return originalPrecision + " " + floatToHashString(min) + " " + floatToHashString(extent) + " " + values.join(' ');
              };

              _createClass(QuantizedFloatArray, [{
                key: "quantizationType",
                get: function get() {
                  switch (this.values.BYTES_PER_ELEMENT) {
                    default:
                    case 1:
                      return 'uint8';

                    case 2:
                      return 'uint16';
                  }
                }
              }]);

              return QuantizedFloatArray;
            }(), (_initializer10$8 = applyDecoratedInitializer(_class16.prototype, "originalPrecision", [serializable$5], null), _initializer11$5 = applyDecoratedInitializer(_class16.prototype, "min", [serializable$5], null), _initializer12$5 = applyDecoratedInitializer(_class16.prototype, "extent", [serializable$5], null), _initializer13$5 = applyDecoratedInitializer(_class16.prototype, "values", [serializable$5], null)), _class16)) || _class15$1);

            function _quantize(values, type) {
              var TypedArrayViewConstructor = QUANTIZATION_TYPE_TO_ARRAY_VIEW_CONSTRUCTOR_MAP[type];
              var MAX = 1 << TypedArrayViewConstructor.BYTES_PER_ELEMENT;
              var min = Number.POSITIVE_INFINITY;
              var max = Number.NEGATIVE_INFINITY;
              values.forEach(function (value) {
                min = Math.min(value, min);
                max = Math.max(value, max);
              });
              var extent = max - min;
              var normalized = TypedArrayViewConstructor.from(values, function (value) {
                return (value - min) / extent * MAX;
              });
              return new QuantizedFloatArray(getFloatArrayPrecision(values), normalized, extent, min);
            }

            function indexQuantized(quantized, index) {
              var quantizedValue = quantized.values[index];
              var MAX_VALUE = 1 << quantized.values.BYTES_PER_ELEMENT;
              return quantizedValue / MAX_VALUE * quantized.extent + quantized.min;
            }

            function createExoticTrackEvaluationRecord(times, values, ValueConstructor, path, property, binder) {
              var trackBinding = new TrackBinding();
              trackBinding.path = new TrackPath().toHierarchy(path).toProperty(property);
              var runtimeBinding = binder(trackBinding);

              if (!runtimeBinding) {
                return null;
              }

              var evaluator = new ExoticTrackEvaluator(times, values, ValueConstructor);
              return {
                runtimeBinding: runtimeBinding,
                evaluator: evaluator
              };
            }

            function loadVec3FromQuantized(values, index, out) {
              Vec3.set(out, indexQuantized(values, 3 * index + 0), indexQuantized(values, 3 * index + 1), indexQuantized(values, 3 * index + 2));
            }

            function loadQuatFromQuantized(values, index, out) {
              Quat.set(out, indexQuantized(values, 4 * index + 0), indexQuantized(values, 4 * index + 1), indexQuantized(values, 4 * index + 2), indexQuantized(values, 4 * index + 3));
            }

            var _dec$S, _class$S, _class2$J, _initializer$H, _initializer2$z, _initializer3$o, _initializer4$m, _initializer5$i, _initializer6$f, _initializer7$b, _initializer8$b, _initializer9$a, _initializer10$9, _class3$9, _temp$c;
            var searchForRootBonePathSymbol = Symbol('SearchForRootBonePath');
            var exoticAnimationTag = Symbol('ExoticAnimation');
            var embeddedPlayerCountTag = Symbol('[[EmbeddedPlayerCount]]');
            var getEmbeddedPlayersTag = Symbol('[[GetEmbeddedPlayers]]');
            var addEmbeddedPlayerTag = Symbol('[[AddEmbeddedPlayer]]');
            var removeEmbeddedPlayerTag = Symbol('[[RemoveEmbeddedPlayer]]');
            var clearEmbeddedPlayersTag = Symbol('[[ClearEmbeddedPlayers]]');
            var AnimationClip = exports('AnimationClip', (_dec$S = ccclass$p('cc.AnimationClip'), _dec$S(_class$S = (_class2$J = (_temp$c = _class3$9 = function (_Asset) {
              _inheritsLoose(AnimationClip, _Asset);

              function AnimationClip() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;
                _this.sample = _initializer$H && _initializer$H();
                _this.speed = _initializer2$z && _initializer2$z();
                _this.wrapMode = _initializer3$o && _initializer3$o();
                _this.enableTrsBlending = _initializer4$m && _initializer4$m();
                _this._duration = _initializer5$i && _initializer5$i();
                _this._hash = _initializer6$f && _initializer6$f();
                _this.frameRate = 0;
                _this._tracks = _initializer7$b && _initializer7$b();
                _this._exoticAnimation = _initializer8$b && _initializer8$b();
                _this._legacyData = undefined;
                _this._legacyDataDirty = false;
                _this._events = _initializer9$a && _initializer9$a();
                _this._embeddedPlayers = _initializer10$9 && _initializer10$9();
                _this._runtimeEvents = {
                  ratios: [],
                  eventGroups: []
                };
                return _this;
              }

              AnimationClip.createWithSpriteFrames = function createWithSpriteFrames(spriteFrames, sample) {
                var clip = new AnimationClip();
                clip.sample = sample || clip.sample;
                clip.duration = spriteFrames.length / clip.sample;
                var step = 1 / clip.sample;
                var track = new ObjectTrack();
                track.path = new TrackPath().toComponent('cc.Sprite').toProperty('spriteFrame');
                var curve = track.channels()[0].curve;
                curve.assignSorted(spriteFrames.map(function (spriteFrame, index) {
                  return [step * index, spriteFrame];
                }));
                clip.addTrack(track);
                return clip;
              };

              var _proto = AnimationClip.prototype;

              _proto.onLoaded = function onLoaded() {
                this.frameRate = this.sample;
                this.events = this._events;
              };

              _proto.range = function range() {
                var range = {
                  min: Infinity,
                  max: -Infinity
                };
                var tracks = this._tracks;
                var nTracks = tracks.length;

                for (var iTrack = 0; iTrack < nTracks; ++iTrack) {
                  var track = tracks[iTrack];
                  var trackRange = track.range();
                  range.min = Math.min(range.min, trackRange.min);
                  range.max = Math.max(range.max, trackRange.max);
                }

                return range;
              };

              _proto.getTrack = function getTrack(index) {
                return this._tracks[index];
              };

              _proto.addTrack = function addTrack(track) {
                var index = this._tracks.length;

                this._tracks.push(track);

                return index;
              };

              _proto.removeTrack = function removeTrack(index) {
                this._tracks.splice(index, 1);
              };

              _proto.clearTracks = function clearTracks() {
                this._tracks.length = 0;
              };

              _proto.containsAnyEvent = function containsAnyEvent() {
                return this._events.length !== 0;
              };

              _proto.createEventEvaluator = function createEventEvaluator(targetNode) {
                return new EventEvaluator(targetNode, this._runtimeEvents.ratios, this._runtimeEvents.eventGroups, this.wrapMode);
              };

              _proto.containsAnyEmbeddedPlayer = function containsAnyEmbeddedPlayer() {
                return this._embeddedPlayers.length !== 0;
              };

              _proto.createEmbeddedPlayerEvaluator = function createEmbeddedPlayerEvaluator(targetNode) {
                return new EmbeddedPlayerEvaluation(this._embeddedPlayers, targetNode);
              };

              _proto.createEvaluator = function createEvaluator(context) {
                var _this2 = this;

                var target = context.target;

                var binder = function binder(binding) {
                  if (context.mask && binding.isMaskedOff(context.mask)) {
                    return undefined;
                  }

                  var trackTarget = binding.createRuntimeBinding(target, _this2.enableTrsBlending ? context.pose : undefined, false);

                  if ( !trackTarget) {
                    warnID(3937, _this2.name, context.target instanceof Node ? context.target.name : context.target);
                  }

                  return trackTarget !== null && trackTarget !== void 0 ? trackTarget : undefined;
                };

                return this._createEvalWithBinder(target, binder, context.rootMotion);
              };

              _proto.destroy = function destroy() {
                var _cclegacy$director$ro;

                if ((_cclegacy$director$ro = legacyCC.director.root) !== null && _cclegacy$director$ro !== void 0 && _cclegacy$director$ro.dataPoolManager) {
                  legacyCC.director.root.dataPoolManager.releaseAnimationClip(this);
                }

                SkelAnimDataHub.destroy(this);
                return _Asset.prototype.destroy.call(this);
              };

              _proto[BAKE_SKELETON_CURVE_SYMBOL] = function (start, samples, frames) {
                var step = 1.0 / samples;

                var animatedJoints = this._collectAnimatedJoints();

                var nAnimatedJoints = animatedJoints.length;
                var jointsBakeInfo = {};

                for (var iAnimatedJoint = 0; iAnimatedJoint < nAnimatedJoints; ++iAnimatedJoint) {
                  var joint = animatedJoints[iAnimatedJoint];
                  jointsBakeInfo[joint] = {
                    transforms: Array.from({
                      length: frames
                    }, function () {
                      return new Mat4();
                    })
                  };
                }

                var skeletonFrames = animatedJoints.reduce(function (result, joint) {
                  result[joint] = new BoneGlobalTransform();
                  return result;
                }, {});

                for (var _joint in skeletonFrames) {
                  var skeletonFrame = skeletonFrames[_joint];

                  var parentJoint = _joint.lastIndexOf('/');

                  if (parentJoint >= 0) {
                    var parentJointName = _joint.substring(0, parentJoint);

                    var parentJointFrame = skeletonFrames[parentJointName];

                    if (parentJointFrame) {
                      skeletonFrame.parent = parentJointFrame;
                    }
                  }
                }

                var binder = function binder(binding) {
                  var trsPath = binding.parseTrsPath();

                  if (!trsPath) {
                    return undefined;
                  }

                  var jointFrame = skeletonFrames[trsPath.node];

                  if (!jointFrame) {
                    return undefined;
                  }

                  return createBoneTransformBinding(jointFrame, trsPath.property);
                };

                var evaluator = this._createEvalWithBinder(undefined, binder, undefined);

                for (var iFrame = 0; iFrame < frames; ++iFrame) {
                  var time = start + step * iFrame;
                  evaluator.evaluate(time);

                  for (var _iAnimatedJoint = 0; _iAnimatedJoint < nAnimatedJoints; ++_iAnimatedJoint) {
                    var _joint2 = animatedJoints[_iAnimatedJoint];
                    Mat4.copy(jointsBakeInfo[_joint2].transforms[iFrame], skeletonFrames[_joint2].globalTransform);
                  }

                  for (var _iAnimatedJoint2 = 0; _iAnimatedJoint2 < nAnimatedJoints; ++_iAnimatedJoint2) {
                    var _joint3 = animatedJoints[_iAnimatedJoint2];

                    skeletonFrames[_joint3].invalidate();
                  }
                }

                return {
                  samples: samples,
                  frames: frames,
                  joints: jointsBakeInfo
                };
              };

              _proto.upgradeUntypedTracks = function upgradeUntypedTracks(refine) {
                var newTracks = [];
                var removals = [];
                var tracks = this._tracks;
                var nTracks = tracks.length;

                for (var iTrack = 0; iTrack < nTracks; ++iTrack) {
                  var track = tracks[iTrack];

                  if (!(track instanceof UntypedTrack)) {
                    continue;
                  }

                  var newTrack = track.upgrade(refine);

                  if (newTrack) {
                    newTracks.push(newTrack);
                    removals.push(track);
                  }
                }

                var nRemovalTracks = removals.length;

                for (var iRemovalTrack = 0; iRemovalTrack < nRemovalTracks; ++iRemovalTrack) {
                  remove(tracks, removals[iRemovalTrack]);
                }

                tracks.push.apply(tracks, newTracks);
              };

              _proto[searchForRootBonePathSymbol] = function () {
                return this._searchForRootBonePath();
              };

              _proto.getPropertyCurves = function getPropertyCurves() {
                return this._getLegacyData().getPropertyCurves();
              };

              _proto.updateEventDatas = function updateEventDatas() {
                this.events = this._events;
              };

              _proto.hasEvents = function hasEvents() {
                return this.events.length !== 0;
              };

              _proto.syncLegacyData = function syncLegacyData() {
                if (this._legacyData) {
                  this._fromLegacy(this._legacyData);

                  this._legacyData = undefined;
                }
              };

              _proto[getEmbeddedPlayersTag] = function () {
                return this._embeddedPlayers;
              };

              _proto[addEmbeddedPlayerTag] = function (embeddedPlayer) {
                this._embeddedPlayers.push(embeddedPlayer);
              };

              _proto[removeEmbeddedPlayerTag] = function (embeddedPlayer) {
                var iEmbeddedPlayer = this._embeddedPlayers.indexOf(embeddedPlayer);

                if (iEmbeddedPlayer >= 0) {
                  this._embeddedPlayers.splice(iEmbeddedPlayer, 1);
                }
              };

              _proto[clearEmbeddedPlayersTag] = function () {
                this._embeddedPlayers.length = 0;
              };

              _proto._createEvalWithBinder = function _createEvalWithBinder(target, binder, rootMotionOptions) {
                if (this._legacyDataDirty) {
                  this._legacyDataDirty = false;
                  this.syncLegacyData();
                }

                var rootMotionTrackExcludes = [];
                var rootMotionEvaluation;

                if (rootMotionOptions) {
                  rootMotionEvaluation = this._createRootMotionEvaluation(target, rootMotionOptions, rootMotionTrackExcludes);
                }

                var trackEvalStatues = [];
                var exoticAnimationEvaluator;
                var tracks = this._tracks;
                var nTracks = tracks.length;

                for (var iTrack = 0; iTrack < nTracks; ++iTrack) {
                  var track = tracks[iTrack];

                  if (rootMotionTrackExcludes.includes(track)) {
                    continue;
                  }

                  if (Array.from(track.channels()).every(function (_ref) {
                    var curve = _ref.curve;
                    return curve.keyFramesCount === 0;
                  })) {
                    continue;
                  }

                  var trackTarget = binder(track[trackBindingTag]);

                  if (!trackTarget) {
                    continue;
                  }

                  var trackEval = track[createEvalSymbol](trackTarget);
                  trackEvalStatues.push({
                    binding: trackTarget,
                    trackEval: trackEval
                  });
                }

                if (this._exoticAnimation) {
                  exoticAnimationEvaluator = this._exoticAnimation.createEvaluator(binder);
                }

                var evaluation = new AnimationClipEvaluation(trackEvalStatues, exoticAnimationEvaluator, rootMotionEvaluation);
                return evaluation;
              };

              _proto._createRootMotionEvaluation = function _createRootMotionEvaluation(target, rootMotionOptions, rootMotionTrackExcludes) {
                if (!(target instanceof Node)) {
                  errorID(3920);
                  return undefined;
                }

                var rootBonePath = this._searchForRootBonePath();

                if (!rootBonePath) {
                  warnID(3923);
                  return undefined;
                }

                var rootBone = target.getChildByPath(rootBonePath);

                if (!rootBone) {
                  warnID(3924);
                  return undefined;
                }

                var boneTransform = new BoneTransform();
                var rootMotionsTrackEvaluations = [];
                var tracks = this._tracks;
                var nTracks = tracks.length;

                for (var iTrack = 0; iTrack < nTracks; ++iTrack) {
                  var track = tracks[iTrack];
                  var trackBinding = track[trackBindingTag];
                  var trsPath = trackBinding.parseTrsPath();

                  if (!trsPath) {
                    continue;
                  }

                  var bonePath = trsPath.node;

                  if (bonePath !== rootBonePath) {
                    continue;
                  }

                  rootMotionTrackExcludes.push(track);
                  var property = trsPath.property;
                  var trackTarget = createBoneTransformBinding(boneTransform, property);

                  if (!trackTarget) {
                    continue;
                  }

                  var trackEval = track[createEvalSymbol](trackTarget);
                  rootMotionsTrackEvaluations.push({
                    binding: trackTarget,
                    trackEval: trackEval
                  });
                }

                var rootMotionEvaluation = new RootMotionEvaluation(rootBone, this._duration, boneTransform, rootMotionsTrackEvaluations);
                return rootMotionEvaluation;
              };

              _proto._searchForRootBonePath = function _searchForRootBonePath() {
                var paths = this._tracks.map(function (track) {
                  var trsPath = track[trackBindingTag].parseTrsPath();

                  if (trsPath) {
                    var nodePath = trsPath.node;
                    return {
                      path: nodePath,
                      rank: nodePath.split('/').length
                    };
                  } else {
                    return {
                      path: '',
                      rank: 0
                    };
                  }
                });

                paths.sort(function (a, b) {
                  return a.rank - b.rank;
                });
                var iNonEmptyPath = paths.findIndex(function (p) {
                  return p.rank !== 0;
                });

                if (iNonEmptyPath < 0) {
                  return '';
                }

                var nPaths = paths.length;
                var firstPath = paths[iNonEmptyPath];
                var highestPathsAreSame = true;

                for (var iPath = iNonEmptyPath + 1; iPath < nPaths; ++iPath) {
                  var path = paths[iPath];

                  if (path.rank !== firstPath.rank) {
                    break;
                  }

                  if (path.path !== firstPath.path) {
                    highestPathsAreSame = false;
                    break;
                  }
                }

                return highestPathsAreSame ? firstPath.path : '';
              };

              _proto._getLegacyData = function _getLegacyData() {
                if (!this._legacyData) {
                  this._legacyData = this._toLegacy();
                }

                return this._legacyData;
              };

              _proto._toLegacy = function _toLegacy() {
                var keys = [];
                var legacyCurves = [];
                var commonTargets = [];
                var legacyClipData = new AnimationClipLegacyData(this._duration);
                legacyClipData.keys = keys;
                legacyClipData.curves = legacyCurves;
                legacyClipData.commonTargets = commonTargets;
                return legacyClipData;
              };

              _proto._fromLegacy = function _fromLegacy(legacyData) {
                var newTracks = legacyData.toTracks();
                var nNewTracks = newTracks.length;

                for (var iNewTrack = 0; iNewTrack < nNewTracks; ++iNewTrack) {
                  this.addTrack(newTracks[iNewTrack]);
                }
              };

              _proto._collectAnimatedJoints = function _collectAnimatedJoints() {
                var joints = new Set();
                var tracks = this._tracks;
                var nTracks = tracks.length;

                for (var iTrack = 0; iTrack < nTracks; ++iTrack) {
                  var track = tracks[iTrack];
                  var trsPath = track[trackBindingTag].parseTrsPath();

                  if (trsPath) {
                    joints.add(trsPath.node);
                  }
                }

                if (this._exoticAnimation) {
                  var animatedJoints = this._exoticAnimation.collectAnimatedJoints();

                  var nAnimatedJoints = animatedJoints.length;

                  for (var iAnimatedJoint = 0; iAnimatedJoint < nAnimatedJoints; ++iAnimatedJoint) {
                    joints.add(animatedJoints[iAnimatedJoint]);
                  }
                }

                return Array.from(joints);
              };

              _createClass(AnimationClip, [{
                key: "duration",
                get: function get() {
                  return this._duration;
                },
                set: function set(value) {
                  this._duration = value;
                }
              }, {
                key: "tracksCount",
                get: function get() {
                  return this._tracks.length;
                }
              }, {
                key: "tracks",
                get: function get() {
                  return this._tracks;
                }
              }, {
                key: "hash",
                get: function get() {
                  var _this$_exoticAnimatio, _this$_exoticAnimatio2;

                  if (this._hash) {
                    return this._hash;
                  }

                  var hashString = "Exotic:" + ((_this$_exoticAnimatio = (_this$_exoticAnimatio2 = this._exoticAnimation) === null || _this$_exoticAnimatio2 === void 0 ? void 0 : _this$_exoticAnimatio2.toHashString()) !== null && _this$_exoticAnimatio !== void 0 ? _this$_exoticAnimatio : '');
                  return this._hash = murmurhash2_32_gc(hashString, 666);
                }
              }, {
                key: "events",
                get: function get() {
                  return this._events;
                },
                set: function set(value) {
                  var _this3 = this;

                  this._events = value;
                  var ratios = [];
                  var eventGroups = [];
                  var events = this.events.sort(function (a, b) {
                    return a.frame - b.frame;
                  });
                  var nEvents = events.length;

                  var _loop = function _loop(iEvent) {
                    var eventData = events[iEvent];
                    var ratio = eventData.frame / _this3._duration;
                    var i = ratios.findIndex(function (r) {
                      return r === ratio;
                    });

                    if (i < 0) {
                      i = ratios.length;
                      ratios.push(ratio);
                      eventGroups.push({
                        events: []
                      });
                    }

                    eventGroups[i].events.push({
                      functionName: eventData.func,
                      parameters: eventData.params
                    });
                  };

                  for (var iEvent = 0; iEvent < nEvents; ++iEvent) {
                    _loop(iEvent);
                  }

                  this._runtimeEvents = {
                    ratios: ratios,
                    eventGroups: eventGroups
                  };
                }
              }, {
                key: exoticAnimationTag,
                get: function get() {
                  return this._exoticAnimation;
                }
              }, {
                key: exoticAnimationTag,
                set: function set(value) {
                  this._exoticAnimation = value;
                }
              }, {
                key: "keys",
                get: function get() {
                  return this._getLegacyData().keys;
                }
              }, {
                key: "keys",
                set: function set(value) {
                  this._legacyDataDirty = true;
                  this._getLegacyData().keys = value;
                }
              }, {
                key: "curves",
                get: function get() {
                  this._legacyDataDirty = true;
                  return this._getLegacyData().curves;
                }
              }, {
                key: "curves",
                set: function set(value) {
                  this._getLegacyData().curves = value;
                }
              }, {
                key: "commonTargets",
                get: function get() {
                  return this._getLegacyData().commonTargets;
                }
              }, {
                key: "commonTargets",
                set: function set(value) {
                  this._legacyDataDirty = true;
                  this._getLegacyData().commonTargets = value;
                }
              }, {
                key: "data",
                get: function get() {
                  return this._getLegacyData().data;
                }
              }, {
                key: "eventGroups",
                get: function get() {
                  return this._runtimeEvents.eventGroups;
                }
              }, {
                key: embeddedPlayerCountTag,
                get: function get() {
                  return this._embeddedPlayers.length;
                }
              }]);

              return AnimationClip;
            }(Asset), _class3$9.WrapMode = WrapMode, _temp$c), (_initializer$H = applyDecoratedInitializer(_class2$J.prototype, "sample", [serializable$j], function () {
              return 60;
            }), _initializer2$z = applyDecoratedInitializer(_class2$J.prototype, "speed", [serializable$j], function () {
              return 1;
            }), _initializer3$o = applyDecoratedInitializer(_class2$J.prototype, "wrapMode", [serializable$j], function () {
              return WrapMode.Normal;
            }), _initializer4$m = applyDecoratedInitializer(_class2$J.prototype, "enableTrsBlending", [serializable$j], function () {
              return false;
            }), _initializer5$i = applyDecoratedInitializer(_class2$J.prototype, "_duration", [serializable$j], function () {
              return 0;
            }), _initializer6$f = applyDecoratedInitializer(_class2$J.prototype, "_hash", [serializable$j], function () {
              return 0;
            }), _initializer7$b = applyDecoratedInitializer(_class2$J.prototype, "_tracks", [serializable$j], function () {
              return [];
            }), _initializer8$b = applyDecoratedInitializer(_class2$J.prototype, "_exoticAnimation", [serializable$j], function () {
              return null;
            }), _initializer9$a = applyDecoratedInitializer(_class2$J.prototype, "_events", [serializable$j], function () {
              return [];
            }), _initializer10$9 = applyDecoratedInitializer(_class2$J.prototype, "_embeddedPlayers", [serializable$j], function () {
              return [];
            })), _class2$J)) || _class$S));
            legacyCC.AnimationClip = AnimationClip;

            var EmbeddedPlayerEvaluation = function () {
              function EmbeddedPlayerEvaluation(embeddedPlayers, rootNode) {
                this._embeddedPlayers = embeddedPlayers;
                this._embeddedPlayerEvaluationInfos = embeddedPlayers.map(function (embeddedPlayer) {
                  var player = embeddedPlayer.playable;

                  if (!player) {
                    return null;
                  }

                  var instantiatedPlayer = player.instantiate(rootNode);

                  if (!instantiatedPlayer) {
                    return null;
                  }

                  return {
                    instantiatedPlayer: instantiatedPlayer,
                    entered: false,
                    hostPauseTime: 0.0,
                    lastIterations: 0
                  };
                });
              }

              var _proto2 = EmbeddedPlayerEvaluation.prototype;

              _proto2.destroy = function destroy() {
                var embeddedPlayerEvaluationInfos = this._embeddedPlayerEvaluationInfos;
                var nEmbeddedPlayers = embeddedPlayerEvaluationInfos.length;

                for (var iEmbeddedPlayer = 0; iEmbeddedPlayer < nEmbeddedPlayers; ++iEmbeddedPlayer) {
                  var _embeddedPlayerEvalua;

                  (_embeddedPlayerEvalua = embeddedPlayerEvaluationInfos[iEmbeddedPlayer]) === null || _embeddedPlayerEvalua === void 0 ? void 0 : _embeddedPlayerEvalua.instantiatedPlayer.destroy();
                }

                this._embeddedPlayerEvaluationInfos.length = 0;
              };

              _proto2.evaluate = function evaluate(time, iterations) {
                assertIsTrue(Number.isInteger(iterations));
                var embeddedPlayers = this._embeddedPlayers,
                    embeddedPlayerEvaluationInfos = this._embeddedPlayerEvaluationInfos;
                var nEmbeddedPlayers = embeddedPlayers.length;

                for (var iEmbeddedPlayer = 0; iEmbeddedPlayer < nEmbeddedPlayers; ++iEmbeddedPlayer) {
                  var embeddedPlayerEvaluationInfo = embeddedPlayerEvaluationInfos[iEmbeddedPlayer];

                  if (!embeddedPlayerEvaluationInfo) {
                    continue;
                  }

                  var entered = embeddedPlayerEvaluationInfo.entered,
                      instantiatedPlayer = embeddedPlayerEvaluationInfo.instantiatedPlayer,
                      lastIterations = embeddedPlayerEvaluationInfo.lastIterations;
                  var _embeddedPlayers$iEmb = embeddedPlayers[iEmbeddedPlayer],
                      begin = _embeddedPlayers$iEmb.begin,
                      end = _embeddedPlayers$iEmb.end;
                  var withinEmbeddedPlayer = time >= begin && time <= end;

                  if (withinEmbeddedPlayer) {
                    if (!entered) {
                      instantiatedPlayer.play();
                      embeddedPlayerEvaluationInfo.entered = true;
                    } else if (iterations !== lastIterations) {
                      instantiatedPlayer.stop();
                      instantiatedPlayer.play();
                      embeddedPlayerEvaluationInfo.entered = true;
                    }
                  } else if (entered) {
                    instantiatedPlayer.stop();
                    embeddedPlayerEvaluationInfo.entered = false;
                  }

                  embeddedPlayerEvaluationInfo.lastIterations = iterations;

                  if (embeddedPlayerEvaluationInfo.entered) {
                    var playerTime = time - begin;
                    embeddedPlayerEvaluationInfo.instantiatedPlayer.setTime(playerTime);
                  }
                }
              };

              _proto2.notifyHostSpeedChanged = function notifyHostSpeedChanged(speed) {
                var embeddedPlayers = this._embeddedPlayers,
                    embeddedPlayerEvaluationInfos = this._embeddedPlayerEvaluationInfos;
                var nEmbeddedPlayers = embeddedPlayers.length;

                for (var iEmbeddedPlayer = 0; iEmbeddedPlayer < nEmbeddedPlayers; ++iEmbeddedPlayer) {
                  var embeddedPlayerEvaluationInfo = embeddedPlayerEvaluationInfos[iEmbeddedPlayer];

                  if (!embeddedPlayerEvaluationInfo) {
                    continue;
                  }

                  var instantiatedPlayer = embeddedPlayerEvaluationInfo.instantiatedPlayer;
                  var reconciledSpeed = embeddedPlayers[iEmbeddedPlayer].reconciledSpeed;

                  if (reconciledSpeed) {
                    instantiatedPlayer.setSpeed(speed);
                  }
                }
              };

              _proto2.notifyHostPlay = function notifyHostPlay(time) {
                var embeddedPlayers = this._embeddedPlayers,
                    embeddedPlayerEvaluationInfos = this._embeddedPlayerEvaluationInfos;
                var nEmbeddedPlayers = embeddedPlayers.length;

                for (var iEmbeddedPlayer = 0; iEmbeddedPlayer < nEmbeddedPlayers; ++iEmbeddedPlayer) {
                  var embeddedPlayerEvaluationInfo = embeddedPlayerEvaluationInfos[iEmbeddedPlayer];

                  if (!embeddedPlayerEvaluationInfo) {
                    continue;
                  }

                  var _embeddedPlayers$iEmb2 = embeddedPlayers[iEmbeddedPlayer],
                      begin = _embeddedPlayers$iEmb2.begin,
                      end = _embeddedPlayers$iEmb2.end;
                  var instantiatedPlayer = embeddedPlayerEvaluationInfo.instantiatedPlayer,
                      entered = embeddedPlayerEvaluationInfo.entered;

                  if (entered) {
                    var hostPauseTime = embeddedPlayerEvaluationInfo.hostPauseTime;

                    if (instantiatedPlayer.randomAccess || approx(hostPauseTime, time, 1e-5)) {
                      var startTime = clamp$1(time, begin, end);
                      instantiatedPlayer.play();
                      instantiatedPlayer.setTime(startTime - begin);
                    } else {
                      instantiatedPlayer.stop();
                    }
                  }
                }
              };

              _proto2.notifyHostPause = function notifyHostPause(time) {
                var embeddedPlayers = this._embeddedPlayers,
                    embeddedPlayerEvaluationInfos = this._embeddedPlayerEvaluationInfos;
                var nEmbeddedPlayers = embeddedPlayers.length;

                for (var iEmbeddedPlayer = 0; iEmbeddedPlayer < nEmbeddedPlayers; ++iEmbeddedPlayer) {
                  var embeddedPlayerEvaluationInfo = embeddedPlayerEvaluationInfos[iEmbeddedPlayer];

                  if (!embeddedPlayerEvaluationInfo) {
                    continue;
                  }

                  var instantiatedPlayer = embeddedPlayerEvaluationInfo.instantiatedPlayer,
                      entered = embeddedPlayerEvaluationInfo.entered;

                  if (entered) {
                    instantiatedPlayer.pause();
                    embeddedPlayerEvaluationInfo.hostPauseTime = time;
                  }
                }
              };

              _proto2.notifyHostStop = function notifyHostStop() {
                var embeddedPlayers = this._embeddedPlayers,
                    embeddedPlayerEvaluationInfos = this._embeddedPlayerEvaluationInfos;
                var nEmbeddedPlayers = embeddedPlayers.length;

                for (var iEmbeddedPlayer = 0; iEmbeddedPlayer < nEmbeddedPlayers; ++iEmbeddedPlayer) {
                  var embeddedPlayerEvaluationInfo = embeddedPlayerEvaluationInfos[iEmbeddedPlayer];

                  if (!embeddedPlayerEvaluationInfo) {
                    continue;
                  }

                  var instantiatedPlayer = embeddedPlayerEvaluationInfo.instantiatedPlayer,
                      entered = embeddedPlayerEvaluationInfo.entered;

                  if (entered) {
                    embeddedPlayerEvaluationInfo.entered = false;
                    instantiatedPlayer.stop();
                  }
                }
              };

              return EmbeddedPlayerEvaluation;
            }();

            var AnimationClipEvaluation = function () {
              function AnimationClipEvaluation(trackEvalStatuses, exoticAnimationEvaluator, rootMotionEvaluation) {
                this._exoticAnimationEvaluator = void 0;
                this._trackEvalStatues = [];
                this._rootMotionEvaluation = undefined;
                this._trackEvalStatues = trackEvalStatuses;
                this._exoticAnimationEvaluator = exoticAnimationEvaluator;
                this._rootMotionEvaluation = rootMotionEvaluation;
              }

              var _proto3 = AnimationClipEvaluation.prototype;

              _proto3.evaluate = function evaluate(time) {
                var trackEvalStatuses = this._trackEvalStatues,
                    exoticAnimationEvaluator = this._exoticAnimationEvaluator;
                var nTrackEvalStatuses = trackEvalStatuses.length;

                for (var iTrackEvalStatus = 0; iTrackEvalStatus < nTrackEvalStatuses; ++iTrackEvalStatus) {
                  var _trackEvalStatuses$iT = trackEvalStatuses[iTrackEvalStatus],
                      trackEval = _trackEvalStatuses$iT.trackEval,
                      binding = _trackEvalStatuses$iT.binding;
                  var value = trackEval.evaluate(time, binding);
                  binding.setValue(value);
                }

                if (exoticAnimationEvaluator) {
                  exoticAnimationEvaluator.evaluate(time);
                }
              };

              _proto3.evaluateRootMotion = function evaluateRootMotion(time, motionLength) {
                var rootMotionEvaluation = this._rootMotionEvaluation;

                if (rootMotionEvaluation) {
                  rootMotionEvaluation.evaluate(time, motionLength);
                }
              };

              return AnimationClipEvaluation;
            }();

            var BoneTransform = function () {
              function BoneTransform() {
                this.position = new Vec3();
                this.scale = new Vec3(1.0, 1.0, 1.0);
                this.rotation = new Quat();
                this.eulerAngles = new Vec3();
              }

              var _proto4 = BoneTransform.prototype;

              _proto4.getTransform = function getTransform(out) {
                Mat4.fromRTS(out, this.rotation, this.position, this.scale);
              };

              return BoneTransform;
            }();

            var BoneGlobalTransform = function (_BoneTransform) {
              _inheritsLoose(BoneGlobalTransform, _BoneTransform);

              function BoneGlobalTransform() {
                var _this4;

                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args[_key3] = arguments[_key3];
                }

                _this4 = _BoneTransform.call.apply(_BoneTransform, [this].concat(args)) || this;
                _this4.parent = null;
                _this4._dirty = true;
                _this4._transform = new Mat4();
                return _this4;
              }

              var _proto5 = BoneGlobalTransform.prototype;

              _proto5.invalidate = function invalidate() {
                this._dirty = true;
              };

              _createClass(BoneGlobalTransform, [{
                key: "globalTransform",
                get: function get() {
                  var transform = this._transform;

                  if (this._dirty) {
                    this._dirty = false;
                    Mat4.fromRTS(transform, this.rotation, this.position, this.scale);

                    if (this.parent) {
                      Mat4.multiply(transform, this.parent.globalTransform, transform);
                    }
                  }

                  return this._transform;
                }
              }]);

              return BoneGlobalTransform;
            }(BoneTransform);

            var motionTransformCache = new Mat4();

            var RootMotionEvaluation = function () {
              function RootMotionEvaluation(_rootBone, _duration, _boneTransform, _trackEvalStatuses) {
                this._initialTransformCache = new Mat4();
                this._clipEndTransformCache = new Mat4();
                this._startTransformCache = new Mat4();
                this._endTransformCache = new Mat4();
                this._motionTransformCache = new Mat4();
                this._translationMotionCache = new Vec3();
                this._rotationMotionCache = new Quat();
                this._scaleMotionCache = new Vec3();
                this._rootBone = _rootBone;
                this._duration = _duration;
                this._boneTransform = _boneTransform;
                this._trackEvalStatuses = _trackEvalStatuses;
              }

              var _proto6 = RootMotionEvaluation.prototype;

              _proto6.evaluate = function evaluate(time, motionLength) {
                var motionTransform = this._calcMotionTransform(time, motionLength, this._motionTransformCache);

                var translationMotion = this._translationMotionCache,
                    rotationMotion = this._rotationMotionCache,
                    scaleMotion = this._scaleMotionCache,
                    rootBone = this._rootBone;
                Mat4.toRTS(motionTransform, rotationMotion, translationMotion, scaleMotion);
                Vec3.add(translationMotion, translationMotion, rootBone.position);
                rootBone.setPosition(translationMotion);
                Quat.multiply(rotationMotion, rotationMotion, rootBone.rotation);
                rootBone.setRotation(rotationMotion);
                Vec3.multiply(scaleMotion, scaleMotion, rootBone.scale);
                rootBone.setScale(scaleMotion);
              };

              _proto6._calcMotionTransform = function _calcMotionTransform(time, motionLength, outTransform) {
                var duration = this._duration;
                var remainLength = duration - time;
                assertIsTrue(remainLength >= 0);

                var startTransform = this._evaluateAt(time, this._startTransformCache);

                if (motionLength < remainLength) {
                  var endTransform = this._evaluateAt(time + motionLength, this._endTransformCache);

                  relativeTransform(outTransform, startTransform, endTransform);
                } else {
                  Mat4.identity(outTransform);

                  var accumulateMotionTransform = function accumulateMotionTransform(from, to) {
                    relativeTransform(motionTransformCache, from, to);
                    Mat4.multiply(outTransform, outTransform, motionTransformCache);
                  };

                  var diff = motionLength - remainLength;
                  var repeatCount = Math.floor(diff / duration);
                  var lastRemainTime = diff - repeatCount * duration;

                  var clipStartTransform = this._evaluateAt(0, this._initialTransformCache);

                  var clipEndTransform = this._evaluateAt(duration, this._clipEndTransformCache);

                  var _endTransform = this._evaluateAt(lastRemainTime, this._endTransformCache);

                  accumulateMotionTransform(startTransform, clipEndTransform);
                  relativeTransform(motionTransformCache, clipStartTransform, clipEndTransform);

                  for (var i = 0; i < repeatCount; ++i) {
                    Mat4.multiply(outTransform, outTransform, motionTransformCache);
                  }

                  accumulateMotionTransform(clipStartTransform, _endTransform);
                }

                return outTransform;
              };

              _proto6._evaluateAt = function _evaluateAt(time, outTransform) {
                var trackEvalStatuses = this._trackEvalStatuses;
                var nTrackEvalStatuses = trackEvalStatuses.length;

                for (var iTrackEvalStatus = 0; iTrackEvalStatus < nTrackEvalStatuses; ++iTrackEvalStatus) {
                  var _trackEvalStatuses$iT2 = trackEvalStatuses[iTrackEvalStatus],
                      trackEval = _trackEvalStatuses$iT2.trackEval,
                      binding = _trackEvalStatuses$iT2.binding;
                  var value = trackEval.evaluate(time, binding);
                  binding.setValue(value);
                }

                this._boneTransform.getTransform(outTransform);

                return outTransform;
              };

              return RootMotionEvaluation;
            }();

            function relativeTransform(out, from, to) {
              Mat4.invert(out, from);
              Mat4.multiply(out, to, out);
            }

            function createBoneTransformBinding(boneTransform, property) {
              switch (property) {
                default:
                  return undefined;

                case 'position':
                  return {
                    setValue: function setValue(value) {
                      Vec3.copy(boneTransform.position, value);
                    }
                  };

                case 'rotation':
                  return {
                    setValue: function setValue(value) {
                      Quat.copy(boneTransform.rotation, value);
                    }
                  };

                case 'scale':
                  return {
                    setValue: function setValue(value) {
                      Vec3.copy(boneTransform.scale, value);
                    }
                  };

                case 'eulerAngles':
                  return {
                    setValue: function setValue(value) {
                      Vec3.copy(boneTransform.eulerAngles, value);
                    }
                  };
              }
            }

            var InvalidIndex = -1;

            var EventEvaluator = function () {
              function EventEvaluator(_targetNode, _ratios, _eventGroups, _wrapMode) {
                this._lastFrameIndex = -1;
                this._lastIterations = 0.0;
                this._lastDirection = 0;
                this._ignoreIndex = InvalidIndex;
                this._sampled = false;
                this._targetNode = _targetNode;
                this._ratios = _ratios;
                this._eventGroups = _eventGroups;
                this._wrapMode = _wrapMode;
              }

              var _proto7 = EventEvaluator.prototype;

              _proto7.setWrapMode = function setWrapMode(wrapMode) {
                this._wrapMode = wrapMode;
              };

              _proto7.ignore = function ignore(ratio, direction) {
                this._ignoreIndex = InvalidIndex;
                this._sampled = false;
                var frameIndex = getEventGroupIndexAtRatio(ratio, this._ratios);

                if (frameIndex < 0) {
                  frameIndex = ~frameIndex - 1;

                  if (direction < 0) {
                    frameIndex += 1;
                  }

                  this._ignoreIndex = frameIndex;
                }
              };

              _proto7.sample = function sample(ratio, direction, iterations) {
                var length = this._eventGroups.length;
                var eventIndex = getEventGroupIndexAtRatio(ratio, this._ratios);

                if (eventIndex < 0) {
                  eventIndex = ~eventIndex - 1;

                  if (direction < 0) {
                    eventIndex += 1;
                  }
                }

                if (this._ignoreIndex !== eventIndex) {
                  this._ignoreIndex = InvalidIndex;
                }

                if (!this._sampled) {
                  this._sampled = true;

                  this._doFire(eventIndex, false);

                  this._lastFrameIndex = eventIndex;
                  this._lastIterations = iterations;
                  this._lastDirection = direction;
                  return;
                }

                var wrapMode = this._wrapMode;
                var currentIterations = wrapIterations(iterations);
                var lastIterations = wrapIterations(this._lastIterations);
                var lastIndex = this._lastFrameIndex;
                var lastDirection = this._lastDirection;
                var iterationsChanged = lastIterations !== -1 && currentIterations !== lastIterations;

                if (lastIndex === eventIndex && iterationsChanged && length === 1) {
                  this._doFire(0, false);
                } else if (lastIndex !== eventIndex || iterationsChanged) {
                  direction = lastDirection;

                  do {
                    if (lastIndex !== eventIndex) {
                      if (direction === -1 && lastIndex === 0 && eventIndex > 0) {
                        if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
                          direction *= -1;
                        } else {
                          lastIndex = length;
                        }

                        lastIterations++;
                      } else if (direction === 1 && lastIndex === length - 1 && eventIndex < length - 1) {
                        if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
                          direction *= -1;
                        } else {
                          lastIndex = -1;
                        }

                        lastIterations++;
                      }

                      if (lastIndex === eventIndex) {
                        break;
                      }

                      if (lastIterations > currentIterations) {
                        break;
                      }
                    }

                    lastIndex += direction;

                    this._doFire(lastIndex, true);
                  } while (lastIndex !== eventIndex && lastIndex > -1 && lastIndex < length);
                }

                this._lastFrameIndex = eventIndex;
                this._lastIterations = iterations;
                this._lastDirection = direction;
              };

              _proto7._doFire = function _doFire(eventIndex, delay) {
                if (delay) {
                  getGlobalAnimationManager().pushDelayEvent(this._checkAndFire, this, [eventIndex]);
                } else {
                  this._checkAndFire(eventIndex);
                }
              };

              _proto7._checkAndFire = function _checkAndFire(eventIndex) {
                if (!this._targetNode || !this._targetNode.isValid) {
                  return;
                }

                var eventGroups = this._eventGroups;

                if (eventIndex < 0 || eventIndex >= eventGroups.length || this._ignoreIndex === eventIndex) {
                  return;
                }

                var eventGroup = eventGroups[eventIndex];
                var components = this._targetNode.components;
                var nEvents = eventGroup.events.length;

                for (var iEvent = 0; iEvent < nEvents; ++iEvent) {
                  var event = eventGroup.events[iEvent];
                  var functionName = event.functionName;
                  var nComponents = components.length;

                  for (var iComponent = 0; iComponent < nComponents; ++iComponent) {
                    var component = components[iComponent];
                    var fx = component[functionName];

                    if (typeof fx === 'function') {
                      fx.apply(component, event.parameters);
                    }
                  }
                }
              };

              return EventEvaluator;
            }();

            function wrapIterations(iterations) {
              if (iterations - (iterations | 0) === 0) {
                iterations -= 1;
              }

              return iterations | 0;
            }

            function getEventGroupIndexAtRatio(ratio, ratios) {
              var result = binarySearchEpsilon(ratios, ratio);
              return result;
            }

            var _dec$T, _dec2$B, _class$T, _class2$K, _initializer$I;
            var ccclass$6 = ccclass$p,
                type$3 = type$8;
            var ClipMotion = (_dec$T = ccclass$6('cc.animation.ClipMotion'), _dec2$B = type$3(AnimationClip), _dec$T(_class$T = (_class2$K = function (_EditorExtendable) {
              _inheritsLoose(ClipMotion, _EditorExtendable);

              function ClipMotion() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _EditorExtendable.call.apply(_EditorExtendable, [this].concat(args)) || this;
                _this.clip = _initializer$I && _initializer$I();
                return _this;
              }

              var _proto = ClipMotion.prototype;

              _proto[createEval] = function (context) {
                if (!this.clip) {
                  return null;
                }

                var clipMotionEval = new ClipMotionEval(context, this.clip);

                return clipMotionEval;
              };

              _proto.clone = function clone() {
                var that = new ClipMotion();
                that.clip = this.clip;
                that[editorExtrasTag] = cloneAnimationGraphEditorExtrasFrom(this);
                return that;
              };

              return ClipMotion;
            }(EditorExtendable), (_initializer$I = applyDecoratedInitializer(_class2$K.prototype, "clip", [_dec2$B], function () {
              return null;
            })), _class2$K)) || _class$T);

            var ClipMotionEval = function () {
              function ClipMotionEval(context, clip) {
                var _context$clipOverride, _context$clipOverride2;

                var overriding = (_context$clipOverride = (_context$clipOverride2 = context.clipOverrides) === null || _context$clipOverride2 === void 0 ? void 0 : _context$clipOverride2.get(clip)) !== null && _context$clipOverride !== void 0 ? _context$clipOverride : clip;
                this._duration = overriding.duration / overriding.speed;
                this._state = this._createState(overriding, context);
                this._originalClip = clip;
              }

              var _proto2 = ClipMotionEval.prototype;

              _proto2.getClipStatuses = function getClipStatuses(baseWeight) {
                var _this2 = this;

                var got = false;
                return {
                  next: function next() {
                    if (got) {
                      return {
                        done: true,
                        value: undefined
                      };
                    } else {
                      got = true;
                      return {
                        done: false,
                        value: {
                          __DEBUG_ID__: _this2.__DEBUG__ID__,
                          clip: _this2._state.clip,
                          weight: baseWeight
                        }
                      };
                    }
                  }
                };
              };

              _proto2.sample = function sample(progress, weight) {
                if (weight === 0.0) {
                  return;
                }

                var time = this._state.duration * progress;
                this._state.time = time;
                this._state.weight = weight;

                this._state.sample();

                this._state.weight = 0.0;
              };

              _proto2.overrideClips = function overrideClips(overrides, context) {
                var originalClip = this._originalClip;
                var overriding = overrides.get(originalClip);

                if (overriding) {
                  this._state.destroy();

                  this._state = this._createState(overriding, context);
                  this._duration = overriding.duration / overriding.speed;
                }
              };

              _proto2._createState = function _createState(clip, context) {
                var state = new AnimationState(clip);
                state.initialize(context.node, context.blendBuffer, context.mask);
                return state;
              };

              _createClass(ClipMotionEval, [{
                key: "duration",
                get: function get() {
                  return this._duration;
                }
              }, {
                key: "progress",
                get: function get() {
                  return this._state.time / this.duration;
                }
              }]);

              return ClipMotionEval;
            }();

            var _dec$U, _class$U, _class2$L, _initializer$J, _initializer2$A, _dec2$C, _class4$b, _class5$b, _initializer3$p, _initializer4$n;
            var ccclass$7 = ccclass$p,
                serializable$6 = serializable$j;
            var BindableNumber = (_dec$U = ccclass$7(CLASS_NAME_PREFIX_ANIM + "BindableNumber"), _dec$U(_class$U = (_class2$L = function () {
              function BindableNumber(value) {
                if (value === void 0) {
                  value = 0.0;
                }

                this.variable = _initializer$J && _initializer$J();
                this.value = _initializer2$A && _initializer2$A();
                this.value = value;
              }

              var _proto = BindableNumber.prototype;

              _proto.clone = function clone() {
                var that = new BindableNumber();
                that.value = this.value;
                that.variable = this.variable;
                return that;
              };

              return BindableNumber;
            }(), (_initializer$J = applyDecoratedInitializer(_class2$L.prototype, "variable", [serializable$6], function () {
              return '';
            }), _initializer2$A = applyDecoratedInitializer(_class2$L.prototype, "value", [serializable$6], function () {
              return 0.0;
            })), _class2$L)) || _class$U);
            var BindableBoolean = (_dec2$C = ccclass$7(CLASS_NAME_PREFIX_ANIM + "BindableBoolean"), _dec2$C(_class4$b = (_class5$b = function () {
              function BindableBoolean(value) {
                if (value === void 0) {
                  value = false;
                }

                this.variable = _initializer3$p && _initializer3$p();
                this.value = _initializer4$n && _initializer4$n();
                this.value = value;
              }

              var _proto2 = BindableBoolean.prototype;

              _proto2.clone = function clone() {
                var that = new BindableBoolean();
                that.value = this.value;
                that.variable = this.variable;
                return that;
              };

              return BindableBoolean;
            }(), (_initializer3$p = applyDecoratedInitializer(_class5$b.prototype, "variable", [serializable$6], function () {
              return '';
            }), _initializer4$n = applyDecoratedInitializer(_class5$b.prototype, "value", [serializable$6], function () {
              return false;
            })), _class5$b)) || _class4$b);
            function bindOr(context, bindable, type, callback, thisArg) {
              var variable = bindable.variable,
                  value = bindable.value;

              if (!variable) {
                return value;
              }

              var varInstance = context.getVar(variable);

              if (!validateVariableExistence(varInstance, variable)) {
                return value;
              }

              if (varInstance.type !== type) {
                throw new VariableTypeMismatchedError(variable, 'number');
              }

              for (var _len = arguments.length, args = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
                args[_key - 5] = arguments[_key];
              }

              var initialValue = varInstance.bind.apply(varInstance, [callback, thisArg].concat(args));
              return initialValue;
            }
            function bindNumericOr(context, bindable, type, callback, thisArg) {
              var variable = bindable.variable,
                  value = bindable.value;

              if (!variable) {
                return value;
              }

              var varInstance = context.getVar(variable);

              if (!validateVariableExistence(varInstance, variable)) {
                return value;
              }

              if (type !== VariableType.FLOAT && type !== VariableType.INTEGER) {
                throw new VariableTypeMismatchedError(variable, 'number or integer');
              }

              for (var _len2 = arguments.length, args = new Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {
                args[_key2 - 5] = arguments[_key2];
              }

              var initialValue = varInstance.bind.apply(varInstance, [callback, thisArg].concat(args));
              return initialValue;
            }
            function validateVariableExistence(varInstance, name) {
              if (!varInstance) {
                throw new VariableNotDefinedError(name);
              } else {
                return true;
              }
            }
            function validateVariableType(type, expected, name) {
              if (type !== expected) {
                throw new VariableTypeMismatchedError(name, 'number');
              }
            }
            function validateVariableTypeTriggerLike(type, name) {
              if (type !== VariableType.TRIGGER) {
                throw new VariableTypeMismatchedError(name, 'trigger');
              }
            }

            var _dec$V, _class$V, _class2$M, _initializer$K, _dec2$D, _class4$c, _class5$c, _initializer2$B;
            var ccclass$8 = ccclass$p,
                serializable$7 = serializable$j;
            var AnimationBlendItem = (_dec$V = ccclass$8(CLASS_NAME_PREFIX_ANIM + "AnimationBlendItem"), _dec$V(_class$V = (_class2$M = function () {
              function AnimationBlendItem() {
                this.motion = _initializer$K && _initializer$K();
              }

              var _proto = AnimationBlendItem.prototype;

              _proto.clone = function clone() {
                var that = new AnimationBlendItem();

                this._copyTo(that);

                return that;
              };

              _proto._copyTo = function _copyTo(that) {
                var _this$motion$clone, _this$motion;

                that.motion = (_this$motion$clone = (_this$motion = this.motion) === null || _this$motion === void 0 ? void 0 : _this$motion.clone()) !== null && _this$motion$clone !== void 0 ? _this$motion$clone : null;
                return that;
              };

              return AnimationBlendItem;
            }(), (_initializer$K = applyDecoratedInitializer(_class2$M.prototype, "motion", [serializable$7], function () {
              return null;
            })), _class2$M)) || _class$V);
            var AnimationBlend = (_dec2$D = ccclass$8(CLASS_NAME_PREFIX_ANIM + "AnimationBlend"), _dec2$D(_class4$c = (_class5$c = function (_EditorExtendable) {
              _inheritsLoose(AnimationBlend, _EditorExtendable);

              function AnimationBlend() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _EditorExtendable.call.apply(_EditorExtendable, [this].concat(args)) || this;
                _this.name = _initializer2$B && _initializer2$B();
                return _this;
              }

              var _proto2 = AnimationBlend.prototype;

              _proto2.copyTo = function copyTo(that) {
                that.name = this.name;
                that[editorExtrasTag] = cloneAnimationGraphEditorExtrasFrom(this);
              };

              return AnimationBlend;
            }(EditorExtendable), (_initializer2$B = applyDecoratedInitializer(_class5$c.prototype, "name", [serializable$7], function () {
              return '';
            })), _class5$c)) || _class4$c);
            var AnimationBlendEval = function () {
              function AnimationBlendEval(context, base, children, inputs) {
                this._childEvaluators = children.map(function (child) {
                  var _child$motion$createE, _child$motion;

                  return (_child$motion$createE = (_child$motion = child.motion) === null || _child$motion === void 0 ? void 0 : _child$motion[createEval](context)) !== null && _child$motion$createE !== void 0 ? _child$motion$createE : null;
                });
                this._weights = new Array(this._childEvaluators.length).fill(0);
                this._inputs = [].concat(inputs);
              }

              var _proto3 = AnimationBlendEval.prototype;

              _proto3.getChildWeight = function getChildWeight(childIndex) {
                return this._weights[childIndex];
              };

              _proto3.getChildMotionEval = function getChildMotionEval(childIndex) {
                return this._childEvaluators[childIndex];
              };

              _proto3.getClipStatuses = function getClipStatuses(baseWeight) {
                var children = this._childEvaluators,
                    weights = this._weights;
                var nChildren = children.length;
                var iChild = 0;
                var currentChildIterator;
                return {
                  next: function next() {
                    while (true) {
                      if (currentChildIterator) {
                        var result = currentChildIterator.next();

                        if (!result.done) {
                          return result;
                        }
                      }

                      if (iChild >= nChildren) {
                        return {
                          done: true,
                          value: undefined
                        };
                      } else {
                        var child = children[iChild];
                        currentChildIterator = child === null || child === void 0 ? void 0 : child.getClipStatuses(baseWeight * weights[iChild]);
                        ++iChild;
                      }
                    }
                  }
                };
              };

              _proto3.sample = function sample(progress, weight) {
                for (var iChild = 0; iChild < this._childEvaluators.length; ++iChild) {
                  var _this$_childEvaluator;

                  (_this$_childEvaluator = this._childEvaluators[iChild]) === null || _this$_childEvaluator === void 0 ? void 0 : _this$_childEvaluator.sample(progress, weight * this._weights[iChild]);
                }
              };

              _proto3.overrideClips = function overrideClips(overrides, context) {
                for (var iChild = 0; iChild < this._childEvaluators.length; ++iChild) {
                  var _this$_childEvaluator2;

                  (_this$_childEvaluator2 = this._childEvaluators[iChild]) === null || _this$_childEvaluator2 === void 0 ? void 0 : _this$_childEvaluator2.overrideClips(overrides, context);
                }
              };

              _proto3.setInput = function setInput(value, index) {
                this._inputs[index] = value;
                this.doEval();
              };

              _proto3.doEval = function doEval() {
                this.eval(this._weights, this._inputs);
              };

              _proto3.eval = function _eval(_weights, _inputs) {};

              _createClass(AnimationBlendEval, [{
                key: "childCount",
                get: function get() {
                  return this._weights.length;
                }
              }, {
                key: "duration",
                get: function get() {
                  var uniformDuration = 0.0;

                  for (var iChild = 0; iChild < this._childEvaluators.length; ++iChild) {
                    var _this$_childEvaluator3, _this$_childEvaluator4;

                    uniformDuration += ((_this$_childEvaluator3 = (_this$_childEvaluator4 = this._childEvaluators[iChild]) === null || _this$_childEvaluator4 === void 0 ? void 0 : _this$_childEvaluator4.duration) !== null && _this$_childEvaluator3 !== void 0 ? _this$_childEvaluator3 : 0.0) * this._weights[iChild];
                  }

                  return uniformDuration;
                }
              }]);

              return AnimationBlendEval;
            }();

            function blend1D(weights, thresholds, value) {
              weights.fill(0.0);

              if (thresholds.length === 0) ; else if (value <= thresholds[0]) {
                weights[0] = 1;
              } else if (value >= thresholds[thresholds.length - 1]) {
                weights[weights.length - 1] = 1;
              } else {
                var iUpper = 0;

                for (var iThresholds = 1; iThresholds < thresholds.length; ++iThresholds) {
                  if (thresholds[iThresholds] > value) {
                    iUpper = iThresholds;
                    break;
                  }
                }

                var lower = thresholds[iUpper - 1];
                var upper = thresholds[iUpper];
                var dVal = upper - lower;
                weights[iUpper - 1] = (upper - value) / dVal;
                weights[iUpper] = (value - lower) / dVal;
              }
            }

            var _dec$W, _class$W, _class2$N, _initializer$L, _dec2$E, _class4$d, _class5$d, _initializer2$C, _initializer3$q, _class6$2, _temp$d;
            var ccclass$9 = ccclass$p,
                serializable$8 = serializable$j;
            var AnimationBlend1DItem = (_dec$W = ccclass$9(CLASS_NAME_PREFIX_ANIM + "AnimationBlend1DItem"), _dec$W(_class$W = (_class2$N = function (_AnimationBlendItem) {
              _inheritsLoose(AnimationBlend1DItem, _AnimationBlendItem);

              function AnimationBlend1DItem() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _AnimationBlendItem.call.apply(_AnimationBlendItem, [this].concat(args)) || this;
                _this.threshold = _initializer$L && _initializer$L();
                return _this;
              }

              var _proto = AnimationBlend1DItem.prototype;

              _proto.clone = function clone() {
                var that = new AnimationBlend1DItem();

                this._copyTo(that);

                return that;
              };

              _proto._copyTo = function _copyTo(that) {
                _AnimationBlendItem.prototype._copyTo.call(this, that);

                that.threshold = this.threshold;
                return that;
              };

              return AnimationBlend1DItem;
            }(AnimationBlendItem), (_initializer$L = applyDecoratedInitializer(_class2$N.prototype, "threshold", [serializable$8], function () {
              return 0.0;
            })), _class2$N)) || _class$W);
            var AnimationBlend1D = (_dec2$E = ccclass$9('cc.animation.AnimationBlend1D'), _dec2$E(_class4$d = (_class5$d = (_temp$d = _class6$2 = function (_AnimationBlend) {
              _inheritsLoose(AnimationBlend1D, _AnimationBlend);

              function AnimationBlend1D() {
                var _this2;

                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args[_key3] = arguments[_key3];
                }

                _this2 = _AnimationBlend.call.apply(_AnimationBlend, [this].concat(args)) || this;
                _this2._items = _initializer2$C && _initializer2$C();
                _this2.param = _initializer3$q && _initializer3$q();
                return _this2;
              }

              var _proto2 = AnimationBlend1D.prototype;

              _proto2.clone = function clone() {
                var that = new AnimationBlend1D();
                this.copyTo(that);
                that._items = this._items.map(function (item) {
                  return item.clone();
                });
                that.param = this.param.clone();
                return that;
              };

              _proto2[createEval] = function (context) {
                var evaluation = new AnimationBlend1DEval(context, this, this._items, this._items.map(function (_ref) {
                  var threshold = _ref.threshold;
                  return threshold;
                }), 0.0);
                var initialValue = bindOr(context, this.param, VariableType.FLOAT, evaluation.setInput, evaluation, 0);
                evaluation.setInput(initialValue, 0);
                return evaluation;
              };

              _createClass(AnimationBlend1D, [{
                key: "items",
                get: function get() {
                  return this._items;
                },
                set: function set(value) {
                  this._items = Array.from(value).sort(function (_ref2, _ref3) {
                    var lhs = _ref2.threshold;
                    var rhs = _ref3.threshold;
                    return lhs - rhs;
                  });
                }
              }]);

              return AnimationBlend1D;
            }(AnimationBlend), _class6$2.Item = AnimationBlend1DItem, _temp$d), (_initializer2$C = applyDecoratedInitializer(_class5$d.prototype, "_items", [serializable$8], function () {
              return [];
            }), _initializer3$q = applyDecoratedInitializer(_class5$d.prototype, "param", [serializable$8], function () {
              return new BindableNumber();
            })), _class5$d)) || _class4$d);

            var AnimationBlend1DEval = function (_AnimationBlendEval) {
              _inheritsLoose(AnimationBlend1DEval, _AnimationBlendEval);

              function AnimationBlend1DEval(context, base, items, thresholds, input) {
                var _this3;

                _this3 = _AnimationBlendEval.call(this, context, base, items, [input]) || this;
                _this3._thresholds = thresholds;

                _this3.doEval();

                return _this3;
              }

              var _proto3 = AnimationBlend1DEval.prototype;

              _proto3.eval = function _eval(weights, _ref4) {
                var value = _ref4[0];
                blend1D(weights, this._thresholds, value);
              };

              return AnimationBlend1DEval;
            }(AnimationBlendEval);

            var blendSimpleDirectional = function () {
              var CACHE_NORMALIZED_SAMPLE = new Vec2();
              var CACHE_BARYCENTRIC_SOLUTIONS = {
                wA: 0,
                wB: 0
              };
              return function blendSimpleDirectional(weights, samples, input) {
                assertIsTrue(weights.length === samples.length);

                if (samples.length === 0) {
                  return;
                }

                if (samples.length === 1) {
                  weights[0] = 1.0;
                  return;
                }

                if (Vec2.strictEquals(input, Vec2.ZERO)) {
                  var _iCenter = samples.findIndex(function (sample) {
                    return Vec2.strictEquals(sample, Vec2.ZERO);
                  });

                  if (_iCenter >= 0) {
                    weights[_iCenter] = 1.0;
                  } else {
                    weights.fill(1.0 / samples.length);
                  }

                  return;
                }

                var iSectorStart = -1;
                var iSectorEnd = -1;
                var iCenter = -1;
                var lhsCosAngle = Number.NEGATIVE_INFINITY;
                var rhsCosAngle = Number.NEGATIVE_INFINITY;
                var inputX = input.x,
                    inputY = input.y;

                for (var iSample = 0; iSample < samples.length; ++iSample) {
                  var sample = samples[iSample];

                  if (Vec2.equals(sample, Vec2.ZERO)) {
                    iCenter = iSample;
                    continue;
                  }

                  var sampleNormalized = Vec2.normalize(CACHE_NORMALIZED_SAMPLE, sample);
                  var cosAngle = Vec2.dot(sampleNormalized, input);
                  var sign = sampleNormalized.x * inputY - sampleNormalized.y * inputX;

                  if (sign > 0) {
                    if (cosAngle >= rhsCosAngle) {
                      rhsCosAngle = cosAngle;
                      iSectorStart = iSample;
                    }
                  } else if (cosAngle >= lhsCosAngle) {
                    lhsCosAngle = cosAngle;
                    iSectorEnd = iSample;
                  }
                }

                var centerWeight = 0.0;

                if (iSectorStart < 0 || iSectorEnd < 0) {
                  centerWeight = 1.0;
                } else {
                  var _solveBarycentric = solveBarycentric(samples[iSectorStart], samples[iSectorEnd], input, CACHE_BARYCENTRIC_SOLUTIONS),
                      wA = _solveBarycentric.wA,
                      wB = _solveBarycentric.wB;

                  var w1 = 0.0;
                  var w2 = 0.0;
                  var sum = wA + wB;

                  if (sum > 1) {
                    w1 = wA / sum;
                    w2 = wB / sum;
                  } else if (sum < 0) {
                    w1 = 0.0;
                    w2 = 0.0;
                    centerWeight = 1.0;
                  } else {
                    w1 = wA;
                    w2 = wB;
                    centerWeight = 1.0 - sum;
                  }

                  weights[iSectorStart] = w1;
                  weights[iSectorEnd] = w2;
                }

                if (centerWeight > 0.0) {
                  if (iCenter >= 0) {
                    weights[iCenter] = centerWeight;
                  } else {
                    var average = centerWeight / weights.length;

                    for (var i = 0; i < weights.length; ++i) {
                      weights[i] += average;
                    }
                  }
                }
              };
            }();
            function sampleFreeformCartesian(weights, thresholds, value) {
              sampleFreeform(weights, thresholds, value, getGradientBandCartesianCoords);
            }
            function sampleFreeformDirectional(weights, thresholds, value) {
              sampleFreeform(weights, thresholds, value, getGradientBandPolarCoords);
            }

            function sampleFreeform(weights, samples, value, getGradientBandCoords) {
              weights.fill(0.0);
              var pIpInput = new Vec2(0, 0);
              var pIJ = new Vec2(0, 0);
              var sumInfluence = 0.0;
              var nSamples = samples.length;

              for (var iSample = 0; iSample < nSamples; ++iSample) {
                var influence = Number.MAX_VALUE;
                var outsideHull = false;

                for (var jSample = 0; jSample < nSamples; ++jSample) {
                  if (iSample === jSample) {
                    continue;
                  }

                  getGradientBandCoords(samples[iSample], samples[jSample], value, pIpInput, pIJ);
                  var t = 1 - Vec2.dot(pIpInput, pIJ) / Vec2.lengthSqr(pIJ);

                  if (t < 0) {
                    outsideHull = true;
                    break;
                  }

                  influence = Math.min(influence, t);
                }

                if (!outsideHull) {
                  weights[iSample] = influence;
                  sumInfluence += influence;
                }
              }

              if (sumInfluence > 0) {
                weights.forEach(function (influence, index) {
                  return weights[index] = influence / sumInfluence;
                });
              }
            }

            function solveBarycentric(a, b, p, resolutions) {
              var det = Vec2.cross(a, b);

              if (!det) {
                resolutions.wA = 0.0;
                resolutions.wB = 0.0;
              } else {
                resolutions.wA = Vec2.cross(p, b) / det;
                resolutions.wB = Vec2.cross(p, a) / -det;
              }

              return resolutions;
            }

            var getGradientBandCartesianCoords = function getGradientBandCartesianCoords(pI, pJ, input, pIpInput, pIpJ) {
              Vec2.subtract(pIpInput, input, pI);
              Vec2.subtract(pIpJ, pJ, pI);
            };

            var getGradientBandPolarCoords = function () {
              var axis = new Vec3(0, 0, 0);
              var tmpV3 = new Vec3(0, 0, 0);
              var pQueriedProjected = new Vec3(0, 0, 0);
              var pi3 = new Vec3(0, 0, 0);
              var pj3 = new Vec3(0, 0, 0);
              var pQueried3 = new Vec3(0, 0, 0);
              return function (pI, pJ, input, pIpInput, pIpJ) {
                var aIJ = 0.0;
                var aIQ = 0.0;
                var angleMultiplier = 2.0;
                Vec3.set(pQueriedProjected, input.x, input.y, 0.0);

                if (Vec2.equals(pI, Vec2.ZERO)) {
                  aIJ = Vec2.angle(input, pJ);
                  aIQ = 0.0;
                  angleMultiplier = 1.0;
                } else if (Vec2.equals(pJ, Vec2.ZERO)) {
                  aIJ = Vec2.angle(input, pI);
                  aIQ = aIJ;
                  angleMultiplier = 1.0;
                } else {
                  aIJ = Vec2.angle(pI, pJ);

                  if (aIJ <= 0.0) {
                    aIQ = 0.0;
                  } else if (Vec2.equals(input, Vec2.ZERO)) {
                    aIQ = aIJ;
                  } else {
                    Vec3.set(pi3, pI.x, pI.y, 0);
                    Vec3.set(pj3, pJ.x, pJ.y, 0);
                    Vec3.set(pQueried3, input.x, input.y, 0);
                    Vec3.cross(axis, pi3, pj3);
                    Vec3.projectOnPlane(pQueriedProjected, pQueried3, axis);
                    aIQ = Vec3.angle(pi3, pQueriedProjected);

                    if (aIJ < Math.PI * 0.99) {
                      if (Vec3.dot(Vec3.cross(tmpV3, pi3, pQueriedProjected), axis) < 0) {
                        aIQ = -aIQ;
                      }
                    }
                  }
                }

                var lenPI = Vec2.len(pI);
                var lenPJ = Vec2.len(pJ);
                var deno = (lenPJ + lenPI) / 2;
                Vec2.set(pIpJ, (lenPJ - lenPI) / deno, aIJ * angleMultiplier);
                Vec2.set(pIpInput, (Vec3.len(pQueriedProjected) - lenPI) / deno, aIQ * angleMultiplier);
              };
            }();

            var _dec$X, _class$X, _class2$O, _initializer$M, _dec2$F, _class4$e, _class5$e, _initializer2$D, _initializer3$r, _initializer4$o, _initializer5$j, _class6$3, _temp$e;
            var ccclass$a = ccclass$p,
                serializable$9 = serializable$j;
            var Algorithm;

            (function (Algorithm) {
              Algorithm[Algorithm["SIMPLE_DIRECTIONAL"] = 0] = "SIMPLE_DIRECTIONAL";
              Algorithm[Algorithm["FREEFORM_CARTESIAN"] = 1] = "FREEFORM_CARTESIAN";
              Algorithm[Algorithm["FREEFORM_DIRECTIONAL"] = 2] = "FREEFORM_DIRECTIONAL";
            })(Algorithm || (Algorithm = {}));

            ccenum(Algorithm);
            var AnimationBlend2DItem = (_dec$X = ccclass$a(CLASS_NAME_PREFIX_ANIM + "AnimationBlend2DItem"), _dec$X(_class$X = (_class2$O = function (_AnimationBlendItem) {
              _inheritsLoose(AnimationBlend2DItem, _AnimationBlendItem);

              function AnimationBlend2DItem() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _AnimationBlendItem.call.apply(_AnimationBlendItem, [this].concat(args)) || this;
                _this.threshold = _initializer$M && _initializer$M();
                return _this;
              }

              var _proto = AnimationBlend2DItem.prototype;

              _proto.clone = function clone() {
                var that = new AnimationBlend2DItem();

                this._copyTo(that);

                return that;
              };

              _proto._copyTo = function _copyTo(that) {
                _AnimationBlendItem.prototype._copyTo.call(this, that);

                Vec2.copy(that.threshold, this.threshold);
                return that;
              };

              return AnimationBlend2DItem;
            }(AnimationBlendItem), (_initializer$M = applyDecoratedInitializer(_class2$O.prototype, "threshold", [serializable$9], function () {
              return new Vec2();
            })), _class2$O)) || _class$X);
            var AnimationBlend2D = (_dec2$F = ccclass$a('cc.animation.AnimationBlend2D'), _dec2$F(_class4$e = (_class5$e = (_temp$e = _class6$3 = function (_AnimationBlend) {
              _inheritsLoose(AnimationBlend2D, _AnimationBlend);

              function AnimationBlend2D() {
                var _this2;

                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args[_key3] = arguments[_key3];
                }

                _this2 = _AnimationBlend.call.apply(_AnimationBlend, [this].concat(args)) || this;
                _this2.algorithm = _initializer2$D && _initializer2$D();
                _this2._items = _initializer3$r && _initializer3$r();
                _this2.paramX = _initializer4$o && _initializer4$o();
                _this2.paramY = _initializer5$j && _initializer5$j();
                return _this2;
              }

              var _proto2 = AnimationBlend2D.prototype;

              _proto2.clone = function clone() {
                var that = new AnimationBlend2D();
                this.copyTo(that);
                that._items = this._items.map(function (item) {
                  var _item$clone;

                  return (_item$clone = item === null || item === void 0 ? void 0 : item.clone()) !== null && _item$clone !== void 0 ? _item$clone : null;
                });
                that.paramX = this.paramX.clone();
                that.paramY = this.paramY.clone();
                return that;
              };

              _proto2[createEval] = function (context) {
                var evaluation = new AnimationBlend2DEval(context, this, this._items, this._items.map(function (_ref) {
                  var threshold = _ref.threshold;
                  return threshold;
                }), this.algorithm, [0.0, 0.0]);
                var initialValueX = bindOr(context, this.paramX, VariableType.FLOAT, evaluation.setInput, evaluation, 0);
                var initialValueY = bindOr(context, this.paramY, VariableType.FLOAT, evaluation.setInput, evaluation, 1);
                evaluation.setInput(initialValueX, 0);
                evaluation.setInput(initialValueY, 1);
                return evaluation;
              };

              _createClass(AnimationBlend2D, [{
                key: "items",
                get: function get() {
                  return this._items;
                },
                set: function set(items) {
                  this._items = Array.from(items);
                }
              }]);

              return AnimationBlend2D;
            }(AnimationBlend), _class6$3.Algorithm = Algorithm, _class6$3.Item = AnimationBlend2DItem, _temp$e), (_initializer2$D = applyDecoratedInitializer(_class5$e.prototype, "algorithm", [serializable$9], function () {
              return Algorithm.SIMPLE_DIRECTIONAL;
            }), _initializer3$r = applyDecoratedInitializer(_class5$e.prototype, "_items", [serializable$9], function () {
              return [];
            }), _initializer4$o = applyDecoratedInitializer(_class5$e.prototype, "paramX", [serializable$9], function () {
              return new BindableNumber();
            }), _initializer5$j = applyDecoratedInitializer(_class5$e.prototype, "paramY", [serializable$9], function () {
              return new BindableNumber();
            })), _class5$e)) || _class4$e);

            var AnimationBlend2DEval = function (_AnimationBlendEval) {
              _inheritsLoose(AnimationBlend2DEval, _AnimationBlendEval);

              function AnimationBlend2DEval(context, base, items, thresholds, algorithm, inputs) {
                var _this3;

                _this3 = _AnimationBlendEval.call(this, context, base, items, inputs) || this;
                _this3._thresholds = void 0;
                _this3._algorithm = void 0;
                _this3._value = new Vec2();
                _this3._thresholds = thresholds;
                _this3._algorithm = algorithm;

                _this3.doEval();

                return _this3;
              }

              var _proto3 = AnimationBlend2DEval.prototype;

              _proto3.eval = function _eval(weights, _ref2) {
                var x = _ref2[0],
                    y = _ref2[1];
                Vec2.set(this._value, x, y);
                weights.fill(0);

                switch (this._algorithm) {
                  case Algorithm.SIMPLE_DIRECTIONAL:
                    blendSimpleDirectional(weights, this._thresholds, this._value);
                    break;

                  case Algorithm.FREEFORM_CARTESIAN:
                    sampleFreeformCartesian(weights, this._thresholds, this._value);
                    break;

                  case Algorithm.FREEFORM_DIRECTIONAL:
                    sampleFreeformDirectional(weights, this._thresholds, this._value);
                    break;
                }
              };

              return AnimationBlend2DEval;
            }(AnimationBlendEval);

            var _dec$Y, _class$Y, _class2$P, _initializer$N, _dec2$G, _class4$f, _class5$f, _initializer2$E, _class6$4, _temp$f;
            var ccclass$b = ccclass$p,
                serializable$a = serializable$j;
            var AnimationBlendDirectItem = (_dec$Y = ccclass$b(CLASS_NAME_PREFIX_ANIM + "AnimationBlendDirectItem"), _dec$Y(_class$Y = (_class2$P = function (_AnimationBlendItem) {
              _inheritsLoose(AnimationBlendDirectItem, _AnimationBlendItem);

              function AnimationBlendDirectItem() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _AnimationBlendItem.call.apply(_AnimationBlendItem, [this].concat(args)) || this;
                _this.weight = _initializer$N && _initializer$N();
                return _this;
              }

              var _proto = AnimationBlendDirectItem.prototype;

              _proto.clone = function clone() {
                var that = new AnimationBlendDirectItem();

                this._copyTo(that);

                return that;
              };

              _proto._copyTo = function _copyTo(that) {
                _AnimationBlendItem.prototype._copyTo.call(this, that);

                that.weight = this.weight;
                return that;
              };

              return AnimationBlendDirectItem;
            }(AnimationBlendItem), (_initializer$N = applyDecoratedInitializer(_class2$P.prototype, "weight", [serializable$a], function () {
              return 0.0;
            })), _class2$P)) || _class$Y);
            var AnimationBlendDirect = (_dec2$G = ccclass$b('cc.animation.AnimationBlendDirect'), _dec2$G(_class4$f = (_class5$f = (_temp$f = _class6$4 = function (_AnimationBlend) {
              _inheritsLoose(AnimationBlendDirect, _AnimationBlend);

              function AnimationBlendDirect() {
                var _this2;

                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args[_key3] = arguments[_key3];
                }

                _this2 = _AnimationBlend.call.apply(_AnimationBlend, [this].concat(args)) || this;
                _this2._items = _initializer2$E && _initializer2$E();
                return _this2;
              }

              var _proto2 = AnimationBlendDirect.prototype;

              _proto2.clone = function clone() {
                var that = new AnimationBlendDirect();
                this.copyTo(that);
                that._items = this._items.map(function (item) {
                  var _item$clone;

                  return (_item$clone = item === null || item === void 0 ? void 0 : item.clone()) !== null && _item$clone !== void 0 ? _item$clone : null;
                });
                return that;
              };

              _proto2[createEval] = function (context) {
                var myEval = new AnimationBlendDirectEval(context, this, this._items, this._items.map(function (_ref) {
                  var weight = _ref.weight;
                  return weight;
                }));
                return myEval;
              };

              _createClass(AnimationBlendDirect, [{
                key: "items",
                get: function get() {
                  return this._items;
                },
                set: function set(value) {
                  this._items = Array.from(value);
                }
              }]);

              return AnimationBlendDirect;
            }(AnimationBlend), _class6$4.Item = AnimationBlendDirectItem, _temp$f), (_initializer2$E = applyDecoratedInitializer(_class5$f.prototype, "_items", [serializable$a], function () {
              return [];
            })), _class5$f)) || _class4$f);

            var AnimationBlendDirectEval = function (_AnimationBlendEval) {
              _inheritsLoose(AnimationBlendDirectEval, _AnimationBlendEval);

              function AnimationBlendDirectEval() {
                var _this3;

                for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                  args[_key5] = arguments[_key5];
                }

                _this3 = _AnimationBlendEval.call.apply(_AnimationBlendEval, [this].concat(args)) || this;

                _this3.doEval();

                return _this3;
              }

              var _proto3 = AnimationBlendDirectEval.prototype;

              _proto3.eval = function _eval(weights, inputs) {
                var nChildren = weights.length;

                for (var iChild = 0; iChild < nChildren; ++iChild) {
                  weights[iChild] = inputs[iChild];
                }
              };

              return AnimationBlendDirectEval;
            }(AnimationBlendEval);

            var _dec$Z, _class$Z, _class2$Q, _initializer$O, _initializer2$F, _dec2$H, _dec3$q, _class4$g, _class5$g, _initializer3$s;
            var JointMask = (_dec$Z = ccclass$p('cc.JointMask'), _dec$Z(_class$Z = (_class2$Q = function JointMask() {
              this.path = _initializer$O && _initializer$O();
              this.enabled = _initializer2$F && _initializer2$F();
            }, (_initializer$O = applyDecoratedInitializer(_class2$Q.prototype, "path", [serializable$j], function () {
              return '';
            }), _initializer2$F = applyDecoratedInitializer(_class2$Q.prototype, "enabled", [serializable$j], function () {
              return true;
            })), _class2$Q)) || _class$Z);
            var AnimationMask = (_dec2$H = ccclass$p(CLASS_NAME_PREFIX_ANIM + "AnimationMask"), _dec3$q = type$8(JointMask), _dec2$H(_class4$g = (_class5$g = function (_Asset) {
              _inheritsLoose(AnimationMask, _Asset);

              function AnimationMask() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;
                _this._jointMasks = _initializer3$s && _initializer3$s();
                return _this;
              }

              var _proto = AnimationMask.prototype;

              _proto.addJoint = function addJoint(path, enabled) {
                this.removeJoint(path);
                var info = new JointMask();
                info.path = path;
                info.enabled = enabled;

                this._jointMasks.push(info);
              };

              _proto.removeJoint = function removeJoint(removal) {
                removeIf(this._jointMasks, function (_ref) {
                  var path = _ref.path;
                  return path === removal;
                });
              };

              _proto.clear = function clear() {
                this._jointMasks.length = 0;
              };

              _proto.filterDisabledNodes = function filterDisabledNodes(root) {
                var jointMasks = this._jointMasks;
                var nJointMasks = jointMasks.length;
                var disabledNodes = new Set();

                for (var iJointMask = 0; iJointMask < nJointMasks; ++iJointMask) {
                  var _jointMasks$iJointMas = jointMasks[iJointMask],
                      path = _jointMasks$iJointMas.path,
                      enabled = _jointMasks$iJointMas.enabled;

                  if (enabled) {
                    continue;
                  }

                  var node = root.getChildByPath(path);

                  if (node) {
                    disabledNodes.add(node);
                  }
                }

                return disabledNodes;
              };

              _createClass(AnimationMask, [{
                key: "joints",
                get: function get() {
                  return this._jointMasks;
                },
                set: function set(value) {
                  this.clear();

                  for (var _iterator = _createForOfIteratorHelperLoose(value), _step; !(_step = _iterator()).done;) {
                    var joint = _step.value;
                    this.addJoint(joint.path, joint.enabled);
                  }
                }
              }]);

              return AnimationMask;
            }(Asset), (_initializer3$s = applyDecoratedInitializer(_class5$g.prototype, "_jointMasks", [serializable$j], function () {
              return [];
            }), _applyDecoratedDescriptor(_class5$g.prototype, "joints", [_dec3$q], Object.getOwnPropertyDescriptor(_class5$g.prototype, "joints"), _class5$g.prototype)), _class5$g)) || _class4$g);

            var _Symbol$iterator;

            var _dec$_, _class$_, _class2$R, _initializer$P, _initializer2$G, _dec2$I, _dec3$r, _class4$h, _class5$h, _initializer3$t, _initializer4$p, _dec4$h, _class7$4, _class8$3, _initializer5$k;
            var ClipOverrideEntry = (_dec$_ = ccclass$p(CLASS_NAME_PREFIX_ANIM + "ClipOverrideEntry"), _dec$_(_class$_ = (_class2$R = function ClipOverrideEntry() {
              this.original = _initializer$P && _initializer$P();
              this.substitution = _initializer2$G && _initializer2$G();
            }, (_initializer$P = applyDecoratedInitializer(_class2$R.prototype, "original", [serializable$j], function () {
              return null;
            }), _initializer2$G = applyDecoratedInitializer(_class2$R.prototype, "substitution", [serializable$j], function () {
              return null;
            })), _class2$R)) || _class$_);
            var AnimationGraphVariant = (_dec2$I = ccclass$p(CLASS_NAME_PREFIX_ANIM + "AnimationGraphVariant"), _dec3$r = type$8(AnimationGraph), _dec2$I(_class4$h = (_class5$h = function (_AnimationGraphLike) {
              _inheritsLoose(AnimationGraphVariant, _AnimationGraphLike);

              function AnimationGraphVariant() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _AnimationGraphLike.call.apply(_AnimationGraphLike, [this].concat(args)) || this;
                _this._graph = _initializer3$t && _initializer3$t();
                _this._clipOverrides = _initializer4$p && _initializer4$p();
                return _this;
              }

              _createClass(AnimationGraphVariant, [{
                key: "original",
                get: function get() {
                  return this._graph;
                },
                set: function set(value) {
                  this._graph = value;
                }
              }, {
                key: "clipOverrides",
                get: function get() {
                  return this._clipOverrides;
                }
              }]);

              return AnimationGraphVariant;
            }(AnimationGraphLike), (_applyDecoratedDescriptor(_class5$h.prototype, "original", [_dec3$r], Object.getOwnPropertyDescriptor(_class5$h.prototype, "original"), _class5$h.prototype), _initializer3$t = applyDecoratedInitializer(_class5$h.prototype, "_graph", [serializable$j], function () {
              return null;
            }), _initializer4$p = applyDecoratedInitializer(_class5$h.prototype, "_clipOverrides", [serializable$j], function () {
              return new ClipOverrideMap();
            })), _class5$h)) || _class4$h);
            var ClipOverrideMap = (_dec4$h = ccclass$p(CLASS_NAME_PREFIX_ANIM + "ClipOverrideMap"), _dec4$h(_class7$4 = (_class8$3 = (_Symbol$iterator = Symbol.iterator, function () {
              function ClipOverrideMap() {
                this._entries = _initializer5$k && _initializer5$k();
              }

              var _proto = ClipOverrideMap.prototype;

              _proto[_Symbol$iterator] = function () {
                return this._entries[Symbol.iterator]();
              };

              _proto.has = function has(original) {
                return !!this._entries.find(function (_ref) {
                  var o = _ref.original;
                  return o === original;
                });
              };

              _proto.get = function get(original) {
                var entry = this._entries.find(function (_ref2) {
                  var o = _ref2.original;
                  return o === original;
                });

                return entry === null || entry === void 0 ? void 0 : entry.substitution;
              };

              _proto.set = function set(original, substitution) {
                var entry = this._entries.find(function (_ref3) {
                  var o = _ref3.original;
                  return o === original;
                });

                if (entry) {
                  entry.substitution = substitution;
                } else {
                  var newEntry = new ClipOverrideEntry();
                  newEntry.original = original;
                  newEntry.substitution = substitution;

                  this._entries.push(newEntry);
                }
              };

              _proto["delete"] = function _delete(original) {
                removeIf(this._entries, function (_ref4) {
                  var o = _ref4.original;
                  return o === original;
                });
              };

              _proto.clear = function clear() {
                this._entries.length = 0;
              };

              _createClass(ClipOverrideMap, [{
                key: "size",
                get: function get() {
                  return this._entries.length;
                }
              }]);

              return ClipOverrideMap;
            }()), (_initializer5$k = applyDecoratedInitializer(_class8$3.prototype, "_entries", [serializable$j], function () {
              return [];
            })), _class8$3)) || _class7$4);

            var _dec$$, _class$$, _class2$S, _initializer$Q, _initializer2$H, _initializer3$u, _class3$a, _temp$g, _dec2$J, _class4$i, _class5$i, _initializer4$q, _initializer5$l, _class6$5, _temp2, _dec3$s, _class7$5, _class8$4, _initializer6$g;
            var ccclass$c = ccclass$p,
                serializable$b = serializable$j;
            var BinaryOperator;

            (function (BinaryOperator) {
              BinaryOperator[BinaryOperator["EQUAL_TO"] = 0] = "EQUAL_TO";
              BinaryOperator[BinaryOperator["NOT_EQUAL_TO"] = 1] = "NOT_EQUAL_TO";
              BinaryOperator[BinaryOperator["LESS_THAN"] = 2] = "LESS_THAN";
              BinaryOperator[BinaryOperator["LESS_THAN_OR_EQUAL_TO"] = 3] = "LESS_THAN_OR_EQUAL_TO";
              BinaryOperator[BinaryOperator["GREATER_THAN"] = 4] = "GREATER_THAN";
              BinaryOperator[BinaryOperator["GREATER_THAN_OR_EQUAL_TO"] = 5] = "GREATER_THAN_OR_EQUAL_TO";
            })(BinaryOperator || (BinaryOperator = {}));

            var BinaryCondition = (_dec$$ = ccclass$c(CLASS_NAME_PREFIX_ANIM + "BinaryCondition"), _dec$$(_class$$ = (_class2$S = (_temp$g = _class3$a = function () {
              function BinaryCondition() {
                this.operator = _initializer$Q && _initializer$Q();
                this.lhs = _initializer2$H && _initializer2$H();
                this.rhs = _initializer3$u && _initializer3$u();
              }

              var _proto = BinaryCondition.prototype;

              _proto.clone = function clone() {
                var that = new BinaryCondition();
                that.operator = this.operator;
                that.lhs = this.lhs.clone();
                that.rhs = this.rhs.clone();
                return that;
              };

              _proto[createEval] = function (context) {
                var operator = this.operator,
                    lhs = this.lhs,
                    rhs = this.rhs;
                var evaluation = new BinaryConditionEval(operator, 0.0, 0.0);
                var lhsValue = bindNumericOr(context, lhs, VariableType.FLOAT, evaluation.setLhs, evaluation);
                var rhsValue = bindNumericOr(context, rhs, VariableType.FLOAT, evaluation.setRhs, evaluation);
                evaluation.reset(lhsValue, rhsValue);
                return evaluation;
              };

              return BinaryCondition;
            }(), _class3$a.Operator = BinaryOperator, _temp$g), (_initializer$Q = applyDecoratedInitializer(_class2$S.prototype, "operator", [serializable$b], function () {
              return BinaryOperator.EQUAL_TO;
            }), _initializer2$H = applyDecoratedInitializer(_class2$S.prototype, "lhs", [serializable$b], function () {
              return new BindableNumber();
            }), _initializer3$u = applyDecoratedInitializer(_class2$S.prototype, "rhs", [serializable$b], function () {
              return new BindableNumber();
            })), _class2$S)) || _class$$);

            var BinaryConditionEval = function () {
              function BinaryConditionEval(operator, lhs, rhs) {
                this._operator = operator;
                this._lhs = lhs;
                this._rhs = rhs;

                this._eval();
              }

              var _proto2 = BinaryConditionEval.prototype;

              _proto2.reset = function reset(lhs, rhs) {
                this._lhs = lhs;
                this._rhs = rhs;

                this._eval();
              };

              _proto2.setLhs = function setLhs(value) {
                this._lhs = value;

                this._eval();
              };

              _proto2.setRhs = function setRhs(value) {
                this._rhs = value;

                this._eval();
              };

              _proto2.eval = function _eval() {
                return this._result;
              };

              _proto2._eval = function _eval() {
                var lhs = this._lhs,
                    rhs = this._rhs;

                switch (this._operator) {
                  default:
                  case BinaryOperator.EQUAL_TO:
                    this._result = lhs === rhs;
                    break;

                  case BinaryOperator.NOT_EQUAL_TO:
                    this._result = lhs !== rhs;
                    break;

                  case BinaryOperator.LESS_THAN:
                    this._result = lhs < rhs;
                    break;

                  case BinaryOperator.LESS_THAN_OR_EQUAL_TO:
                    this._result = lhs <= rhs;
                    break;

                  case BinaryOperator.GREATER_THAN:
                    this._result = lhs > rhs;
                    break;

                  case BinaryOperator.GREATER_THAN_OR_EQUAL_TO:
                    this._result = lhs >= rhs;
                    break;
                }
              };

              return BinaryConditionEval;
            }();

            var UnaryOperator;

            (function (UnaryOperator) {
              UnaryOperator[UnaryOperator["TRUTHY"] = 0] = "TRUTHY";
              UnaryOperator[UnaryOperator["FALSY"] = 1] = "FALSY";
            })(UnaryOperator || (UnaryOperator = {}));

            var UnaryCondition = (_dec2$J = ccclass$c(CLASS_NAME_PREFIX_ANIM + "UnaryCondition"), _dec2$J(_class4$i = (_class5$i = (_temp2 = _class6$5 = function () {
              function UnaryCondition() {
                this.operator = _initializer4$q && _initializer4$q();
                this.operand = _initializer5$l && _initializer5$l();
              }

              var _proto3 = UnaryCondition.prototype;

              _proto3.clone = function clone() {
                var that = new UnaryCondition();
                that.operator = this.operator;
                that.operand = this.operand.clone();
                return that;
              };

              _proto3[createEval] = function (context) {
                var operator = this.operator,
                    operand = this.operand;
                var evaluation = new UnaryConditionEval(operator, false);
                var value = bindOr(context, operand, VariableType.BOOLEAN, evaluation.setOperand, evaluation);
                evaluation.reset(value);
                return evaluation;
              };

              return UnaryCondition;
            }(), _class6$5.Operator = UnaryOperator, _temp2), (_initializer4$q = applyDecoratedInitializer(_class5$i.prototype, "operator", [serializable$b], function () {
              return UnaryOperator.TRUTHY;
            }), _initializer5$l = applyDecoratedInitializer(_class5$i.prototype, "operand", [serializable$b], function () {
              return new BindableBoolean();
            })), _class5$i)) || _class4$i);

            var UnaryConditionEval = function () {
              function UnaryConditionEval(operator, operand) {
                this._operator = operator;
                this._operand = operand;

                this._eval();
              }

              var _proto4 = UnaryConditionEval.prototype;

              _proto4.reset = function reset(value) {
                this.setOperand(value);
              };

              _proto4.setOperand = function setOperand(value) {
                this._operand = value;

                this._eval();
              };

              _proto4.eval = function _eval() {
                return this._result;
              };

              _proto4._eval = function _eval() {
                var operand = this._operand;

                switch (this._operator) {
                  default:
                  case UnaryOperator.TRUTHY:
                    this._result = !!operand;
                    break;

                  case UnaryOperator.FALSY:
                    this._result = !operand;
                    break;
                }
              };

              return UnaryConditionEval;
            }();

            var TriggerCondition = (_dec3$s = ccclass$c(CLASS_NAME_PREFIX_ANIM + "TriggerCondition"), _dec3$s(_class7$5 = (_class8$4 = function () {
              function TriggerCondition() {
                this.trigger = _initializer6$g && _initializer6$g();
              }

              var _proto5 = TriggerCondition.prototype;

              _proto5.clone = function clone() {
                var that = new TriggerCondition();
                that.trigger = this.trigger;
                return that;
              };

              _proto5[createEval] = function (context) {
                var evaluation = new TriggerConditionEval(false);
                var triggerInstance = context.getVar(this.trigger);

                if (validateVariableExistence(triggerInstance, this.trigger)) {
                  validateVariableTypeTriggerLike(triggerInstance.type, this.trigger);
                  evaluation.setTrigger(triggerInstance.bind(evaluation.setTrigger, evaluation));
                }

                return evaluation;
              };

              return TriggerCondition;
            }(), (_initializer6$g = applyDecoratedInitializer(_class8$4.prototype, "trigger", [serializable$b], function () {
              return '';
            })), _class8$4)) || _class7$5);

            var TriggerConditionEval = function () {
              function TriggerConditionEval(triggered) {
                this._triggered = false;
                this._triggered = triggered;
              }

              var _proto6 = TriggerConditionEval.prototype;

              _proto6.setTrigger = function setTrigger(trigger) {
                this._triggered = trigger;
              };

              _proto6.eval = function _eval() {
                return this._triggered;
              };

              return TriggerConditionEval;
            }();

            var MAX_ANIMATION_LAYER = 32;

            var BlendStateBuffer = function () {
              function BlendStateBuffer() {
                this._nodeBlendStates = new Map();
              }

              var _proto = BlendStateBuffer.prototype;

              _proto.createWriter = function createWriter(node, property, host, constants) {
                var propertyBlendState = this.ref(node, property);
                return new BlendStateWriterInternal(node, property, propertyBlendState, host, constants);
              };

              _proto.destroyWriter = function destroyWriter(writer) {
                var internal = writer;
                this.deRef(internal.node, internal.property);
              };

              _proto.ref = function ref(node, property) {
                var nodeBlendState = this._nodeBlendStates.get(node);

                if (!nodeBlendState) {
                  nodeBlendState = this.createNodeBlendState();

                  this._nodeBlendStates.set(node, nodeBlendState);
                }

                var propertyBlendState = nodeBlendState.refProperty(node, property);
                return propertyBlendState;
              };

              _proto.deRef = function deRef(node, property) {
                var nodeBlendState = this._nodeBlendStates.get(node);

                if (!nodeBlendState) {
                  return;
                }

                nodeBlendState.deRefProperty(property);

                if (nodeBlendState.empty) {
                  this._nodeBlendStates["delete"](node);
                }
              };

              _proto.apply = function apply() {
                this._nodeBlendStates.forEach(function (nodeBlendState, node) {
                  nodeBlendState.apply(node);
                });
              };

              return BlendStateBuffer;
            }();

            var BlendStateWriterInternal = function () {
              function BlendStateWriterInternal(_node, _property, _propertyBlendState, _host, _constants) {
                this._node = _node;
                this._property = _property;
                this._propertyBlendState = _propertyBlendState;
                this._host = _host;
                this._constants = _constants;
              }

              var _proto2 = BlendStateWriterInternal.prototype;

              _proto2.getValue = function getValue() {
                return this._node[this._property];
              };

              _proto2.setValue = function setValue(value) {
                var propertyBlendState = this._propertyBlendState,
                    host = this._host;
                var weight = host.weight;
                propertyBlendState.blend(value, weight);
              };

              _createClass(BlendStateWriterInternal, [{
                key: "node",
                get: function get() {
                  return this._node;
                }
              }, {
                key: "property",
                get: function get() {
                  return this._property;
                }
              }]);

              return BlendStateWriterInternal;
            }();

            var TransformApplyFlag;

            (function (TransformApplyFlag) {
              TransformApplyFlag[TransformApplyFlag["POSITION"] = 1] = "POSITION";
              TransformApplyFlag[TransformApplyFlag["ROTATION"] = 2] = "ROTATION";
              TransformApplyFlag[TransformApplyFlag["SCALE"] = 4] = "SCALE";
              TransformApplyFlag[TransformApplyFlag["EULER_ANGLES"] = 8] = "EULER_ANGLES";
            })(TransformApplyFlag || (TransformApplyFlag = {}));

            var TRANSFORM_APPLY_FLAGS_ALL = TransformApplyFlag.POSITION | TransformApplyFlag.ROTATION | TransformApplyFlag.SCALE | TransformApplyFlag.EULER_ANGLES;

            var LegacyVec3PropertyBlendState = function () {
              function LegacyVec3PropertyBlendState() {
                this.refCount = 0;
                this.accumulatedWeight = 0.0;
                this.result = new Vec3();
              }

              var _proto3 = LegacyVec3PropertyBlendState.prototype;

              _proto3.blend = function blend(value, weight) {
                this.accumulatedWeight = mixAveragedVec3(this.result, this.result, this.accumulatedWeight, value, weight);
              };

              _proto3.reset = function reset() {
                this.accumulatedWeight = 0.0;
                Vec3.zero(this.result);
              };

              return LegacyVec3PropertyBlendState;
            }();

            var LegacyQuatPropertyBlendState = function () {
              function LegacyQuatPropertyBlendState() {
                this.refCount = 0;
                this.accumulatedWeight = 0.0;
                this.result = new Quat();
              }

              var _proto4 = LegacyQuatPropertyBlendState.prototype;

              _proto4.blend = function blend(value, weight) {
                this.accumulatedWeight = mixAveragedQuat(this.result, this.result, this.accumulatedWeight, value, weight);
              };

              _proto4.reset = function reset() {
                this.accumulatedWeight = 0.0;
                Quat.identity(this.result);
              };

              return LegacyQuatPropertyBlendState;
            }();

            var NodeBlendState = function () {
              function NodeBlendState() {
                this._transformApplyFlags = 0;
                this._properties = {};
              }

              var _proto5 = NodeBlendState.prototype;

              _proto5.refProperty = function refProperty(node, property) {
                var _properties$property, _properties$property2;

                var properties = this._properties;
                var propertyBlendState;

                switch (property) {
                  default:
                  case 'position':
                  case 'scale':
                  case 'eulerAngles':
                    propertyBlendState = (_properties$property = properties[property]) !== null && _properties$property !== void 0 ? _properties$property : properties[property] = this._createVec3BlendState(node[property]);
                    break;

                  case 'rotation':
                    propertyBlendState = (_properties$property2 = properties[property]) !== null && _properties$property2 !== void 0 ? _properties$property2 : properties[property] = this._createQuatBlendState(node.rotation);
                    break;
                }

                ++propertyBlendState.refCount;
                return propertyBlendState;
              };

              _proto5.deRefProperty = function deRefProperty(property) {
                var properties = this._properties;
                var propertyBlendState = properties[property];

                if (!propertyBlendState) {
                  return;
                }

                --propertyBlendState.refCount;

                if (propertyBlendState.refCount > 0) {
                  return;
                }

                delete properties[property];
              };

              _proto5.apply = function apply(node) {
                var transformApplyFlags = this._transformApplyFlags,
                    _this$_properties = this._properties,
                    position = _this$_properties.position,
                    scale = _this$_properties.scale,
                    rotation = _this$_properties.rotation,
                    eulerAngles = _this$_properties.eulerAngles;

                if (!transformApplyFlags) {
                  return;
                }

                var t;
                var s;
                var r;

                if (position && transformApplyFlags & TransformApplyFlag.POSITION) {
                  t = position.result;
                }

                if (scale && transformApplyFlags & TransformApplyFlag.SCALE) {
                  s = scale.result;
                }

                if (eulerAngles && transformApplyFlags & TransformApplyFlag.EULER_ANGLES) {
                  r = eulerAngles.result;
                }

                if (rotation && transformApplyFlags & TransformApplyFlag.ROTATION) {
                  r = rotation.result;
                }

                if (r || t || s) {
                  node.setRTS(r, t, s);
                }

                this._transformApplyFlags = 0;
              };

              _createClass(NodeBlendState, [{
                key: "empty",
                get: function get() {
                  var properties = this._properties;
                  return !properties.position && !properties.rotation && !properties.eulerAngles && !properties.scale;
                }
              }]);

              return NodeBlendState;
            }();

            var LegacyNodeBlendState = function (_NodeBlendState) {
              _inheritsLoose(LegacyNodeBlendState, _NodeBlendState);

              function LegacyNodeBlendState() {
                return _NodeBlendState.apply(this, arguments) || this;
              }

              var _proto6 = LegacyNodeBlendState.prototype;

              _proto6.apply = function apply(node) {
                var _this$_properties2 = this._properties,
                    position = _this$_properties2.position,
                    scale = _this$_properties2.scale,
                    rotation = _this$_properties2.rotation,
                    eulerAngles = _this$_properties2.eulerAngles;

                if (position && position.accumulatedWeight) {
                  this._transformApplyFlags |= TransformApplyFlag.POSITION;

                  if (position.accumulatedWeight < 1.0) {
                    position.blend(node.position, 1.0 - position.accumulatedWeight);
                  }
                }

                if (scale && scale.accumulatedWeight) {
                  this._transformApplyFlags |= TransformApplyFlag.SCALE;

                  if (scale.accumulatedWeight < 1.0) {
                    scale.blend(node.scale, 1.0 - scale.accumulatedWeight);
                  }
                }

                if (eulerAngles && eulerAngles.accumulatedWeight) {
                  this._transformApplyFlags |= TransformApplyFlag.EULER_ANGLES;

                  if (eulerAngles.accumulatedWeight < 1.0) {
                    eulerAngles.blend(node.eulerAngles, 1.0 - eulerAngles.accumulatedWeight);
                  }
                }

                if (rotation && rotation.accumulatedWeight) {
                  this._transformApplyFlags |= TransformApplyFlag.ROTATION;

                  if (rotation.accumulatedWeight < 1.0) {
                    rotation.blend(node.rotation, 1.0 - rotation.accumulatedWeight);
                  }
                }

                _NodeBlendState.prototype.apply.call(this, node);

                position === null || position === void 0 ? void 0 : position.reset();
                scale === null || scale === void 0 ? void 0 : scale.reset();
                rotation === null || rotation === void 0 ? void 0 : rotation.reset();
                eulerAngles === null || eulerAngles === void 0 ? void 0 : eulerAngles.reset();
              };

              _proto6._createVec3BlendState = function _createVec3BlendState(_currentValue) {
                return new LegacyVec3PropertyBlendState();
              };

              _proto6._createQuatBlendState = function _createQuatBlendState(_currentValue) {
                return new LegacyQuatPropertyBlendState();
              };

              return LegacyNodeBlendState;
            }(NodeBlendState);

            var LegacyBlendStateBuffer = function (_BlendStateBuffer) {
              _inheritsLoose(LegacyBlendStateBuffer, _BlendStateBuffer);

              function LegacyBlendStateBuffer() {
                return _BlendStateBuffer.apply(this, arguments) || this;
              }

              var _proto7 = LegacyBlendStateBuffer.prototype;

              _proto7.createNodeBlendState = function createNodeBlendState() {
                return new LegacyNodeBlendState();
              };

              return LegacyBlendStateBuffer;
            }(BlendStateBuffer);

            var LayeredVec3PropertyBlendState = function () {
              function LayeredVec3PropertyBlendState(defaultValue) {
                this.refCount = 0;
                this.result = new Vec3();
                this._defaultValue = new Vec3();
                this._clipBlendResult = new Vec3();
                this._accumulatedWeight = 0.0;
                Vec3.copy(this._defaultValue, defaultValue);
                Vec3.copy(this.result, defaultValue);
              }

              var _proto8 = LayeredVec3PropertyBlendState.prototype;

              _proto8.blend = function blend(value, weight) {
                this._accumulatedWeight = mixAveragedVec3(this._clipBlendResult, this._clipBlendResult, this._accumulatedWeight, value, weight);
              };

              _proto8.commitLayerChange = function commitLayerChange(weight) {
                var result = this.result,
                    clipBlendResult = this._clipBlendResult,
                    accumulatedWeight = this._accumulatedWeight;

                if (accumulatedWeight < 1.0) {
                  this.blend(this._defaultValue, 1.0 - accumulatedWeight);
                }

                Vec3.lerp(result, result, clipBlendResult, weight);
                Vec3.zero(this._clipBlendResult);
                this._accumulatedWeight = 0.0;
              };

              _proto8.reset = function reset() {
                Vec3.copy(this.result, this._defaultValue);
              };

              return LayeredVec3PropertyBlendState;
            }();

            var LayeredQuatPropertyBlendState = function () {
              function LayeredQuatPropertyBlendState(defaultValue) {
                this.refCount = 0;
                this.result = new Quat();
                this._defaultValue = new Quat();
                this._clipBlendResult = new Quat();
                this._accumulatedWeight = 0.0;
                Quat.copy(this._defaultValue, defaultValue);
                Quat.copy(this.result, defaultValue);
              }

              var _proto9 = LayeredQuatPropertyBlendState.prototype;

              _proto9.blend = function blend(value, weight) {
                this._accumulatedWeight = mixAveragedQuat(this._clipBlendResult, this._clipBlendResult, this._accumulatedWeight, value, weight);
              };

              _proto9.commitLayerChange = function commitLayerChange(weight) {
                var result = this.result,
                    clipBlendResult = this._clipBlendResult,
                    accumulatedWeight = this._accumulatedWeight;

                if (accumulatedWeight < 1.0) {
                  this.blend(this._defaultValue, 1.0 - accumulatedWeight);
                }

                Quat.slerp(result, result, clipBlendResult, weight);
                Quat.identity(this._clipBlendResult);
                this._accumulatedWeight = 0.0;
              };

              _proto9.reset = function reset() {
                Quat.copy(this.result, this._defaultValue);
              };

              return LayeredQuatPropertyBlendState;
            }();

            var LayeredNodeBlendState = function (_NodeBlendState2) {
              _inheritsLoose(LayeredNodeBlendState, _NodeBlendState2);

              function LayeredNodeBlendState() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _NodeBlendState2.call.apply(_NodeBlendState2, [this].concat(args)) || this;
                _this._layerMask = ~0 >>> 0;
                return _this;
              }

              var _proto10 = LayeredNodeBlendState.prototype;

              _proto10.setLayerMask = function setLayerMask(layerIndex) {
                this._layerMask &= ~(1 << layerIndex);
              };

              _proto10.commitLayerChanges = function commitLayerChanges(layerIndex, weight) {
                if (!(this._layerMask & 1 << layerIndex)) {
                  return;
                }

                var _this$_properties3 = this._properties,
                    position = _this$_properties3.position,
                    scale = _this$_properties3.scale,
                    rotation = _this$_properties3.rotation,
                    eulerAngles = _this$_properties3.eulerAngles;

                if (position) {
                  position.commitLayerChange(weight);
                }

                if (scale) {
                  scale.commitLayerChange(weight);
                }

                if (rotation) {
                  rotation.commitLayerChange(weight);
                }

                if (eulerAngles) {
                  eulerAngles.commitLayerChange(weight);
                }
              };

              _proto10.apply = function apply(node) {
                this._transformApplyFlags = TRANSFORM_APPLY_FLAGS_ALL;

                _NodeBlendState2.prototype.apply.call(this, node);

                var _this$_properties4 = this._properties,
                    position = _this$_properties4.position,
                    scale = _this$_properties4.scale,
                    rotation = _this$_properties4.rotation,
                    eulerAngles = _this$_properties4.eulerAngles;
                position === null || position === void 0 ? void 0 : position.reset();
                scale === null || scale === void 0 ? void 0 : scale.reset();
                rotation === null || rotation === void 0 ? void 0 : rotation.reset();
                eulerAngles === null || eulerAngles === void 0 ? void 0 : eulerAngles.reset();
              };

              _proto10._createVec3BlendState = function _createVec3BlendState(currentValue) {
                return new LayeredVec3PropertyBlendState(currentValue);
              };

              _proto10._createQuatBlendState = function _createQuatBlendState(currentValue) {
                return new LayeredQuatPropertyBlendState(currentValue);
              };

              return LayeredNodeBlendState;
            }(NodeBlendState);

            var LayeredBlendStateBuffer = function (_BlendStateBuffer2) {
              _inheritsLoose(LayeredBlendStateBuffer, _BlendStateBuffer2);

              function LayeredBlendStateBuffer() {
                return _BlendStateBuffer2.apply(this, arguments) || this;
              }

              var _proto11 = LayeredBlendStateBuffer.prototype;

              _proto11.setMask = function setMask(layerIndex, excludeNodes) {
                {
                  checkLayerIndex(layerIndex);
                }

                this._nodeBlendStates.forEach(function (nodeBlendState, node) {
                  if (excludeNodes.has(node)) {
                    nodeBlendState.setLayerMask(layerIndex);
                  }
                });
              };

              _proto11.commitLayerChanges = function commitLayerChanges(layerIndex, weight) {
                {
                  checkLayerIndex(layerIndex);
                }

                this._nodeBlendStates.forEach(function (nodeBlendState, node) {
                  nodeBlendState.commitLayerChanges(layerIndex, weight);
                });
              };

              _proto11.createNodeBlendState = function createNodeBlendState() {
                return new LayeredNodeBlendState();
              };

              return LayeredBlendStateBuffer;
            }(BlendStateBuffer);

            function checkLayerIndex(layerIndex) {
              assertIsTrue(layerIndex < MAX_ANIMATION_LAYER);
            }

            function mixAveragedVec3(result, previous, accumulatedWeight, input, weight) {
              var newSum = accumulatedWeight + weight;

              if (weight === 1.0 && !accumulatedWeight) {
                Vec3.copy(result, input);
              } else if (newSum) {
                var t = weight / newSum;
                Vec3.lerp(result, result, input, t);
              }

              return newSum;
            }

            function mixAveragedQuat(result, previous, accumulatedWeight, input, weight) {
              var newSum = accumulatedWeight + weight;

              if (weight === 1.0 && !accumulatedWeight) {
                Quat.copy(result, input);
              } else if (newSum) {
                var t = weight / newSum;
                Quat.slerp(result, previous, input, t);
              }

              return newSum;
            }

            var _dec$10, _class$10;
            var StateMachineComponent = (_dec$10 = ccclass$p(CLASS_NAME_PREFIX_ANIM + "StateMachineComponent"), _dec$10(_class$10 = function () {
              function StateMachineComponent() {}

              var _proto = StateMachineComponent.prototype;

              _proto.onMotionStateEnter = function onMotionStateEnter(controller, motionStateStatus) {};

              _proto.onMotionStateExit = function onMotionStateExit(controller, motionStateStatus) {};

              _proto.onMotionStateUpdate = function onMotionStateUpdate(controller, motionStateStatus) {};

              _proto.onStateMachineEnter = function onStateMachineEnter(controller) {};

              _proto.onStateMachineExit = function onStateMachineExit(controller) {};

              return StateMachineComponent;
            }()) || _class$10);

            var _Object$freeze;
            var AnimationGraphEval = function () {
              function AnimationGraphEval(graph, root, controller, clipOverrides) {
                var _this = this;

                this._blendBuffer = new LayeredBlendStateBuffer();
                this._currentTransitionCache = {
                  duration: 0.0,
                  time: 0.0
                };
                this._varInstances = {};
                this._hasAutoTrigger = false;
                this._root = void 0;

                {
                  if (graph.layers.length >= MAX_ANIMATION_LAYER) {
                    throw new Error("Max layer count exceeds. " + ("Allowed: " + MAX_ANIMATION_LAYER + ", actual: " + graph.layers.length));
                  }
                }

                for (var _iterator = _createForOfIteratorHelperLoose(graph.variables), _step; !(_step = _iterator()).done;) {
                  var _step$value = _step.value,
                      _name = _step$value[0],
                      variable = _step$value[1];
                  var varInstance = this._varInstances[_name] = new VarInstance(variable.type, variable.value);

                  if (variable.type === VariableType.TRIGGER) {
                    var resetMode = variable.resetMode;
                    varInstance.resetMode = resetMode;

                    if (resetMode === TriggerResetMode.NEXT_FRAME_OR_AFTER_CONSUMED) {
                      this._hasAutoTrigger = true;
                    }
                  }
                }

                var context = {
                  controller: controller,
                  blendBuffer: this._blendBuffer,
                  node: root,
                  clipOverrides: clipOverrides,
                  getVar: function getVar(id) {
                    return _this._varInstances[id];
                  },
                  triggerResetFn: function triggerResetFn(name) {
                    _this.setValue(name, false);
                  }
                };
                var layerEvaluations = this._layerEvaluations = graph.layers.map(function (layer) {
                  var layerEval = new LayerEval(layer, _extends({}, context));
                  return layerEval;
                });
                var nLayers = layerEvaluations.length;

                for (var iLayer = 0; iLayer < nLayers; ++iLayer) {
                  var mask = graph.layers[iLayer].mask;

                  if (mask) {
                    var excludeNodes = mask.filterDisabledNodes(context.node);

                    this._blendBuffer.setMask(iLayer, excludeNodes);
                  }
                }

                this._root = root;
              }

              var _proto = AnimationGraphEval.prototype;

              _proto.update = function update(deltaTime) {
                var blendBuffer = this._blendBuffer,
                    layerEvaluations = this._layerEvaluations;
                var nLayers = layerEvaluations.length;

                for (var iLayer = 0; iLayer < nLayers; ++iLayer) {
                  var layerEval = layerEvaluations[iLayer];
                  layerEval.update(deltaTime);
                  blendBuffer.commitLayerChanges(iLayer, layerEval.weight * layerEval.passthroughWeight);
                }

                if (this._hasAutoTrigger) {
                  var varInstances = this._varInstances;

                  for (var varName in varInstances) {
                    var varInstance = varInstances[varName];

                    if (varInstance.type === VariableType.TRIGGER && varInstance.resetMode === TriggerResetMode.NEXT_FRAME_OR_AFTER_CONSUMED) {
                      varInstance.value = false;
                    }
                  }
                }

                this._blendBuffer.apply();
              };

              _proto.getVariables = function getVariables() {
                return Object.entries(this._varInstances);
              };

              _proto.getCurrentStateStatus = function getCurrentStateStatus(layer) {
                return this._layerEvaluations[layer].getCurrentStateStatus();
              };

              _proto.getCurrentClipStatuses = function getCurrentClipStatuses(layer) {
                return this._layerEvaluations[layer].getCurrentClipStatuses();
              };

              _proto.getCurrentTransition = function getCurrentTransition(layer) {
                var layers = this._layerEvaluations,
                    currentTransition = this._currentTransitionCache;
                var isInTransition = layers[layer].getCurrentTransition(currentTransition);
                return isInTransition ? currentTransition : null;
              };

              _proto.getNextStateStatus = function getNextStateStatus(layer) {
                return this._layerEvaluations[layer].getNextStateStatus();
              };

              _proto.getNextClipStatuses = function getNextClipStatuses(layer) {
                return this._layerEvaluations[layer].getNextClipStatuses();
              };

              _proto.getValue = function getValue(name) {
                var varInstance = this._varInstances[name];

                if (!varInstance) {
                  return undefined;
                } else {
                  return varInstance.value;
                }
              };

              _proto.setValue = function setValue(name, value) {
                var varInstance = this._varInstances[name];

                if (!varInstance) {
                  return;
                }

                varInstance.value = value;
              };

              _proto.getLayerWeight = function getLayerWeight(layerIndex) {
                assertIsTrue(layerIndex >= 0 && layerIndex < this._layerEvaluations.length, "Invalid layer index");
                return this._layerEvaluations[layerIndex].weight;
              };

              _proto.setLayerWeight = function setLayerWeight(layerIndex, weight) {
                assertIsTrue(layerIndex >= 0 && layerIndex < this._layerEvaluations.length, "Invalid layer index");
                this._layerEvaluations[layerIndex].weight = weight;
              };

              _proto.overrideClips = function overrideClips(overrides) {
                var layerEvaluations = this._layerEvaluations;
                var nLayers = layerEvaluations.length;

                for (var iLayer = 0; iLayer < nLayers; ++iLayer) {
                  var layerEval = layerEvaluations[iLayer];
                  layerEval.overrideClips(overrides, this._root, this._blendBuffer);
                }
              };

              _createClass(AnimationGraphEval, [{
                key: "layerCount",
                get: function get() {
                  return this._layerEvaluations.length;
                }
              }]);

              return AnimationGraphEval;
            }();

            var LayerEval = function () {
              function LayerEval(layer, context) {
                var _layer$mask;

                this.passthroughWeight = 1.0;
                this._motionStates = [];
                this._topLevelEntry = void 0;
                this._topLevelExit = void 0;
                this._currentNode = void 0;
                this._currentTransitionToNode = null;
                this._currentTransitionPath = [];
                this._transitionProgress = 0;
                this._fromWeight = 0.0;
                this._toWeight = 0.0;
                this._fromUpdated = false;
                this._toUpdated = false;
                this._transitionSnapshot = new TransitionSnapshotEval();
                this._mask = null;
                this.name = layer.name;
                this._controller = context.controller;
                this.weight = layer.weight;

                var _this$_addStateMachin = this._addStateMachine(layer.stateMachine, null, _extends({
                  mask: (_layer$mask = layer.mask) !== null && _layer$mask !== void 0 ? _layer$mask : undefined
                }, context), layer.name),
                    entry = _this$_addStateMachin.entry,
                    exit = _this$_addStateMachin.exit;

                this._topLevelEntry = entry;
                this._topLevelExit = exit;
                this._currentNode = entry;
                this._resetTrigger = context.triggerResetFn;
                this._mask = layer.mask;
              }

              var _proto2 = LayerEval.prototype;

              _proto2.update = function update(deltaTime) {
                if (!this.exited) {
                  this._fromWeight = 1.0;
                  this._toWeight = 0.0;

                  this._eval(deltaTime);

                  this._sample();
                }
              };

              _proto2.getCurrentStateStatus = function getCurrentStateStatus() {
                var currentNode = this._currentNode;

                if (currentNode.kind === NodeKind.animation) {
                  return currentNode.getFromPortStatus();
                } else if (currentNode.kind === NodeKind.transitionSnapshot) {
                  return currentNode.first.getFromPortStatus();
                } else {
                  return null;
                }
              };

              _proto2.getCurrentClipStatuses = function getCurrentClipStatuses() {
                var currentNode = this._currentNode;

                if (currentNode.kind === NodeKind.animation) {
                  return currentNode.getClipStatuses(this._fromWeight);
                } else if (currentNode.kind === NodeKind.transitionSnapshot) {
                  return currentNode.first.getClipStatuses(this._fromWeight);
                } else {
                  return emptyClipStatusesIterable;
                }
              };

              _proto2.getCurrentTransition = function getCurrentTransition(transitionStatus) {
                var currentTransitionPath = this._currentTransitionPath;

                if (currentTransitionPath.length !== 0) {
                  var lastNode = currentTransitionPath[currentTransitionPath.length - 1];

                  if (lastNode.to.kind !== NodeKind.animation && lastNode.to.kind !== NodeKind.empty) {
                    return false;
                  }

                  var _currentTransitionPat = currentTransitionPath[0],
                      duration = _currentTransitionPat.duration,
                      normalizedDuration = _currentTransitionPat.normalizedDuration;
                  var durationInSeconds = transitionStatus.duration = normalizedDuration ? duration * (this._currentNode.kind === NodeKind.animation ? this._currentNode.duration : this._currentNode.kind === NodeKind.transitionSnapshot ? this._currentNode.first.duration : 0.0) : duration;
                  transitionStatus.time = this._transitionProgress * durationInSeconds;
                  return true;
                } else {
                  return false;
                }
              };

              _proto2.getNextStateStatus = function getNextStateStatus() {
                if (!this._currentTransitionToNode || this._currentTransitionToNode.kind === NodeKind.empty) {
                  return null;
                }

                return this._currentTransitionToNode.getToPortStatus();
              };

              _proto2.getNextClipStatuses = function getNextClipStatuses() {
                var _to$getClipStatuses;

                var currentTransitionPath = this._currentTransitionPath;
                var nCurrentTransitionPath = currentTransitionPath.length;

                if (nCurrentTransitionPath === 0) {
                  return emptyClipStatusesIterable;
                }

                var to = currentTransitionPath[nCurrentTransitionPath - 1].to;

                if (to.kind !== NodeKind.animation) {
                  return emptyClipStatusesIterable;
                }

                return (_to$getClipStatuses = to.getClipStatuses(this._toWeight)) !== null && _to$getClipStatuses !== void 0 ? _to$getClipStatuses : emptyClipStatusesIterable;
              };

              _proto2.overrideClips = function overrideClips(overrides, node, blendBuffer) {
                var _this$_mask;

                var motionStates = this._motionStates;
                var overrideClipContext = {
                  node: node,
                  blendBuffer: blendBuffer,
                  mask: (_this$_mask = this._mask) !== null && _this$_mask !== void 0 ? _this$_mask : undefined
                };
                var nMotionStates = motionStates.length;

                for (var iMotionState = 0; iMotionState < nMotionStates; ++iMotionState) {
                  var _node = motionStates[iMotionState];

                  if (_node.kind === NodeKind.animation) {
                    _node.overrideClips(overrides, overrideClipContext);
                  }
                }
              };

              _proto2._addStateMachine = function _addStateMachine(graph, parentStateMachineInfo, context, __DEBUG_ID__) {
                var _this2 = this;

                var nodes = Array.from(graph.states());
                var entryEval;
                var anyNode;
                var exitEval;
                var nodeEvaluations = nodes.map(function (node) {
                  if (node instanceof MotionState) {
                    var motionStateEval = new MotionStateEval(node, context);

                    _this2._motionStates.push(motionStateEval);

                    return motionStateEval;
                  } else if (node === graph.entryState) {
                    return entryEval = new SpecialStateEval(node, NodeKind.entry, node.name);
                  } else if (node === graph.exitState) {
                    return exitEval = new SpecialStateEval(node, NodeKind.exit, node.name);
                  } else if (node === graph.anyState) {
                    return anyNode = new SpecialStateEval(node, NodeKind.any, node.name);
                  } else if (node instanceof EmptyState) {
                    return new EmptyStateEval(node);
                  } else {
                    assertIsTrue(node instanceof SubStateMachine);
                    return null;
                  }
                });
                assertIsNonNullable(entryEval, 'Entry node is missing');
                assertIsNonNullable(exitEval, 'Exit node is missing');
                assertIsNonNullable(anyNode, 'Any node is missing');
                var stateMachineInfo = {
                  components: null,
                  parent: parentStateMachineInfo,
                  entry: entryEval,
                  exit: exitEval,
                  any: anyNode
                };

                for (var iNode = 0; iNode < nodes.length; ++iNode) {
                  var nodeEval = nodeEvaluations[iNode];

                  if (nodeEval) {
                    nodeEval.stateMachine = stateMachineInfo;
                  }
                }

                var subStateMachineInfos = nodes.map(function (node) {
                  if (node instanceof SubStateMachine) {
                    var subStateMachineInfo = _this2._addStateMachine(node.stateMachine, stateMachineInfo, context, __DEBUG_ID__ + "/" + node.name);

                    subStateMachineInfo.components = new InstantiatedComponents(node);
                    return subStateMachineInfo;
                  } else {
                    return null;
                  }
                });

                {
                  for (var _iterator2 = _createForOfIteratorHelperLoose(nodeEvaluations), _step2; !(_step2 = _iterator2()).done;) {
                    var _nodeEval = _step2.value;

                    if (_nodeEval) {
                      _nodeEval.__DEBUG_ID__ = _nodeEval.name + "(from " + __DEBUG_ID__ + ")";
                    }
                  }
                }

                for (var _iNode = 0; _iNode < nodes.length; ++_iNode) {
                  var node = nodes[_iNode];
                  var outgoingTemplates = graph.getOutgoings(node);
                  var outgoingTransitions = [];
                  var fromNode = void 0;

                  if (node instanceof SubStateMachine) {
                    var subStateMachineInfo = subStateMachineInfos[_iNode];
                    assertIsNonNullable(subStateMachineInfo);
                    fromNode = subStateMachineInfo.exit;
                  } else {
                    var _nodeEval2 = nodeEvaluations[_iNode];
                    assertIsNonNullable(_nodeEval2);
                    fromNode = _nodeEval2;
                  }

                  var _loop = function _loop() {
                    var outgoing = _step3.value;
                    var outgoingNode = outgoing.to;
                    var iOutgoingNode = nodes.findIndex(function (nodeTemplate) {
                      return nodeTemplate === outgoing.to;
                    });

                    if (iOutgoingNode < 0) {
                      assertIsTrue(false, 'Bad animation data');
                    }

                    var toNode = void 0;

                    if (outgoingNode instanceof SubStateMachine) {
                      var _subStateMachineInfo = subStateMachineInfos[iOutgoingNode];
                      assertIsNonNullable(_subStateMachineInfo);
                      toNode = _subStateMachineInfo.entry;
                    } else {
                      var _nodeEval3 = nodeEvaluations[iOutgoingNode];
                      assertIsNonNullable(_nodeEval3);
                      toNode = _nodeEval3;
                    }

                    var conditions = outgoing.conditions.map(function (condition) {
                      return condition[createEval](context);
                    });
                    var transitionEval = {
                      conditions: conditions,
                      to: toNode,
                      triggers: undefined,
                      duration: 0.0,
                      normalizedDuration: false,
                      destinationStart: 0.0,
                      relativeDestinationStart: false,
                      exitCondition: 0.0,
                      exitConditionEnabled: false,
                      interruption: TransitionInterruptionSource.NONE
                    };

                    if (isAnimationTransition(outgoing)) {
                      transitionEval.duration = outgoing.duration;
                      transitionEval.normalizedDuration = outgoing.relativeDuration;
                      transitionEval.exitConditionEnabled = outgoing.exitConditionEnabled;
                      transitionEval.exitCondition = outgoing.exitCondition;
                      transitionEval.destinationStart = outgoing.destinationStart;
                      transitionEval.relativeDestinationStart = outgoing.relativeDestinationStart;
                      transitionEval.interruption = outgoing.interruptionSource;
                    } else if (outgoing instanceof EmptyStateTransition) {
                      transitionEval.duration = outgoing.duration;
                      transitionEval.destinationStart = outgoing.destinationStart;
                      transitionEval.relativeDestinationStart = outgoing.relativeDestinationStart;
                    }

                    transitionEval.conditions.forEach(function (conditionEval, iCondition) {
                      var condition = outgoing.conditions[iCondition];

                      if (condition instanceof TriggerCondition && condition.trigger) {
                        var _transitionEval$trigg;

                        ((_transitionEval$trigg = transitionEval.triggers) !== null && _transitionEval$trigg !== void 0 ? _transitionEval$trigg : transitionEval.triggers = []).push(condition.trigger);
                      }
                    });
                    outgoingTransitions.push(transitionEval);
                  };

                  for (var _iterator3 = _createForOfIteratorHelperLoose(outgoingTemplates), _step3; !(_step3 = _iterator3()).done;) {
                    _loop();
                  }

                  fromNode.outgoingTransitions = outgoingTransitions;
                }

                return stateMachineInfo;
              };

              _proto2._eval = function _eval(deltaTime) {
                assertIsTrue(!this.exited);

                var haltOnNonMotionState = this._continueDanglingTransition();

                if (haltOnNonMotionState) {
                  return 0.0;
                }

                var MAX_ITERATIONS = 100;
                var remainTimePiece = deltaTime;

                for (var continueNextIterationForce = true, iterations = 0; continueNextIterationForce || remainTimePiece > 0.0;) {
                  continueNextIterationForce = false;

                  if (iterations === MAX_ITERATIONS) {
                    warnID(14000, MAX_ITERATIONS);
                    break;
                  }

                  ++iterations;

                  if (this._currentTransitionPath.length > 0) {
                    var _transitionMatch = this._detectInterruption(remainTimePiece, interruptingTransitionMatchCache);

                    if (_transitionMatch) {
                      remainTimePiece -= _transitionMatch.requires;

                      var ranIntoNonMotionState = this._interrupt(_transitionMatch);

                      if (ranIntoNonMotionState) {
                        break;
                      }

                      continueNextIterationForce = true;
                      continue;
                    }

                    var currentUpdatingConsume = this._updateCurrentTransition(remainTimePiece);

                    remainTimePiece -= currentUpdatingConsume;

                    if (this._currentNode.kind === NodeKind.exit) {
                      break;
                    }

                    if (this._currentTransitionPath.length === 0) {
                      continueNextIterationForce = true;
                    }

                    continue;
                  }

                  var currentNode = this._currentNode;

                  var transitionMatch = this._matchCurrentNodeTransition(remainTimePiece);

                  if (transitionMatch) {
                    var transition = transitionMatch.transition,
                        updateRequires = transitionMatch.requires;
                    remainTimePiece -= updateRequires;

                    if (currentNode.kind === NodeKind.animation) {
                      currentNode.updateFromPort(updateRequires);
                      this._fromUpdated = true;
                    }

                    var _ranIntoNonMotionState = this._switchTo(transition);

                    if (_ranIntoNonMotionState) {
                      break;
                    }

                    continueNextIterationForce = true;
                  } else {
                    if (currentNode.kind === NodeKind.animation) {
                      currentNode.updateFromPort(remainTimePiece);
                      this._fromUpdated = true;
                      remainTimePiece = 0.0;
                    } else {
                      remainTimePiece = 0.0;
                    }

                    continue;
                  }
                }

                if (this._fromUpdated && this._currentNode.kind === NodeKind.animation) {
                  this._fromUpdated = false;

                  this._currentNode.triggerFromPortUpdate(this._controller);
                }

                if (this._currentTransitionToNode && this._toUpdated && this._currentTransitionToNode.kind === NodeKind.animation) {
                  this._toUpdated = false;

                  this._currentTransitionToNode.triggerToPortUpdate(this._controller);
                }

                return remainTimePiece;
              };

              _proto2._sample = function _sample() {
                var currentNode = this._currentNode,
                    currentTransitionToNode = this._currentTransitionToNode,
                    fromWeight = this._fromWeight,
                    toWeight = this._toWeight;

                if (currentNode.kind === NodeKind.empty) {
                  this.passthroughWeight = 0.0;

                  if (currentTransitionToNode && currentTransitionToNode.kind === NodeKind.animation) {
                    this.passthroughWeight = toWeight;
                    currentTransitionToNode.sampleToPort(1.0);
                  }
                } else if (currentTransitionToNode && currentTransitionToNode.kind === NodeKind.empty) {
                  this.passthroughWeight = fromWeight;

                  this._sampleSource(1.0);
                } else {
                  this.passthroughWeight = 1.0;

                  this._sampleSource(fromWeight);

                  if (currentTransitionToNode && currentTransitionToNode.kind === NodeKind.animation) {
                    currentTransitionToNode.sampleToPort(toWeight);
                  }
                }
              };

              _proto2._sampleSource = function _sampleSource(weight) {
                var currentNode = this._currentNode;

                if (currentNode.kind === NodeKind.animation) {
                  currentNode.sampleFromPort(weight);
                } else if (currentNode.kind === NodeKind.transitionSnapshot) {
                  currentNode.sample(weight);
                }
              };

              _proto2._matchCurrentNodeTransition = function _matchCurrentNodeTransition(deltaTime) {
                var currentNode = this._currentNode;
                var transitionMatch = transitionMatchCache.reset();

                this._matchTransition(currentNode, currentNode, deltaTime, null, transitionMatch);

                if (transitionMatch.hasZeroCost()) {
                  return transitionMatch;
                }

                if (currentNode.kind === NodeKind.animation) {
                  this._matchAnyScoped(currentNode, deltaTime, transitionMatch);

                  if (transitionMatch.hasZeroCost()) {
                    return transitionMatch;
                  }
                }

                if (transitionMatch.isValid()) {
                  return transitionMatch;
                }

                return null;
              };

              _proto2._matchAnyScoped = function _matchAnyScoped(realNode, deltaTime, result) {
                var transitionMatchUpdated = false;

                for (var ancestor = realNode.stateMachine; ancestor !== null; ancestor = ancestor.parent) {
                  var updated = this._matchTransition(ancestor.any, realNode, deltaTime, null, result);

                  if (updated) {
                    transitionMatchUpdated = true;
                  }

                  if (result.hasZeroCost()) {
                    break;
                  }
                }

                return transitionMatchUpdated;
              };

              _proto2._matchTransition = function _matchTransition(node, realNode, deltaTime, except, result) {
                assertIsTrue(node === realNode || node.kind === NodeKind.any);
                var outgoingTransitions = node.outgoingTransitions;
                var nTransitions = outgoingTransitions.length;
                var resultUpdated = false;

                for (var iTransition = 0; iTransition < nTransitions; ++iTransition) {
                  var transition = outgoingTransitions[iTransition];

                  if (transition === except) {
                    continue;
                  }

                  var conditions = transition.conditions;
                  var nConditions = conditions.length;

                  if (nConditions === 0) {
                    if (node.kind === NodeKind.entry || node.kind === NodeKind.exit) {
                      result.set(transition, 0.0);
                      resultUpdated = true;
                      break;
                    }

                    if (!transition.exitConditionEnabled) {
                      continue;
                    }
                  }

                  var deltaTimeRequired = 0.0;

                  if (realNode.kind === NodeKind.animation && transition.exitConditionEnabled) {
                    var exitTime = realNode.duration * transition.exitCondition;
                    deltaTimeRequired = Math.max(exitTime - realNode.fromPortTime, 0.0);

                    if (deltaTimeRequired > deltaTime || deltaTimeRequired >= result.requires) {
                      continue;
                    }
                  }

                  var satisfied = true;

                  for (var iCondition = 0; iCondition < nConditions; ++iCondition) {
                    var condition = conditions[iCondition];

                    if (!condition.eval()) {
                      satisfied = false;
                      break;
                    }
                  }

                  if (!satisfied) {
                    continue;
                  }

                  if (deltaTimeRequired === 0.0) {
                    result.set(transition, 0.0);
                    resultUpdated = true;
                    break;
                  }

                  assertIsTrue(deltaTimeRequired <= result.requires);
                  result.set(transition, deltaTimeRequired);
                  resultUpdated = true;
                }

                return resultUpdated;
              };

              _proto2._switchTo = function _switchTo(transition) {
                var currentTransitionPath = this._currentTransitionPath;

                this._consumeTransition(transition);

                currentTransitionPath.push(transition);

                var motionNode = this._matchTransitionPathUntilMotion();

                if (motionNode) {
                  this._doTransitionToMotion(motionNode);

                  return false;
                } else {
                  return true;
                }
              };

              _proto2._continueDanglingTransition = function _continueDanglingTransition() {
                var currentTransitionPath = this._currentTransitionPath;
                var lenCurrentTransitionPath = currentTransitionPath.length;

                if (lenCurrentTransitionPath === 0) {
                  return false;
                }

                var lastTransition = currentTransitionPath[lenCurrentTransitionPath - 1];
                var tailNode = lastTransition.to;

                if (tailNode.kind !== NodeKind.animation && tailNode.kind !== NodeKind.empty) {
                  var motionNode = this._matchTransitionPathUntilMotion();

                  if (motionNode) {
                    this._doTransitionToMotion(motionNode);

                    return false;
                  } else {
                    return true;
                  }
                }

                return false;
              };

              _proto2._matchTransitionPathUntilMotion = function _matchTransitionPathUntilMotion() {
                var currentTransitionPath = this._currentTransitionPath;
                var lenCurrentTransitionPath = currentTransitionPath.length;
                assertIsTrue(lenCurrentTransitionPath !== 0);
                var lastTransition = currentTransitionPath[lenCurrentTransitionPath - 1];
                var tailNode = lastTransition.to;

                for (; tailNode.kind !== NodeKind.animation && tailNode.kind !== NodeKind.empty;) {
                  var transitionMatch = transitionMatchCache.reset();

                  this._matchTransition(tailNode, tailNode, 0.0, null, transitionMatch);

                  if (!transitionMatch.transition) {
                    break;
                  }

                  var transition = transitionMatch.transition;

                  this._consumeTransition(transition);

                  currentTransitionPath.push(transition);
                  tailNode = transition.to;
                }

                return tailNode.kind === NodeKind.animation || tailNode.kind === NodeKind.empty ? tailNode : null;
              };

              _proto2._consumeTransition = function _consumeTransition(transition) {
                var to = transition.to;

                if (to.kind === NodeKind.entry) {
                  this._callEnterMethods(to);
                }
              };

              _proto2._resetTriggersAlongThePath = function _resetTriggersAlongThePath() {
                var currentTransitionPath = this._currentTransitionPath;
                var nTransitions = currentTransitionPath.length;

                for (var iTransition = 0; iTransition < nTransitions; ++iTransition) {
                  var transition = currentTransitionPath[iTransition];

                  this._resetTriggersOnTransition(transition);
                }
              };

              _proto2._doTransitionToMotion = function _doTransitionToMotion(targetNode) {
                var currentTransitionPath = this._currentTransitionPath;
                assertIsTrue(currentTransitionPath.length !== 0);

                this._resetTriggersAlongThePath();

                this._transitionProgress = 0.0;
                this._currentTransitionToNode = targetNode;
                this._toUpdated = false;

                if (targetNode.kind === NodeKind.animation) {
                  var _currentTransitionPat2 = currentTransitionPath[0],
                      destinationStart = _currentTransitionPat2.destinationStart,
                      relativeDestinationStart = _currentTransitionPat2.relativeDestinationStart;
                  var destinationStartRatio = relativeDestinationStart ? destinationStart : targetNode.duration === 0 ? 0.0 : destinationStart / targetNode.duration;
                  targetNode.resetToPort(destinationStartRatio);
                }

                this._callEnterMethods(targetNode);
              };

              _proto2._updateCurrentTransition = function _updateCurrentTransition(deltaTime) {
                var _toNode$name;

                var currentTransitionPath = this._currentTransitionPath,
                    currentTransitionToNode = this._currentTransitionToNode;
                assertIsNonNullable(currentTransitionPath.length > 0);
                assertIsNonNullable(currentTransitionToNode);
                var currentTransition = currentTransitionPath[0];
                var transitionDuration = currentTransition.duration,
                    normalizedDuration = currentTransition.normalizedDuration;
                var fromNode = this._currentNode;
                var toNode = currentTransitionToNode;
                var contrib = 0.0;
                var ratio = 0.0;

                if (transitionDuration <= 0) {
                  contrib = 0.0;
                  ratio = 1.0;
                } else {
                  assertIsTrue(fromNode.kind === NodeKind.animation || fromNode.kind === NodeKind.empty || fromNode.kind === NodeKind.transitionSnapshot);
                  var transitionProgress = this._transitionProgress;
                  var durationSeconds = fromNode.kind === NodeKind.empty ? transitionDuration : normalizedDuration ? transitionDuration * (fromNode.kind === NodeKind.animation ? fromNode.duration : fromNode.first.duration) : transitionDuration;
                  var progressSeconds = transitionProgress * durationSeconds;
                  var remain = durationSeconds - progressSeconds;
                  assertIsTrue(remain >= 0.0);
                  contrib = Math.min(remain, deltaTime);
                  ratio = this._transitionProgress = (progressSeconds + contrib) / durationSeconds;
                  assertIsTrue(ratio >= 0.0 && ratio <= 1.0);
                }

                var toNodeName = (_toNode$name = toNode === null || toNode === void 0 ? void 0 : toNode.name) !== null && _toNode$name !== void 0 ? _toNode$name : '<Empty>';
                this._fromWeight = 1.0 - ratio;
                this._toWeight = ratio;
                var shouldUpdatePorts = contrib !== 0;
                var hasFinished = ratio === 1.0;

                if (fromNode.kind === NodeKind.animation && shouldUpdatePorts) {
                  fromNode.updateFromPort(contrib);
                  this._fromUpdated = true;
                }

                if (toNode.kind === NodeKind.animation && shouldUpdatePorts) {
                  toNode.updateToPort(contrib);
                  this._toUpdated = true;
                }

                if (hasFinished) {
                  this._finishCurrentTransition();
                }

                return contrib;
              };

              _proto2._finishCurrentTransition = function _finishCurrentTransition() {
                var currentTransitionPath = this._currentTransitionPath,
                    currentTransitionToNode = this._currentTransitionToNode;
                assertIsNonNullable(currentTransitionPath.length > 0);
                assertIsNonNullable(currentTransitionToNode);
                var fromNode = this._currentNode;
                var toNode = currentTransitionToNode;

                this._callExitMethods(fromNode);

                var transitions = this._currentTransitionPath;
                var nTransition = transitions.length;

                for (var iTransition = 0; iTransition < nTransition; ++iTransition) {
                  var to = transitions[iTransition].to;

                  if (to.kind === NodeKind.exit) {
                    this._callExitMethods(to);
                  }
                }

                this._fromUpdated = this._toUpdated;
                this._toUpdated = false;

                this._dropCurrentTransition();

                this._currentNode = toNode;

                if (fromNode.kind === NodeKind.transitionSnapshot) {
                  fromNode.clear();
                }
              };

              _proto2._dropCurrentTransition = function _dropCurrentTransition() {
                var currentTransitionToNode = this._currentTransitionToNode;
                assertIsNonNullable(currentTransitionToNode);

                if (currentTransitionToNode.kind === NodeKind.animation) {
                  currentTransitionToNode.finishTransition();
                }

                this._currentTransitionToNode = null;
                this._currentTransitionPath.length = 0;
                this._fromWeight = 1.0;
                this._toWeight = 0.0;
              };

              _proto2._detectInterruption = function _detectInterruption(remainTimePiece, result) {
                var currentTransitionPath = this._currentTransitionPath,
                    currentNode = this._currentNode,
                    currentTransitionToNode = this._currentTransitionToNode;

                if (currentNode.kind !== NodeKind.animation && currentNode.kind !== NodeKind.transitionSnapshot) {
                  return null;
                }

                if (!currentTransitionToNode || currentTransitionToNode.kind !== NodeKind.animation) {
                  return null;
                }

                assertIsTrue(currentTransitionPath.length !== 0);
                var currentTransition = currentTransitionPath[0];
                var interruption = currentTransition.interruption;

                if (interruption === TransitionInterruptionSource.NONE) {
                  return null;
                }

                var transitionMatch = transitionMatchCache.reset();
                var transitionMatchSource = null;
                var anyTransitionMeasureBaseState = currentNode.kind === NodeKind.animation ? currentNode : currentNode.first;

                var transitionMatchUpdated = this._matchAnyScoped(anyTransitionMeasureBaseState, remainTimePiece, transitionMatch);

                if (transitionMatchUpdated) {
                  transitionMatchSource = anyTransitionMeasureBaseState;
                }

                if (transitionMatch.hasZeroCost()) ;

                var motion0 = interruption === TransitionInterruptionSource.CURRENT_STATE || interruption === TransitionInterruptionSource.CURRENT_STATE_THEN_NEXT_STATE ? getInterruptionSourceMotion(currentNode) : currentTransitionToNode;
                transitionMatchUpdated = this._matchTransition(motion0, motion0, remainTimePiece, currentTransition, transitionMatch);

                if (transitionMatchUpdated) {
                  transitionMatchSource = motion0;
                }

                if (transitionMatch.hasZeroCost()) ;

                var motion1 = interruption === TransitionInterruptionSource.NEXT_STATE_THEN_CURRENT_STATE ? getInterruptionSourceMotion(currentNode) : interruption === TransitionInterruptionSource.CURRENT_STATE_THEN_NEXT_STATE ? currentTransitionToNode : null;

                if (motion1) {
                  transitionMatchUpdated = this._matchTransition(motion1, motion1, remainTimePiece, currentTransition, transitionMatch);

                  if (transitionMatchUpdated) {
                    transitionMatchSource = motion1;
                  }

                  if (transitionMatch.hasZeroCost()) ;
                }

                if (transitionMatchCache.transition) {
                  assertIsNonNullable(transitionMatchSource);
                  return result.set(transitionMatchSource, transitionMatchCache.transition, transitionMatchCache.requires);
                }

                return null;
              };

              _proto2._interrupt = function _interrupt(_ref) {
                var transitionSource = _ref.from,
                    transition = _ref.transition,
                    transitionRequires = _ref.requires;
                var currentNode = this._currentNode;
                assertIsTrue(currentNode.kind === NodeKind.animation || currentNode.kind === NodeKind.transitionSnapshot);

                if (currentNode.kind === NodeKind.animation) {
                  currentNode.updateFromPort(transitionRequires);
                  this._fromUpdated = true;
                  var transitionSnapshot = this._transitionSnapshot;
                  assertIsTrue(transitionSnapshot.empty);
                  transitionSnapshot.enqueue(currentNode, 1.0);
                }

                this._takeCurrentTransitionSnapshot(transitionSource);

                this._dropCurrentTransition();

                this._currentNode = this._transitionSnapshot;

                var ranIntoNonMotionState = this._switchTo(transition);

                return ranIntoNonMotionState;
              };

              _proto2._takeCurrentTransitionSnapshot = function _takeCurrentTransitionSnapshot(transitionSource) {
                var currentTransitionPath = this._currentTransitionPath,
                    currentTransitionToNode = this._currentTransitionToNode,
                    transitionSnapshot = this._transitionSnapshot;
                assertIsTrue(currentTransitionPath.length !== 0);
                assertIsTrue(currentTransitionToNode && currentTransitionToNode.kind === NodeKind.animation);
                var currentTransition = currentTransitionPath[0];
                var transitionDuration = currentTransition.duration,
                    normalizedDuration = currentTransition.normalizedDuration;
                var fromNode = transitionSource;
                var ratio = 0.0;

                if (transitionDuration <= 0) {
                  ratio = 1.0;
                } else {
                  var transitionProgress = this._transitionProgress;
                  var durationSeconds = normalizedDuration ? transitionDuration * fromNode.duration : transitionDuration;
                  var progressSeconds = transitionProgress * durationSeconds;
                  var remain = durationSeconds - progressSeconds;
                  assertIsTrue(remain >= 0.0);
                  ratio = progressSeconds / durationSeconds;
                  assertIsTrue(ratio >= 0.0 && ratio <= 1.0);
                }

                transitionSnapshot.enqueue(currentTransitionToNode, ratio);
              };

              _proto2._resetTriggersOnTransition = function _resetTriggersOnTransition(transition) {
                var triggers = transition.triggers;

                if (triggers) {
                  var nTriggers = triggers.length;

                  for (var iTrigger = 0; iTrigger < nTriggers; ++iTrigger) {
                    var trigger = triggers[iTrigger];

                    this._resetTrigger(trigger);
                  }
                }
              };

              _proto2._resetTrigger = function _resetTrigger(name) {
                var triggerResetFn = this._triggerReset;
                triggerResetFn(name);
              };

              _proto2._callEnterMethods = function _callEnterMethods(node) {
                var _node$stateMachine$co;

                var controller = this._controller;

                switch (node.kind) {
                  default:
                    break;

                  case NodeKind.animation:
                    {
                      node.components.callMotionStateEnterMethods(controller, node.getToPortStatus());
                      break;
                    }

                  case NodeKind.entry:
                    (_node$stateMachine$co = node.stateMachine.components) === null || _node$stateMachine$co === void 0 ? void 0 : _node$stateMachine$co.callStateMachineEnterMethods(controller);
                    break;
                }
              };

              _proto2._callExitMethods = function _callExitMethods(node) {
                var _node$stateMachine$co2;

                var controller = this._controller;

                switch (node.kind) {
                  default:
                    break;

                  case NodeKind.animation:
                    {
                      node.components.callMotionStateExitMethods(controller, node.getFromPortStatus());
                      break;
                    }

                  case NodeKind.exit:
                    (_node$stateMachine$co2 = node.stateMachine.components) === null || _node$stateMachine$co2 === void 0 ? void 0 : _node$stateMachine$co2.callStateMachineExitMethods(controller);
                    break;
                }
              };

              _createClass(LayerEval, [{
                key: "exited",
                get: function get() {
                  return this._currentNode === this._topLevelExit;
                }
              }]);

              return LayerEval;
            }();

            function getInterruptionSourceMotion(state) {
              return state.kind === NodeKind.animation ? state : state.first;
            }

            function createStateStatusCache() {
              return {
                progress: 0.0
              };
            }

            var emptyClipStatusesIterator = Object.freeze({
              next: function next() {
                return {
                  done: true,
                  value: undefined
                };
              }
            });
            var emptyClipStatusesIterable = Object.freeze((_Object$freeze = {}, _Object$freeze[Symbol.iterator] = function () {
              return emptyClipStatusesIterator;
            }, _Object$freeze));

            var TransitionMatchCache = function () {
              function TransitionMatchCache() {
                this.transition = null;
                this.requires = Infinity;
              }

              var _proto3 = TransitionMatchCache.prototype;

              _proto3.hasZeroCost = function hasZeroCost() {
                return this.requires === 0;
              };

              _proto3.isValid = function isValid() {
                return this.transition !== null;
              };

              _proto3.set = function set(transition, requires) {
                this.transition = transition;
                this.requires = requires;
                return this;
              };

              _proto3.reset = function reset() {
                this.requires = Infinity;
                this.transition = null;
                return this;
              };

              return TransitionMatchCache;
            }();

            var transitionMatchCache = new TransitionMatchCache();

            var InterruptingTransitionMatchCache = function () {
              function InterruptingTransitionMatchCache() {
                this.transition = null;
                this.requires = 0.0;
                this.from = null;
              }

              var _proto4 = InterruptingTransitionMatchCache.prototype;

              _proto4.set = function set(from, transition, requires) {
                this.from = from;
                this.transition = transition;
                this.requires = requires;
                return this;
              };

              return InterruptingTransitionMatchCache;
            }();

            var interruptingTransitionMatchCache = new InterruptingTransitionMatchCache();
            var NodeKind;

            (function (NodeKind) {
              NodeKind[NodeKind["entry"] = 0] = "entry";
              NodeKind[NodeKind["exit"] = 1] = "exit";
              NodeKind[NodeKind["any"] = 2] = "any";
              NodeKind[NodeKind["animation"] = 3] = "animation";
              NodeKind[NodeKind["empty"] = 4] = "empty";
              NodeKind[NodeKind["transitionSnapshot"] = 5] = "transitionSnapshot";
            })(NodeKind || (NodeKind = {}));

            var StateEval = function StateEval(node) {
              this.name = void 0;
              this.outgoingTransitions = [];
              this.name = node.name;
            };

            var InstantiatedComponents = function () {
              function InstantiatedComponents(node) {
                this._components = node.instantiateComponents();
              }

              var _proto5 = InstantiatedComponents.prototype;

              _proto5.callMotionStateEnterMethods = function callMotionStateEnterMethods(controller, status) {
                this._callMotionStateCallbackIfNonDefault('onMotionStateEnter', controller, status);
              };

              _proto5.callMotionStateUpdateMethods = function callMotionStateUpdateMethods(controller, status) {
                this._callMotionStateCallbackIfNonDefault('onMotionStateUpdate', controller, status);
              };

              _proto5.callMotionStateExitMethods = function callMotionStateExitMethods(controller, status) {
                this._callMotionStateCallbackIfNonDefault('onMotionStateExit', controller, status);
              };

              _proto5.callStateMachineEnterMethods = function callStateMachineEnterMethods(controller) {
                this._callStateMachineCallbackIfNonDefault('onStateMachineEnter', controller);
              };

              _proto5.callStateMachineExitMethods = function callStateMachineExitMethods(controller) {
                this._callStateMachineCallbackIfNonDefault('onStateMachineExit', controller);
              };

              _proto5._callMotionStateCallbackIfNonDefault = function _callMotionStateCallbackIfNonDefault(methodName, controller, status) {
                var components = this._components;
                var nComponents = components.length;

                for (var iComponent = 0; iComponent < nComponents; ++iComponent) {
                  var component = components[iComponent];

                  if (component[methodName] !== StateMachineComponent.prototype[methodName]) {
                    component[methodName](controller, status);
                  }
                }
              };

              _proto5._callStateMachineCallbackIfNonDefault = function _callStateMachineCallbackIfNonDefault(methodName, controller) {
                var components = this._components;
                var nComponents = components.length;

                for (var iComponent = 0; iComponent < nComponents; ++iComponent) {
                  var component = components[iComponent];

                  if (component[methodName] !== StateMachineComponent.prototype[methodName]) {
                    component[methodName](controller);
                  }
                }
              };

              return InstantiatedComponents;
            }();

            var MotionStateEval = function (_StateEval) {
              _inheritsLoose(MotionStateEval, _StateEval);

              function MotionStateEval(node, context) {
                var _node$motion$createEv, _node$motion;

                var _this3;

                _this3 = _StateEval.call(this, node) || this;
                _this3.kind = NodeKind.animation;
                _this3._source = null;
                _this3._baseSpeed = 1.0;
                _this3._speed = 1.0;
                _this3._fromPort = {
                  progress: 0.0,
                  statusCache: createStateStatusCache()
                };
                _this3._toPort = {
                  progress: 0.0,
                  statusCache: createStateStatusCache()
                };
                _this3._baseSpeed = node.speed;

                _this3._setSpeedMultiplier(1.0);

                if (node.speedMultiplierEnabled && node.speedMultiplier) {
                  var speedMultiplierVarName = node.speedMultiplier;
                  var varInstance = context.getVar(speedMultiplierVarName);

                  if (validateVariableExistence(varInstance, speedMultiplierVarName)) {
                    validateVariableType(varInstance.type, VariableType.FLOAT, speedMultiplierVarName);
                    varInstance.bind(_this3._setSpeedMultiplier, _assertThisInitialized(_this3));
                    var initialSpeedMultiplier = varInstance.value;

                    _this3._setSpeedMultiplier(initialSpeedMultiplier);
                  }
                }

                var sourceEvalContext = _extends({}, context);

                var sourceEval = (_node$motion$createEv = (_node$motion = node.motion) === null || _node$motion === void 0 ? void 0 : _node$motion[createEval](sourceEvalContext)) !== null && _node$motion$createEv !== void 0 ? _node$motion$createEv : null;

                if (sourceEval) {
                  Object.defineProperty(sourceEval, '__DEBUG_ID__', {
                    value: _this3.name
                  });
                }

                _this3._source = sourceEval;
                _this3.components = new InstantiatedComponents(node);
                return _this3;
              }

              var _proto6 = MotionStateEval.prototype;

              _proto6.updateFromPort = function updateFromPort(deltaTime) {
                this._fromPort.progress = calcProgressUpdate(this._fromPort.progress, this.duration, deltaTime * this._speed);
              };

              _proto6.updateToPort = function updateToPort(deltaTime) {
                {
                  assertIsTrue(!Number.isNaN(this._toPort.progress));
                }

                this._toPort.progress = calcProgressUpdate(this._toPort.progress, this.duration, deltaTime * this._speed);
              };

              _proto6.triggerFromPortUpdate = function triggerFromPortUpdate(controller) {
                this.components.callMotionStateUpdateMethods(controller, this.getFromPortStatus());
              };

              _proto6.triggerToPortUpdate = function triggerToPortUpdate(controller) {
                this.components.callMotionStateUpdateMethods(controller, this.getToPortStatus());
              };

              _proto6.getFromPortStatus = function getFromPortStatus() {
                var stateStatus = this._fromPort.statusCache;

                {
                  stateStatus.__DEBUG_ID__ = this.name;
                }

                stateStatus.progress = normalizeProgress(this._fromPort.progress);
                return stateStatus;
              };

              _proto6.getToPortStatus = function getToPortStatus() {
                {
                  assertIsTrue(!Number.isNaN(this._toPort.progress));
                }

                var stateStatus = this._toPort.statusCache;

                {
                  stateStatus.__DEBUG_ID__ = this.name;
                }

                stateStatus.progress = normalizeProgress(this._toPort.progress);
                return stateStatus;
              };

              _proto6.resetToPort = function resetToPort(at) {
                this._toPort.progress = at;
              };

              _proto6.finishTransition = function finishTransition() {
                this._fromPort.progress = this._toPort.progress;

                {
                  this._toPort.progress = Number.NaN;
                }
              };

              _proto6.sampleFromPort = function sampleFromPort(weight) {
                var _this$_source;

                (_this$_source = this._source) === null || _this$_source === void 0 ? void 0 : _this$_source.sample(this._fromPort.progress, weight);
              };

              _proto6.sampleToPort = function sampleToPort(weight) {
                var _this$_source2;

                {
                  assertIsTrue(!Number.isNaN(this._toPort.progress));
                }

                (_this$_source2 = this._source) === null || _this$_source2 === void 0 ? void 0 : _this$_source2.sample(this._toPort.progress, weight);
              };

              _proto6.getClipStatuses = function getClipStatuses(baseWeight) {
                var source = this._source;

                if (!source) {
                  return emptyClipStatusesIterable;
                } else {
                  var _ref2;

                  return _ref2 = {}, _ref2[Symbol.iterator] = function () {
                    return source.getClipStatuses(baseWeight);
                  }, _ref2;
                }
              };

              _proto6.overrideClips = function overrideClips(overrides, context) {
                var _this$_source3;

                (_this$_source3 = this._source) === null || _this$_source3 === void 0 ? void 0 : _this$_source3.overrideClips(overrides, context);
              };

              _proto6._setSpeedMultiplier = function _setSpeedMultiplier(value) {
                this._speed = this._baseSpeed * value;
              };

              _createClass(MotionStateEval, [{
                key: "duration",
                get: function get() {
                  var _this$_source$duratio, _this$_source4;

                  return (_this$_source$duratio = (_this$_source4 = this._source) === null || _this$_source4 === void 0 ? void 0 : _this$_source4.duration) !== null && _this$_source$duratio !== void 0 ? _this$_source$duratio : 0.0;
                }
              }, {
                key: "fromPortTime",
                get: function get() {
                  return this._fromPort.progress * this.duration;
                }
              }]);

              return MotionStateEval;
            }(StateEval);

            function calcProgressUpdate(currentProgress, duration, deltaTime) {
              if (duration === 0.0) {
                return 0.0;
              }

              var progress = currentProgress + deltaTime / duration;
              return progress;
            }

            function normalizeProgress(progress) {
              var signedFrac = progress - Math.trunc(progress);
              return signedFrac >= 0.0 ? signedFrac : 1.0 + signedFrac;
            }

            var SpecialStateEval = function (_StateEval2) {
              _inheritsLoose(SpecialStateEval, _StateEval2);

              function SpecialStateEval(node, kind, name) {
                var _this4;

                _this4 = _StateEval2.call(this, node) || this;
                _this4.kind = void 0;
                _this4.kind = kind;
                return _this4;
              }

              return SpecialStateEval;
            }(StateEval);
            var EmptyStateEval = function (_StateEval3) {
              _inheritsLoose(EmptyStateEval, _StateEval3);

              function EmptyStateEval(node) {
                var _this5;

                _this5 = _StateEval3.call(this, node) || this;
                _this5.kind = NodeKind.empty;
                return _this5;
              }

              return EmptyStateEval;
            }(StateEval);

            var QueuedMotion = function QueuedMotion(motion, weight) {
              this.motion = motion;
              this.weight = weight;
            };

            var TransitionSnapshotEval = function (_StateEval4) {
              _inheritsLoose(TransitionSnapshotEval, _StateEval4);

              function TransitionSnapshotEval() {
                var _this6;

                _this6 = _StateEval4.call(this, {
                  name: "[[TransitionSnapshotEval]]"
                }) || this;
                _this6.kind = NodeKind.transitionSnapshot;
                _this6._queue = [];
                return _this6;
              }

              var _proto7 = TransitionSnapshotEval.prototype;

              _proto7.sample = function sample(weight) {
                var queue = this._queue;
                var nQueue = queue.length;

                for (var iQueuedMotions = 0; iQueuedMotions < nQueue; ++iQueuedMotions) {
                  var _queue$iQueuedMotions = queue[iQueuedMotions],
                      _motion = _queue$iQueuedMotions.motion,
                      snapshotWeight = _queue$iQueuedMotions.weight;

                  _motion.sampleFromPort(snapshotWeight * weight);
                }
              };

              _proto7.clear = function clear() {
                this._queue.length = 0;
              };

              _proto7.enqueue = function enqueue(state, weight) {
                var queue = this._queue;
                var nQueue = queue.length;
                var complementWeight = 1.0 - weight;

                for (var iQueuedMotions = 0; iQueuedMotions < nQueue; ++iQueuedMotions) {
                  queue[iQueuedMotions].weight *= complementWeight;
                }

                queue.push(new QueuedMotion(state, weight));
              };

              _createClass(TransitionSnapshotEval, [{
                key: "empty",
                get: function get() {
                  return this._queue.length === 0;
                }
              }, {
                key: "first",
                get: function get() {
                  var queue = this._queue;
                  assertIsTrue(queue.length > 0);
                  return queue[0].motion;
                }
              }]);

              return TransitionSnapshotEval;
            }(StateEval);

            var _dec$11, _dec2$K, _dec3$t, _class$11, _class2$T, _initializer$R;
            var ccclass$d = ccclass$p,
                type$4 = type$8,
                serializable$c = serializable$j,
                formerlySerializedAs$2 = formerlySerializedAs$3;
            var AnimationController = (_dec$11 = ccclass$d('cc.animation.AnimationController'), _dec2$K = type$4(AnimationGraphLike), _dec3$t = formerlySerializedAs$2('graph'), _dec$11(_class$11 = (_class2$T = function (_Component) {
              _inheritsLoose(AnimationController, _Component);

              function AnimationController() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._graph = _initializer$R && _initializer$R();
                _this._graphEval = null;
                return _this;
              }

              var _proto = AnimationController.prototype;

              _proto.__preload = function __preload() {
                var graph = this.graph;

                if (graph) {
                  var originalGraph;
                  var clipOverrides = null;

                  if (graph instanceof AnimationGraphVariant) {
                    if (!graph.original) {
                      return;
                    }

                    originalGraph = graph.original;
                    clipOverrides = graph.clipOverrides;
                  } else {
                    assertIsTrue(graph instanceof AnimationGraph);
                    originalGraph = graph;
                  }

                  var graphEval = new AnimationGraphEval(originalGraph, this.node, this, clipOverrides);
                  this._graphEval = graphEval;
                }
              };

              _proto.update = function update(deltaTime) {
                var _this$_graphEval;

                (_this$_graphEval = this._graphEval) === null || _this$_graphEval === void 0 ? void 0 : _this$_graphEval.update(deltaTime);
              };

              _proto.getVariables = function getVariables() {
                var graphEval = this._graphEval;
                assertIsNonNullable(graphEval);
                return graphEval.getVariables();
              };

              _proto.setValue = function setValue(name, value) {
                var graphEval = this._graphEval;
                assertIsNonNullable(graphEval);
                graphEval.setValue(name, value);
              };

              _proto.getValue = function getValue(name) {
                var graphEval = this._graphEval;
                assertIsNonNullable(graphEval);
                return graphEval.getValue(name);
              };

              _proto.getCurrentStateStatus = function getCurrentStateStatus(layer) {
                var graphEval = this._graphEval;
                assertIsNonNullable(graphEval);
                return graphEval.getCurrentStateStatus(layer);
              };

              _proto.getCurrentClipStatuses = function getCurrentClipStatuses(layer) {
                var graphEval = this._graphEval;
                assertIsNonNullable(graphEval);
                return graphEval.getCurrentClipStatuses(layer);
              };

              _proto.getCurrentTransition = function getCurrentTransition(layer) {
                var graphEval = this._graphEval;
                assertIsNonNullable(graphEval);
                return graphEval.getCurrentTransition(layer);
              };

              _proto.getNextStateStatus = function getNextStateStatus(layer) {
                var graphEval = this._graphEval;
                assertIsNonNullable(graphEval);
                return graphEval.getNextStateStatus(layer);
              };

              _proto.getNextClipStatuses = function getNextClipStatuses(layer) {
                var graphEval = this._graphEval;
                assertIsNonNullable(graphEval);
                return graphEval.getNextClipStatuses(layer);
              };

              _proto.getLayerWeight = function getLayerWeight(layer) {
                var graphEval = this._graphEval;
                assertIsNonNullable(graphEval);
                return graphEval.getLayerWeight(layer);
              };

              _proto.setLayerWeight = function setLayerWeight(layer, weight) {
                var graphEval = this._graphEval;
                assertIsNonNullable(graphEval);
                return graphEval.setLayerWeight(layer, weight);
              };

              _proto.overrideClips_experimental = function overrideClips_experimental(overrides) {
                var graphEval = this._graphEval;
                assertIsNonNullable(graphEval);
                graphEval.overrideClips(overrides);
              };

              _createClass(AnimationController, [{
                key: "graph",
                get: function get() {
                  return this._graph;
                },
                set: function set(value) {
                  this._graph = value;
                }
              }, {
                key: "layerCount",
                get: function get() {
                  var _this$_graphEval$laye, _this$_graphEval2;

                  return (_this$_graphEval$laye = (_this$_graphEval2 = this._graphEval) === null || _this$_graphEval2 === void 0 ? void 0 : _this$_graphEval2.layerCount) !== null && _this$_graphEval$laye !== void 0 ? _this$_graphEval$laye : 0;
                }
              }]);

              return AnimationController;
            }(Component), (_applyDecoratedDescriptor(_class2$T.prototype, "graph", [_dec2$K], Object.getOwnPropertyDescriptor(_class2$T.prototype, "graph"), _class2$T.prototype), _initializer$R = applyDecoratedInitializer(_class2$T.prototype, "_graph", [serializable$c, _dec3$t], function () {
              return null;
            })), _class2$T)) || _class$11);

            var animation = /*#__PURE__*/Object.freeze({
                __proto__: null,
                UniformProxyFactory: UniformProxyFactory,
                MorphWeightValueProxy: MorphWeightValueProxy,
                MorphWeightsValueProxy: MorphWeightsValueProxy,
                MorphWeightsAllValueProxy: MorphWeightsAllValueProxy,
                Track: Track,
                TrackPath: TrackPath,
                RealTrack: RealTrack,
                VectorTrack: VectorTrack,
                QuatTrack: QuatTrack,
                ColorTrack: ColorTrack,
                SizeTrack: SizeTrack,
                ObjectTrack: ObjectTrack,
                isPropertyPath: isPropertyPath,
                isCustomPath: isCustomPath,
                HierarchyPath: HierarchyPath,
                ComponentPath: ComponentPath,
                CubicSplineVec2Value: CubicSplineVec2Value,
                CubicSplineVec3Value: CubicSplineVec3Value,
                CubicSplineVec4Value: CubicSplineVec4Value,
                CubicSplineQuatValue: CubicSplineQuatValue,
                CubicSplineNumberValue: CubicSplineNumberValue,
                AnimationController: AnimationController,
                get VariableType () { return VariableType; },
                StateMachineComponent: StateMachineComponent
            });
            exports('animation', animation);

            var _class$12, _class2$U, _temp$h;
            var AnimationManager = exports('AnimationManager', ccclass$p(_class$12 = (_temp$h = _class2$U = function (_System) {
              _inheritsLoose(AnimationManager, _System);

              function AnimationManager() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _System.call.apply(_System, [this].concat(args)) || this;
                _this._anims = new MutableForwardIterator([]);
                _this._crossFades = new MutableForwardIterator([]);
                _this._delayEvents = [];
                _this._blendStateBuffer = new LegacyBlendStateBuffer();
                _this._sockets = [];
                return _this;
              }

              var _proto = AnimationManager.prototype;

              _proto.addCrossFade = function addCrossFade(crossFade) {
                var index = this._crossFades.array.indexOf(crossFade);

                if (index === -1) {
                  this._crossFades.push(crossFade);
                }
              };

              _proto.removeCrossFade = function removeCrossFade(crossFade) {
                var index = this._crossFades.array.indexOf(crossFade);

                if (index >= 0) {
                  this._crossFades.fastRemoveAt(index);
                } else {
                  errorID(3907);
                }
              };

              _proto.update = function update(dt) {
                var _delayEvents = this._delayEvents,
                    crossFadesIter = this._crossFades,
                    _sockets = this._sockets;
                {
                  var crossFades = crossFadesIter.array;

                  for (crossFadesIter.i = 0; crossFadesIter.i < crossFades.length; ++crossFadesIter.i) {
                    var crossFade = crossFades[crossFadesIter.i];
                    crossFade.update(dt);
                  }
                }
                var iterator = this._anims;
                var array = iterator.array;

                for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                  var anim = array[iterator.i];

                  if (!anim.isMotionless) {
                    anim.update(dt);
                  }
                }

                this._blendStateBuffer.apply();

                var stamp = director.getTotalFrames();

                for (var i = 0, l = _sockets.length; i < l; i++) {
                  var _sockets$i = _sockets[i],
                      target = _sockets$i.target,
                      transform = _sockets$i.transform;
                  target.matrix = getWorldMatrix(transform, stamp);
                }

                for (var _i = 0, _l = _delayEvents.length; _i < _l; _i++) {
                  var event = _delayEvents[_i];
                  event.fn.apply(event.thisArg, event.args);
                }

                _delayEvents.length = 0;
              };

              _proto.destruct = function destruct() {};

              _proto.addAnimation = function addAnimation(anim) {
                var index = this._anims.array.indexOf(anim);

                if (index === -1) {
                  this._anims.push(anim);
                }
              };

              _proto.removeAnimation = function removeAnimation(anim) {
                var index = this._anims.array.indexOf(anim);

                if (index >= 0) {
                  this._anims.fastRemoveAt(index);
                } else {
                  errorID(3907);
                }
              };

              _proto.pushDelayEvent = function pushDelayEvent(fn, thisArg, args) {
                this._delayEvents.push({
                  fn: fn,
                  thisArg: thisArg,
                  args: args
                });
              };

              _proto.addSockets = function addSockets(root, sockets) {
                var _this2 = this;

                var _loop = function _loop(i) {
                  var socket = sockets[i];

                  if (_this2._sockets.find(function (s) {
                    return s.target === socket.target;
                  })) {
                    return "continue";
                  }

                  var targetNode = root.getChildByPath(socket.path);
                  var transform = socket.target && targetNode && getTransform(targetNode, root);

                  if (transform) {
                    _this2._sockets.push({
                      target: socket.target,
                      transform: transform
                    });
                  }
                };

                for (var i = 0; i < sockets.length; ++i) {
                  var _ret = _loop(i);

                  if (_ret === "continue") continue;
                }
              };

              _proto.removeSockets = function removeSockets(root, sockets) {
                for (var i = 0; i < sockets.length; ++i) {
                  var socketToRemove = sockets[i];

                  for (var j = 0; j < this._sockets.length; ++j) {
                    var socket = this._sockets[j];

                    if (socket.target === socketToRemove.target) {
                      deleteTransform(socket.transform.node);
                      this._sockets[j] = this._sockets[this._sockets.length - 1];
                      this._sockets.length--;
                      break;
                    }
                  }
                }
              };

              _createClass(AnimationManager, [{
                key: "blendState",
                get: function get() {
                  return this._blendStateBuffer;
                }
              }]);

              return AnimationManager;
            }(System), _class2$U.ID = 'animation', _temp$h)) || _class$12);
            director.on(Director.EVENT_INIT, function () {
              var animationManager = new AnimationManager();
              director.registerSystem(AnimationManager.ID, animationManager, System.Priority.HIGH);
            });
            legacyCC.AnimationManager = AnimationManager;

            var CrossFade = function (_Playable) {
              _inheritsLoose(CrossFade, _Playable);

              function CrossFade(scheduler) {
                var _this;

                _this = _Playable.call(this) || this;
                _this._managedStates = [];
                _this._fadings = [];
                _this._scheduled = false;
                _this._scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : getGlobalAnimationManager();
                return _this;
              }

              var _proto = CrossFade.prototype;

              _proto.update = function update(deltaTime) {
                if (this.isMotionless) {
                  return;
                }

                var managedStates = this._managedStates;
                var fadings = this._fadings;

                if (managedStates.length === 1 && fadings.length === 1) {
                  var state = managedStates[0].state;

                  if (state) {
                    state.weight = 1.0;
                  }
                } else {
                  this._calculateWeights(deltaTime);
                }

                if (managedStates.length === 1 && fadings.length === 1) {
                  this._unscheduleThis();
                }
              };

              _proto.crossFade = function crossFade(state, duration) {
                var _target$state;

                if (this._managedStates.length === 0) {
                  duration = 0;
                }

                if (duration === 0) {
                  this.clear();
                }

                var target = this._managedStates.find(function (weightedState) {
                  return weightedState.state === state;
                });

                if (!target) {
                  target = {
                    state: state,
                    reference: 0
                  };

                  if (state) {
                    state.play();
                  }

                  this._managedStates.push(target);
                } else if ((_target$state = target.state) !== null && _target$state !== void 0 && _target$state.isMotionless) {
                  target.state.play();
                }

                ++target.reference;

                this._fadings.unshift({
                  easeDuration: duration,
                  easeTime: 0,
                  target: target
                });

                if (!this.isMotionless) {
                  this._scheduleThis();
                }
              };

              _proto.clear = function clear() {
                for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                  var state = this._managedStates[iManagedState].state;

                  if (state) {
                    state.stop();
                  }
                }

                this._managedStates.length = 0;
                this._fadings.length = 0;
              };

              _proto.onPlay = function onPlay() {
                _Playable.prototype.onPlay.call(this);

                this._scheduleThis();
              };

              _proto.onPause = function onPause() {
                _Playable.prototype.onPause.call(this);

                for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                  var state = this._managedStates[iManagedState].state;

                  if (state) {
                    state.pause();
                  }
                }

                this._unscheduleThis();
              };

              _proto.onResume = function onResume() {
                _Playable.prototype.onResume.call(this);

                for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                  var state = this._managedStates[iManagedState].state;

                  if (state) {
                    state.resume();
                  }
                }

                this._scheduleThis();
              };

              _proto.onStop = function onStop() {
                _Playable.prototype.onStop.call(this);

                this.clear();
              };

              _proto._calculateWeights = function _calculateWeights(deltaTime) {
                var managedStates = this._managedStates;
                var fadings = this._fadings;

                for (var iManagedState = 0; iManagedState < managedStates.length; ++iManagedState) {
                  var state = managedStates[iManagedState].state;

                  if (state) {
                    state.weight = 0;
                  }
                }

                var absoluteWeight = 1.0;
                var deadFadingBegin = fadings.length;

                for (var iFading = 0; iFading < fadings.length; ++iFading) {
                  var fading = fadings[iFading];
                  fading.easeTime += deltaTime;
                  var relativeWeight = fading.easeDuration === 0 ? 1 : clamp01(fading.easeTime / fading.easeDuration);
                  var weight = relativeWeight * absoluteWeight;
                  absoluteWeight *= 1.0 - relativeWeight;

                  if (fading.target.state) {
                    fading.target.state.weight += weight;
                  }

                  if (fading.easeTime >= fading.easeDuration) {
                    deadFadingBegin = iFading + 1;
                    fading.easeTime = fading.easeDuration;
                    break;
                  }
                }

                if (deadFadingBegin !== fadings.length) {
                  for (var iDeadFading = deadFadingBegin; iDeadFading < fadings.length; ++iDeadFading) {
                    var deadFading = fadings[iDeadFading];
                    --deadFading.target.reference;

                    if (deadFading.target.reference <= 0) {
                      if (deadFading.target.state) {
                        deadFading.target.state.stop();
                      }

                      remove(this._managedStates, deadFading.target);
                    }
                  }

                  fadings.splice(deadFadingBegin);
                }
              };

              _proto._scheduleThis = function _scheduleThis() {
                if (!this._scheduled) {
                  this._scheduler.addCrossFade(this);

                  this._scheduled = true;
                }
              };

              _proto._unscheduleThis = function _unscheduleThis() {
                if (this._scheduled) {
                  this._scheduler.removeCrossFade(this);

                  this._scheduled = false;
                }
              };

              return CrossFade;
            }(Playable);

            var _dec$12, _dec2$L, _dec3$u, _dec4$i, _dec5$d, _class$13, _class2$V, _initializer$S, _initializer2$I, _initializer3$v, _class3$b, _temp$i;
            var Animation = function (v) { return exports({ Animation: v, AnimationComponent: v }), v; }((_dec$12 = ccclass$p('cc.Animation'), _dec2$L = executionOrder(99), _dec3$u = type$8([AnimationClip]), _dec4$i = type$8(AnimationClip), _dec5$d = type$8([AnimationClip]), _dec$12(_class$13 = _dec2$L(_class$13 = (_class2$V = (_temp$i = _class3$b = function (_Eventify) {
              _inheritsLoose(Animation, _Eventify);

              function Animation() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Eventify.call.apply(_Eventify, [this].concat(args)) || this;
                _this.playOnLoad = _initializer$S && _initializer$S();
                _this._crossFade = new CrossFade();
                _this._nameToState = createMap(true);
                _this._clips = _initializer2$I && _initializer2$I();
                _this._defaultClip = _initializer3$v && _initializer3$v();
                _this._hasBeenPlayed = false;
                return _this;
              }

              var _proto = Animation.prototype;

              _proto.onLoad = function onLoad() {
                this.clips = this._clips;

                for (var stateName in this._nameToState) {
                  var state = this._nameToState[stateName];
                  state.initialize(this.node);
                }
              };

              _proto.start = function start() {
                if ( this.playOnLoad && !this._hasBeenPlayed && this._defaultClip) {
                  this.crossFade(this._defaultClip.name, 0);
                }
              };

              _proto.onEnable = function onEnable() {
                this._crossFade.resume();
              };

              _proto.onDisable = function onDisable() {
                this._crossFade.pause();
              };

              _proto.onDestroy = function onDestroy() {
                this._crossFade.stop();

                for (var name in this._nameToState) {
                  var state = this._nameToState[name];
                  state.destroy();
                }

                this._nameToState = createMap(true);
              };

              _proto.play = function play(name) {
                this._hasBeenPlayed = true;

                if (!name) {
                  if (!this._defaultClip) {
                    return;
                  }

                  name = this._defaultClip.name;
                }

                this.crossFade(name, 0);
              };

              _proto.crossFade = function crossFade(name, duration) {
                if (duration === void 0) {
                  duration = 0.3;
                }

                this._hasBeenPlayed = true;
                var state = this._nameToState[name];

                if (state) {
                  this.doPlayOrCrossFade(state, duration);
                }
              };

              _proto.pause = function pause() {
                this._crossFade.pause();
              };

              _proto.resume = function resume() {
                this._crossFade.resume();
              };

              _proto.stop = function stop() {
                this._crossFade.stop();
              };

              _proto.getState = function getState(name) {
                var state = this._nameToState[name];

                if (state && !state.curveLoaded) {
                  state.initialize(this.node);
                }

                return state || null;
              };

              _proto.createState = function createState(clip, name) {
                name = name || clip.name;
                this.removeState(name);
                return this._doCreateState(clip, name);
              };

              _proto.removeState = function removeState(name) {
                var state = this._nameToState[name];

                if (state) {
                  state.allowLastFrameEvent(false);
                  state.stop();
                  delete this._nameToState[name];
                }
              };

              _proto.addClip = function addClip(clip, name) {
                if (!contains(this._clips, clip)) {
                  this._clips.push(clip);
                }

                return this.createState(clip, name);
              };

              _proto.removeClip = function removeClip(clip, force) {
                var removalState;

                for (var name in this._nameToState) {
                  var state = this._nameToState[name];
                  var stateClip = state.clip;

                  if (stateClip === clip) {
                    removalState = state;
                    break;
                  }
                }

                if (clip === this._defaultClip) {
                  if (force) {
                    this._defaultClip = null;
                  } else {
                    {
                      warnID(3902);
                    }

                    return;
                  }
                }

                if (removalState && removalState.isPlaying) {
                  if (force) {
                    removalState.stop();
                  } else {
                    {
                      warnID(3903);
                    }

                    return;
                  }
                }

                this._clips = this._clips.filter(function (item) {
                  return item !== clip;
                });

                if (removalState) {
                  delete this._nameToState[removalState.name];
                }
              };

              _proto.on = function on(type, callback, thisArg, once) {
                var ret = _Eventify.prototype.on.call(this, type, callback, thisArg, once);

                if (type === EventType$1.LASTFRAME) {
                  this._syncAllowLastFrameEvent();
                }

                return ret;
              };

              _proto.once = function once(type, callback, thisArg) {
                var ret = _Eventify.prototype.once.call(this, type, callback, thisArg);

                if (type === EventType$1.LASTFRAME) {
                  this._syncAllowLastFrameEvent();
                }

                return ret;
              };

              _proto.off = function off(type, callback, thisArg) {
                _Eventify.prototype.off.call(this, type, callback, thisArg);

                if (type === EventType$1.LASTFRAME) {
                  this._syncDisallowLastFrameEvent();
                }
              };

              _proto._createState = function _createState(clip, name) {
                return new AnimationState(clip, name);
              };

              _proto._doCreateState = function _doCreateState(clip, name) {
                var state = this._createState(clip, name);

                state._setEventTarget(this);

                state.allowLastFrameEvent(this.hasEventListener(EventType$1.LASTFRAME));

                if (this.node) {
                  state.initialize(this.node);
                }

                this._nameToState[state.name] = state;
                return state;
              };

              _proto.doPlayOrCrossFade = function doPlayOrCrossFade(state, duration) {
                this._crossFade.play();

                this._crossFade.crossFade(state, duration);
              };

              _proto._removeStateOfAutomaticClip = function _removeStateOfAutomaticClip(clip) {
                for (var name in this._nameToState) {
                  var state = this._nameToState[name];

                  if (equalClips(clip, state.clip)) {
                    state.stop();
                    delete this._nameToState[name];
                  }
                }
              };

              _proto._syncAllowLastFrameEvent = function _syncAllowLastFrameEvent() {
                if (this.hasEventListener(EventType$1.LASTFRAME)) {
                  for (var stateName in this._nameToState) {
                    this._nameToState[stateName].allowLastFrameEvent(true);
                  }
                }
              };

              _proto._syncDisallowLastFrameEvent = function _syncDisallowLastFrameEvent() {
                if (!this.hasEventListener(EventType$1.LASTFRAME)) {
                  for (var stateName in this._nameToState) {
                    this._nameToState[stateName].allowLastFrameEvent(false);
                  }
                }
              };

              _createClass(Animation, [{
                key: "clips",
                get: function get() {
                  return this._clips;
                },
                set: function set(value) {
                  var _this2 = this;

                  if (this._crossFade) {
                    this._crossFade.clear();
                  }

                  for (var _iterator = _createForOfIteratorHelperLoose(this._clips), _step; !(_step = _iterator()).done;) {
                    var clip = _step.value;

                    if (clip) {
                      this._removeStateOfAutomaticClip(clip);
                    }
                  }

                  for (var _iterator2 = _createForOfIteratorHelperLoose(value), _step2; !(_step2 = _iterator2()).done;) {
                    var _clip = _step2.value;

                    if (_clip) {
                      this.createState(_clip);
                    }
                  }

                  var newDefaultClip = value.find(function (clip) {
                    return equalClips(clip, _this2._defaultClip);
                  });

                  if (newDefaultClip) {
                    this._defaultClip = newDefaultClip;
                  } else {
                    this._defaultClip = null;
                  }

                  this._clips = value;
                }
              }, {
                key: "defaultClip",
                get: function get() {
                  return this._defaultClip;
                },
                set: function set(value) {
                  this._defaultClip = value;

                  if (!value) {
                    return;
                  }

                  var isBoundedDefaultClip = this._clips.findIndex(function (clip) {
                    return equalClips(clip, value);
                  }) >= 0;

                  if (!isBoundedDefaultClip) {
                    this._clips.push(value);

                    this.createState(value);
                  }
                }
              }]);

              return Animation;
            }(Eventify(Component)), _class3$b.EventType = EventType$1, _temp$i), (_applyDecoratedDescriptor(_class2$V.prototype, "clips", [_dec3$u], Object.getOwnPropertyDescriptor(_class2$V.prototype, "clips"), _class2$V.prototype), _applyDecoratedDescriptor(_class2$V.prototype, "defaultClip", [_dec4$i], Object.getOwnPropertyDescriptor(_class2$V.prototype, "defaultClip"), _class2$V.prototype), _initializer$S = applyDecoratedInitializer(_class2$V.prototype, "playOnLoad", [serializable$j], function () {
              return false;
            }), _initializer2$I = applyDecoratedInitializer(_class2$V.prototype, "_clips", [_dec5$d], function () {
              return [];
            }), _initializer3$v = applyDecoratedInitializer(_class2$V.prototype, "_defaultClip", [serializable$j], function () {
              return null;
            })), _class2$V)) || _class$13) || _class$13));

            function equalClips(clip1, clip2) {
              if (clip1 === clip2) {
                return true;
              }

              return !!clip1 && !!clip2 && clip1._uuid === clip2._uuid && clip1._uuid;
            }

            legacyCC.Animation = Animation;
            legacyCC.AnimationComponent = Animation;
            setClassAlias(Animation, 'cc.AnimationComponent');

            var AudioEvent;

            (function (AudioEvent) {
              AudioEvent["PLAYED"] = "play";
              AudioEvent["PAUSED"] = "pause";
              AudioEvent["STOPPED"] = "stop";
              AudioEvent["SEEKED"] = "seeked";
              AudioEvent["ENDED"] = "ended";
              AudioEvent["INTERRUPTION_BEGIN"] = "interruptionBegin";
              AudioEvent["INTERRUPTION_END"] = "interruptionEnd";
              AudioEvent["USER_GESTURE"] = "on_gesture";
            })(AudioEvent || (AudioEvent = {}));

            var AudioType;

            (function (AudioType) {
              AudioType[AudioType["DOM_AUDIO"] = 0] = "DOM_AUDIO";
              AudioType[AudioType["WEB_AUDIO"] = 1] = "WEB_AUDIO";
              AudioType[AudioType["MINIGAME_AUDIO"] = 2] = "MINIGAME_AUDIO";
              AudioType[AudioType["NATIVE_AUDIO"] = 3] = "NATIVE_AUDIO";
              AudioType[AudioType["UNKNOWN_AUDIO"] = 4] = "UNKNOWN_AUDIO";
            })(AudioType || (AudioType = {}));

            var AudioState;

            (function (AudioState) {
              AudioState[AudioState["INIT"] = 0] = "INIT";
              AudioState[AudioState["PLAYING"] = 1] = "PLAYING";
              AudioState[AudioState["PAUSED"] = 2] = "PAUSED";
              AudioState[AudioState["STOPPED"] = 3] = "STOPPED";
              AudioState[AudioState["INTERRUPTED"] = 4] = "INTERRUPTED";
            })(AudioState || (AudioState = {}));

            var AudioPCMDataView = exports('AudioPCMDataView', function () {
              function AudioPCMDataView() {
                this._bufferView = void 0;
                this._normalizeFactor = 1;

                if (arguments.length === 2) {
                  this._bufferView = arguments.length <= 0 ? undefined : arguments[0];
                  this._normalizeFactor = arguments.length <= 1 ? undefined : arguments[1];
                } else {
                  var _arrayBuffer = arguments.length <= 0 ? undefined : arguments[0];

                  var _Ctor = arguments.length <= 1 ? undefined : arguments[1];

                  var _normalizeFactor = arguments.length <= 2 ? undefined : arguments[2];

                  this._bufferView = new _Ctor(_arrayBuffer);
                  this._normalizeFactor = _normalizeFactor;
                }
              }

              var _proto = AudioPCMDataView.prototype;

              _proto.getData = function getData(offset) {
                return this._bufferView[offset] * this._normalizeFactor;
              };

              _createClass(AudioPCMDataView, [{
                key: "length",
                get: function get() {
                  return this._bufferView.length;
                }
              }]);

              return AudioPCMDataView;
            }());

            var operationId = 0;

            function _tryCallingRecursively(target, opInfo) {
              var _opInfo$func;

              if (opInfo.invoking) {
                return;
              }

              opInfo.invoking = true;

              (_opInfo$func = opInfo.func).call.apply(_opInfo$func, [target].concat(opInfo.args)).then(function () {
                opInfo.invoking = false;

                target._operationQueue.shift();

                target._eventTarget.emit(opInfo.id.toString());

                var nextOpInfo = target._operationQueue[0];
                nextOpInfo && _tryCallingRecursively(target, nextOpInfo);
              })["catch"](function (e) {});
            }

            function enqueueOperation(target, propertyKey, descriptor) {
              var originalOperation = descriptor.value;

              descriptor.value = function () {
                var _this = this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                return new Promise(function (resolve) {
                  var id = operationId++;
                  var instance = _this;

                  instance._operationQueue.push({
                    id: id,
                    func: originalOperation,
                    args: args,
                    invoking: false
                  });

                  instance._eventTarget.once(id.toString(), resolve);

                  var opInfo = instance._operationQueue[0];

                  _tryCallingRecursively(instance, opInfo);
                });
              };
            }

            var _class$14;

            function ensurePlaying(domAudio) {
              return new Promise(function (resolve) {
                var promise = domAudio.play();

                if (promise === undefined) {
                  return resolve();
                }

                promise.then(resolve)["catch"](function () {
                  var onGesture = function onGesture() {
                    domAudio.play().then(function () {
                      canvas === null || canvas === void 0 ? void 0 : canvas.removeEventListener('touchend', onGesture, {
                        capture: true
                      });
                      canvas === null || canvas === void 0 ? void 0 : canvas.removeEventListener('mouseup', onGesture, {
                        capture: true
                      });
                    })["catch"](function (e) {});
                    resolve();
                  };

                  var canvas = document.getElementById('GameCanvas');
                  canvas === null || canvas === void 0 ? void 0 : canvas.addEventListener('touchend', onGesture, {
                    capture: true
                  });
                  canvas === null || canvas === void 0 ? void 0 : canvas.addEventListener('mouseup', onGesture, {
                    capture: true
                  });
                });
                return null;
              });
            }

            var OneShotAudioDOM = function () {
              function OneShotAudioDOM(nativeAudio, volume) {
                this._domAudio = void 0;
                this._onPlayCb = void 0;
                this._onEndCb = void 0;
                this._domAudio = nativeAudio;
                nativeAudio.volume = volume;
              }

              var _proto = OneShotAudioDOM.prototype;

              _proto.play = function play() {
                var _this = this;

                ensurePlaying(this._domAudio).then(function () {
                  var _this$onPlay;

                  (_this$onPlay = _this.onPlay) === null || _this$onPlay === void 0 ? void 0 : _this$onPlay.call(_this);
                })["catch"](function (e) {});
              };

              _proto.stop = function stop() {
                this._domAudio.pause();
              };

              _createClass(OneShotAudioDOM, [{
                key: "onPlay",
                get: function get() {
                  return this._onPlayCb;
                },
                set: function set(cb) {
                  this._onPlayCb = cb;
                }
              }, {
                key: "onEnd",
                get: function get() {
                  return this._onEndCb;
                },
                set: function set(cb) {
                  if (this._onEndCb) {
                    this._domAudio.removeEventListener('ended', this._onEndCb);
                  }

                  this._onEndCb = cb;

                  if (cb) {
                    this._domAudio.addEventListener('ended', cb);
                  }
                }
              }]);

              return OneShotAudioDOM;
            }();
            var AudioPlayerDOM = (_class$14 = function () {
              function AudioPlayerDOM(nativeAudio) {
                var _this2 = this;

                this._domAudio = void 0;
                this._state = AudioState.INIT;
                this._onEnded = void 0;
                this._eventTarget = new EventTarget();
                this._operationQueue = [];
                this._domAudio = nativeAudio;
                game.on(Game.EVENT_PAUSE, this._onInterruptedBegin, this);
                game.on(Game.EVENT_RESUME, this._onInterruptedEnd, this);

                this._onEnded = function () {
                  _this2.seek(0)["catch"](function (e) {});

                  _this2._state = AudioState.INIT;

                  _this2._eventTarget.emit(AudioEvent.ENDED);
                };

                this._domAudio.addEventListener('ended', this._onEnded);
              }

              var _proto2 = AudioPlayerDOM.prototype;

              _proto2.destroy = function destroy() {
                game.off(Game.EVENT_PAUSE, this._onInterruptedBegin, this);
                game.off(Game.EVENT_RESUME, this._onInterruptedEnd, this);

                this._domAudio.removeEventListener('ended', this._onEnded);

                this._domAudio = null;
              };

              AudioPlayerDOM.load = function load(url) {
                return new Promise(function (resolve) {
                  AudioPlayerDOM.loadNative(url).then(function (domAudio) {
                    resolve(new AudioPlayerDOM(domAudio));
                  })["catch"](function (e) {});
                });
              };

              AudioPlayerDOM.loadNative = function loadNative(url) {
                return new Promise(function (resolve, reject) {
                  var domAudio = document.createElement('audio');
                  var loadedEvent = 'canplaythrough';

                  if (systemInfo.os === OS.IOS) {
                    loadedEvent = 'loadedmetadata';
                  } else if (systemInfo.browserType === BrowserType.FIREFOX) {
                    loadedEvent = 'canplay';
                  }

                  var timer = setTimeout(function () {
                    if (domAudio.readyState === 0) {
                      failure();
                    } else {
                      success();
                    }
                  }, 8000);

                  var clearEvent = function clearEvent() {
                    clearTimeout(timer);
                    domAudio.removeEventListener(loadedEvent, success, false);
                    domAudio.removeEventListener('error', failure, false);
                  };

                  var success = function success() {
                    clearEvent();
                    resolve(domAudio);
                  };

                  var failure = function failure() {
                    clearEvent();
                    var message = "load audio failure - " + url;
                    reject(message);
                  };

                  domAudio.addEventListener(loadedEvent, success, false);
                  domAudio.addEventListener('error', failure, false);
                  domAudio.src = url;
                });
              };

              AudioPlayerDOM.loadOneShotAudio = function loadOneShotAudio(url, volume) {
                return new Promise(function (resolve, reject) {
                  AudioPlayerDOM.loadNative(url).then(function (domAudio) {
                    var oneShotAudio = new OneShotAudioDOM(domAudio, volume);
                    resolve(oneShotAudio);
                  })["catch"](reject);
                });
              };

              _proto2._onInterruptedBegin = function _onInterruptedBegin() {
                var _this3 = this;

                if (this._state === AudioState.PLAYING) {
                  this.pause().then(function () {
                    _this3._state = AudioState.INTERRUPTED;

                    _this3._eventTarget.emit(AudioEvent.INTERRUPTION_BEGIN);
                  })["catch"](function (e) {});
                }
              };

              _proto2._onInterruptedEnd = function _onInterruptedEnd() {
                var _this4 = this;

                if (this._state === AudioState.INTERRUPTED) {
                  this.play().then(function () {
                    _this4._eventTarget.emit(AudioEvent.INTERRUPTION_END);
                  })["catch"](function (e) {});
                }
              };

              _proto2.getPCMData = function getPCMData(channelIndex) {
                return undefined;
              };

              _proto2.seek = function seek(time) {
                time = clamp$1(time, 0, this.duration);
                this._domAudio.currentTime = time;
                return Promise.resolve();
              };

              _proto2.play = function play() {
                var _this5 = this;

                return new Promise(function (resolve) {
                  ensurePlaying(_this5._domAudio).then(function () {
                    _this5._state = AudioState.PLAYING;
                    resolve();
                  })["catch"](function (e) {});
                });
              };

              _proto2.pause = function pause() {
                this._domAudio.pause();

                this._state = AudioState.PAUSED;
                return Promise.resolve();
              };

              _proto2.stop = function stop() {
                var _this6 = this;

                return new Promise(function (resolve) {
                  _this6._domAudio.pause();

                  _this6._domAudio.currentTime = 0;
                  _this6._state = AudioState.STOPPED;
                  resolve();
                });
              };

              _proto2.onInterruptionBegin = function onInterruptionBegin(cb) {
                this._eventTarget.on(AudioEvent.INTERRUPTION_BEGIN, cb);
              };

              _proto2.offInterruptionBegin = function offInterruptionBegin(cb) {
                this._eventTarget.off(AudioEvent.INTERRUPTION_BEGIN, cb);
              };

              _proto2.onInterruptionEnd = function onInterruptionEnd(cb) {
                this._eventTarget.on(AudioEvent.INTERRUPTION_END, cb);
              };

              _proto2.offInterruptionEnd = function offInterruptionEnd(cb) {
                this._eventTarget.off(AudioEvent.INTERRUPTION_END, cb);
              };

              _proto2.onEnded = function onEnded(cb) {
                this._eventTarget.on(AudioEvent.ENDED, cb);
              };

              _proto2.offEnded = function offEnded(cb) {
                this._eventTarget.off(AudioEvent.ENDED, cb);
              };

              _createClass(AudioPlayerDOM, [{
                key: "src",
                get: function get() {
                  return this._domAudio ? this._domAudio.src : '';
                }
              }, {
                key: "type",
                get: function get() {
                  return AudioType.DOM_AUDIO;
                }
              }, {
                key: "state",
                get: function get() {
                  return this._state;
                }
              }, {
                key: "loop",
                get: function get() {
                  return this._domAudio.loop;
                },
                set: function set(val) {
                  this._domAudio.loop = val;
                }
              }, {
                key: "volume",
                get: function get() {
                  return this._domAudio.volume;
                },
                set: function set(val) {
                  val = clamp01(val);
                  this._domAudio.volume = val;
                }
              }, {
                key: "duration",
                get: function get() {
                  return this._domAudio.duration;
                }
              }, {
                key: "currentTime",
                get: function get() {
                  return this._domAudio.currentTime;
                }
              }, {
                key: "sampleRate",
                get: function get() {
                  return 0;
                }
              }]);

              return AudioPlayerDOM;
            }(), (_applyDecoratedDescriptor(_class$14.prototype, "seek", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$14.prototype, "seek"), _class$14.prototype), _applyDecoratedDescriptor(_class$14.prototype, "play", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$14.prototype, "play"), _class$14.prototype), _applyDecoratedDescriptor(_class$14.prototype, "pause", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$14.prototype, "pause"), _class$14.prototype), _applyDecoratedDescriptor(_class$14.prototype, "stop", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$14.prototype, "stop"), _class$14.prototype)), _class$14);

            var AudioTimer = function () {
              function AudioTimer(nativeAudio) {
                this._nativeAudio = void 0;
                this._startTime = 0;
                this._startOffset = 0;
                this._isPaused = true;
                this._nativeAudio = nativeAudio;
              }

              var _proto = AudioTimer.prototype;

              _proto.destroy = function destroy() {
                this._nativeAudio = undefined;
              };

              _proto._now = function _now() {
                return performance.now() / 1000;
              };

              _proto._calculateCurrentTime = function _calculateCurrentTime() {
                var timePassed = this._now() - this._startTime;

                var currentTime = this._startOffset + timePassed;

                if (currentTime >= this.duration) {
                  this._startTime = this._now();
                  this._startOffset = 0;
                }

                return currentTime % this.duration;
              };

              _proto.start = function start() {
                this._isPaused = false;
                this._startTime = this._now();
              };

              _proto.pause = function pause() {
                if (this._isPaused) {
                  return;
                }

                this._isPaused = true;
                this._startOffset = this._calculateCurrentTime();
              };

              _proto.stop = function stop() {
                this._isPaused = true;
                this._startOffset = 0;
              };

              _proto.seek = function seek(time) {
                this._startTime = this._now();
                this._startOffset = clamp$1(time, 0, this.duration);
              };

              _createClass(AudioTimer, [{
                key: "duration",
                get: function get() {
                  return this._nativeAudio.duration;
                }
              }, {
                key: "currentTime",
                get: function get() {
                  if (this._isPaused) {
                    return this._startOffset;
                  } else {
                    return this._calculateCurrentTime();
                  }
                }
              }]);

              return AudioTimer;
            }();

            var AudioBufferManager = function () {
              function AudioBufferManager() {
                this._audioBufferDataMap = {};
              }

              var _proto = AudioBufferManager.prototype;

              _proto.addCache = function addCache(url, audioBuffer) {
                var audioBufferData = this._audioBufferDataMap[url];

                if (audioBufferData) {
                  console.warn("Audio buffer " + url + " has been cached");
                  return;
                }

                this._audioBufferDataMap[url] = {
                  usedCount: 1,
                  audioBuffer: audioBuffer
                };
              };

              _proto.retainCache = function retainCache(url) {
                var audioBufferData = this._audioBufferDataMap[url];

                if (!audioBufferData) {
                  console.warn("Audio buffer cache " + url + " has not been added.");
                  return;
                }

                audioBufferData.usedCount++;
              };

              _proto.getCache = function getCache(url) {
                var audioBufferData = this._audioBufferDataMap[url];
                return audioBufferData === null || audioBufferData === void 0 ? void 0 : audioBufferData.audioBuffer;
              };

              _proto.tryReleasingCache = function tryReleasingCache(url) {
                var audioBufferData = this._audioBufferDataMap[url];

                if (!audioBufferData) {
                  console.warn("Audio buffer cache " + url + " has not been added.");
                  return;
                }

                if (--audioBufferData.usedCount <= 0) {
                  delete this._audioBufferDataMap[url];
                }
              };

              return AudioBufferManager;
            }();

            var audioBufferManager = new AudioBufferManager();

            var _class$15;
            var AudioContextClass = window.AudioContext || window.webkitAudioContext || window.mozAudioContext;
            var _contextRunningEvent = 'on-context-running';
            var AudioContextAgent = function () {
              function AudioContextAgent() {
                var _this = this;

                this._eventTarget = void 0;
                this._context = void 0;
                this._isRunning = false;
                this._context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
                this._eventTarget = new EventTarget();

                this._context.onstatechange = function () {
                  if (_this._context.state === 'running') {
                    _this._isRunning = true;

                    _this._eventTarget.emit(_contextRunningEvent);
                  } else {
                    _this._isRunning = false;
                  }
                };
              }

              var _proto = AudioContextAgent.prototype;

              _proto.onceRunning = function onceRunning(cb, target) {
                this._eventTarget.once(_contextRunningEvent, cb, target);
              };

              _proto.offRunning = function offRunning(cb, target) {
                this._eventTarget.off(_contextRunningEvent, cb, target);
              };

              _proto.decodeAudioData = function decodeAudioData(audioData) {
                var _this2 = this;

                return new Promise(function (resolve) {
                  var promise = _this2._context.decodeAudioData(audioData, function (audioBuffer) {
                    resolve(audioBuffer);
                  }, function (err) {
                    console.error('failed to load Web Audio', err);
                  });

                  promise === null || promise === void 0 ? void 0 : promise["catch"](function (e) {});
                });
              };

              _proto.runContext = function runContext() {
                var _this3 = this;

                return new Promise(function (resolve) {
                  if (_this3.isRunning) {
                    resolve();
                    return;
                  }

                  var context = _this3._context;

                  if (!context.resume) {
                    resolve();
                    return;
                  }

                  context.resume()["catch"](function (e) {});

                  if (context.state === 'running') {
                    resolve();
                    return;
                  }

                  var canvas = document.getElementById('GameCanvas');

                  var onGesture = function onGesture() {
                    context.resume().then(function () {
                      canvas === null || canvas === void 0 ? void 0 : canvas.removeEventListener('touchend', onGesture, {
                        capture: true
                      });
                      canvas === null || canvas === void 0 ? void 0 : canvas.removeEventListener('mouseup', onGesture, {
                        capture: true
                      });
                      resolve();
                    })["catch"](function (e) {});
                  };

                  canvas === null || canvas === void 0 ? void 0 : canvas.addEventListener('touchend', onGesture, {
                    capture: true
                  });
                  canvas === null || canvas === void 0 ? void 0 : canvas.addEventListener('mouseup', onGesture, {
                    capture: true
                  });
                });
              };

              _proto.createBufferSource = function createBufferSource(audioBuffer, loop) {
                var sourceBufferNode = this._context.createBufferSource();

                if (audioBuffer !== undefined) {
                  sourceBufferNode.buffer = audioBuffer;
                }

                if (loop !== undefined) {
                  sourceBufferNode.loop = loop;
                }

                return sourceBufferNode;
              };

              _proto.createGain = function createGain(volume) {
                if (volume === void 0) {
                  volume = 1;
                }

                var gainNode = this._context.createGain();

                this.setGainValue(gainNode, volume);
                return gainNode;
              };

              _proto.setGainValue = function setGainValue(gain, volume) {
                if (gain.gain.setTargetAtTime) {
                  try {
                    gain.gain.setTargetAtTime(volume, this._context.currentTime, 0);
                  } catch (e) {
                    gain.gain.setTargetAtTime(volume, this._context.currentTime, 0.01);
                  }
                } else {
                  gain.gain.value = volume;
                }
              };

              _proto.connectContext = function connectContext(audioNode) {
                if (!this._context) {
                  return;
                }

                audioNode.connect(this._context.destination);
              };

              _createClass(AudioContextAgent, [{
                key: "isRunning",
                get: function get() {
                  return this._isRunning;
                }
              }, {
                key: "currentTime",
                get: function get() {
                  return this._context.currentTime;
                }
              }]);

              return AudioContextAgent;
            }();
            AudioContextAgent.support = !!AudioContextClass;
            var audioContextAgent;

            if (AudioContextAgent.support) {
              audioContextAgent = new AudioContextAgent();
            }

            var OneShotAudioWeb = function () {
              function OneShotAudioWeb(audioBuffer, volume, url) {
                this._duration = void 0;
                this._bufferSourceNode = void 0;
                this._onPlayCb = void 0;
                this._currentTimer = 0;
                this._url = void 0;
                this._onEndCb = void 0;
                this._duration = audioBuffer.duration;
                this._url = url;
                this._bufferSourceNode = audioContextAgent.createBufferSource(audioBuffer, false);
                var gainNode = audioContextAgent.createGain(volume);

                this._bufferSourceNode.connect(gainNode);

                audioContextAgent.connectContext(gainNode);
              }

              var _proto2 = OneShotAudioWeb.prototype;

              _proto2.play = function play() {
                var _this4 = this;

                this._bufferSourceNode.start();

                audioContextAgent.runContext().then(function () {
                  var _this4$onPlay;

                  (_this4$onPlay = _this4.onPlay) === null || _this4$onPlay === void 0 ? void 0 : _this4$onPlay.call(_this4);
                  _this4._currentTimer = window.setTimeout(function () {
                    var _this4$onEnd;

                    audioBufferManager.tryReleasingCache(_this4._url);
                    (_this4$onEnd = _this4.onEnd) === null || _this4$onEnd === void 0 ? void 0 : _this4$onEnd.call(_this4);
                  }, _this4._duration * 1000);
                })["catch"](function (e) {});
              };

              _proto2.stop = function stop() {
                clearTimeout(this._currentTimer);
                audioBufferManager.tryReleasingCache(this._url);

                this._bufferSourceNode.stop();

                this._bufferSourceNode.buffer = null;
              };

              _createClass(OneShotAudioWeb, [{
                key: "onPlay",
                get: function get() {
                  return this._onPlayCb;
                },
                set: function set(cb) {
                  this._onPlayCb = cb;
                }
              }, {
                key: "onEnd",
                get: function get() {
                  return this._onEndCb;
                },
                set: function set(cb) {
                  this._onEndCb = cb;
                }
              }]);

              return OneShotAudioWeb;
            }();
            var AudioPlayerWeb = (_class$15 = function () {
              function AudioPlayerWeb(audioBuffer, url) {
                this._src = void 0;
                this._audioBuffer = void 0;
                this._sourceNode = void 0;
                this._gainNode = void 0;
                this._currentTimer = 0;
                this._volume = 1;
                this._loop = false;
                this._state = AudioState.INIT;
                this._audioTimer = void 0;
                this._runningCallback = void 0;
                this._eventTarget = new EventTarget();
                this._operationQueue = [];
                this._audioBuffer = audioBuffer;
                this._audioTimer = new AudioTimer(audioBuffer);
                this._gainNode = audioContextAgent.createGain();
                audioContextAgent.connectContext(this._gainNode);
                this._src = url;
                game.on(Game.EVENT_PAUSE, this._onInterruptedBegin, this);
                game.on(Game.EVENT_RESUME, this._onInterruptedEnd, this);
              }

              var _proto3 = AudioPlayerWeb.prototype;

              _proto3.destroy = function destroy() {
                this._audioTimer.destroy();

                if (this._audioBuffer) {
                  this._audioBuffer = null;
                }

                audioBufferManager.tryReleasingCache(this._src);
                game.off(Game.EVENT_PAUSE, this._onInterruptedBegin, this);
                game.off(Game.EVENT_RESUME, this._onInterruptedEnd, this);
              };

              AudioPlayerWeb.load = function load(url) {
                return new Promise(function (resolve) {
                  AudioPlayerWeb.loadNative(url).then(function (audioBuffer) {
                    resolve(new AudioPlayerWeb(audioBuffer, url));
                  })["catch"](function (e) {});
                });
              };

              AudioPlayerWeb.loadNative = function loadNative(url) {
                return new Promise(function (resolve, reject) {
                  var cachedAudioBuffer = audioBufferManager.getCache(url);

                  if (cachedAudioBuffer) {
                    audioBufferManager.retainCache(url);
                    resolve(cachedAudioBuffer);
                    return;
                  }

                  var xhr = new XMLHttpRequest();
                  var errInfo = "load audio failed: " + url + ", status: ";
                  xhr.open('GET', url, true);
                  xhr.responseType = 'arraybuffer';

                  xhr.onload = function () {
                    if (xhr.status === 200 || xhr.status === 0) {
                      audioContextAgent.decodeAudioData(xhr.response).then(function (decodedAudioBuffer) {
                        audioBufferManager.addCache(url, decodedAudioBuffer);
                        resolve(decodedAudioBuffer);
                      })["catch"](function (e) {});
                    } else {
                      reject(new Error("" + errInfo + xhr.status + "(no response)"));
                    }
                  };

                  xhr.onerror = function () {
                    reject(new Error("" + errInfo + xhr.status + "(error)"));
                  };

                  xhr.ontimeout = function () {
                    reject(new Error("" + errInfo + xhr.status + "(time out)"));
                  };

                  xhr.onabort = function () {
                    reject(new Error("" + errInfo + xhr.status + "(abort)"));
                  };

                  xhr.send(null);
                });
              };

              AudioPlayerWeb.loadOneShotAudio = function loadOneShotAudio(url, volume) {
                return new Promise(function (resolve, reject) {
                  AudioPlayerWeb.loadNative(url).then(function (audioBuffer) {
                    var oneShotAudio = new OneShotAudioWeb(audioBuffer, volume, url);
                    resolve(oneShotAudio);
                  })["catch"](reject);
                });
              };

              _proto3.getPCMData = function getPCMData(channelIndex) {
                return new AudioPCMDataView(this._audioBuffer.getChannelData(channelIndex), 1);
              };

              _proto3._onInterruptedBegin = function _onInterruptedBegin() {
                var _this5 = this;

                if (this._state === AudioState.PLAYING) {
                  this.pause().then(function () {
                    _this5._state = AudioState.INTERRUPTED;

                    _this5._eventTarget.emit(AudioEvent.INTERRUPTION_BEGIN);
                  })["catch"](function (e) {});
                }
              };

              _proto3._onInterruptedEnd = function _onInterruptedEnd() {
                var _this6 = this;

                if (this._state === AudioState.INTERRUPTED) {
                  this.play().then(function () {
                    _this6._eventTarget.emit(AudioEvent.INTERRUPTION_END);
                  })["catch"](function (e) {});
                }
              };

              _proto3.offRunning = function offRunning() {
                if (this._runningCallback) {
                  audioContextAgent.offRunning(this._runningCallback);
                  this._runningCallback = undefined;
                }
              };

              _proto3.seek = function seek(time) {
                var _this7 = this;

                return new Promise(function (resolve) {
                  _this7.offRunning();

                  _this7._audioTimer.seek(time);

                  if (_this7._state === AudioState.PLAYING) {
                    _this7._doPlay().then(resolve)["catch"](function (e) {});
                  } else {
                    resolve();
                  }
                });
              };

              _proto3.play = function play() {
                this.offRunning();

                return this._doPlay();
              };

              _proto3._doPlay = function _doPlay() {
                var _this8 = this;

                return new Promise(function (resolve) {
                  if (audioContextAgent.isRunning) {
                    _this8._startSourceNode();

                    resolve();
                  } else {
                    _this8.offRunning();

                    _this8._runningCallback = function () {
                      _this8._startSourceNode();

                      resolve();
                    };

                    audioContextAgent.onceRunning(_this8._runningCallback);
                    audioContextAgent.runContext()["catch"](function (e) {});
                  }
                });
              };

              _proto3._startSourceNode = function _startSourceNode() {
                var _this9 = this;

                this._stopSourceNode();

                this._sourceNode = audioContextAgent.createBufferSource(this._audioBuffer, this.loop);

                this._sourceNode.connect(this._gainNode);

                this._sourceNode.start(0, this._audioTimer.currentTime);

                this._state = AudioState.PLAYING;

                this._audioTimer.start();

                var checkEnded = function checkEnded() {
                  if (_this9.loop) {
                    _this9._currentTimer = window.setTimeout(checkEnded, _this9._audioBuffer.duration * 1000);
                  } else {
                    _this9._audioTimer.stop();

                    _this9._eventTarget.emit(AudioEvent.ENDED);

                    _this9._state = AudioState.INIT;
                  }
                };

                window.clearTimeout(this._currentTimer);
                this._currentTimer = window.setTimeout(checkEnded, (this._audioBuffer.duration - this._audioTimer.currentTime) * 1000);
              };

              _proto3._stopSourceNode = function _stopSourceNode() {
                try {
                  if (this._sourceNode) {
                    this._sourceNode.stop();

                    this._sourceNode.buffer = null;
                  }
                } catch (e) {}
              };

              _proto3.pause = function pause() {
                this.offRunning();

                if (this._state !== AudioState.PLAYING || !this._sourceNode) {
                  return Promise.resolve();
                }

                this._audioTimer.pause();

                this._state = AudioState.PAUSED;
                window.clearTimeout(this._currentTimer);

                this._stopSourceNode();

                return Promise.resolve();
              };

              _proto3.stop = function stop() {
                this.offRunning();

                if (!this._sourceNode) {
                  return Promise.resolve();
                }

                this._audioTimer.stop();

                this._state = AudioState.STOPPED;
                window.clearTimeout(this._currentTimer);

                this._stopSourceNode();

                return Promise.resolve();
              };

              _proto3.onInterruptionBegin = function onInterruptionBegin(cb) {
                this._eventTarget.on(AudioEvent.INTERRUPTION_BEGIN, cb);
              };

              _proto3.offInterruptionBegin = function offInterruptionBegin(cb) {
                this._eventTarget.off(AudioEvent.INTERRUPTION_BEGIN, cb);
              };

              _proto3.onInterruptionEnd = function onInterruptionEnd(cb) {
                this._eventTarget.on(AudioEvent.INTERRUPTION_END, cb);
              };

              _proto3.offInterruptionEnd = function offInterruptionEnd(cb) {
                this._eventTarget.off(AudioEvent.INTERRUPTION_END, cb);
              };

              _proto3.onEnded = function onEnded(cb) {
                this._eventTarget.on(AudioEvent.ENDED, cb);
              };

              _proto3.offEnded = function offEnded(cb) {
                this._eventTarget.off(AudioEvent.ENDED, cb);
              };

              _createClass(AudioPlayerWeb, [{
                key: "sampleRate",
                get: function get() {
                  return this._audioBuffer.sampleRate;
                }
              }, {
                key: "src",
                get: function get() {
                  return this._src;
                }
              }, {
                key: "type",
                get: function get() {
                  return AudioType.WEB_AUDIO;
                }
              }, {
                key: "state",
                get: function get() {
                  return this._state;
                }
              }, {
                key: "loop",
                get: function get() {
                  return this._loop;
                },
                set: function set(val) {
                  this._loop = val;

                  if (this._sourceNode) {
                    this._sourceNode.loop = val;
                  }
                }
              }, {
                key: "volume",
                get: function get() {
                  return this._volume;
                },
                set: function set(val) {
                  val = clamp01(val);
                  this._volume = val;
                  audioContextAgent.setGainValue(this._gainNode, val);
                }
              }, {
                key: "duration",
                get: function get() {
                  return this._audioBuffer.duration;
                }
              }, {
                key: "currentTime",
                get: function get() {
                  return this._audioTimer.currentTime;
                }
              }]);

              return AudioPlayerWeb;
            }(), (_applyDecoratedDescriptor(_class$15.prototype, "seek", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$15.prototype, "seek"), _class$15.prototype), _applyDecoratedDescriptor(_class$15.prototype, "play", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$15.prototype, "play"), _class$15.prototype), _applyDecoratedDescriptor(_class$15.prototype, "pause", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$15.prototype, "pause"), _class$15.prototype), _applyDecoratedDescriptor(_class$15.prototype, "stop", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$15.prototype, "stop"), _class$15.prototype)), _class$15);

            var OneShotAudio = function () {
              function OneShotAudio(audio) {
                this._audio = void 0;
                this._audio = audio;
              }

              var _proto = OneShotAudio.prototype;

              _proto.play = function play() {
                this._audio.play();
              };

              _proto.stop = function stop() {
                this._audio.stop();
              };

              _createClass(OneShotAudio, [{
                key: "onPlay",
                get: function get() {
                  return this._audio.onPlay;
                },
                set: function set(v) {
                  this._audio.onPlay = v;
                }
              }, {
                key: "onEnd",
                get: function get() {
                  return this._audio.onEnd;
                },
                set: function set(v) {
                  this._audio.onEnd = v;
                }
              }]);

              return OneShotAudio;
            }();
            var AudioPlayer = function () {
              function AudioPlayer(player) {
                this._player = void 0;
                this._player = player;
              }

              AudioPlayer.load = function load(url, opts) {
                return new Promise(function (resolve) {
                  if ((opts === null || opts === void 0 ? void 0 : opts.audioLoadMode) === AudioType.DOM_AUDIO || !AudioContextAgent.support) {
                    if (!AudioContextAgent.support) {
                      warnID(5201);
                    }

                    AudioPlayerDOM.load(url).then(function (domPlayer) {
                      resolve(new AudioPlayer(domPlayer));
                    })["catch"](function (e) {});
                  } else {
                    AudioPlayerWeb.load(url).then(function (webPlayer) {
                      resolve(new AudioPlayer(webPlayer));
                    })["catch"](function (e) {});
                  }
                });
              };

              var _proto2 = AudioPlayer.prototype;

              _proto2.destroy = function destroy() {
                this._player.destroy();
              };

              AudioPlayer.loadNative = function loadNative(url, opts) {
                if ((opts === null || opts === void 0 ? void 0 : opts.audioLoadMode) === AudioType.DOM_AUDIO || !AudioContextAgent.support) {
                  if (!AudioContextAgent.support) {
                    warnID(5201);
                  }

                  return AudioPlayerDOM.loadNative(url);
                }

                return AudioPlayerWeb.loadNative(url);
              };

              AudioPlayer.loadOneShotAudio = function loadOneShotAudio(url, volume, opts) {
                return new Promise(function (resolve, reject) {
                  if ((opts === null || opts === void 0 ? void 0 : opts.audioLoadMode) === AudioType.DOM_AUDIO || !AudioContextAgent.support) {
                    if (!AudioContextAgent.support) {
                      warnID(5201);
                    }

                    AudioPlayerDOM.loadOneShotAudio(url, volume).then(function (oneShotAudioDOM) {
                      resolve(new OneShotAudio(oneShotAudioDOM));
                    })["catch"](reject);
                  } else {
                    AudioPlayerWeb.loadOneShotAudio(url, volume).then(function (oneShotAudioWeb) {
                      resolve(new OneShotAudio(oneShotAudioWeb));
                    })["catch"](reject);
                  }
                });
              };

              _proto2.getPCMData = function getPCMData(channelIndex) {
                return this._player.getPCMData(channelIndex);
              };

              _proto2.seek = function seek(time) {
                return this._player.seek(time);
              };

              _proto2.play = function play() {
                return this._player.play();
              };

              _proto2.pause = function pause() {
                return this._player.pause();
              };

              _proto2.stop = function stop() {
                return this._player.stop();
              };

              _proto2.onInterruptionBegin = function onInterruptionBegin(cb) {
                this._player.onInterruptionBegin(cb);
              };

              _proto2.offInterruptionBegin = function offInterruptionBegin(cb) {
                this._player.offInterruptionBegin(cb);
              };

              _proto2.onInterruptionEnd = function onInterruptionEnd(cb) {
                this._player.onInterruptionEnd(cb);
              };

              _proto2.offInterruptionEnd = function offInterruptionEnd(cb) {
                this._player.offInterruptionEnd(cb);
              };

              _proto2.onEnded = function onEnded(cb) {
                this._player.onEnded(cb);
              };

              _proto2.offEnded = function offEnded(cb) {
                this._player.offEnded(cb);
              };

              _createClass(AudioPlayer, [{
                key: "src",
                get: function get() {
                  return this._player.src;
                }
              }, {
                key: "type",
                get: function get() {
                  return this._player.type;
                }
              }, {
                key: "state",
                get: function get() {
                  return this._player.state;
                }
              }, {
                key: "loop",
                get: function get() {
                  return this._player.loop;
                },
                set: function set(val) {
                  this._player.loop = val;
                }
              }, {
                key: "volume",
                get: function get() {
                  return this._player.volume;
                },
                set: function set(val) {
                  this._player.volume = val;
                }
              }, {
                key: "duration",
                get: function get() {
                  return this._player.duration;
                }
              }, {
                key: "currentTime",
                get: function get() {
                  return this._player.currentTime;
                }
              }, {
                key: "sampleRate",
                get: function get() {
                  return this._player.sampleRate;
                }
              }]);

              return AudioPlayer;
            }();
            AudioPlayer.maxAudioChannel = 24;

            var _dec$13, _class$16, _class2$W, _initializer$T, _class3$c, _temp$j;
            var AudioClip = exports('AudioClip', (_dec$13 = ccclass$p('cc.AudioClip'), _dec$13(_class$16 = (_class2$W = (_temp$j = _class3$c = function (_Asset) {
              _inheritsLoose(AudioClip, _Asset);

              function AudioClip() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;
                _this._duration = _initializer$T && _initializer$T();
                _this._loadMode = AudioType.UNKNOWN_AUDIO;
                _this._meta = null;
                _this._player = null;
                return _this;
              }

              var _proto = AudioClip.prototype;

              _proto.destroy = function destroy() {
                var _this$_player;

                var destroyResult = _Asset.prototype.destroy.call(this);

                (_this$_player = this._player) === null || _this$_player === void 0 ? void 0 : _this$_player.destroy();
                this._player = null;

                if (this._meta) {
                  this._meta.player = null;
                }

                return destroyResult;
              };

              _proto.validate = function validate() {
                return !!this._meta;
              };

              _proto.getDuration = function getDuration() {
                if (this._duration) {
                  return this._duration;
                }

                return this._meta ? this._meta.duration : 0;
              };

              _proto.getCurrentTime = function getCurrentTime() {
                return this._player ? this._player.currentTime : 0;
              };

              _proto.getVolume = function getVolume() {
                return this._player ? this._player.volume : 0;
              };

              _proto.getLoop = function getLoop() {
                return this._player ? this._player.loop : false;
              };

              _proto.setCurrentTime = function setCurrentTime(time) {
                var _this$_player2;

                (_this$_player2 = this._player) === null || _this$_player2 === void 0 ? void 0 : _this$_player2.seek(time)["catch"](function (e) {});
              };

              _proto.setVolume = function setVolume(volume) {
                if (this._player) {
                  this._player.volume = volume;
                }
              };

              _proto.setLoop = function setLoop(loop) {
                if (this._player) {
                  this._player.loop = loop;
                }
              };

              _proto.play = function play() {
                var _this$_player3;

                (_this$_player3 = this._player) === null || _this$_player3 === void 0 ? void 0 : _this$_player3.play()["catch"](function (e) {});
              };

              _proto.pause = function pause() {
                var _this$_player4;

                (_this$_player4 = this._player) === null || _this$_player4 === void 0 ? void 0 : _this$_player4.pause()["catch"](function (e) {});
              };

              _proto.stop = function stop() {
                var _this$_player5;

                (_this$_player5 = this._player) === null || _this$_player5 === void 0 ? void 0 : _this$_player5.stop()["catch"](function (e) {});
              };

              _proto.playOneShot = function playOneShot(volume) {
                if (volume === void 0) {
                  volume = 1;
                }

                if (this._nativeAsset) {
                  AudioPlayer.loadOneShotAudio(this._nativeAsset.url, volume).then(function (oneShotAudio) {
                    oneShotAudio.play();
                  })["catch"](function (e) {});
                }
              };

              _createClass(AudioClip, [{
                key: "_nativeAsset",
                get: function get() {
                  return this._meta;
                },
                set: function set(meta) {
                  this._meta = meta;

                  if (meta) {
                    this._loadMode = meta.type;
                    this._player = meta.player;
                  } else {
                    this._meta = null;
                    this._loadMode = AudioType.UNKNOWN_AUDIO;
                    this._duration = 0;
                  }
                }
              }, {
                key: "_nativeDep",
                get: function get() {
                  return {
                    uuid: this._uuid,
                    audioLoadMode: this.loadMode,
                    ext: this._native,
                    __isNative__: true
                  };
                }
              }, {
                key: "loadMode",
                get: function get() {
                  return this._loadMode;
                }
              }, {
                key: "state",
                get: function get() {
                  return this._player ? this._player.state : AudioState.INIT;
                }
              }]);

              return AudioClip;
            }(Asset), _class3$c.AudioType = AudioType, _temp$j), (_initializer$T = applyDecoratedInitializer(_class2$W.prototype, "_duration", [serializable$j], function () {
              return 0;
            }), _applyDecoratedDescriptor(_class2$W.prototype, "_nativeDep", [override$1], Object.getOwnPropertyDescriptor(_class2$W.prototype, "_nativeDep"), _class2$W.prototype)), _class2$W)) || _class$16));
            legacyCC.AudioClip = AudioClip;

            function loadAudioPlayer(url, options, onComplete) {
              AudioPlayer.load(url, {
                audioLoadMode: options.audioLoadMode
              }).then(function (player) {
                var audioMeta = {
                  player: player,
                  url: url,
                  duration: player.duration,
                  type: player.type
                };
                onComplete(null, audioMeta);
              })["catch"](function (err) {
                onComplete(err);
              });
            }

            function createAudioClip(id, data, options, onComplete) {
              var out = new AudioClip();
              out._nativeUrl = id;
              out._nativeAsset = data;
              out._duration = data.duration;
              onComplete(null, out);
            }

            downloader.register({
              '.mp3': loadAudioPlayer,
              '.ogg': loadAudioPlayer,
              '.wav': loadAudioPlayer,
              '.m4a': loadAudioPlayer
            });
            factory.register({
              '.mp3': createAudioClip,
              '.ogg': createAudioClip,
              '.wav': createAudioClip,
              '.m4a': createAudioClip
            });

            var AudioManager = function () {
              function AudioManager() {
                this._oneShotAudioInfoList = [];
                this._audioPlayerInfoList = [];
              }

              var _proto = AudioManager.prototype;

              _proto._findIndex = function _findIndex(audioInfoList, audio) {
                return audioInfoList.findIndex(function (item) {
                  return item.audio === audio;
                });
              };

              _proto._tryAddPlaying = function _tryAddPlaying(audioInfoList, audio) {
                var idx = this._findIndex(audioInfoList, audio);

                if (idx > -1) {
                  audioInfoList[idx].playTime = performance.now();
                  return false;
                }

                audioInfoList.push({
                  audio: audio,
                  playTime: performance.now()
                });
                return true;
              };

              _proto.addPlaying = function addPlaying(audio) {
                if (audio instanceof AudioPlayer) {
                  this._tryAddPlaying(this._audioPlayerInfoList, audio);
                } else {
                  this._tryAddPlaying(this._oneShotAudioInfoList, audio);
                }
              };

              _proto._tryRemovePlaying = function _tryRemovePlaying(audioInfoList, audio) {
                var idx = this._findIndex(audioInfoList, audio);

                if (idx === -1) {
                  return false;
                }

                fastRemoveAt(audioInfoList, idx);
                return true;
              };

              _proto.removePlaying = function removePlaying(audio) {
                if (audio instanceof AudioPlayer) {
                  this._tryRemovePlaying(this._audioPlayerInfoList, audio);
                } else {
                  this._tryRemovePlaying(this._oneShotAudioInfoList, audio);
                }
              };

              _proto.discardOnePlayingIfNeeded = function discardOnePlayingIfNeeded() {
                if (this._audioPlayerInfoList.length + this._oneShotAudioInfoList.length < AudioPlayer.maxAudioChannel) {
                  return;
                }

                var audioInfoToDiscard;

                if (this._oneShotAudioInfoList.length > 0) {
                  this._oneShotAudioInfoList.forEach(function (audioInfo) {
                    if (!audioInfoToDiscard || audioInfo.playTime < audioInfoToDiscard.playTime) {
                      audioInfoToDiscard = audioInfo;
                    }
                  });
                } else {
                  this._audioPlayerInfoList.forEach(function (audioInfo) {
                    if (!audioInfoToDiscard || audioInfo.playTime < audioInfoToDiscard.playTime) {
                      audioInfoToDiscard = audioInfo;
                    }
                  });
                }

                if (audioInfoToDiscard) {
                  audioInfoToDiscard.audio.stop();
                  this.removePlaying(audioInfoToDiscard.audio);
                }
              };

              _proto.pause = function pause() {
                this._oneShotAudioInfoList.forEach(function (info) {
                  info.audio.stop();
                });

                this._audioPlayerInfoList.forEach(function (info) {
                  info.audio.pause()["catch"](function (e) {});
                });
              };

              _proto.resume = function resume() {
                this._audioPlayerInfoList.forEach(function (info) {
                  info.audio.play()["catch"](function (e) {});
                });
              };

              return AudioManager;
            }();
            var audioManager = new AudioManager();

            var _dec$14, _dec2$M, _dec3$v, _class$17, _class2$X, _initializer$U, _initializer2$J, _initializer3$w, _initializer4$r, _class3$d, _temp$k;
            var _LOADED_EVENT = 'audiosource-loaded';
            var AudioSourceEventType;

            (function (AudioSourceEventType) {
              AudioSourceEventType["STARTED"] = "started";
              AudioSourceEventType["ENDED"] = "ended";
            })(AudioSourceEventType || (AudioSourceEventType = {}));

            var AudioSource = function (v) { return exports({ AudioSource: v, AudioSourceComponent: v }), v; }((_dec$14 = ccclass$p('cc.AudioSource'), _dec2$M = type$8(AudioClip), _dec3$v = type$8(AudioClip), _dec$14(_class$17 = (_class2$X = (_temp$k = _class3$d = function (_Component) {
              _inheritsLoose(AudioSource, _Component);

              function AudioSource() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._clip = _initializer$U && _initializer$U();
                _this._player = null;
                _this._loop = _initializer2$J && _initializer2$J();
                _this._playOnAwake = _initializer3$w && _initializer3$w();
                _this._volume = _initializer4$r && _initializer4$r();
                _this._cachedCurrentTime = 0;
                _this._operationsBeforeLoading = [];
                _this._isLoaded = false;
                _this._lastSetClip = null;
                return _this;
              }

              var _proto = AudioSource.prototype;

              _proto._resetPlayer = function _resetPlayer() {
                if (this._player) {
                  audioManager.removePlaying(this._player);

                  this._player.offEnded();

                  this._player.offInterruptionBegin();

                  this._player.offInterruptionEnd();

                  this._player.destroy();

                  this._player = null;
                }
              };

              _proto._syncPlayer = function _syncPlayer() {
                var _this2 = this;

                var clip = this._clip;

                if (this._lastSetClip === clip) {
                  return;
                }

                if (!clip) {
                  this._lastSetClip = null;

                  this._resetPlayer();

                  return;
                }

                if (!clip._nativeAsset) {
                  console.error('Invalid audio clip');
                  return;
                }

                this._isLoaded = false;
                this._lastSetClip = clip;
                this._operationsBeforeLoading.length = 0;
                AudioPlayer.load(clip._nativeAsset.url, {
                  audioLoadMode: clip.loadMode
                }).then(function (player) {
                  var _this2$node2;

                  if (_this2._lastSetClip !== clip) {
                    player.destroy();
                    return;
                  }

                  _this2._isLoaded = true;

                  _this2._resetPlayer();

                  _this2._player = player;
                  player.onEnded(function () {
                    var _this2$node;

                    audioManager.removePlaying(player);
                    (_this2$node = _this2.node) === null || _this2$node === void 0 ? void 0 : _this2$node.emit(AudioSourceEventType.ENDED, _this2);
                  });
                  player.onInterruptionBegin(function () {
                    audioManager.removePlaying(player);
                  });
                  player.onInterruptionEnd(function () {
                    audioManager.addPlaying(player);
                  });

                  _this2._syncStates();

                  (_this2$node2 = _this2.node) === null || _this2$node2 === void 0 ? void 0 : _this2$node2.emit(_LOADED_EVENT);
                })["catch"](function (e) {});
              };

              _proto.onLoad = function onLoad() {
                this._syncPlayer();
              };

              _proto.onEnable = function onEnable() {
                if (this._playOnAwake && !this.playing) {
                  this.play();
                }
              };

              _proto.onDisable = function onDisable() {
                var rootNode = this._getRootNode();

                if (rootNode !== null && rootNode !== void 0 && rootNode._persistNode) {
                  return;
                }

                this.pause();
              };

              _proto.onDestroy = function onDestroy() {
                var _this$_player;

                this.stop();
                (_this$_player = this._player) === null || _this$_player === void 0 ? void 0 : _this$_player.destroy();
                this._player = null;
              };

              _proto.getPCMData = function getPCMData(channelIndex) {
                var _this3 = this;

                return new Promise(function (resolve) {
                  if (channelIndex !== 0 && channelIndex !== 1) {
                    console.warn('Only support channel index 0 or 1 to get buffer');
                    resolve(undefined);
                    return;
                  }

                  if (_this3._player) {
                    resolve(_this3._player.getPCMData(channelIndex));
                  } else {
                    var _this3$node;

                    (_this3$node = _this3.node) === null || _this3$node === void 0 ? void 0 : _this3$node.once(_LOADED_EVENT, function () {
                      var _this3$_player;

                      resolve((_this3$_player = _this3._player) === null || _this3$_player === void 0 ? void 0 : _this3$_player.getPCMData(channelIndex));
                    });
                  }
                });
              };

              _proto.getSampleRate = function getSampleRate() {
                var _this4 = this;

                return new Promise(function (resolve) {
                  if (_this4._player) {
                    resolve(_this4._player.sampleRate);
                  } else {
                    var _this4$node;

                    (_this4$node = _this4.node) === null || _this4$node === void 0 ? void 0 : _this4$node.once(_LOADED_EVENT, function () {
                      resolve(_this4._player.sampleRate);
                    });
                  }
                });
              };

              _proto._getRootNode = function _getRootNode() {
                var _currentNode, _currentNode$parent;

                var currentNode = this.node;
                var currentGrandparentNode = (_currentNode = currentNode) === null || _currentNode === void 0 ? void 0 : (_currentNode$parent = _currentNode.parent) === null || _currentNode$parent === void 0 ? void 0 : _currentNode$parent.parent;

                while (currentGrandparentNode) {
                  var _currentNode2, _currentNode3, _currentNode3$parent;

                  currentNode = (_currentNode2 = currentNode) === null || _currentNode2 === void 0 ? void 0 : _currentNode2.parent;
                  currentGrandparentNode = (_currentNode3 = currentNode) === null || _currentNode3 === void 0 ? void 0 : (_currentNode3$parent = _currentNode3.parent) === null || _currentNode3$parent === void 0 ? void 0 : _currentNode3$parent.parent;
                }

                return currentNode;
              };

              _proto.play = function play() {
                var _this$_player3,
                    _this5 = this;

                if (!this._isLoaded && this.clip) {
                  this._operationsBeforeLoading.push('play');

                  return;
                }

                audioManager.discardOnePlayingIfNeeded();

                if (this.state === AudioState.PLAYING) {
                  var _this$_player2;

                  (_this$_player2 = this._player) === null || _this$_player2 === void 0 ? void 0 : _this$_player2.stop()["catch"](function (e) {});
                }

                var player = this._player;
                (_this$_player3 = this._player) === null || _this$_player3 === void 0 ? void 0 : _this$_player3.play().then(function () {
                  var _this5$node;

                  audioManager.addPlaying(player);
                  (_this5$node = _this5.node) === null || _this5$node === void 0 ? void 0 : _this5$node.emit(AudioSourceEventType.STARTED, _this5);
                })["catch"](function (e) {});
              };

              _proto.pause = function pause() {
                var _this$_player4;

                if (!this._isLoaded && this.clip) {
                  this._operationsBeforeLoading.push('pause');

                  return;
                }

                var player = this._player;
                (_this$_player4 = this._player) === null || _this$_player4 === void 0 ? void 0 : _this$_player4.pause().then(function () {
                  audioManager.removePlaying(player);
                })["catch"](function (e) {});
              };

              _proto.stop = function stop() {
                var _this$_player5;

                if (!this._isLoaded && this.clip) {
                  this._operationsBeforeLoading.push('stop');

                  return;
                }

                var player = this._player;
                (_this$_player5 = this._player) === null || _this$_player5 === void 0 ? void 0 : _this$_player5.stop().then(function () {
                  audioManager.removePlaying(player);
                })["catch"](function (e) {});
              };

              _proto.playOneShot = function playOneShot(clip, volumeScale) {
                if (volumeScale === void 0) {
                  volumeScale = 1;
                }

                if (!clip._nativeAsset) {
                  console.error('Invalid audio clip');
                  return;
                }

                AudioPlayer.loadOneShotAudio(clip._nativeAsset.url, this._volume * volumeScale, {
                  audioLoadMode: clip.loadMode
                }).then(function (oneShotAudio) {
                  audioManager.discardOnePlayingIfNeeded();

                  oneShotAudio.onPlay = function () {
                    audioManager.addPlaying(oneShotAudio);
                  };

                  oneShotAudio.onEnd = function () {
                    audioManager.removePlaying(oneShotAudio);
                  };

                  oneShotAudio.play();
                })["catch"](function (e) {});
              };

              _proto._syncStates = function _syncStates() {
                var _this6 = this;

                if (!this._player) {
                  return;
                }

                this._player.seek(this._cachedCurrentTime).then(function () {
                  if (_this6._player) {
                    _this6._player.loop = _this6._loop;
                    _this6._player.volume = _this6._volume;

                    _this6._operationsBeforeLoading.forEach(function (opName) {
                      var _this6$opName;

                      (_this6$opName = _this6[opName]) === null || _this6$opName === void 0 ? void 0 : _this6$opName.call(_this6);
                    });

                    _this6._operationsBeforeLoading.length = 0;
                  }
                })["catch"](function (e) {});
              };

              _createClass(AudioSource, [{
                key: "clip",
                get: function get() {
                  return this._clip;
                },
                set: function set(val) {
                  if (val === this._clip) {
                    return;
                  }

                  this._clip = val;

                  this._syncPlayer();
                }
              }, {
                key: "loop",
                get: function get() {
                  return this._loop;
                },
                set: function set(val) {
                  this._loop = val;
                  this._player && (this._player.loop = val);
                }
              }, {
                key: "playOnAwake",
                get: function get() {
                  return this._playOnAwake;
                },
                set: function set(val) {
                  this._playOnAwake = val;
                }
              }, {
                key: "volume",
                get: function get() {
                  return this._volume;
                },
                set: function set(val) {
                  if (Number.isNaN(val)) {
                    console.warn('illegal audio volume!');
                    return;
                  }

                  val = clamp$1(val, 0, 1);

                  if (this._player) {
                    this._player.volume = val;
                    this._volume = this._player.volume;
                  } else {
                    this._volume = val;
                  }
                }
              }, {
                key: "currentTime",
                get: function get() {
                  return this._player ? this._player.currentTime : this._cachedCurrentTime;
                },
                set: function set(num) {
                  var _this$_player6;

                  if (Number.isNaN(num)) {
                    console.warn('illegal audio time!');
                    return;
                  }

                  num = clamp$1(num, 0, this.duration);
                  this._cachedCurrentTime = num;
                  (_this$_player6 = this._player) === null || _this$_player6 === void 0 ? void 0 : _this$_player6.seek(this._cachedCurrentTime)["catch"](function (e) {});
                }
              }, {
                key: "duration",
                get: function get() {
                  var _this$_clip$getDurati, _this$_clip;

                  return (_this$_clip$getDurati = (_this$_clip = this._clip) === null || _this$_clip === void 0 ? void 0 : _this$_clip.getDuration()) !== null && _this$_clip$getDurati !== void 0 ? _this$_clip$getDurati : this._player ? this._player.duration : 0;
                }
              }, {
                key: "state",
                get: function get() {
                  return this._player ? this._player.state : AudioState.INIT;
                }
              }, {
                key: "playing",
                get: function get() {
                  return this.state === AudioSource.AudioState.PLAYING;
                }
              }], [{
                key: "maxAudioChannel",
                get: function get() {
                  return AudioPlayer.maxAudioChannel;
                }
              }]);

              return AudioSource;
            }(Component), _class3$d.AudioState = AudioState, _class3$d.EventType = AudioSourceEventType, _temp$k), (_initializer$U = applyDecoratedInitializer(_class2$X.prototype, "_clip", [_dec2$M], function () {
              return null;
            }), _initializer2$J = applyDecoratedInitializer(_class2$X.prototype, "_loop", [serializable$j], function () {
              return false;
            }), _initializer3$w = applyDecoratedInitializer(_class2$X.prototype, "_playOnAwake", [serializable$j], function () {
              return true;
            }), _initializer4$r = applyDecoratedInitializer(_class2$X.prototype, "_volume", [serializable$j], function () {
              return 1;
            }), _applyDecoratedDescriptor(_class2$X.prototype, "clip", [_dec3$v], Object.getOwnPropertyDescriptor(_class2$X.prototype, "clip"), _class2$X.prototype)), _class2$X)) || _class$17));

            legacyCC.AudioSourceComponent = AudioSource;
            setClassAlias(AudioSource, 'cc.AudioSourceComponent');

            legacyCC.log = log;
            legacyCC.warn = warn;
            legacyCC.error = error;
            legacyCC.assert = assert;
            legacyCC._throw = _throw;
            legacyCC.logID = logID;
            legacyCC.warnID = warnID;
            legacyCC.errorID = errorID;
            legacyCC.assertID = assertID;
            legacyCC.debug = debug$1;
            legacyCC.path = {
              join: join,
              extname: extname,
              mainFileName: mainFileName,
              basename: basename,
              dirname: dirname,
              changeExtname: changeExtname,
              changeBasename: changeBasename,
              _normalize: _normalize,
              stripSep: stripSep,

              get sep() {
                return getSeperator();
              }

            };

            function isUICamera(camera) {
              var scene = camera.scene;
              var batches = scene.batches;

              for (var i = 0; i < batches.length; i++) {
                var batch = batches[i];

                if (camera.visibility & batch.visFlags) {
                  return true;
                }
              }

              return false;
            }

            var ForwardPipelineBuilder = exports('ForwardPipelineBuilder', function () {
              function ForwardPipelineBuilder() {}

              var _proto = ForwardPipelineBuilder.prototype;

              _proto.setup = function setup(cameras, ppl) {
                for (var i = 0; i < cameras.length; i++) {
                  var camera = cameras[i];

                  if (camera.scene === null) {
                    continue;
                  }

                  buildForwardPass(camera, ppl, false);
                }
              };

              return ForwardPipelineBuilder;
            }());
            var DeferredPipelineBuilder = exports('DeferredPipelineBuilder', function () {
              function DeferredPipelineBuilder() {}

              var _proto2 = DeferredPipelineBuilder.prototype;

              _proto2.setup = function setup(cameras, ppl) {
                for (var i = 0; i < cameras.length; ++i) {
                  var camera = cameras[i];

                  if (!camera.scene) {
                    continue;
                  }

                  var isGameView = camera.cameraUsage === CameraUsage.GAME || camera.cameraUsage === CameraUsage.GAME_VIEW;

                  if (!isGameView) {
                    buildForwardPass(camera, ppl, false);
                    continue;
                  }

                  if (!isUICamera(camera)) {
                    var gBufferInfo = buildGBufferPass(camera, ppl);
                    var lightInfo = buildLightingPass(camera, ppl, gBufferInfo);
                    buildPostprocessPass(camera, ppl, lightInfo.rtName);
                    continue;
                  }

                  buildUIPass(camera, ppl);
                }
              };

              return DeferredPipelineBuilder;
            }());

            var NodePool = exports('NodePool', function () {
              function NodePool(poolHandlerComp) {
                this.poolHandlerComp = void 0;
                this._pool = void 0;
                this.poolHandlerComp = poolHandlerComp;
                this._pool = [];
              }

              var _proto = NodePool.prototype;

              _proto.size = function size() {
                return this._pool.length;
              };

              _proto.clear = function clear() {
                var count = this._pool.length;

                for (var i = 0; i < count; ++i) {
                  this._pool[i].destroy();
                }

                this._pool.length = 0;
              };

              _proto.put = function put(obj) {
                if (obj && this._pool.indexOf(obj) === -1) {
                  obj.removeFromParent();
                  var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;

                  if (handler && handler.unuse) {
                    handler.unuse();
                  }

                  this._pool.push(obj);
                }
              };

              _proto.get = function get() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                var last = this._pool.length - 1;

                if (last < 0) {
                  return null;
                } else {
                  var obj = this._pool[last];
                  this._pool.length = last;
                  var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;

                  if (handler && handler.reuse) {
                    handler.reuse(arguments);
                  }

                  return obj;
                }
              };

              return NodePool;
            }());
            legacyCC.NodePool = NodePool;

            var _globalThis$jsb, _globalJsb$copyTextTo;
            var globalJsb = (_globalThis$jsb = globalThis.jsb) !== null && _globalThis$jsb !== void 0 ? _globalThis$jsb : {};

            var _native = exports('native', {
              DownloaderHints: globalJsb.DownloaderHints,
              Downloader: globalJsb.Downloader,
              zipUtils: globalJsb.zipUtils,
              fileUtils: globalJsb.fileUtils,
              DebugRenderer: globalJsb.DebugRenderer,
              copyTextToClipboard: (_globalJsb$copyTextTo = globalJsb.copyTextToClipboard) === null || _globalJsb$copyTextTo === void 0 ? void 0 : _globalJsb$copyTextTo.bind(globalJsb),
              garbageCollect: globalJsb.garbageCollect,
              reflection: globalJsb.reflection,
              bridge: globalJsb.bridge,
              jsbBridgeWrapper: globalJsb.jsbBridgeWrapper,
              AssetsManager: globalJsb.AssetsManager,
              EventAssetsManager: globalJsb.EventAssetsManager,
              Manifest: globalJsb.Manifest,
              saveImageData: globalJsb.saveImageData,
              process: globalJsb.process
            });

            legacyCC.renderer = renderer;

            var __extends=undefined&&undefined.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var dragonBones={};(function(dragonBones){})(dragonBones||(dragonBones={}));(function(dragonBones){var DragonBones=function(){function DragonBones(eventManager){this._clock=new dragonBones.WorldClock();this._events=[];this._objects=[];this._eventManager=null;this._eventManager=eventManager;console.info("DragonBones: "+DragonBones.VERSION+"\nWebsite: http://dragonbones.com/\nSource and Demo: https://github.com/DragonBones/");}DragonBones.prototype.advanceTime=function(passedTime){if(this._objects.length>0){for(var _i=0,_a=this._objects;_i<_a.length;_i++){var object=_a[_i];object.returnToPool();}this._objects.length=0;}this._clock.advanceTime(passedTime);if(this._events.length>0){for(var i=0;i<this._events.length;++i){var eventObject=this._events[i];var armature=eventObject.armature;if(armature._armatureData!==null){armature.eventDispatcher.dispatchDBEvent(eventObject.type,eventObject);if(eventObject.type===dragonBones.EventObject.SOUND_EVENT){this._eventManager.dispatchDBEvent(eventObject.type,eventObject);}}this.bufferObject(eventObject);}this._events.length=0;}};DragonBones.prototype.bufferEvent=function(value){if(this._events.indexOf(value)<0){this._events.push(value);}};DragonBones.prototype.bufferObject=function(object){if(this._objects.indexOf(object)<0){this._objects.push(object);}};Object.defineProperty(DragonBones.prototype,"clock",{get:function get(){return this._clock;},enumerable:true,configurable:true});Object.defineProperty(DragonBones.prototype,"eventManager",{get:function get(){return this._eventManager;},enumerable:true,configurable:true});DragonBones.VERSION="5.6.300";DragonBones.yDown=false;DragonBones.debug=false;DragonBones.debugDraw=false;DragonBones.webAssembly=false;return DragonBones;}();dragonBones.DragonBones=DragonBones;})(dragonBones||(dragonBones={}));if(!console.warn){console.warn=function(){};}if(!console.assert){console.assert=function(){};}if(!Date.now){Date.now=function now(){return new Date().getTime();};}var __extends=function __extends(t,e){function r(){this.constructor=t;}for(var i in e){if(e.hasOwnProperty(i)){t[i]=e[i];}}r.prototype=e.prototype,t.prototype=new r();};(function(dragonBones){var BaseObject=function(){function BaseObject(){this.hashCode=BaseObject._hashCode++;this._isInPool=false;}BaseObject._returnObject=function(object){var classType=String(object.constructor);var maxCount=classType in BaseObject._maxCountMap?BaseObject._maxCountMap[classType]:BaseObject._defaultMaxCount;var pool=BaseObject._poolsMap[classType]=BaseObject._poolsMap[classType]||[];if(pool.length<maxCount){if(!object._isInPool){object._isInPool=true;pool.push(object);}else {console.warn("The object is already in the pool.");}}};BaseObject.toString=function(){throw new Error();};BaseObject.setMaxCount=function(objectConstructor,maxCount){if(maxCount<0||maxCount!==maxCount){maxCount=0;}if(objectConstructor!==null){var classType=String(objectConstructor);var pool=classType in BaseObject._poolsMap?BaseObject._poolsMap[classType]:null;if(pool!==null&&pool.length>maxCount){pool.length=maxCount;}BaseObject._maxCountMap[classType]=maxCount;}else {BaseObject._defaultMaxCount=maxCount;for(var classType in BaseObject._poolsMap){var pool=BaseObject._poolsMap[classType];if(pool.length>maxCount){pool.length=maxCount;}if(classType in BaseObject._maxCountMap){BaseObject._maxCountMap[classType]=maxCount;}}}};BaseObject.clearPool=function(objectConstructor){if(objectConstructor===void 0){objectConstructor=null;}if(objectConstructor!==null){var classType=String(objectConstructor);var pool=classType in BaseObject._poolsMap?BaseObject._poolsMap[classType]:null;if(pool!==null&&pool.length>0){pool.length=0;}}else {for(var k in BaseObject._poolsMap){var pool=BaseObject._poolsMap[k];pool.length=0;}}};BaseObject.borrowObject=function(objectConstructor){var classType=String(objectConstructor);var pool=classType in BaseObject._poolsMap?BaseObject._poolsMap[classType]:null;if(pool!==null&&pool.length>0){var object_1=pool.pop();object_1._isInPool=false;return object_1;}var object=new objectConstructor();object._onClear();return object;};BaseObject.prototype.returnToPool=function(){this._onClear();BaseObject._returnObject(this);};BaseObject._hashCode=0;BaseObject._defaultMaxCount=3000;BaseObject._maxCountMap={};BaseObject._poolsMap={};return BaseObject;}();dragonBones.BaseObject=BaseObject;})(dragonBones||(dragonBones={}));(function(dragonBones){var Matrix=function(){function Matrix(a,b,c,d,tx,ty){if(a===void 0){a=1.0;}if(b===void 0){b=0.0;}if(c===void 0){c=0.0;}if(d===void 0){d=1.0;}if(tx===void 0){tx=0.0;}if(ty===void 0){ty=0.0;}this.a=a;this.b=b;this.c=c;this.d=d;this.tx=tx;this.ty=ty;}Matrix.prototype.toString=function(){return "[object dragonBones.Matrix] a:"+this.a+" b:"+this.b+" c:"+this.c+" d:"+this.d+" tx:"+this.tx+" ty:"+this.ty;};Matrix.prototype.copyFrom=function(value){this.a=value.a;this.b=value.b;this.c=value.c;this.d=value.d;this.tx=value.tx;this.ty=value.ty;return this;};Matrix.prototype.copyFromArray=function(value,offset){if(offset===void 0){offset=0;}this.a=value[offset];this.b=value[offset+1];this.c=value[offset+2];this.d=value[offset+3];this.tx=value[offset+4];this.ty=value[offset+5];return this;};Matrix.prototype.identity=function(){this.a=this.d=1.0;this.b=this.c=0.0;this.tx=this.ty=0.0;return this;};Matrix.prototype.concat=function(value){var aA=this.a*value.a;var bA=0.0;var cA=0.0;var dA=this.d*value.d;var txA=this.tx*value.a+value.tx;var tyA=this.ty*value.d+value.ty;if(this.b!==0.0||this.c!==0.0){aA+=this.b*value.c;bA+=this.b*value.d;cA+=this.c*value.a;dA+=this.c*value.b;}if(value.b!==0.0||value.c!==0.0){bA+=this.a*value.b;cA+=this.d*value.c;txA+=this.ty*value.c;tyA+=this.tx*value.b;}this.a=aA;this.b=bA;this.c=cA;this.d=dA;this.tx=txA;this.ty=tyA;return this;};Matrix.prototype.invert=function(){var aA=this.a;var bA=this.b;var cA=this.c;var dA=this.d;var txA=this.tx;var tyA=this.ty;if(bA===0.0&&cA===0.0){this.b=this.c=0.0;if(aA===0.0||dA===0.0){this.a=this.b=this.tx=this.ty=0.0;}else {aA=this.a=1.0/aA;dA=this.d=1.0/dA;this.tx=-aA*txA;this.ty=-dA*tyA;}return this;}var determinant=aA*dA-bA*cA;if(determinant===0.0){this.a=this.d=1.0;this.b=this.c=0.0;this.tx=this.ty=0.0;return this;}determinant=1.0/determinant;var k=this.a=dA*determinant;bA=this.b=-bA*determinant;cA=this.c=-cA*determinant;dA=this.d=aA*determinant;this.tx=-(k*txA+cA*tyA);this.ty=-(bA*txA+dA*tyA);return this;};Matrix.prototype.transformPoint=function(x,y,result,delta){if(delta===void 0){delta=false;}result.x=this.a*x+this.c*y;result.y=this.b*x+this.d*y;if(!delta){result.x+=this.tx;result.y+=this.ty;}};Matrix.prototype.transformRectangle=function(rectangle,delta){if(delta===void 0){delta=false;}var a=this.a;var b=this.b;var c=this.c;var d=this.d;var tx=delta?0.0:this.tx;var ty=delta?0.0:this.ty;var x=rectangle.x;var y=rectangle.y;var xMax=x+rectangle.width;var yMax=y+rectangle.height;var x0=a*x+c*y+tx;var y0=b*x+d*y+ty;var x1=a*xMax+c*y+tx;var y1=b*xMax+d*y+ty;var x2=a*xMax+c*yMax+tx;var y2=b*xMax+d*yMax+ty;var x3=a*x+c*yMax+tx;var y3=b*x+d*yMax+ty;var tmp=0.0;if(x0>x1){tmp=x0;x0=x1;x1=tmp;}if(x2>x3){tmp=x2;x2=x3;x3=tmp;}rectangle.x=Math.floor(x0<x2?x0:x2);rectangle.width=Math.ceil((x1>x3?x1:x3)-rectangle.x);if(y0>y1){tmp=y0;y0=y1;y1=tmp;}if(y2>y3){tmp=y2;y2=y3;y3=tmp;}rectangle.y=Math.floor(y0<y2?y0:y2);rectangle.height=Math.ceil((y1>y3?y1:y3)-rectangle.y);};return Matrix;}();dragonBones.Matrix=Matrix;})(dragonBones||(dragonBones={}));(function(dragonBones){var Transform=function(){function Transform(x,y,skew,rotation,scaleX,scaleY){if(x===void 0){x=0.0;}if(y===void 0){y=0.0;}if(skew===void 0){skew=0.0;}if(rotation===void 0){rotation=0.0;}if(scaleX===void 0){scaleX=1.0;}if(scaleY===void 0){scaleY=1.0;}this.x=x;this.y=y;this.skew=skew;this.rotation=rotation;this.scaleX=scaleX;this.scaleY=scaleY;}Transform.normalizeRadian=function(value){value=(value+Math.PI)%(Math.PI*2.0);value+=value>0.0?-Math.PI:Math.PI;return value;};Transform.prototype.toString=function(){return "[object dragonBones.Transform] x:"+this.x+" y:"+this.y+" skewX:"+this.skew*180.0/Math.PI+" skewY:"+this.rotation*180.0/Math.PI+" scaleX:"+this.scaleX+" scaleY:"+this.scaleY;};Transform.prototype.copyFrom=function(value){this.x=value.x;this.y=value.y;this.skew=value.skew;this.rotation=value.rotation;this.scaleX=value.scaleX;this.scaleY=value.scaleY;return this;};Transform.prototype.identity=function(){this.x=this.y=0.0;this.skew=this.rotation=0.0;this.scaleX=this.scaleY=1.0;return this;};Transform.prototype.add=function(value){this.x+=value.x;this.y+=value.y;this.skew+=value.skew;this.rotation+=value.rotation;this.scaleX*=value.scaleX;this.scaleY*=value.scaleY;return this;};Transform.prototype.minus=function(value){this.x-=value.x;this.y-=value.y;this.skew-=value.skew;this.rotation-=value.rotation;this.scaleX/=value.scaleX;this.scaleY/=value.scaleY;return this;};Transform.prototype.fromMatrix=function(matrix){var backupScaleX=this.scaleX,backupScaleY=this.scaleY;var PI_Q=Transform.PI_Q;this.x=matrix.tx;this.y=matrix.ty;this.rotation=Math.atan(matrix.b/matrix.a);var skewX=Math.atan(-matrix.c/matrix.d);this.scaleX=this.rotation>-PI_Q&&this.rotation<PI_Q?matrix.a/Math.cos(this.rotation):matrix.b/Math.sin(this.rotation);this.scaleY=skewX>-PI_Q&&skewX<PI_Q?matrix.d/Math.cos(skewX):-matrix.c/Math.sin(skewX);if(backupScaleX>=0.0&&this.scaleX<0.0){this.scaleX=-this.scaleX;this.rotation=this.rotation-Math.PI;}if(backupScaleY>=0.0&&this.scaleY<0.0){this.scaleY=-this.scaleY;skewX=skewX-Math.PI;}this.skew=skewX-this.rotation;return this;};Transform.prototype.toMatrix=function(matrix){if(this.rotation===0.0){matrix.a=1.0;matrix.b=0.0;}else {matrix.a=Math.cos(this.rotation);matrix.b=Math.sin(this.rotation);}if(this.skew===0.0){matrix.c=-matrix.b;matrix.d=matrix.a;}else {matrix.c=-Math.sin(this.skew+this.rotation);matrix.d=Math.cos(this.skew+this.rotation);}if(this.scaleX!==1.0){matrix.a*=this.scaleX;matrix.b*=this.scaleX;}if(this.scaleY!==1.0){matrix.c*=this.scaleY;matrix.d*=this.scaleY;}matrix.tx=this.x;matrix.ty=this.y;return this;};Transform.PI=Math.PI;Transform.PI_D=Math.PI*2.0;Transform.PI_H=Math.PI/2.0;Transform.PI_Q=Math.PI/4.0;Transform.RAD_DEG=180.0/Math.PI;Transform.DEG_RAD=Math.PI/180.0;return Transform;}();dragonBones.Transform=Transform;})(dragonBones||(dragonBones={}));(function(dragonBones){var ColorTransform=function(){function ColorTransform(alphaMultiplier,redMultiplier,greenMultiplier,blueMultiplier,alphaOffset,redOffset,greenOffset,blueOffset){if(alphaMultiplier===void 0){alphaMultiplier=1.0;}if(redMultiplier===void 0){redMultiplier=1.0;}if(greenMultiplier===void 0){greenMultiplier=1.0;}if(blueMultiplier===void 0){blueMultiplier=1.0;}if(alphaOffset===void 0){alphaOffset=0;}if(redOffset===void 0){redOffset=0;}if(greenOffset===void 0){greenOffset=0;}if(blueOffset===void 0){blueOffset=0;}this.alphaMultiplier=alphaMultiplier;this.redMultiplier=redMultiplier;this.greenMultiplier=greenMultiplier;this.blueMultiplier=blueMultiplier;this.alphaOffset=alphaOffset;this.redOffset=redOffset;this.greenOffset=greenOffset;this.blueOffset=blueOffset;}ColorTransform.prototype.copyFrom=function(value){this.alphaMultiplier=value.alphaMultiplier;this.redMultiplier=value.redMultiplier;this.greenMultiplier=value.greenMultiplier;this.blueMultiplier=value.blueMultiplier;this.alphaOffset=value.alphaOffset;this.redOffset=value.redOffset;this.greenOffset=value.greenOffset;this.blueOffset=value.blueOffset;};ColorTransform.prototype.identity=function(){this.alphaMultiplier=this.redMultiplier=this.greenMultiplier=this.blueMultiplier=1.0;this.alphaOffset=this.redOffset=this.greenOffset=this.blueOffset=0;};return ColorTransform;}();dragonBones.ColorTransform=ColorTransform;})(dragonBones||(dragonBones={}));(function(dragonBones){var Point=function(){function Point(x,y){if(x===void 0){x=0.0;}if(y===void 0){y=0.0;}this.x=x;this.y=y;}Point.prototype.copyFrom=function(value){this.x=value.x;this.y=value.y;};Point.prototype.clear=function(){this.x=this.y=0.0;};return Point;}();dragonBones.Point=Point;})(dragonBones||(dragonBones={}));(function(dragonBones){var Rectangle=function(){function Rectangle(x,y,width,height){if(x===void 0){x=0.0;}if(y===void 0){y=0.0;}if(width===void 0){width=0.0;}if(height===void 0){height=0.0;}this.x=x;this.y=y;this.width=width;this.height=height;}Rectangle.prototype.copyFrom=function(value){this.x=value.x;this.y=value.y;this.width=value.width;this.height=value.height;};Rectangle.prototype.clear=function(){this.x=this.y=0.0;this.width=this.height=0.0;};return Rectangle;}();dragonBones.Rectangle=Rectangle;})(dragonBones||(dragonBones={}));(function(dragonBones){var UserData=function(_super){__extends(UserData,_super);function UserData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.ints=[];_this.floats=[];_this.strings=[];return _this;}UserData.toString=function(){return "[class dragonBones.UserData]";};UserData.prototype._onClear=function(){this.ints.length=0;this.floats.length=0;this.strings.length=0;};UserData.prototype.addInt=function(value){this.ints.push(value);};UserData.prototype.addFloat=function(value){this.floats.push(value);};UserData.prototype.addString=function(value){this.strings.push(value);};UserData.prototype.getInt=function(index){if(index===void 0){index=0;}return index>=0&&index<this.ints.length?this.ints[index]:0;};UserData.prototype.getFloat=function(index){if(index===void 0){index=0;}return index>=0&&index<this.floats.length?this.floats[index]:0.0;};UserData.prototype.getString=function(index){if(index===void 0){index=0;}return index>=0&&index<this.strings.length?this.strings[index]:"";};return UserData;}(dragonBones.BaseObject);dragonBones.UserData=UserData;var ActionData=function(_super){__extends(ActionData,_super);function ActionData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.data=null;return _this;}ActionData.toString=function(){return "[class dragonBones.ActionData]";};ActionData.prototype._onClear=function(){if(this.data!==null){this.data.returnToPool();}this.type=0;this.name="";this.bone=null;this.slot=null;this.data=null;};return ActionData;}(dragonBones.BaseObject);dragonBones.ActionData=ActionData;})(dragonBones||(dragonBones={}));(function(dragonBones){var DragonBonesData=function(_super){__extends(DragonBonesData,_super);function DragonBonesData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.frameIndices=[];_this.cachedFrames=[];_this.armatureNames=[];_this.armatures={};_this.userData=null;return _this;}DragonBonesData.toString=function(){return "[class dragonBones.DragonBonesData]";};DragonBonesData.prototype._onClear=function(){for(var k in this.armatures){this.armatures[k].returnToPool();delete this.armatures[k];}if(this.userData!==null){this.userData.returnToPool();}this.autoSearch=false;this.frameRate=0;this.version="";this.name="";this.stage=null;this.frameIndices.length=0;this.cachedFrames.length=0;this.armatureNames.length=0;this.binary=null;this.intArray=null;this.floatArray=null;this.frameIntArray=null;this.frameFloatArray=null;this.frameArray=null;this.timelineArray=null;this.userData=null;};DragonBonesData.prototype.addArmature=function(value){if(value.name in this.armatures){console.warn("Same armature: "+value.name);return;}value.parent=this;this.armatures[value.name]=value;this.armatureNames.push(value.name);};DragonBonesData.prototype.getArmature=function(armatureName){return armatureName in this.armatures?this.armatures[armatureName]:null;};DragonBonesData.prototype.dispose=function(){console.warn("已废弃");this.returnToPool();};return DragonBonesData;}(dragonBones.BaseObject);dragonBones.DragonBonesData=DragonBonesData;})(dragonBones||(dragonBones={}));(function(dragonBones){var ArmatureData=function(_super){__extends(ArmatureData,_super);function ArmatureData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.aabb=new dragonBones.Rectangle();_this.animationNames=[];_this.sortedBones=[];_this.sortedSlots=[];_this.defaultActions=[];_this.actions=[];_this.bones={};_this.slots={};_this.constraints={};_this.skins={};_this.animations={};_this.canvas=null;_this.userData=null;return _this;}ArmatureData.toString=function(){return "[class dragonBones.ArmatureData]";};ArmatureData.prototype._onClear=function(){for(var _i=0,_a=this.defaultActions;_i<_a.length;_i++){var action=_a[_i];action.returnToPool();}for(var _b=0,_c=this.actions;_b<_c.length;_b++){var action=_c[_b];action.returnToPool();}for(var k in this.bones){this.bones[k].returnToPool();delete this.bones[k];}for(var k in this.slots){this.slots[k].returnToPool();delete this.slots[k];}for(var k in this.constraints){this.constraints[k].returnToPool();delete this.constraints[k];}for(var k in this.skins){this.skins[k].returnToPool();delete this.skins[k];}for(var k in this.animations){this.animations[k].returnToPool();delete this.animations[k];}if(this.canvas!==null){this.canvas.returnToPool();}if(this.userData!==null){this.userData.returnToPool();}this.type=0;this.frameRate=0;this.cacheFrameRate=0;this.scale=1.0;this.name="";this.aabb.clear();this.animationNames.length=0;this.sortedBones.length=0;this.sortedSlots.length=0;this.defaultActions.length=0;this.actions.length=0;this.defaultSkin=null;this.defaultAnimation=null;this.canvas=null;this.userData=null;this.parent=null;};ArmatureData.prototype.sortBones=function(){var total=this.sortedBones.length;if(total<=0){return;}var sortHelper=this.sortedBones.concat();var index=0;var count=0;this.sortedBones.length=0;while(count<total){var bone=sortHelper[index++];if(index>=total){index=0;}if(this.sortedBones.indexOf(bone)>=0){continue;}var flag=false;for(var k in this.constraints){var constraint=this.constraints[k];if(constraint.root===bone&&this.sortedBones.indexOf(constraint.target)<0){flag=true;break;}}if(flag){continue;}if(bone.parent!==null&&this.sortedBones.indexOf(bone.parent)<0){continue;}this.sortedBones.push(bone);count++;}};ArmatureData.prototype.cacheFrames=function(frameRate){if(this.cacheFrameRate>0){return;}this.cacheFrameRate=frameRate;for(var k in this.animations){this.animations[k].cacheFrames(this.cacheFrameRate);}};ArmatureData.prototype.setCacheFrame=function(globalTransformMatrix,transform){var dataArray=this.parent.cachedFrames;var arrayOffset=dataArray.length;dataArray.length+=10;dataArray[arrayOffset]=globalTransformMatrix.a;dataArray[arrayOffset+1]=globalTransformMatrix.b;dataArray[arrayOffset+2]=globalTransformMatrix.c;dataArray[arrayOffset+3]=globalTransformMatrix.d;dataArray[arrayOffset+4]=globalTransformMatrix.tx;dataArray[arrayOffset+5]=globalTransformMatrix.ty;dataArray[arrayOffset+6]=transform.rotation;dataArray[arrayOffset+7]=transform.skew;dataArray[arrayOffset+8]=transform.scaleX;dataArray[arrayOffset+9]=transform.scaleY;return arrayOffset;};ArmatureData.prototype.getCacheFrame=function(globalTransformMatrix,transform,arrayOffset){var dataArray=this.parent.cachedFrames;globalTransformMatrix.a=dataArray[arrayOffset];globalTransformMatrix.b=dataArray[arrayOffset+1];globalTransformMatrix.c=dataArray[arrayOffset+2];globalTransformMatrix.d=dataArray[arrayOffset+3];globalTransformMatrix.tx=dataArray[arrayOffset+4];globalTransformMatrix.ty=dataArray[arrayOffset+5];transform.rotation=dataArray[arrayOffset+6];transform.skew=dataArray[arrayOffset+7];transform.scaleX=dataArray[arrayOffset+8];transform.scaleY=dataArray[arrayOffset+9];transform.x=globalTransformMatrix.tx;transform.y=globalTransformMatrix.ty;};ArmatureData.prototype.addBone=function(value){if(value.name in this.bones){console.warn("Same bone: "+value.name);return;}this.bones[value.name]=value;this.sortedBones.push(value);};ArmatureData.prototype.addSlot=function(value){if(value.name in this.slots){console.warn("Same slot: "+value.name);return;}this.slots[value.name]=value;this.sortedSlots.push(value);};ArmatureData.prototype.addConstraint=function(value){if(value.name in this.constraints){console.warn("Same constraint: "+value.name);return;}this.constraints[value.name]=value;};ArmatureData.prototype.addSkin=function(value){if(value.name in this.skins){console.warn("Same skin: "+value.name);return;}value.parent=this;this.skins[value.name]=value;if(this.defaultSkin===null){this.defaultSkin=value;}if(value.name==="default"){this.defaultSkin=value;}};ArmatureData.prototype.addAnimation=function(value){if(value.name in this.animations){console.warn("Same animation: "+value.name);return;}value.parent=this;this.animations[value.name]=value;this.animationNames.push(value.name);if(this.defaultAnimation===null){this.defaultAnimation=value;}};ArmatureData.prototype.addAction=function(value,isDefault){if(isDefault){this.defaultActions.push(value);}else {this.actions.push(value);}};ArmatureData.prototype.getBone=function(boneName){return boneName in this.bones?this.bones[boneName]:null;};ArmatureData.prototype.getSlot=function(slotName){return slotName in this.slots?this.slots[slotName]:null;};ArmatureData.prototype.getConstraint=function(constraintName){return constraintName in this.constraints?this.constraints[constraintName]:null;};ArmatureData.prototype.getSkin=function(skinName){return skinName in this.skins?this.skins[skinName]:null;};ArmatureData.prototype.getMesh=function(skinName,slotName,meshName){var skin=this.getSkin(skinName);if(skin===null){return null;}return skin.getDisplay(slotName,meshName);};ArmatureData.prototype.getAnimation=function(animationName){return animationName in this.animations?this.animations[animationName]:null;};return ArmatureData;}(dragonBones.BaseObject);dragonBones.ArmatureData=ArmatureData;var BoneData=function(_super){__extends(BoneData,_super);function BoneData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.transform=new dragonBones.Transform();_this.userData=null;return _this;}BoneData.toString=function(){return "[class dragonBones.BoneData]";};BoneData.prototype._onClear=function(){if(this.userData!==null){this.userData.returnToPool();}this.inheritTranslation=false;this.inheritRotation=false;this.inheritScale=false;this.inheritReflection=false;this.type=0;this.length=0.0;this.name="";this.transform.identity();this.userData=null;this.parent=null;};return BoneData;}(dragonBones.BaseObject);dragonBones.BoneData=BoneData;var SurfaceData=function(_super){__extends(SurfaceData,_super);function SurfaceData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.vertices=[];return _this;}SurfaceData.toString=function(){return "[class dragonBones.SurfaceData]";};SurfaceData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.type=1;this.segmentX=0;this.segmentY=0;this.vertices.length=0;};return SurfaceData;}(BoneData);dragonBones.SurfaceData=SurfaceData;var SlotData=function(_super){__extends(SlotData,_super);function SlotData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.color=null;_this.userData=null;return _this;}SlotData.createColor=function(){return new dragonBones.ColorTransform();};SlotData.toString=function(){return "[class dragonBones.SlotData]";};SlotData.prototype._onClear=function(){if(this.userData!==null){this.userData.returnToPool();}this.blendMode=0;this.displayIndex=0;this.zOrder=0;this.name="";this.color=null;this.userData=null;this.parent=null;};SlotData.DEFAULT_COLOR=new dragonBones.ColorTransform();return SlotData;}(dragonBones.BaseObject);dragonBones.SlotData=SlotData;})(dragonBones||(dragonBones={}));(function(dragonBones){var ConstraintData=function(_super){__extends(ConstraintData,_super);function ConstraintData(){return _super!==null&&_super.apply(this,arguments)||this;}ConstraintData.prototype._onClear=function(){this.order=0;this.name="";this.type=0;this.target=null;this.root=null;this.bone=null;};return ConstraintData;}(dragonBones.BaseObject);dragonBones.ConstraintData=ConstraintData;var IKConstraintData=function(_super){__extends(IKConstraintData,_super);function IKConstraintData(){return _super!==null&&_super.apply(this,arguments)||this;}IKConstraintData.toString=function(){return "[class dragonBones.IKConstraintData]";};IKConstraintData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.scaleEnabled=false;this.bendPositive=false;this.weight=1.0;};return IKConstraintData;}(ConstraintData);dragonBones.IKConstraintData=IKConstraintData;var PathConstraintData=function(_super){__extends(PathConstraintData,_super);function PathConstraintData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.bones=[];return _this;}PathConstraintData.toString=function(){return "[class dragonBones.PathConstraintData]";};PathConstraintData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.pathSlot=null;this.pathDisplayData=null;this.bones.length=0;this.positionMode=0;this.spacingMode=1;this.rotateMode=1;this.position=0.0;this.spacing=0.0;this.rotateOffset=0.0;this.rotateMix=0.0;this.translateMix=0.0;};PathConstraintData.prototype.AddBone=function(value){this.bones.push(value);};return PathConstraintData;}(ConstraintData);dragonBones.PathConstraintData=PathConstraintData;})(dragonBones||(dragonBones={}));(function(dragonBones){var CanvasData=function(_super){__extends(CanvasData,_super);function CanvasData(){return _super!==null&&_super.apply(this,arguments)||this;}CanvasData.toString=function(){return "[class dragonBones.CanvasData]";};CanvasData.prototype._onClear=function(){this.hasBackground=false;this.color=0x000000;this.x=0;this.y=0;this.width=0;this.height=0;};return CanvasData;}(dragonBones.BaseObject);dragonBones.CanvasData=CanvasData;})(dragonBones||(dragonBones={}));(function(dragonBones){var SkinData=function(_super){__extends(SkinData,_super);function SkinData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.displays={};return _this;}SkinData.toString=function(){return "[class dragonBones.SkinData]";};SkinData.prototype._onClear=function(){for(var k in this.displays){var slotDisplays=this.displays[k];for(var _i=0,slotDisplays_1=slotDisplays;_i<slotDisplays_1.length;_i++){var display=slotDisplays_1[_i];if(display!==null){display.returnToPool();}}delete this.displays[k];}this.name="";this.parent=null;};SkinData.prototype.addDisplay=function(slotName,value){if(!(slotName in this.displays)){this.displays[slotName]=[];}if(value!==null){value.parent=this;}var slotDisplays=this.displays[slotName];slotDisplays.push(value);};SkinData.prototype.getDisplay=function(slotName,displayName){var slotDisplays=this.getDisplays(slotName);if(slotDisplays!==null){for(var _i=0,slotDisplays_2=slotDisplays;_i<slotDisplays_2.length;_i++){var display=slotDisplays_2[_i];if(display!==null&&display.name===displayName){return display;}}}return null;};SkinData.prototype.getDisplays=function(slotName){if(!(slotName in this.displays)){return null;}return this.displays[slotName];};return SkinData;}(dragonBones.BaseObject);dragonBones.SkinData=SkinData;})(dragonBones||(dragonBones={}));(function(dragonBones){var VerticesData=function(){function VerticesData(){this.weight=null;}VerticesData.prototype.clear=function(){if(!this.isShared&&this.weight!==null){this.weight.returnToPool();}this.isShared=false;this.inheritDeform=false;this.offset=0;this.data=null;this.weight=null;};VerticesData.prototype.shareFrom=function(value){this.isShared=true;this.offset=value.offset;this.weight=value.weight;};return VerticesData;}();dragonBones.VerticesData=VerticesData;var DisplayData=function(_super){__extends(DisplayData,_super);function DisplayData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.transform=new dragonBones.Transform();return _this;}DisplayData.prototype._onClear=function(){this.name="";this.path="";this.transform.identity();this.parent=null;};return DisplayData;}(dragonBones.BaseObject);dragonBones.DisplayData=DisplayData;var ImageDisplayData=function(_super){__extends(ImageDisplayData,_super);function ImageDisplayData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.pivot=new dragonBones.Point();return _this;}ImageDisplayData.toString=function(){return "[class dragonBones.ImageDisplayData]";};ImageDisplayData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.type=0;this.pivot.clear();this.texture=null;};return ImageDisplayData;}(DisplayData);dragonBones.ImageDisplayData=ImageDisplayData;var ArmatureDisplayData=function(_super){__extends(ArmatureDisplayData,_super);function ArmatureDisplayData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.actions=[];return _this;}ArmatureDisplayData.toString=function(){return "[class dragonBones.ArmatureDisplayData]";};ArmatureDisplayData.prototype._onClear=function(){_super.prototype._onClear.call(this);for(var _i=0,_a=this.actions;_i<_a.length;_i++){var action=_a[_i];action.returnToPool();}this.type=1;this.inheritAnimation=false;this.actions.length=0;this.armature=null;};ArmatureDisplayData.prototype.addAction=function(value){this.actions.push(value);};return ArmatureDisplayData;}(DisplayData);dragonBones.ArmatureDisplayData=ArmatureDisplayData;var MeshDisplayData=function(_super){__extends(MeshDisplayData,_super);function MeshDisplayData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.vertices=new VerticesData();return _this;}MeshDisplayData.toString=function(){return "[class dragonBones.MeshDisplayData]";};MeshDisplayData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.type=2;this.vertices.clear();this.texture=null;};return MeshDisplayData;}(DisplayData);dragonBones.MeshDisplayData=MeshDisplayData;var BoundingBoxDisplayData=function(_super){__extends(BoundingBoxDisplayData,_super);function BoundingBoxDisplayData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.boundingBox=null;return _this;}BoundingBoxDisplayData.toString=function(){return "[class dragonBones.BoundingBoxDisplayData]";};BoundingBoxDisplayData.prototype._onClear=function(){_super.prototype._onClear.call(this);if(this.boundingBox!==null){this.boundingBox.returnToPool();}this.type=3;this.boundingBox=null;};return BoundingBoxDisplayData;}(DisplayData);dragonBones.BoundingBoxDisplayData=BoundingBoxDisplayData;var PathDisplayData=function(_super){__extends(PathDisplayData,_super);function PathDisplayData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.vertices=new VerticesData();_this.curveLengths=[];return _this;}PathDisplayData.toString=function(){return "[class dragonBones.PathDisplayData]";};PathDisplayData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.type=4;this.closed=false;this.constantSpeed=false;this.vertices.clear();this.curveLengths.length=0;};return PathDisplayData;}(DisplayData);dragonBones.PathDisplayData=PathDisplayData;var WeightData=function(_super){__extends(WeightData,_super);function WeightData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.bones=[];return _this;}WeightData.toString=function(){return "[class dragonBones.WeightData]";};WeightData.prototype._onClear=function(){this.count=0;this.offset=0;this.bones.length=0;};WeightData.prototype.addBone=function(value){this.bones.push(value);};return WeightData;}(dragonBones.BaseObject);dragonBones.WeightData=WeightData;})(dragonBones||(dragonBones={}));(function(dragonBones){var BoundingBoxData=function(_super){__extends(BoundingBoxData,_super);function BoundingBoxData(){return _super!==null&&_super.apply(this,arguments)||this;}BoundingBoxData.prototype._onClear=function(){this.color=0x000000;this.width=0.0;this.height=0.0;};return BoundingBoxData;}(dragonBones.BaseObject);dragonBones.BoundingBoxData=BoundingBoxData;var RectangleBoundingBoxData=function(_super){__extends(RectangleBoundingBoxData,_super);function RectangleBoundingBoxData(){return _super!==null&&_super.apply(this,arguments)||this;}RectangleBoundingBoxData.toString=function(){return "[class dragonBones.RectangleBoundingBoxData]";};RectangleBoundingBoxData._computeOutCode=function(x,y,xMin,yMin,xMax,yMax){var code=0;if(x<xMin){code|=1;}else if(x>xMax){code|=2;}if(y<yMin){code|=4;}else if(y>yMax){code|=8;}return code;};RectangleBoundingBoxData.rectangleIntersectsSegment=function(xA,yA,xB,yB,xMin,yMin,xMax,yMax,intersectionPointA,intersectionPointB,normalRadians){if(intersectionPointA===void 0){intersectionPointA=null;}if(intersectionPointB===void 0){intersectionPointB=null;}if(normalRadians===void 0){normalRadians=null;}var inSideA=xA>xMin&&xA<xMax&&yA>yMin&&yA<yMax;var inSideB=xB>xMin&&xB<xMax&&yB>yMin&&yB<yMax;if(inSideA&&inSideB){return -1;}var intersectionCount=0;var outcode0=RectangleBoundingBoxData._computeOutCode(xA,yA,xMin,yMin,xMax,yMax);var outcode1=RectangleBoundingBoxData._computeOutCode(xB,yB,xMin,yMin,xMax,yMax);while(true){if((outcode0|outcode1)===0){intersectionCount=2;break;}else if((outcode0&outcode1)!==0){break;}var x=0.0;var y=0.0;var normalRadian=0.0;var outcodeOut=outcode0!==0?outcode0:outcode1;if((outcodeOut&4)!==0){x=xA+(xB-xA)*(yMin-yA)/(yB-yA);y=yMin;if(normalRadians!==null){normalRadian=-Math.PI*0.5;}}else if((outcodeOut&8)!==0){x=xA+(xB-xA)*(yMax-yA)/(yB-yA);y=yMax;if(normalRadians!==null){normalRadian=Math.PI*0.5;}}else if((outcodeOut&2)!==0){y=yA+(yB-yA)*(xMax-xA)/(xB-xA);x=xMax;if(normalRadians!==null){normalRadian=0;}}else if((outcodeOut&1)!==0){y=yA+(yB-yA)*(xMin-xA)/(xB-xA);x=xMin;if(normalRadians!==null){normalRadian=Math.PI;}}if(outcodeOut===outcode0){xA=x;yA=y;outcode0=RectangleBoundingBoxData._computeOutCode(xA,yA,xMin,yMin,xMax,yMax);if(normalRadians!==null){normalRadians.x=normalRadian;}}else {xB=x;yB=y;outcode1=RectangleBoundingBoxData._computeOutCode(xB,yB,xMin,yMin,xMax,yMax);if(normalRadians!==null){normalRadians.y=normalRadian;}}}if(intersectionCount){if(inSideA){intersectionCount=2;if(intersectionPointA!==null){intersectionPointA.x=xB;intersectionPointA.y=yB;}if(intersectionPointB!==null){intersectionPointB.x=xB;intersectionPointB.y=xB;}if(normalRadians!==null){normalRadians.x=normalRadians.y+Math.PI;}}else if(inSideB){intersectionCount=1;if(intersectionPointA!==null){intersectionPointA.x=xA;intersectionPointA.y=yA;}if(intersectionPointB!==null){intersectionPointB.x=xA;intersectionPointB.y=yA;}if(normalRadians!==null){normalRadians.y=normalRadians.x+Math.PI;}}else {intersectionCount=3;if(intersectionPointA!==null){intersectionPointA.x=xA;intersectionPointA.y=yA;}if(intersectionPointB!==null){intersectionPointB.x=xB;intersectionPointB.y=yB;}}}return intersectionCount;};RectangleBoundingBoxData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.type=0;};RectangleBoundingBoxData.prototype.containsPoint=function(pX,pY){var widthH=this.width*0.5;if(pX>=-widthH&&pX<=widthH){var heightH=this.height*0.5;if(pY>=-heightH&&pY<=heightH){return true;}}return false;};RectangleBoundingBoxData.prototype.intersectsSegment=function(xA,yA,xB,yB,intersectionPointA,intersectionPointB,normalRadians){if(intersectionPointA===void 0){intersectionPointA=null;}if(intersectionPointB===void 0){intersectionPointB=null;}if(normalRadians===void 0){normalRadians=null;}var widthH=this.width*0.5;var heightH=this.height*0.5;var intersectionCount=RectangleBoundingBoxData.rectangleIntersectsSegment(xA,yA,xB,yB,-widthH,-heightH,widthH,heightH,intersectionPointA,intersectionPointB,normalRadians);return intersectionCount;};return RectangleBoundingBoxData;}(BoundingBoxData);dragonBones.RectangleBoundingBoxData=RectangleBoundingBoxData;var EllipseBoundingBoxData=function(_super){__extends(EllipseBoundingBoxData,_super);function EllipseBoundingBoxData(){return _super!==null&&_super.apply(this,arguments)||this;}EllipseBoundingBoxData.toString=function(){return "[class dragonBones.EllipseData]";};EllipseBoundingBoxData.ellipseIntersectsSegment=function(xA,yA,xB,yB,xC,yC,widthH,heightH,intersectionPointA,intersectionPointB,normalRadians){if(intersectionPointA===void 0){intersectionPointA=null;}if(intersectionPointB===void 0){intersectionPointB=null;}if(normalRadians===void 0){normalRadians=null;}var d=widthH/heightH;var dd=d*d;yA*=d;yB*=d;var dX=xB-xA;var dY=yB-yA;var lAB=Math.sqrt(dX*dX+dY*dY);var xD=dX/lAB;var yD=dY/lAB;var a=(xC-xA)*xD+(yC-yA)*yD;var aa=a*a;var ee=xA*xA+yA*yA;var rr=widthH*widthH;var dR=rr-ee+aa;var intersectionCount=0;if(dR>=0.0){var dT=Math.sqrt(dR);var sA=a-dT;var sB=a+dT;var inSideA=sA<0.0?-1:sA<=lAB?0:1;var inSideB=sB<0.0?-1:sB<=lAB?0:1;var sideAB=inSideA*inSideB;if(sideAB<0){return -1;}else if(sideAB===0){if(inSideA===-1){intersectionCount=2;xB=xA+sB*xD;yB=(yA+sB*yD)/d;if(intersectionPointA!==null){intersectionPointA.x=xB;intersectionPointA.y=yB;}if(intersectionPointB!==null){intersectionPointB.x=xB;intersectionPointB.y=yB;}if(normalRadians!==null){normalRadians.x=Math.atan2(yB/rr*dd,xB/rr);normalRadians.y=normalRadians.x+Math.PI;}}else if(inSideB===1){intersectionCount=1;xA=xA+sA*xD;yA=(yA+sA*yD)/d;if(intersectionPointA!==null){intersectionPointA.x=xA;intersectionPointA.y=yA;}if(intersectionPointB!==null){intersectionPointB.x=xA;intersectionPointB.y=yA;}if(normalRadians!==null){normalRadians.x=Math.atan2(yA/rr*dd,xA/rr);normalRadians.y=normalRadians.x+Math.PI;}}else {intersectionCount=3;if(intersectionPointA!==null){intersectionPointA.x=xA+sA*xD;intersectionPointA.y=(yA+sA*yD)/d;if(normalRadians!==null){normalRadians.x=Math.atan2(intersectionPointA.y/rr*dd,intersectionPointA.x/rr);}}if(intersectionPointB!==null){intersectionPointB.x=xA+sB*xD;intersectionPointB.y=(yA+sB*yD)/d;if(normalRadians!==null){normalRadians.y=Math.atan2(intersectionPointB.y/rr*dd,intersectionPointB.x/rr);}}}}}return intersectionCount;};EllipseBoundingBoxData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.type=1;};EllipseBoundingBoxData.prototype.containsPoint=function(pX,pY){var widthH=this.width*0.5;if(pX>=-widthH&&pX<=widthH){var heightH=this.height*0.5;if(pY>=-heightH&&pY<=heightH){pY*=widthH/heightH;return Math.sqrt(pX*pX+pY*pY)<=widthH;}}return false;};EllipseBoundingBoxData.prototype.intersectsSegment=function(xA,yA,xB,yB,intersectionPointA,intersectionPointB,normalRadians){if(intersectionPointA===void 0){intersectionPointA=null;}if(intersectionPointB===void 0){intersectionPointB=null;}if(normalRadians===void 0){normalRadians=null;}var intersectionCount=EllipseBoundingBoxData.ellipseIntersectsSegment(xA,yA,xB,yB,0.0,0.0,this.width*0.5,this.height*0.5,intersectionPointA,intersectionPointB,normalRadians);return intersectionCount;};return EllipseBoundingBoxData;}(BoundingBoxData);dragonBones.EllipseBoundingBoxData=EllipseBoundingBoxData;var PolygonBoundingBoxData=function(_super){__extends(PolygonBoundingBoxData,_super);function PolygonBoundingBoxData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.vertices=[];return _this;}PolygonBoundingBoxData.toString=function(){return "[class dragonBones.PolygonBoundingBoxData]";};PolygonBoundingBoxData.polygonIntersectsSegment=function(xA,yA,xB,yB,vertices,intersectionPointA,intersectionPointB,normalRadians){if(intersectionPointA===void 0){intersectionPointA=null;}if(intersectionPointB===void 0){intersectionPointB=null;}if(normalRadians===void 0){normalRadians=null;}if(xA===xB){xA=xB+0.000001;}if(yA===yB){yA=yB+0.000001;}var count=vertices.length;var dXAB=xA-xB;var dYAB=yA-yB;var llAB=xA*yB-yA*xB;var intersectionCount=0;var xC=vertices[count-2];var yC=vertices[count-1];var dMin=0.0;var dMax=0.0;var xMin=0.0;var yMin=0.0;var xMax=0.0;var yMax=0.0;for(var i=0;i<count;i+=2){var xD=vertices[i];var yD=vertices[i+1];if(xC===xD){xC=xD+0.0001;}if(yC===yD){yC=yD+0.0001;}var dXCD=xC-xD;var dYCD=yC-yD;var llCD=xC*yD-yC*xD;var ll=dXAB*dYCD-dYAB*dXCD;var x=(llAB*dXCD-dXAB*llCD)/ll;if((x>=xC&&x<=xD||x>=xD&&x<=xC)&&(dXAB===0.0||x>=xA&&x<=xB||x>=xB&&x<=xA)){var y=(llAB*dYCD-dYAB*llCD)/ll;if((y>=yC&&y<=yD||y>=yD&&y<=yC)&&(dYAB===0.0||y>=yA&&y<=yB||y>=yB&&y<=yA)){if(intersectionPointB!==null){var d=x-xA;if(d<0.0){d=-d;}if(intersectionCount===0){dMin=d;dMax=d;xMin=x;yMin=y;xMax=x;yMax=y;if(normalRadians!==null){normalRadians.x=Math.atan2(yD-yC,xD-xC)-Math.PI*0.5;normalRadians.y=normalRadians.x;}}else {if(d<dMin){dMin=d;xMin=x;yMin=y;if(normalRadians!==null){normalRadians.x=Math.atan2(yD-yC,xD-xC)-Math.PI*0.5;}}if(d>dMax){dMax=d;xMax=x;yMax=y;if(normalRadians!==null){normalRadians.y=Math.atan2(yD-yC,xD-xC)-Math.PI*0.5;}}}intersectionCount++;}else {xMin=x;yMin=y;xMax=x;yMax=y;intersectionCount++;if(normalRadians!==null){normalRadians.x=Math.atan2(yD-yC,xD-xC)-Math.PI*0.5;normalRadians.y=normalRadians.x;}break;}}}xC=xD;yC=yD;}if(intersectionCount===1){if(intersectionPointA!==null){intersectionPointA.x=xMin;intersectionPointA.y=yMin;}if(intersectionPointB!==null){intersectionPointB.x=xMin;intersectionPointB.y=yMin;}if(normalRadians!==null){normalRadians.y=normalRadians.x+Math.PI;}}else if(intersectionCount>1){intersectionCount++;if(intersectionPointA!==null){intersectionPointA.x=xMin;intersectionPointA.y=yMin;}if(intersectionPointB!==null){intersectionPointB.x=xMax;intersectionPointB.y=yMax;}}return intersectionCount;};PolygonBoundingBoxData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.type=2;this.x=0.0;this.y=0.0;this.vertices.length=0;};PolygonBoundingBoxData.prototype.containsPoint=function(pX,pY){var isInSide=false;if(pX>=this.x&&pX<=this.width&&pY>=this.y&&pY<=this.height){for(var i=0,l=this.vertices.length,iP=l-2;i<l;i+=2){var yA=this.vertices[iP+1];var yB=this.vertices[i+1];if(yB<pY&&yA>=pY||yA<pY&&yB>=pY){var xA=this.vertices[iP];var xB=this.vertices[i];if((pY-yB)*(xA-xB)/(yA-yB)+xB<pX){isInSide=!isInSide;}}iP=i;}}return isInSide;};PolygonBoundingBoxData.prototype.intersectsSegment=function(xA,yA,xB,yB,intersectionPointA,intersectionPointB,normalRadians){if(intersectionPointA===void 0){intersectionPointA=null;}if(intersectionPointB===void 0){intersectionPointB=null;}if(normalRadians===void 0){normalRadians=null;}var intersectionCount=0;if(RectangleBoundingBoxData.rectangleIntersectsSegment(xA,yA,xB,yB,this.x,this.y,this.x+this.width,this.y+this.height,null,null,null)!==0){intersectionCount=PolygonBoundingBoxData.polygonIntersectsSegment(xA,yA,xB,yB,this.vertices,intersectionPointA,intersectionPointB,normalRadians);}return intersectionCount;};return PolygonBoundingBoxData;}(BoundingBoxData);dragonBones.PolygonBoundingBoxData=PolygonBoundingBoxData;})(dragonBones||(dragonBones={}));(function(dragonBones){var AnimationData=function(_super){__extends(AnimationData,_super);function AnimationData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.cachedFrames=[];_this.boneTimelines={};_this.surfaceTimelines={};_this.slotTimelines={};_this.constraintTimelines={};_this.animationTimelines={};_this.boneCachedFrameIndices={};_this.slotCachedFrameIndices={};_this.actionTimeline=null;_this.zOrderTimeline=null;return _this;}AnimationData.toString=function(){return "[class dragonBones.AnimationData]";};AnimationData.prototype._onClear=function(){for(var k in this.boneTimelines){for(var _i=0,_a=this.boneTimelines[k];_i<_a.length;_i++){var timeline=_a[_i];timeline.returnToPool();}delete this.boneTimelines[k];}for(var k in this.surfaceTimelines){for(var _b=0,_c=this.surfaceTimelines[k];_b<_c.length;_b++){var timeline=_c[_b];timeline.returnToPool();}delete this.surfaceTimelines[k];}for(var k in this.slotTimelines){for(var _d=0,_e=this.slotTimelines[k];_d<_e.length;_d++){var timeline=_e[_d];timeline.returnToPool();}delete this.slotTimelines[k];}for(var k in this.constraintTimelines){for(var _f=0,_g=this.constraintTimelines[k];_f<_g.length;_f++){var timeline=_g[_f];timeline.returnToPool();}delete this.constraintTimelines[k];}for(var k in this.animationTimelines){for(var _h=0,_j=this.animationTimelines[k];_h<_j.length;_h++){var timeline=_j[_h];timeline.returnToPool();}delete this.animationTimelines[k];}for(var k in this.boneCachedFrameIndices){delete this.boneCachedFrameIndices[k];}for(var k in this.slotCachedFrameIndices){delete this.slotCachedFrameIndices[k];}if(this.actionTimeline!==null){this.actionTimeline.returnToPool();}if(this.zOrderTimeline!==null){this.zOrderTimeline.returnToPool();}this.frameIntOffset=0;this.frameFloatOffset=0;this.frameOffset=0;this.frameCount=0;this.playTimes=0;this.duration=0.0;this.scale=1.0;this.fadeInTime=0.0;this.cacheFrameRate=0.0;this.name="";this.cachedFrames.length=0;this.actionTimeline=null;this.zOrderTimeline=null;this.parent=null;};AnimationData.prototype.cacheFrames=function(frameRate){if(this.cacheFrameRate>0.0){return;}this.cacheFrameRate=Math.max(Math.ceil(frameRate*this.scale),1.0);var cacheFrameCount=Math.ceil(this.cacheFrameRate*this.duration)+1;this.cachedFrames.length=cacheFrameCount;for(var i=0,l=this.cacheFrames.length;i<l;++i){this.cachedFrames[i]=false;}for(var _i=0,_a=this.parent.sortedBones;_i<_a.length;_i++){var bone=_a[_i];var indices=new Array(cacheFrameCount);for(var i=0,l=indices.length;i<l;++i){indices[i]=-1;}this.boneCachedFrameIndices[bone.name]=indices;}for(var _b=0,_c=this.parent.sortedSlots;_b<_c.length;_b++){var slot=_c[_b];var indices=new Array(cacheFrameCount);for(var i=0,l=indices.length;i<l;++i){indices[i]=-1;}this.slotCachedFrameIndices[slot.name]=indices;}};AnimationData.prototype.addBoneTimeline=function(bone,timeline){var timelines=bone.name in this.boneTimelines?this.boneTimelines[bone.name]:this.boneTimelines[bone.name]=[];if(timelines.indexOf(timeline)<0){timelines.push(timeline);}};AnimationData.prototype.addSurfaceTimeline=function(surface,timeline){var timelines=surface.name in this.surfaceTimelines?this.surfaceTimelines[surface.name]:this.surfaceTimelines[surface.name]=[];if(timelines.indexOf(timeline)<0){timelines.push(timeline);}};AnimationData.prototype.addSlotTimeline=function(slot,timeline){var timelines=slot.name in this.slotTimelines?this.slotTimelines[slot.name]:this.slotTimelines[slot.name]=[];if(timelines.indexOf(timeline)<0){timelines.push(timeline);}};AnimationData.prototype.addConstraintTimeline=function(constraint,timeline){var timelines=constraint.name in this.constraintTimelines?this.constraintTimelines[constraint.name]:this.constraintTimelines[constraint.name]=[];if(timelines.indexOf(timeline)<0){timelines.push(timeline);}};AnimationData.prototype.addAnimationTimeline=function(timelineName,timeline){var timelines=timelineName in this.animationTimelines?this.animationTimelines[timelineName]:this.animationTimelines[timelineName]=[];if(timelines.indexOf(timeline)<0){timelines.push(timeline);}};AnimationData.prototype.getBoneTimelines=function(timelineName){return timelineName in this.boneTimelines?this.boneTimelines[timelineName]:null;};AnimationData.prototype.getSurfaceTimelines=function(timelineName){return timelineName in this.surfaceTimelines?this.surfaceTimelines[timelineName]:null;};AnimationData.prototype.getSlotTimelines=function(timelineName){return timelineName in this.slotTimelines?this.slotTimelines[timelineName]:null;};AnimationData.prototype.getConstraintTimelines=function(timelineName){return timelineName in this.constraintTimelines?this.constraintTimelines[timelineName]:null;};AnimationData.prototype.getAnimationTimelines=function(timelineName){return timelineName in this.animationTimelines?this.animationTimelines[timelineName]:null;};AnimationData.prototype.getBoneCachedFrameIndices=function(boneName){return boneName in this.boneCachedFrameIndices?this.boneCachedFrameIndices[boneName]:null;};AnimationData.prototype.getSlotCachedFrameIndices=function(slotName){return slotName in this.slotCachedFrameIndices?this.slotCachedFrameIndices[slotName]:null;};return AnimationData;}(dragonBones.BaseObject);dragonBones.AnimationData=AnimationData;var TimelineData=function(_super){__extends(TimelineData,_super);function TimelineData(){return _super!==null&&_super.apply(this,arguments)||this;}TimelineData.toString=function(){return "[class dragonBones.TimelineData]";};TimelineData.prototype._onClear=function(){this.type=10;this.offset=0;this.frameIndicesOffset=-1;};return TimelineData;}(dragonBones.BaseObject);dragonBones.TimelineData=TimelineData;})(dragonBones||(dragonBones={}));(function(dragonBones){var AnimationConfig=function(_super){__extends(AnimationConfig,_super);function AnimationConfig(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.boneMask=[];return _this;}AnimationConfig.toString=function(){return "[class dragonBones.AnimationConfig]";};AnimationConfig.prototype._onClear=function(){this.pauseFadeOut=true;this.fadeOutMode=4;this.fadeOutTweenType=1;this.fadeOutTime=-1.0;this.actionEnabled=true;this.additiveBlending=false;this.displayControl=true;this.pauseFadeIn=true;this.resetToPose=true;this.fadeInTweenType=1;this.playTimes=-1;this.layer=0;this.position=0.0;this.duration=-1.0;this.timeScale=-100.0;this.weight=1.0;this.fadeInTime=-1.0;this.autoFadeOutTime=-1.0;this.name="";this.animation="";this.group="";this.boneMask.length=0;};AnimationConfig.prototype.clear=function(){this._onClear();};AnimationConfig.prototype.copyFrom=function(value){this.pauseFadeOut=value.pauseFadeOut;this.fadeOutMode=value.fadeOutMode;this.autoFadeOutTime=value.autoFadeOutTime;this.fadeOutTweenType=value.fadeOutTweenType;this.actionEnabled=value.actionEnabled;this.additiveBlending=value.additiveBlending;this.displayControl=value.displayControl;this.pauseFadeIn=value.pauseFadeIn;this.resetToPose=value.resetToPose;this.playTimes=value.playTimes;this.layer=value.layer;this.position=value.position;this.duration=value.duration;this.timeScale=value.timeScale;this.fadeInTime=value.fadeInTime;this.fadeOutTime=value.fadeOutTime;this.fadeInTweenType=value.fadeInTweenType;this.weight=value.weight;this.name=value.name;this.animation=value.animation;this.group=value.group;this.boneMask.length=value.boneMask.length;for(var i=0,l=this.boneMask.length;i<l;++i){this.boneMask[i]=value.boneMask[i];}};AnimationConfig.prototype.containsBoneMask=function(boneName){return this.boneMask.length===0||this.boneMask.indexOf(boneName)>=0;};AnimationConfig.prototype.addBoneMask=function(armature,boneName,recursive){if(recursive===void 0){recursive=true;}var currentBone=armature.getBone(boneName);if(currentBone===null){return;}if(this.boneMask.indexOf(boneName)<0){this.boneMask.push(boneName);}if(recursive){for(var _i=0,_a=armature.getBones();_i<_a.length;_i++){var bone=_a[_i];if(this.boneMask.indexOf(bone.name)<0&&currentBone.contains(bone)){this.boneMask.push(bone.name);}}}};AnimationConfig.prototype.removeBoneMask=function(armature,boneName,recursive){if(recursive===void 0){recursive=true;}var index=this.boneMask.indexOf(boneName);if(index>=0){this.boneMask.splice(index,1);}if(recursive){var currentBone=armature.getBone(boneName);if(currentBone!==null){if(this.boneMask.length>0){for(var _i=0,_a=armature.getBones();_i<_a.length;_i++){var bone=_a[_i];var index_1=this.boneMask.indexOf(bone.name);if(index_1>=0&&currentBone.contains(bone)){this.boneMask.splice(index_1,1);}}}else {for(var _b=0,_c=armature.getBones();_b<_c.length;_b++){var bone=_c[_b];if(bone===currentBone){continue;}if(!currentBone.contains(bone)){this.boneMask.push(bone.name);}}}}}};return AnimationConfig;}(dragonBones.BaseObject);dragonBones.AnimationConfig=AnimationConfig;})(dragonBones||(dragonBones={}));(function(dragonBones){var TextureAtlasData=function(_super){__extends(TextureAtlasData,_super);function TextureAtlasData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.textures={};return _this;}TextureAtlasData.prototype._onClear=function(){for(var k in this.textures){this.textures[k].returnToPool();delete this.textures[k];}this.autoSearch=false;this.width=0;this.height=0;this.scale=1.0;this.name="";this.imagePath="";};TextureAtlasData.prototype.copyFrom=function(value){this.autoSearch=value.autoSearch;this.scale=value.scale;this.width=value.width;this.height=value.height;this.name=value.name;this.imagePath=value.imagePath;for(var k in this.textures){this.textures[k].returnToPool();delete this.textures[k];}for(var k in value.textures){var texture=this.createTexture();texture.copyFrom(value.textures[k]);this.textures[k]=texture;}};TextureAtlasData.prototype.addTexture=function(value){if(value.name in this.textures){console.warn("Same texture: "+value.name);return;}value.parent=this;this.textures[value.name]=value;};TextureAtlasData.prototype.getTexture=function(textureName){return textureName in this.textures?this.textures[textureName]:null;};return TextureAtlasData;}(dragonBones.BaseObject);dragonBones.TextureAtlasData=TextureAtlasData;var TextureData=function(_super){__extends(TextureData,_super);function TextureData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.region=new dragonBones.Rectangle();_this.frame=null;return _this;}TextureData.createRectangle=function(){return new dragonBones.Rectangle();};TextureData.prototype._onClear=function(){this.rotated=false;this.name="";this.region.clear();this.parent=null;this.frame=null;};TextureData.prototype.copyFrom=function(value){this.rotated=value.rotated;this.name=value.name;this.region.copyFrom(value.region);this.parent=value.parent;if(this.frame===null&&value.frame!==null){this.frame=TextureData.createRectangle();}else if(this.frame!==null&&value.frame===null){this.frame=null;}if(this.frame!==null&&value.frame!==null){this.frame.copyFrom(value.frame);}};return TextureData;}(dragonBones.BaseObject);dragonBones.TextureData=TextureData;})(dragonBones||(dragonBones={}));(function(dragonBones){var DeformVertices=function(_super){__extends(DeformVertices,_super);function DeformVertices(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.vertices=[];_this.bones=[];return _this;}DeformVertices.toString=function(){return "[class dragonBones.DeformVertices]";};DeformVertices.prototype._onClear=function(){this.verticesDirty=false;this.vertices.length=0;this.bones.length=0;this.verticesData=null;};DeformVertices.prototype.init=function(verticesDataValue,armature){this.verticesData=verticesDataValue;if(this.verticesData!==null){var vertexCount=0;if(this.verticesData.weight!==null){vertexCount=this.verticesData.weight.count*2;}else {vertexCount=this.verticesData.data.intArray[this.verticesData.offset+0]*2;}this.verticesDirty=true;this.vertices.length=vertexCount;this.bones.length=0;for(var i=0,l=this.vertices.length;i<l;++i){this.vertices[i]=0.0;}if(this.verticesData.weight!==null){for(var i=0,l=this.verticesData.weight.bones.length;i<l;++i){var bone=armature.getBone(this.verticesData.weight.bones[i].name);this.bones.push(bone);}}}else {this.verticesDirty=false;this.vertices.length=0;this.bones.length=0;this.verticesData=null;}};DeformVertices.prototype.isBonesUpdate=function(){for(var _i=0,_a=this.bones;_i<_a.length;_i++){var bone=_a[_i];if(bone!==null&&bone._childrenTransformDirty){return true;}}return false;};return DeformVertices;}(dragonBones.BaseObject);dragonBones.DeformVertices=DeformVertices;})(dragonBones||(dragonBones={}));(function(dragonBones_1){var Armature=function(_super){__extends(Armature,_super);function Armature(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._bones=[];_this._slots=[];_this._constraints=[];_this._actions=[];_this._animation=null;_this._proxy=null;_this._replaceTextureAtlasData=null;_this._clock=null;return _this;}Armature.toString=function(){return "[class dragonBones.Armature]";};Armature._onSortSlots=function(a,b){return a._zOrder>b._zOrder?1:-1;};Armature.prototype._onClear=function(){if(this._clock!==null){this._clock.remove(this);}for(var _i=0,_a=this._bones;_i<_a.length;_i++){var bone=_a[_i];bone.returnToPool();}for(var _b=0,_c=this._slots;_b<_c.length;_b++){var slot=_c[_b];slot.returnToPool();}for(var _d=0,_e=this._constraints;_d<_e.length;_d++){var constraint=_e[_d];constraint.returnToPool();}for(var _f=0,_g=this._actions;_f<_g.length;_f++){var action=_g[_f];action.returnToPool();}if(this._animation!==null){this._animation.returnToPool();}if(this._proxy!==null){this._proxy.dbClear();}if(this._replaceTextureAtlasData!==null){this._replaceTextureAtlasData.returnToPool();}this.inheritAnimation=true;this.userData=null;this._lockUpdate=false;this._slotsDirty=true;this._zOrderDirty=false;this._flipX=false;this._flipY=false;this._cacheFrameIndex=-1;this._bones.length=0;this._slots.length=0;this._constraints.length=0;this._actions.length=0;this._armatureData=null;this._animation=null;this._proxy=null;this._display=null;this._replaceTextureAtlasData=null;this._replacedTexture=null;this._dragonBones=null;this._clock=null;this._parent=null;};Armature.prototype._sortZOrder=function(slotIndices,offset){var slotDatas=this._armatureData.sortedSlots;var isOriginal=slotIndices===null;if(this._zOrderDirty||!isOriginal){for(var i=0,l=slotDatas.length;i<l;++i){var slotIndex=isOriginal?i:slotIndices[offset+i];if(slotIndex<0||slotIndex>=l){continue;}var slotData=slotDatas[slotIndex];var slot=this.getSlot(slotData.name);if(slot!==null){slot._setZorder(i);}}this._slotsDirty=true;this._zOrderDirty=!isOriginal;}};Armature.prototype._addBone=function(value){if(this._bones.indexOf(value)<0){this._bones.push(value);}};Armature.prototype._addSlot=function(value){if(this._slots.indexOf(value)<0){this._slots.push(value);}};Armature.prototype._addConstraint=function(value){if(this._constraints.indexOf(value)<0){this._constraints.push(value);}};Armature.prototype._bufferAction=function(action,append){if(this._actions.indexOf(action)<0){if(append){this._actions.push(action);}else {this._actions.unshift(action);}}};Armature.prototype.dispose=function(){if(this._armatureData!==null){this._lockUpdate=true;this._dragonBones.bufferObject(this);}};Armature.prototype.init=function(armatureData,proxy,display,dragonBones){if(this._armatureData!==null){return;}this._armatureData=armatureData;this._animation=dragonBones_1.BaseObject.borrowObject(dragonBones_1.Animation);this._proxy=proxy;this._display=display;this._dragonBones=dragonBones;this._proxy.dbInit(this);this._animation.init(this);this._animation.animations=this._armatureData.animations;};Armature.prototype.advanceTime=function(passedTime){if(this._lockUpdate){return;}if(this._armatureData===null){console.warn("The armature has been disposed.");return;}else if(this._armatureData.parent===null){console.warn("The armature data has been disposed.\nPlease make sure dispose armature before call factory.clear().");return;}var prevCacheFrameIndex=this._cacheFrameIndex;this._animation.advanceTime(passedTime);if(this._slotsDirty){this._slotsDirty=false;this._slots.sort(Armature._onSortSlots);}if(this._cacheFrameIndex<0||this._cacheFrameIndex!==prevCacheFrameIndex){var i=0,l=0;for(i=0,l=this._bones.length;i<l;++i){this._bones[i].update(this._cacheFrameIndex);}for(i=0,l=this._slots.length;i<l;++i){this._slots[i].update(this._cacheFrameIndex);}}if(this._actions.length>0){this._lockUpdate=true;for(var _i=0,_a=this._actions;_i<_a.length;_i++){var action=_a[_i];var actionData=action.actionData;if(actionData!==null){if(actionData.type===0){if(action.slot!==null){var childArmature=action.slot.childArmature;if(childArmature!==null){childArmature.animation.fadeIn(actionData.name);}}else if(action.bone!==null){for(var _b=0,_c=this.getSlots();_b<_c.length;_b++){var slot=_c[_b];if(slot.parent===action.bone){var childArmature=slot.childArmature;if(childArmature!==null){childArmature.animation.fadeIn(actionData.name);}}}}else {this._animation.fadeIn(actionData.name);}}}action.returnToPool();}this._actions.length=0;this._lockUpdate=false;}this._proxy.dbUpdate();};Armature.prototype.invalidUpdate=function(boneName,updateSlot){if(boneName===void 0){boneName=null;}if(updateSlot===void 0){updateSlot=false;}if(boneName!==null&&boneName.length>0){var bone=this.getBone(boneName);if(bone!==null){bone.invalidUpdate();if(updateSlot){for(var _i=0,_a=this._slots;_i<_a.length;_i++){var slot=_a[_i];if(slot.parent===bone){slot.invalidUpdate();}}}}}else {for(var _b=0,_c=this._bones;_b<_c.length;_b++){var bone=_c[_b];bone.invalidUpdate();}if(updateSlot){for(var _d=0,_e=this._slots;_d<_e.length;_d++){var slot=_e[_d];slot.invalidUpdate();}}}};Armature.prototype.containsPoint=function(x,y){for(var _i=0,_a=this._slots;_i<_a.length;_i++){var slot=_a[_i];if(slot.containsPoint(x,y)){return slot;}}return null;};Armature.prototype.intersectsSegment=function(xA,yA,xB,yB,intersectionPointA,intersectionPointB,normalRadians){if(intersectionPointA===void 0){intersectionPointA=null;}if(intersectionPointB===void 0){intersectionPointB=null;}if(normalRadians===void 0){normalRadians=null;}var isV=xA===xB;var dMin=0.0;var dMax=0.0;var intXA=0.0;var intYA=0.0;var intXB=0.0;var intYB=0.0;var intAN=0.0;var intBN=0.0;var intSlotA=null;var intSlotB=null;for(var _i=0,_a=this._slots;_i<_a.length;_i++){var slot=_a[_i];var intersectionCount=slot.intersectsSegment(xA,yA,xB,yB,intersectionPointA,intersectionPointB,normalRadians);if(intersectionCount>0){if(intersectionPointA!==null||intersectionPointB!==null){if(intersectionPointA!==null){var d=isV?intersectionPointA.y-yA:intersectionPointA.x-xA;if(d<0.0){d=-d;}if(intSlotA===null||d<dMin){dMin=d;intXA=intersectionPointA.x;intYA=intersectionPointA.y;intSlotA=slot;if(normalRadians){intAN=normalRadians.x;}}}if(intersectionPointB!==null){var d=intersectionPointB.x-xA;if(d<0.0){d=-d;}if(intSlotB===null||d>dMax){dMax=d;intXB=intersectionPointB.x;intYB=intersectionPointB.y;intSlotB=slot;if(normalRadians!==null){intBN=normalRadians.y;}}}}else {intSlotA=slot;break;}}}if(intSlotA!==null&&intersectionPointA!==null){intersectionPointA.x=intXA;intersectionPointA.y=intYA;if(normalRadians!==null){normalRadians.x=intAN;}}if(intSlotB!==null&&intersectionPointB!==null){intersectionPointB.x=intXB;intersectionPointB.y=intYB;if(normalRadians!==null){normalRadians.y=intBN;}}return intSlotA;};Armature.prototype.getBone=function(name){for(var _i=0,_a=this._bones;_i<_a.length;_i++){var bone=_a[_i];if(bone.name===name){return bone;}}return null;};Armature.prototype.getBoneByDisplay=function(display){var slot=this.getSlotByDisplay(display);return slot!==null?slot.parent:null;};Armature.prototype.getSlot=function(name){for(var _i=0,_a=this._slots;_i<_a.length;_i++){var slot=_a[_i];if(slot.name===name){return slot;}}return null;};Armature.prototype.getSlotByDisplay=function(display){if(display!==null){for(var _i=0,_a=this._slots;_i<_a.length;_i++){var slot=_a[_i];if(slot.display===display){return slot;}}}return null;};Armature.prototype.getBones=function(){return this._bones;};Armature.prototype.getSlots=function(){return this._slots;};Object.defineProperty(Armature.prototype,"flipX",{get:function get(){return this._flipX;},set:function set(value){if(this._flipX===value){return;}this._flipX=value;this.invalidUpdate();},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"flipY",{get:function get(){return this._flipY;},set:function set(value){if(this._flipY===value){return;}this._flipY=value;this.invalidUpdate();},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"cacheFrameRate",{get:function get(){return this._armatureData.cacheFrameRate;},set:function set(value){if(this._armatureData.cacheFrameRate!==value){this._armatureData.cacheFrames(value);for(var _i=0,_a=this._slots;_i<_a.length;_i++){var slot=_a[_i];var childArmature=slot.childArmature;if(childArmature!==null){childArmature.cacheFrameRate=value;}}}},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"name",{get:function get(){return this._armatureData.name;},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"armatureData",{get:function get(){return this._armatureData;},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"animation",{get:function get(){return this._animation;},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"proxy",{get:function get(){return this._proxy;},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"eventDispatcher",{get:function get(){return this._proxy;},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"display",{get:function get(){return this._display;},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"replacedTexture",{get:function get(){return this._replacedTexture;},set:function set(value){if(this._replacedTexture===value){return;}if(this._replaceTextureAtlasData!==null){this._replaceTextureAtlasData.returnToPool();this._replaceTextureAtlasData=null;}this._replacedTexture=value;for(var _i=0,_a=this._slots;_i<_a.length;_i++){var slot=_a[_i];slot.invalidUpdate();slot.update(-1);}},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"clock",{get:function get(){return this._clock;},set:function set(value){if(this._clock===value){return;}if(this._clock!==null){this._clock.remove(this);}this._clock=value;if(this._clock){this._clock.add(this);}for(var _i=0,_a=this._slots;_i<_a.length;_i++){var slot=_a[_i];var childArmature=slot.childArmature;if(childArmature!==null){childArmature.clock=this._clock;}}},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"parent",{get:function get(){return this._parent;},enumerable:true,configurable:true});Armature.prototype.replaceTexture=function(texture){this.replacedTexture=texture;};Armature.prototype.hasEventListener=function(type){return this._proxy.hasDBEventListener(type);};Armature.prototype.addEventListener=function(type,listener,target){this._proxy.addDBEventListener(type,listener,target);};Armature.prototype.removeEventListener=function(type,listener,target){this._proxy.removeDBEventListener(type,listener,target);};Armature.prototype.enableAnimationCache=function(frameRate){console.warn("Deprecated.");this.cacheFrameRate=frameRate;};Armature.prototype.getDisplay=function(){return this._display;};return Armature;}(dragonBones_1.BaseObject);dragonBones_1.Armature=Armature;})(dragonBones||(dragonBones={}));(function(dragonBones){var TransformObject=function(_super){__extends(TransformObject,_super);function TransformObject(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.globalTransformMatrix=new dragonBones.Matrix();_this.global=new dragonBones.Transform();_this.offset=new dragonBones.Transform();return _this;}TransformObject.prototype._onClear=function(){this.globalTransformMatrix.identity();this.global.identity();this.offset.identity();this.origin=null;this.userData=null;this._globalDirty=false;this._armature=null;};TransformObject.prototype.updateGlobalTransform=function(){if(this._globalDirty){this._globalDirty=false;this.global.fromMatrix(this.globalTransformMatrix);}};Object.defineProperty(TransformObject.prototype,"armature",{get:function get(){return this._armature;},enumerable:true,configurable:true});TransformObject._helpMatrix=new dragonBones.Matrix();TransformObject._helpTransform=new dragonBones.Transform();TransformObject._helpPoint=new dragonBones.Point();return TransformObject;}(dragonBones.BaseObject);dragonBones.TransformObject=TransformObject;})(dragonBones||(dragonBones={}));(function(dragonBones){var Bone=function(_super){__extends(Bone,_super);function Bone(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.animationPose=new dragonBones.Transform();_this._blendState=new dragonBones.BlendState();return _this;}Bone.toString=function(){return "[class dragonBones.Bone]";};Bone.prototype._onClear=function(){_super.prototype._onClear.call(this);this.offsetMode=1;this.animationPose.identity();this._transformDirty=false;this._childrenTransformDirty=false;this._localDirty=true;this._hasConstraint=false;this._visible=true;this._cachedFrameIndex=-1;this._blendState.clear();this._boneData=null;this._parent=null;this._cachedFrameIndices=null;};Bone.prototype._updateGlobalTransformMatrix=function(isCache){var boneData=this._boneData;var global=this.global;var globalTransformMatrix=this.globalTransformMatrix;var origin=this.origin;var offset=this.offset;var animationPose=this.animationPose;var parent=this._parent;var flipX=this._armature.flipX;var flipY=this._armature.flipY===dragonBones.DragonBones.yDown;var inherit=parent!==null;var rotation=0.0;if(this.offsetMode===1){if(origin!==null){global.x=origin.x+offset.x+animationPose.x;global.scaleX=origin.scaleX*offset.scaleX*animationPose.scaleX;global.scaleY=origin.scaleY*offset.scaleY*animationPose.scaleY;if(dragonBones.DragonBones.yDown){global.y=origin.y+offset.y+animationPose.y;global.skew=origin.skew+offset.skew+animationPose.skew;global.rotation=origin.rotation+offset.rotation+animationPose.rotation;}else {global.y=origin.y-offset.y+animationPose.y;global.skew=origin.skew-offset.skew+animationPose.skew;global.rotation=origin.rotation-offset.rotation+animationPose.rotation;}}else {global.copyFrom(offset);if(!dragonBones.DragonBones.yDown){global.y=-global.y;global.skew=-global.skew;global.rotation=-global.rotation;}global.add(animationPose);}}else if(this.offsetMode===0){if(origin!==null){global.copyFrom(origin).add(animationPose);}else {global.copyFrom(animationPose);}}else {inherit=false;global.copyFrom(offset);if(!dragonBones.DragonBones.yDown){global.y=-global.y;global.skew=-global.skew;global.rotation=-global.rotation;}}if(inherit){var parentMatrix=parent._boneData.type===0?parent.globalTransformMatrix:parent._getGlobalTransformMatrix(global.x,global.y);if(boneData.inheritScale){if(!boneData.inheritRotation){parent.updateGlobalTransform();if(flipX&&flipY){rotation=global.rotation-(parent.global.rotation+Math.PI);}else if(flipX){rotation=global.rotation+parent.global.rotation+Math.PI;}else if(flipY){rotation=global.rotation+parent.global.rotation;}else {rotation=global.rotation-parent.global.rotation;}global.rotation=rotation;}global.toMatrix(globalTransformMatrix);globalTransformMatrix.concat(parentMatrix);if(boneData.inheritTranslation){global.x=globalTransformMatrix.tx;global.y=globalTransformMatrix.ty;}else {globalTransformMatrix.tx=global.x;globalTransformMatrix.ty=global.y;}if(isCache){global.fromMatrix(globalTransformMatrix);}else {this._globalDirty=true;}}else {if(boneData.inheritTranslation){var x=global.x;var y=global.y;global.x=parentMatrix.a*x+parentMatrix.c*y+parentMatrix.tx;global.y=parentMatrix.b*x+parentMatrix.d*y+parentMatrix.ty;}else {if(flipX){global.x=-global.x;}if(flipY){global.y=-global.y;}}if(boneData.inheritRotation){parent.updateGlobalTransform();if(parent.global.scaleX<0.0){rotation=global.rotation+parent.global.rotation+Math.PI;}else {rotation=global.rotation+parent.global.rotation;}if(parentMatrix.a*parentMatrix.d-parentMatrix.b*parentMatrix.c<0.0){rotation-=global.rotation*2.0;if(flipX!==flipY||boneData.inheritReflection){global.skew+=Math.PI;}if(!dragonBones.DragonBones.yDown){global.skew=-global.skew;}}global.rotation=rotation;}else if(flipX||flipY){if(flipX&&flipY){rotation=global.rotation+Math.PI;}else {if(flipX){rotation=Math.PI-global.rotation;}else {rotation=-global.rotation;}global.skew+=Math.PI;}global.rotation=rotation;}global.toMatrix(globalTransformMatrix);}}else {if(flipX||flipY){if(flipX){global.x=-global.x;}if(flipY){global.y=-global.y;}if(flipX&&flipY){rotation=global.rotation+Math.PI;}else {if(flipX){rotation=Math.PI-global.rotation;}else {rotation=-global.rotation;}global.skew+=Math.PI;}global.rotation=rotation;}global.toMatrix(globalTransformMatrix);}};Bone.prototype.init=function(boneData,armatureValue){if(this._boneData!==null){return;}this._boneData=boneData;this._armature=armatureValue;if(this._boneData.parent!==null){this._parent=this._armature.getBone(this._boneData.parent.name);}this._armature._addBone(this);this.origin=this._boneData.transform;};Bone.prototype.update=function(cacheFrameIndex){this._blendState.dirty=false;if(cacheFrameIndex>=0&&this._cachedFrameIndices!==null){var cachedFrameIndex=this._cachedFrameIndices[cacheFrameIndex];if(cachedFrameIndex>=0&&this._cachedFrameIndex===cachedFrameIndex){this._transformDirty=false;}else if(cachedFrameIndex>=0){this._transformDirty=true;this._cachedFrameIndex=cachedFrameIndex;}else {if(this._hasConstraint){for(var _i=0,_a=this._armature._constraints;_i<_a.length;_i++){var constraint=_a[_i];if(constraint._root===this){constraint.update();}}}if(this._transformDirty||this._parent!==null&&this._parent._childrenTransformDirty){this._transformDirty=true;this._cachedFrameIndex=-1;}else if(this._cachedFrameIndex>=0){this._transformDirty=false;this._cachedFrameIndices[cacheFrameIndex]=this._cachedFrameIndex;}else {this._transformDirty=true;this._cachedFrameIndex=-1;}}}else {if(this._hasConstraint){for(var _b=0,_c=this._armature._constraints;_b<_c.length;_b++){var constraint=_c[_b];if(constraint._root===this){constraint.update();}}}if(this._transformDirty||this._parent!==null&&this._parent._childrenTransformDirty){cacheFrameIndex=-1;this._transformDirty=true;this._cachedFrameIndex=-1;}}if(this._transformDirty){this._transformDirty=false;this._childrenTransformDirty=true;if(this._cachedFrameIndex<0){var isCache=cacheFrameIndex>=0;if(this._localDirty){this._updateGlobalTransformMatrix(isCache);}if(isCache&&this._cachedFrameIndices!==null){this._cachedFrameIndex=this._cachedFrameIndices[cacheFrameIndex]=this._armature._armatureData.setCacheFrame(this.globalTransformMatrix,this.global);}}else {this._armature._armatureData.getCacheFrame(this.globalTransformMatrix,this.global,this._cachedFrameIndex);}}else if(this._childrenTransformDirty){this._childrenTransformDirty=false;}this._localDirty=true;};Bone.prototype.updateByConstraint=function(){if(this._localDirty){this._localDirty=false;if(this._transformDirty||this._parent!==null&&this._parent._childrenTransformDirty){this._updateGlobalTransformMatrix(true);}this._transformDirty=true;}};Bone.prototype.invalidUpdate=function(){this._transformDirty=true;};Bone.prototype.contains=function(value){if(value===this){return false;}var ancestor=value;while(ancestor!==this&&ancestor!==null){ancestor=ancestor.parent;}return ancestor===this;};Object.defineProperty(Bone.prototype,"boneData",{get:function get(){return this._boneData;},enumerable:true,configurable:true});Object.defineProperty(Bone.prototype,"visible",{get:function get(){return this._visible;},set:function set(value){if(this._visible===value){return;}this._visible=value;for(var _i=0,_a=this._armature.getSlots();_i<_a.length;_i++){var slot=_a[_i];if(slot.parent===this){slot._updateVisible();}}},enumerable:true,configurable:true});Object.defineProperty(Bone.prototype,"name",{get:function get(){return this._boneData.name;},enumerable:true,configurable:true});Object.defineProperty(Bone.prototype,"parent",{get:function get(){return this._parent;},enumerable:true,configurable:true});Bone.prototype.getBones=function(){console.warn("Deprecated.");var bones=new Array();for(var _i=0,_a=this._armature.getBones();_i<_a.length;_i++){var bone=_a[_i];if(bone.parent===this){bones.push(bone);}}return bones;};Bone.prototype.getSlots=function(){console.warn("Deprecated.");var slots=new Array();for(var _i=0,_a=this._armature.getSlots();_i<_a.length;_i++){var slot=_a[_i];if(slot.parent===this){slots.push(slot);}}return slots;};Object.defineProperty(Bone.prototype,"slot",{get:function get(){console.warn("Deprecated.");for(var _i=0,_a=this._armature.getSlots();_i<_a.length;_i++){var slot=_a[_i];if(slot.parent===this){return slot;}}return null;},enumerable:true,configurable:true});return Bone;}(dragonBones.TransformObject);dragonBones.Bone=Bone;})(dragonBones||(dragonBones={}));(function(dragonBones){var Surface=function(_super){__extends(Surface,_super);function Surface(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._vertices=[];_this._deformVertices=[];_this._hullCache=[];_this._matrixCahce=[];return _this;}Surface.toString=function(){return "[class dragonBones.Surface]";};Surface.prototype._onClear=function(){_super.prototype._onClear.call(this);this._dX=0.0;this._dY=0.0;this._k=0.0;this._kX=0.0;this._kY=0.0;this._vertices.length=0;this._deformVertices.length=0;this._matrixCahce.length=0;this._hullCache.length=0;};Surface.prototype._getAffineTransform=function(x,y,lX,lY,aX,aY,bX,bY,cX,cY,transform,matrix,isDown){var dabX=bX-aX;var dabY=bY-aY;var dacX=cX-aX;var dacY=cY-aY;transform.rotation=Math.atan2(dabY,dabX);transform.skew=Math.atan2(dacY,dacX)-Math.PI*0.5-transform.rotation;if(isDown){transform.rotation+=Math.PI;}transform.scaleX=Math.sqrt(dabX*dabX+dabY*dabY)/lX;transform.scaleY=Math.sqrt(dacX*dacX+dacY*dacY)/lY;transform.toMatrix(matrix);transform.x=matrix.tx=aX-(matrix.a*x+matrix.c*y);transform.y=matrix.ty=aY-(matrix.b*x+matrix.d*y);};Surface.prototype._updateVertices=function(){var originalVertices=this._boneData.vertices;var vertices=this._vertices;var animationVertices=this._deformVertices;if(this._parent!==null){if(this._parent._boneData.type===1){for(var i=0,l=originalVertices.length;i<l;i+=2){var x=originalVertices[i]+animationVertices[i];var y=originalVertices[i+1]+animationVertices[i];var matrix=this._parent._getGlobalTransformMatrix(x,y);vertices[i]=matrix.a*x+matrix.c*y+matrix.tx;vertices[i+1]=matrix.b*x+matrix.d*y+matrix.ty;}}else {var parentMatrix=this._parent.globalTransformMatrix;for(var i=0,l=originalVertices.length;i<l;i+=2){var x=originalVertices[i]+animationVertices[i];var y=originalVertices[i+1]+animationVertices[i+1];vertices[i]=parentMatrix.a*x+parentMatrix.c*y+parentMatrix.tx;vertices[i+1]=parentMatrix.b*x+parentMatrix.d*y+parentMatrix.ty;}}}else {for(var i=0,l=originalVertices.length;i<l;i+=2){vertices[i]=originalVertices[i]+animationVertices[i];vertices[i+1]=originalVertices[i+1]+animationVertices[i+1];}}};Surface.prototype._updateGlobalTransformMatrix=function(isCache){var segmentXD=this._boneData.segmentX*2;var lastIndex=this._vertices.length-2;var lA=200.0;var raX=this._vertices[0];var raY=this._vertices[1];var rbX=this._vertices[segmentXD];var rbY=this._vertices[segmentXD+1];var rcX=this._vertices[lastIndex];var rcY=this._vertices[lastIndex+1];var rdX=this._vertices[lastIndex-segmentXD];var rdY=this._vertices[lastIndex-segmentXD+1];var dacX=raX+(rcX-raX)*0.5;var dacY=raY+(rcY-raY)*0.5;var dbdX=rbX+(rdX-rbX)*0.5;var dbdY=rbY+(rdY-rbY)*0.5;var aX=dacX+(dbdX-dacX)*0.5;var aY=dacY+(dbdY-dacY)*0.5;var bX=rbX+(rcX-rbX)*0.5;var bY=rbY+(rcY-rbY)*0.5;var cX=rdX+(rcX-rdX)*0.5;var cY=rdY+(rcY-rdY)*0.5;this._globalDirty=false;this._getAffineTransform(0.0,0.0,lA,lA,aX,aY,bX,bY,cX,cY,this.global,this.globalTransformMatrix,false);};Surface.prototype._getGlobalTransformMatrix=function(x,y){var lB=1000.0;if(x<-lB||lB<x||y<-lB||lB<y){return this.globalTransformMatrix;}var isDown=false;var lA=200.0;var surfaceData=this._boneData;var segmentX=surfaceData.segmentX;var segmentY=surfaceData.segmentY;var segmentXD=surfaceData.segmentX*2;var dX=this._dX;var dY=this._dY;var indexX=Math.floor((x+lA)/dX);var indexY=Math.floor((y+lA)/dY);var matrixIndex=0;var pX=indexX*dX-lA;var pY=indexY*dY-lA;var matrices=this._matrixCahce;var helpMatrix=Surface._helpMatrix;if(x<-lA){if(y<-lA||y>=lA){return this.globalTransformMatrix;}isDown=y>this._kX*(x+lA)+pY;matrixIndex=((segmentX*(segmentY+1)+segmentX*2+segmentY+indexY)*2+(isDown?1:0))*7;if(this._matrixCahce[matrixIndex]>0.0){helpMatrix.copyFromArray(matrices,matrixIndex+1);}else {var vertexIndex=indexY*(segmentXD+2);var ddX=this._hullCache[4];var ddY=this._hullCache[5];var sX=this._hullCache[2]-(segmentY-indexY)*ddX;var sY=this._hullCache[3]-(segmentY-indexY)*ddY;var vertices=this._vertices;if(isDown){this._getAffineTransform(-lA,pY+dY,lB-lA,dY,vertices[vertexIndex+segmentXD+2],vertices[vertexIndex+segmentXD+3],sX+ddX,sY+ddY,vertices[vertexIndex],vertices[vertexIndex+1],Surface._helpTransform,helpMatrix,true);}else {this._getAffineTransform(-lB,pY,lB-lA,dY,sX,sY,vertices[vertexIndex],vertices[vertexIndex+1],sX+ddX,sY+ddY,Surface._helpTransform,helpMatrix,false);}matrices[matrixIndex]=1.0;matrices[matrixIndex+1]=helpMatrix.a;matrices[matrixIndex+2]=helpMatrix.b;matrices[matrixIndex+3]=helpMatrix.c;matrices[matrixIndex+4]=helpMatrix.d;matrices[matrixIndex+5]=helpMatrix.tx;matrices[matrixIndex+6]=helpMatrix.ty;}}else if(x>=lA){if(y<-lA||y>=lA){return this.globalTransformMatrix;}isDown=y>this._kX*(x-lB)+pY;matrixIndex=((segmentX*(segmentY+1)+segmentX+indexY)*2+(isDown?1:0))*7;if(this._matrixCahce[matrixIndex]>0.0){helpMatrix.copyFromArray(matrices,matrixIndex+1);}else {var vertexIndex=(indexY+1)*(segmentXD+2)-2;var ddX=this._hullCache[4];var ddY=this._hullCache[5];var sX=this._hullCache[0]+indexY*ddX;var sY=this._hullCache[1]+indexY*ddY;var vertices=this._vertices;if(isDown){this._getAffineTransform(lB,pY+dY,lB-lA,dY,sX+ddX,sY+ddY,vertices[vertexIndex+segmentXD+2],vertices[vertexIndex+segmentXD+3],sX,sY,Surface._helpTransform,helpMatrix,true);}else {this._getAffineTransform(lA,pY,lB-lA,dY,vertices[vertexIndex],vertices[vertexIndex+1],sX,sY,vertices[vertexIndex+segmentXD+2],vertices[vertexIndex+segmentXD+3],Surface._helpTransform,helpMatrix,false);}matrices[matrixIndex]=1.0;matrices[matrixIndex+1]=helpMatrix.a;matrices[matrixIndex+2]=helpMatrix.b;matrices[matrixIndex+3]=helpMatrix.c;matrices[matrixIndex+4]=helpMatrix.d;matrices[matrixIndex+5]=helpMatrix.tx;matrices[matrixIndex+6]=helpMatrix.ty;}}else if(y<-lA){if(x<-lA||x>=lA){return this.globalTransformMatrix;}isDown=y>this._kY*(x-pX-dX)-lB;matrixIndex=(segmentX*(segmentY+1)+indexX*2+(isDown?1:0))*7;if(this._matrixCahce[matrixIndex]>0.0){helpMatrix.copyFromArray(matrices,matrixIndex+1);}else {var vertexIndex=indexX*2;var ddX=this._hullCache[10];var ddY=this._hullCache[11];var sX=this._hullCache[8]+indexX*ddX;var sY=this._hullCache[9]+indexX*ddY;var vertices=this._vertices;if(isDown){this._getAffineTransform(pX+dX,-lA,dX,lB-lA,vertices[vertexIndex+2],vertices[vertexIndex+3],vertices[vertexIndex],vertices[vertexIndex+1],sX+ddX,sY+ddY,Surface._helpTransform,helpMatrix,true);}else {this._getAffineTransform(pX,-lB,dX,lB-lA,sX,sY,sX+ddX,sY+ddY,vertices[vertexIndex],vertices[vertexIndex+1],Surface._helpTransform,helpMatrix,false);}matrices[matrixIndex]=1.0;matrices[matrixIndex+1]=helpMatrix.a;matrices[matrixIndex+2]=helpMatrix.b;matrices[matrixIndex+3]=helpMatrix.c;matrices[matrixIndex+4]=helpMatrix.d;matrices[matrixIndex+5]=helpMatrix.tx;matrices[matrixIndex+6]=helpMatrix.ty;}}else if(y>=lA){if(x<-lA||x>=lA){return this.globalTransformMatrix;}isDown=y>this._kY*(x-pX-dX)+lA;matrixIndex=((segmentX*(segmentY+1)+segmentX+segmentY+indexY)*2+(isDown?1:0))*7;if(this._matrixCahce[matrixIndex]>0.0){helpMatrix.copyFromArray(matrices,matrixIndex+1);}else {var vertexIndex=segmentY*(segmentXD+2)+indexX*2;var ddX=this._hullCache[10];var ddY=this._hullCache[11];var sX=this._hullCache[6]-(segmentX-indexX)*ddX;var sY=this._hullCache[7]-(segmentX-indexX)*ddY;var vertices=this._vertices;if(isDown){this._getAffineTransform(pX+dX,lB,dX,lB-lA,sX+ddX,sY+ddY,sX,sY,vertices[vertexIndex+2],vertices[vertexIndex+3],Surface._helpTransform,helpMatrix,true);}else {this._getAffineTransform(pX,lA,dX,lB-lA,vertices[vertexIndex],vertices[vertexIndex+1],vertices[vertexIndex+2],vertices[vertexIndex+3],sX,sY,Surface._helpTransform,helpMatrix,false);}matrices[matrixIndex]=1.0;matrices[matrixIndex+1]=helpMatrix.a;matrices[matrixIndex+2]=helpMatrix.b;matrices[matrixIndex+3]=helpMatrix.c;matrices[matrixIndex+4]=helpMatrix.d;matrices[matrixIndex+5]=helpMatrix.tx;matrices[matrixIndex+6]=helpMatrix.ty;}}else {isDown=y>this._k*(x-pX-dX)+pY;matrixIndex=((segmentX*indexY+indexX)*2+(isDown?1:0))*7;if(this._matrixCahce[matrixIndex]>0.0){helpMatrix.copyFromArray(matrices,matrixIndex+1);}else {var vertexIndex=indexX*2+indexY*(segmentXD+2);var vertices=this._vertices;if(isDown){this._getAffineTransform(pX+dX,pY+dY,dX,dY,vertices[vertexIndex+segmentXD+4],vertices[vertexIndex+segmentXD+5],vertices[vertexIndex+segmentXD+2],vertices[vertexIndex+segmentXD+3],vertices[vertexIndex+2],vertices[vertexIndex+3],Surface._helpTransform,helpMatrix,true);}else {this._getAffineTransform(pX,pY,dX,dY,vertices[vertexIndex],vertices[vertexIndex+1],vertices[vertexIndex+2],vertices[vertexIndex+3],vertices[vertexIndex+segmentXD+2],vertices[vertexIndex+segmentXD+3],Surface._helpTransform,helpMatrix,false);}matrices[matrixIndex]=1.0;matrices[matrixIndex+1]=helpMatrix.a;matrices[matrixIndex+2]=helpMatrix.b;matrices[matrixIndex+3]=helpMatrix.c;matrices[matrixIndex+4]=helpMatrix.d;matrices[matrixIndex+5]=helpMatrix.tx;matrices[matrixIndex+6]=helpMatrix.ty;}}return helpMatrix;};Surface.prototype.init=function(surfaceData,armatureValue){if(this._boneData!==null){return;}_super.prototype.init.call(this,surfaceData,armatureValue);var segmentX=surfaceData.segmentX;var segmentY=surfaceData.segmentY;var vertexCount=surfaceData.vertices.length;var lB=1000.0;var lA=200.0;this._dX=lA*2.0/segmentX;this._dY=lA*2.0/segmentY;this._k=-this._dY/this._dX;this._kX=-this._dY/(lB-lA);this._kY=-(lB-lA)/this._dX;this._vertices.length=vertexCount;this._deformVertices.length=vertexCount;this._matrixCahce.length=(segmentX*segmentY+segmentX*2+segmentY*2)*2*7;this._hullCache.length=10;for(var i=0;i<vertexCount;++i){this._deformVertices[i]=0.0;}};Surface.prototype.update=function(cacheFrameIndex){this._blendState.dirty=false;if(cacheFrameIndex>=0&&this._cachedFrameIndices!==null){var cachedFrameIndex=this._cachedFrameIndices[cacheFrameIndex];if(cachedFrameIndex>=0&&this._cachedFrameIndex===cachedFrameIndex){this._transformDirty=false;}else if(cachedFrameIndex>=0){this._transformDirty=true;this._cachedFrameIndex=cachedFrameIndex;}else {if(this._hasConstraint){for(var _i=0,_a=this._armature._constraints;_i<_a.length;_i++){var constraint=_a[_i];if(constraint._root===this){constraint.update();}}}if(this._transformDirty||this._parent!==null&&this._parent._childrenTransformDirty){this._transformDirty=true;this._cachedFrameIndex=-1;}else if(this._cachedFrameIndex>=0){this._transformDirty=false;this._cachedFrameIndices[cacheFrameIndex]=this._cachedFrameIndex;}else {this._transformDirty=true;this._cachedFrameIndex=-1;}}}else {if(this._hasConstraint){for(var _b=0,_c=this._armature._constraints;_b<_c.length;_b++){var constraint=_c[_b];if(constraint._root===this){constraint.update();}}}if(this._transformDirty||this._parent!==null&&this._parent._childrenTransformDirty){cacheFrameIndex=-1;this._transformDirty=true;this._cachedFrameIndex=-1;}}if(this._transformDirty){this._transformDirty=false;this._childrenTransformDirty=true;for(var i=0,l=this._matrixCahce.length;i<l;i+=7){this._matrixCahce[i]=-1.0;}this._updateVertices();if(this._cachedFrameIndex<0){var isCache=cacheFrameIndex>=0;if(this._localDirty){this._updateGlobalTransformMatrix(isCache);}if(isCache&&this._cachedFrameIndices!==null){this._cachedFrameIndex=this._cachedFrameIndices[cacheFrameIndex]=this._armature._armatureData.setCacheFrame(this.globalTransformMatrix,this.global);}}else {this._armature._armatureData.getCacheFrame(this.globalTransformMatrix,this.global,this._cachedFrameIndex);}var lB=1000.0;var lA=200.0;var ddX=2*this.global.x;var ddY=2*this.global.y;var helpPoint=Surface._helpPoint;this.globalTransformMatrix.transformPoint(lB,-lA,helpPoint);this._hullCache[0]=helpPoint.x;this._hullCache[1]=helpPoint.y;this._hullCache[2]=ddX-helpPoint.x;this._hullCache[3]=ddY-helpPoint.y;this.globalTransformMatrix.transformPoint(0.0,this._dY,helpPoint,true);this._hullCache[4]=helpPoint.x;this._hullCache[5]=helpPoint.y;this.globalTransformMatrix.transformPoint(lA,lB,helpPoint);this._hullCache[6]=helpPoint.x;this._hullCache[7]=helpPoint.y;this._hullCache[8]=ddX-helpPoint.x;this._hullCache[9]=ddY-helpPoint.y;this.globalTransformMatrix.transformPoint(this._dX,0.0,helpPoint,true);this._hullCache[10]=helpPoint.x;this._hullCache[11]=helpPoint.y;}else if(this._childrenTransformDirty){this._childrenTransformDirty=false;}this._localDirty=true;};return Surface;}(dragonBones.Bone);dragonBones.Surface=Surface;})(dragonBones||(dragonBones={}));(function(dragonBones){var Slot=function(_super){__extends(Slot,_super);function Slot(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._localMatrix=new dragonBones.Matrix();_this._colorTransform=new dragonBones.ColorTransform();_this._displayDatas=[];_this._displayList=[];_this._deformVertices=null;_this._rawDisplay=null;_this._meshDisplay=null;return _this;}Slot.prototype._onClear=function(){_super.prototype._onClear.call(this);var disposeDisplayList=[];for(var _i=0,_a=this._displayList;_i<_a.length;_i++){var eachDisplay=_a[_i];if(eachDisplay!==null&&eachDisplay!==this._rawDisplay&&eachDisplay!==this._meshDisplay&&disposeDisplayList.indexOf(eachDisplay)<0){disposeDisplayList.push(eachDisplay);}}for(var _b=0,disposeDisplayList_1=disposeDisplayList;_b<disposeDisplayList_1.length;_b++){var eachDisplay=disposeDisplayList_1[_b];if(eachDisplay instanceof dragonBones.Armature){eachDisplay.dispose();}else {this._disposeDisplay(eachDisplay,true);}}if(this._deformVertices!==null){this._deformVertices.returnToPool();}if(this._meshDisplay!==null&&this._meshDisplay!==this._rawDisplay){this._disposeDisplay(this._meshDisplay,false);}if(this._rawDisplay!==null){this._disposeDisplay(this._rawDisplay,false);}this.displayController=null;this._displayDirty=false;this._zOrderDirty=false;this._blendModeDirty=false;this._colorDirty=false;this._transformDirty=false;this._visible=true;this._blendMode=0;this._displayIndex=-1;this._animationDisplayIndex=-1;this._zOrder=0;this._cachedFrameIndex=-1;this._pivotX=0.0;this._pivotY=0.0;this._localMatrix.identity();this._colorTransform.identity();this._displayList.length=0;this._displayDatas.length=0;this._slotData=null;this._rawDisplayDatas=null;this._displayData=null;this._boundingBoxData=null;this._textureData=null;this._deformVertices=null;this._rawDisplay=null;this._meshDisplay=null;this._display=null;this._childArmature=null;this._parent=null;this._cachedFrameIndices=null;};Slot.prototype._getDefaultRawDisplayData=function(displayIndex){var defaultSkin=this._armature._armatureData.defaultSkin;if(defaultSkin!==null){var defaultRawDisplayDatas=defaultSkin.getDisplays(this._slotData.name);if(defaultRawDisplayDatas!==null){return displayIndex<defaultRawDisplayDatas.length?defaultRawDisplayDatas[displayIndex]:null;}}return null;};Slot.prototype._updateDisplayData=function(){var prevDisplayData=this._displayData;var prevVerticesData=this._deformVertices!==null?this._deformVertices.verticesData:null;var prevTextureData=this._textureData;var rawDisplayData=null;var currentVerticesData=null;this._displayData=null;this._boundingBoxData=null;this._textureData=null;if(this._displayIndex>=0){if(this._rawDisplayDatas!==null){rawDisplayData=this._displayIndex<this._rawDisplayDatas.length?this._rawDisplayDatas[this._displayIndex]:null;}if(rawDisplayData===null){rawDisplayData=this._getDefaultRawDisplayData(this._displayIndex);}if(this._displayIndex<this._displayDatas.length){this._displayData=this._displayDatas[this._displayIndex];}}if(this._displayData!==null){if(this._displayData.type===2){currentVerticesData=this._displayData.vertices;}else if(this._displayData.type===4){currentVerticesData=this._displayData.vertices;}else if(rawDisplayData!==null){if(rawDisplayData.type===2){currentVerticesData=rawDisplayData.vertices;}else if(rawDisplayData.type===4){currentVerticesData=rawDisplayData.vertices;}}if(this._displayData.type===3){this._boundingBoxData=this._displayData.boundingBox;}else if(rawDisplayData!==null){if(rawDisplayData.type===3){this._boundingBoxData=rawDisplayData.boundingBox;}}if(this._displayData.type===0){this._textureData=this._displayData.texture;}else if(this._displayData.type===2){this._textureData=this._displayData.texture;}}if(this._displayData!==prevDisplayData||currentVerticesData!==prevVerticesData||this._textureData!==prevTextureData){if(currentVerticesData===null&&this._textureData!==null){var imageDisplayData=this._displayData;var scale=this._textureData.parent.scale*this._armature._armatureData.scale;var frame=this._textureData.frame;this._pivotX=imageDisplayData.pivot.x;this._pivotY=imageDisplayData.pivot.y;var rect=frame!==null?frame:this._textureData.region;var width=rect.width;var height=rect.height;if(this._textureData.rotated&&frame===null){width=rect.height;height=rect.width;}this._pivotX*=width*scale;this._pivotY*=height*scale;if(frame!==null){this._pivotX+=frame.x*scale;this._pivotY+=frame.y*scale;}if(this._displayData!==null&&rawDisplayData!==null&&this._displayData!==rawDisplayData){rawDisplayData.transform.toMatrix(Slot._helpMatrix);Slot._helpMatrix.invert();Slot._helpMatrix.transformPoint(0.0,0.0,Slot._helpPoint);this._pivotX-=Slot._helpPoint.x;this._pivotY-=Slot._helpPoint.y;this._displayData.transform.toMatrix(Slot._helpMatrix);Slot._helpMatrix.invert();Slot._helpMatrix.transformPoint(0.0,0.0,Slot._helpPoint);this._pivotX+=Slot._helpPoint.x;this._pivotY+=Slot._helpPoint.y;}if(!dragonBones.DragonBones.yDown){this._pivotY=(this._textureData.rotated?this._textureData.region.width:this._textureData.region.height)*scale-this._pivotY;}}else {this._pivotX=0.0;this._pivotY=0.0;}if(rawDisplayData!==null){this.origin=rawDisplayData.transform;}else if(this._displayData!==null){this.origin=this._displayData.transform;}else {this.origin=null;}if(currentVerticesData!==prevVerticesData){if(this._deformVertices===null){this._deformVertices=dragonBones.BaseObject.borrowObject(dragonBones.DeformVertices);}this._deformVertices.init(currentVerticesData,this._armature);}else if(this._deformVertices!==null&&this._textureData!==prevTextureData){this._deformVertices.verticesDirty=true;}this._displayDirty=true;this._transformDirty=true;}};Slot.prototype._updateDisplay=function(){var prevDisplay=this._display!==null?this._display:this._rawDisplay;var prevChildArmature=this._childArmature;if(this._displayIndex>=0&&this._displayIndex<this._displayList.length){this._display=this._displayList[this._displayIndex];if(this._display!==null&&this._display instanceof dragonBones.Armature){this._childArmature=this._display;this._display=this._childArmature.display;}else {this._childArmature=null;}}else {this._display=null;this._childArmature=null;}var currentDisplay=this._display!==null?this._display:this._rawDisplay;if(currentDisplay!==prevDisplay){this._onUpdateDisplay();this._replaceDisplay(prevDisplay);this._transformDirty=true;this._visibleDirty=true;this._blendModeDirty=true;this._colorDirty=true;}if(currentDisplay===this._rawDisplay||currentDisplay===this._meshDisplay){this._updateFrame();}if(this._childArmature!==prevChildArmature){if(prevChildArmature!==null){prevChildArmature._parent=null;prevChildArmature.clock=null;if(prevChildArmature.inheritAnimation){prevChildArmature.animation.reset();}}if(this._childArmature!==null){this._childArmature._parent=this;this._childArmature.clock=this._armature.clock;if(this._childArmature.inheritAnimation){if(this._childArmature.cacheFrameRate===0){var cacheFrameRate=this._armature.cacheFrameRate;if(cacheFrameRate!==0){this._childArmature.cacheFrameRate=cacheFrameRate;}}var actions=null;if(this._displayData!==null&&this._displayData.type===1){actions=this._displayData.actions;}else if(this._displayIndex>=0&&this._rawDisplayDatas!==null){var rawDisplayData=this._displayIndex<this._rawDisplayDatas.length?this._rawDisplayDatas[this._displayIndex]:null;if(rawDisplayData===null){rawDisplayData=this._getDefaultRawDisplayData(this._displayIndex);}if(rawDisplayData!==null&&rawDisplayData.type===1){actions=rawDisplayData.actions;}}if(actions!==null&&actions.length>0){for(var _i=0,actions_1=actions;_i<actions_1.length;_i++){var action=actions_1[_i];var eventObject=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);dragonBones.EventObject.actionDataToInstance(action,eventObject,this._armature);eventObject.slot=this;this._armature._bufferAction(eventObject,false);}}else {this._childArmature.animation.play();}}}}};Slot.prototype._updateGlobalTransformMatrix=function(isCache){var parentMatrix=this._parent._boneData.type===0?this._parent.globalTransformMatrix:this._parent._getGlobalTransformMatrix(this.global.x,this.global.y);this.globalTransformMatrix.copyFrom(this._localMatrix);this.globalTransformMatrix.concat(parentMatrix);if(isCache){this.global.fromMatrix(this.globalTransformMatrix);}else {this._globalDirty=true;}};Slot.prototype._setDisplayIndex=function(value,isAnimation){if(isAnimation===void 0){isAnimation=false;}if(isAnimation){if(this._animationDisplayIndex===value){return false;}this._animationDisplayIndex=value;}if(this._displayIndex===value){return false;}this._displayIndex=value;this._displayDirty=true;this._updateDisplayData();return this._displayDirty;};Slot.prototype._setZorder=function(value){if(this._zOrder===value);this._zOrder=value;this._zOrderDirty=true;return this._zOrderDirty;};Slot.prototype._setColor=function(value){this._colorTransform.copyFrom(value);this._colorDirty=true;return this._colorDirty;};Slot.prototype._setDisplayList=function(value){if(value!==null&&value.length>0){if(this._displayList.length!==value.length){this._displayList.length=value.length;}for(var i=0,l=value.length;i<l;++i){var eachDisplay=value[i];if(eachDisplay!==null&&eachDisplay!==this._rawDisplay&&eachDisplay!==this._meshDisplay&&!(eachDisplay instanceof dragonBones.Armature)&&this._displayList.indexOf(eachDisplay)<0){this._initDisplay(eachDisplay,true);}this._displayList[i]=eachDisplay;}}else if(this._displayList.length>0){this._displayList.length=0;}if(this._displayIndex>=0&&this._displayIndex<this._displayList.length){this._displayDirty=this._display!==this._displayList[this._displayIndex];}else {this._displayDirty=this._display!==null;}this._updateDisplayData();return this._displayDirty;};Slot.prototype.init=function(slotData,armatureValue,rawDisplay,meshDisplay){if(this._slotData!==null){return;}this._slotData=slotData;this._isFromCache=false;this._visibleDirty=true;this._blendModeDirty=true;this._colorDirty=true;this._blendMode=this._slotData.blendMode;this._zOrder=this._slotData.zOrder;this._colorTransform.copyFrom(this._slotData.color);this._rawDisplay=rawDisplay;this._meshDisplay=meshDisplay;this._armature=armatureValue;var slotParent=this._armature.getBone(this._slotData.parent.name);if(slotParent!==null){this._parent=slotParent;}this._armature._addSlot(this);this._initDisplay(this._rawDisplay,false);if(this._rawDisplay!==this._meshDisplay){this._initDisplay(this._meshDisplay,false);}this._onUpdateDisplay();this._addDisplay();};Slot.prototype.update=function(cacheFrameIndex){this._isFromCache=false;if(this._displayDirty){this._displayDirty=false;this._updateDisplay();if(this._transformDirty){if(this.origin!==null){this.global.copyFrom(this.origin).add(this.offset).toMatrix(this._localMatrix);}else {this.global.copyFrom(this.offset).toMatrix(this._localMatrix);}}}if(this._zOrderDirty){this._zOrderDirty=false;this._updateZOrder();}if(cacheFrameIndex>=0&&this._cachedFrameIndices!==null){var cachedFrameIndex=this._cachedFrameIndices[cacheFrameIndex];if(cachedFrameIndex>=0&&this._cachedFrameIndex===cachedFrameIndex){this._transformDirty=false;}else if(cachedFrameIndex>=0){this._transformDirty=true;this._cachedFrameIndex=cachedFrameIndex;}else if(this._transformDirty||this._parent._childrenTransformDirty){this._transformDirty=true;this._cachedFrameIndex=-1;}else if(this._cachedFrameIndex>=0){this._transformDirty=false;this._cachedFrameIndices[cacheFrameIndex]=this._cachedFrameIndex;}else {this._transformDirty=true;this._cachedFrameIndex=-1;}}else if(this._transformDirty||this._parent._childrenTransformDirty){cacheFrameIndex=-1;this._transformDirty=true;this._cachedFrameIndex=-1;}if(this._display===null){return;}if(this._visibleDirty){this._visibleDirty=false;this._updateVisible();}if(this._blendModeDirty){this._blendModeDirty=false;this._updateBlendMode();}if(this._colorDirty){this._colorDirty=false;this._updateColor();}if(this._deformVertices!==null&&this._deformVertices.verticesData!==null&&this._display===this._meshDisplay){var isSkinned=this._deformVertices.verticesData.weight!==null;var isSurface=this._parent._boneData.type!==0;if(this._deformVertices.verticesDirty||isSkinned&&this._deformVertices.isBonesUpdate()||isSurface&&this._parent._childrenTransformDirty){this._deformVertices.verticesDirty=false;this._updateMesh();}if(isSkinned||isSurface){return;}}if(this._transformDirty){this._transformDirty=false;if(this._cachedFrameIndex<0){var isCache=cacheFrameIndex>=0;this._updateGlobalTransformMatrix(isCache);if(isCache&&this._cachedFrameIndices!==null){this._cachedFrameIndex=this._cachedFrameIndices[cacheFrameIndex]=this._armature._armatureData.setCacheFrame(this.globalTransformMatrix,this.global);}}else {this._isFromCache=true;this._armature._armatureData.getCacheFrame(this.globalTransformMatrix,this.global,this._cachedFrameIndex);}this._updateTransform();}};Slot.prototype.updateTransformAndMatrix=function(){if(this._transformDirty){this._transformDirty=false;this._updateGlobalTransformMatrix(false);}};Slot.prototype.replaceDisplayData=function(value,displayIndex){if(displayIndex===void 0){displayIndex=-1;}if(displayIndex<0){if(this._displayIndex<0){displayIndex=0;}else {displayIndex=this._displayIndex;}}if(this._displayDatas.length<=displayIndex){this._displayDatas.length=displayIndex+1;for(var i=0,l=this._displayDatas.length;i<l;++i){if(!this._displayDatas[i]){this._displayDatas[i]=null;}}}this._displayDatas[displayIndex]=value;};Slot.prototype.containsPoint=function(x,y){if(this._boundingBoxData===null){return false;}this.updateTransformAndMatrix();Slot._helpMatrix.copyFrom(this.globalTransformMatrix);Slot._helpMatrix.invert();Slot._helpMatrix.transformPoint(x,y,Slot._helpPoint);return this._boundingBoxData.containsPoint(Slot._helpPoint.x,Slot._helpPoint.y);};Slot.prototype.intersectsSegment=function(xA,yA,xB,yB,intersectionPointA,intersectionPointB,normalRadians){if(intersectionPointA===void 0){intersectionPointA=null;}if(intersectionPointB===void 0){intersectionPointB=null;}if(normalRadians===void 0){normalRadians=null;}if(this._boundingBoxData===null){return 0;}this.updateTransformAndMatrix();Slot._helpMatrix.copyFrom(this.globalTransformMatrix);Slot._helpMatrix.invert();Slot._helpMatrix.transformPoint(xA,yA,Slot._helpPoint);xA=Slot._helpPoint.x;yA=Slot._helpPoint.y;Slot._helpMatrix.transformPoint(xB,yB,Slot._helpPoint);xB=Slot._helpPoint.x;yB=Slot._helpPoint.y;var intersectionCount=this._boundingBoxData.intersectsSegment(xA,yA,xB,yB,intersectionPointA,intersectionPointB,normalRadians);if(intersectionCount>0){if(intersectionCount===1||intersectionCount===2){if(intersectionPointA!==null){this.globalTransformMatrix.transformPoint(intersectionPointA.x,intersectionPointA.y,intersectionPointA);if(intersectionPointB!==null){intersectionPointB.x=intersectionPointA.x;intersectionPointB.y=intersectionPointA.y;}}else if(intersectionPointB!==null){this.globalTransformMatrix.transformPoint(intersectionPointB.x,intersectionPointB.y,intersectionPointB);}}else {if(intersectionPointA!==null){this.globalTransformMatrix.transformPoint(intersectionPointA.x,intersectionPointA.y,intersectionPointA);}if(intersectionPointB!==null){this.globalTransformMatrix.transformPoint(intersectionPointB.x,intersectionPointB.y,intersectionPointB);}}if(normalRadians!==null){this.globalTransformMatrix.transformPoint(Math.cos(normalRadians.x),Math.sin(normalRadians.x),Slot._helpPoint,true);normalRadians.x=Math.atan2(Slot._helpPoint.y,Slot._helpPoint.x);this.globalTransformMatrix.transformPoint(Math.cos(normalRadians.y),Math.sin(normalRadians.y),Slot._helpPoint,true);normalRadians.y=Math.atan2(Slot._helpPoint.y,Slot._helpPoint.x);}}return intersectionCount;};Slot.prototype.invalidUpdate=function(){this._displayDirty=true;this._transformDirty=true;};Object.defineProperty(Slot.prototype,"visible",{get:function get(){return this._visible;},set:function set(value){if(this._visible===value){return;}this._visible=value;this._updateVisible();},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"displayIndex",{get:function get(){return this._displayIndex;},set:function set(value){if(this._setDisplayIndex(value)){this.update(-1);}},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"name",{get:function get(){return this._slotData.name;},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"displayList",{get:function get(){return this._displayList.concat();},set:function set(value){var backupDisplayList=this._displayList.concat();var disposeDisplayList=new Array();if(this._setDisplayList(value)){this.update(-1);}for(var _i=0,backupDisplayList_1=backupDisplayList;_i<backupDisplayList_1.length;_i++){var eachDisplay=backupDisplayList_1[_i];if(eachDisplay!==null&&eachDisplay!==this._rawDisplay&&eachDisplay!==this._meshDisplay&&this._displayList.indexOf(eachDisplay)<0&&disposeDisplayList.indexOf(eachDisplay)<0){disposeDisplayList.push(eachDisplay);}}for(var _a=0,disposeDisplayList_2=disposeDisplayList;_a<disposeDisplayList_2.length;_a++){var eachDisplay=disposeDisplayList_2[_a];if(eachDisplay instanceof dragonBones.Armature);else {this._disposeDisplay(eachDisplay,true);}}},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"slotData",{get:function get(){return this._slotData;},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"rawDisplayDatas",{get:function get(){return this._rawDisplayDatas;},set:function set(value){if(this._rawDisplayDatas===value){return;}this._displayDirty=true;this._rawDisplayDatas=value;if(this._rawDisplayDatas!==null){this._displayDatas.length=this._rawDisplayDatas.length;for(var i=0,l=this._displayDatas.length;i<l;++i){var rawDisplayData=this._rawDisplayDatas[i];if(rawDisplayData===null){rawDisplayData=this._getDefaultRawDisplayData(i);}this._displayDatas[i]=rawDisplayData;}}else {this._displayDatas.length=0;}},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"displayData",{get:function get(){return this._displayData;},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"boundingBoxData",{get:function get(){return this._boundingBoxData;},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"rawDisplay",{get:function get(){return this._rawDisplay;},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"meshDisplay",{get:function get(){return this._meshDisplay;},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"display",{get:function get(){return this._display;},set:function set(value){if(this._display===value){return;}var displayListLength=this._displayList.length;if(this._displayIndex<0&&displayListLength===0){this._displayIndex=0;}if(this._displayIndex<0){return;}else {var replaceDisplayList=this.displayList;if(displayListLength<=this._displayIndex){replaceDisplayList.length=this._displayIndex+1;}replaceDisplayList[this._displayIndex]=value;this.displayList=replaceDisplayList;}},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"childArmature",{get:function get(){return this._childArmature;},set:function set(value){if(this._childArmature===value){return;}this.display=value;},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"parent",{get:function get(){return this._parent;},enumerable:true,configurable:true});Slot.prototype.getDisplay=function(){return this._display;};Slot.prototype.setDisplay=function(value){this.display=value;};return Slot;}(dragonBones.TransformObject);dragonBones.Slot=Slot;})(dragonBones||(dragonBones={}));(function(dragonBones){var Constraint=function(_super){__extends(Constraint,_super);function Constraint(){return _super!==null&&_super.apply(this,arguments)||this;}Constraint.prototype._onClear=function(){this._armature=null;this._target=null;this._root=null;this._bone=null;};Object.defineProperty(Constraint.prototype,"name",{get:function get(){return this._constraintData.name;},enumerable:true,configurable:true});Constraint._helpMatrix=new dragonBones.Matrix();Constraint._helpTransform=new dragonBones.Transform();Constraint._helpPoint=new dragonBones.Point();return Constraint;}(dragonBones.BaseObject);dragonBones.Constraint=Constraint;var IKConstraint=function(_super){__extends(IKConstraint,_super);function IKConstraint(){return _super!==null&&_super.apply(this,arguments)||this;}IKConstraint.toString=function(){return "[class dragonBones.IKConstraint]";};IKConstraint.prototype._onClear=function(){_super.prototype._onClear.call(this);this._scaleEnabled=false;this._bendPositive=false;this._weight=1.0;this._constraintData=null;};IKConstraint.prototype._computeA=function(){var ikGlobal=this._target.global;var global=this._root.global;var globalTransformMatrix=this._root.globalTransformMatrix;var radian=Math.atan2(ikGlobal.y-global.y,ikGlobal.x-global.x);if(global.scaleX<0.0){radian+=Math.PI;}global.rotation+=dragonBones.Transform.normalizeRadian(radian-global.rotation)*this._weight;global.toMatrix(globalTransformMatrix);};IKConstraint.prototype._computeB=function(){var boneLength=this._bone._boneData.length;var parent=this._root;var ikGlobal=this._target.global;var parentGlobal=parent.global;var global=this._bone.global;var globalTransformMatrix=this._bone.globalTransformMatrix;var x=globalTransformMatrix.a*boneLength;var y=globalTransformMatrix.b*boneLength;var lLL=x*x+y*y;var lL=Math.sqrt(lLL);var dX=global.x-parentGlobal.x;var dY=global.y-parentGlobal.y;var lPP=dX*dX+dY*dY;var lP=Math.sqrt(lPP);var rawRadian=global.rotation;var rawParentRadian=parentGlobal.rotation;var rawRadianA=Math.atan2(dY,dX);dX=ikGlobal.x-parentGlobal.x;dY=ikGlobal.y-parentGlobal.y;var lTT=dX*dX+dY*dY;var lT=Math.sqrt(lTT);var radianA=0.0;if(lL+lP<=lT||lT+lL<=lP||lT+lP<=lL){radianA=Math.atan2(ikGlobal.y-parentGlobal.y,ikGlobal.x-parentGlobal.x);if(lL+lP<=lT);else if(lP<lL){radianA+=Math.PI;}}else {var h=(lPP-lLL+lTT)/(2.0*lTT);var r=Math.sqrt(lPP-h*h*lTT)/lT;var hX=parentGlobal.x+dX*h;var hY=parentGlobal.y+dY*h;var rX=-dY*r;var rY=dX*r;var isPPR=false;var parentParent=parent.parent;if(parentParent!==null){var parentParentMatrix=parentParent.globalTransformMatrix;isPPR=parentParentMatrix.a*parentParentMatrix.d-parentParentMatrix.b*parentParentMatrix.c<0.0;}if(isPPR!==this._bendPositive){global.x=hX-rX;global.y=hY-rY;}else {global.x=hX+rX;global.y=hY+rY;}radianA=Math.atan2(global.y-parentGlobal.y,global.x-parentGlobal.x);}var dR=dragonBones.Transform.normalizeRadian(radianA-rawRadianA);parentGlobal.rotation=rawParentRadian+dR*this._weight;parentGlobal.toMatrix(parent.globalTransformMatrix);var currentRadianA=rawRadianA+dR*this._weight;global.x=parentGlobal.x+Math.cos(currentRadianA)*lP;global.y=parentGlobal.y+Math.sin(currentRadianA)*lP;var radianB=Math.atan2(ikGlobal.y-global.y,ikGlobal.x-global.x);if(global.scaleX<0.0){radianB+=Math.PI;}global.rotation=parentGlobal.rotation+rawRadian-rawParentRadian+dragonBones.Transform.normalizeRadian(radianB-dR-rawRadian)*this._weight;global.toMatrix(globalTransformMatrix);};IKConstraint.prototype.init=function(constraintData,armature){if(this._constraintData!==null){return;}this._constraintData=constraintData;this._armature=armature;this._target=this._armature.getBone(this._constraintData.target.name);this._root=this._armature.getBone(this._constraintData.root.name);this._bone=this._constraintData.bone!==null?this._armature.getBone(this._constraintData.bone.name):null;{var ikConstraintData=this._constraintData;this._scaleEnabled=ikConstraintData.scaleEnabled;this._bendPositive=ikConstraintData.bendPositive;this._weight=ikConstraintData.weight;}this._root._hasConstraint=true;};IKConstraint.prototype.update=function(){this._root.updateByConstraint();if(this._bone!==null){this._bone.updateByConstraint();this._computeB();}else {this._computeA();}};IKConstraint.prototype.invalidUpdate=function(){this._root.invalidUpdate();if(this._bone!==null){this._bone.invalidUpdate();}};return IKConstraint;}(Constraint);dragonBones.IKConstraint=IKConstraint;var PathConstraint=function(_super){__extends(PathConstraint,_super);function PathConstraint(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._bones=[];_this._spaces=[];_this._positions=[];_this._curves=[];_this._boneLengths=[];_this._pathGlobalVertices=[];_this._segments=[10];return _this;}PathConstraint.toString=function(){return "[class dragonBones.PathConstraint]";};PathConstraint.prototype._onClear=function(){_super.prototype._onClear.call(this);this.dirty=false;this.pathOffset=0;this.position=0.0;this.spacing=0.0;this.rotateOffset=0.0;this.rotateMix=1.0;this.translateMix=1.0;this._pathSlot=null;this._bones.length=0;this._spaces.length=0;this._positions.length=0;this._curves.length=0;this._boneLengths.length=0;this._pathGlobalVertices.length=0;};PathConstraint.prototype._updatePathVertices=function(verticesData){var armature=this._armature;var dragonBonesData=armature.armatureData.parent;var scale=armature.armatureData.scale;var intArray=dragonBonesData.intArray;var floatArray=dragonBonesData.floatArray;var pathOffset=verticesData.offset;var pathVertexCount=intArray[pathOffset+0];var pathVertexOffset=intArray[pathOffset+2];this._pathGlobalVertices.length=pathVertexCount*2;var weightData=verticesData.weight;if(weightData===null){var parentBone=this._pathSlot.parent;parentBone.updateByConstraint();var matrix=parentBone.globalTransformMatrix;for(var i=0,iV_1=pathVertexOffset;i<pathVertexCount;i+=2){var vx=floatArray[iV_1++]*scale;var vy=floatArray[iV_1++]*scale;var x=matrix.a*vx+matrix.c*vy+matrix.tx;var y=matrix.b*vx+matrix.d*vy+matrix.ty;this._pathGlobalVertices[i]=x;this._pathGlobalVertices[i+1]=y;}return;}var bones=this._pathSlot._deformVertices.bones;var weightBoneCount=weightData.bones.length;var weightOffset=weightData.offset;var floatOffset=intArray[weightOffset+1];var iV=floatOffset;var iB=weightOffset+2+weightBoneCount;for(var i=0,iW=0;i<pathVertexCount;i++){var vertexBoneCount=intArray[iB++];var xG=0.0,yG=0.0;for(var ii=0,ll=vertexBoneCount;ii<ll;ii++){var boneIndex=intArray[iB++];var bone=bones[boneIndex];if(bone===null){continue;}bone.updateByConstraint();var matrix=bone.globalTransformMatrix;var weight=floatArray[iV++];var vx=floatArray[iV++]*scale;var vy=floatArray[iV++]*scale;xG+=(matrix.a*vx+matrix.c*vy+matrix.tx)*weight;yG+=(matrix.b*vx+matrix.d*vy+matrix.ty)*weight;}this._pathGlobalVertices[iW++]=xG;this._pathGlobalVertices[iW++]=yG;}};PathConstraint.prototype._computeVertices=function(start,count,offset,out){for(var i=offset,iW=start;i<count;i+=2){out[i]=this._pathGlobalVertices[iW++];out[i+1]=this._pathGlobalVertices[iW++];}};PathConstraint.prototype._computeBezierCurve=function(pathDisplayDta,spaceCount,tangents,percentPosition,percentSpacing){var armature=this._armature;var intArray=armature.armatureData.parent.intArray;var vertexCount=intArray[pathDisplayDta.vertices.offset+0];var positions=this._positions;var spaces=this._spaces;var isClosed=pathDisplayDta.closed;var curveVertices=Array();var verticesLength=vertexCount*2;var curveCount=verticesLength/6;var preCurve=-1;var position=this.position;positions.length=spaceCount*3+2;var pathLength=0.0;if(!pathDisplayDta.constantSpeed){var lenghts=pathDisplayDta.curveLengths;curveCount-=isClosed?1:2;pathLength=lenghts[curveCount];if(percentPosition){position*=pathLength;}if(percentSpacing){for(var i=0;i<spaceCount;i++){spaces[i]*=pathLength;}}curveVertices.length=8;for(var i=0,o=0,curve=0;i<spaceCount;i++,o+=3){var space=spaces[i];position+=space;if(isClosed){position%=pathLength;if(position<0){position+=pathLength;}curve=0;}else if(position<0){continue;}else if(position>pathLength){continue;}var percent=0.0;for(;;curve++){var len=lenghts[curve];if(position>len){continue;}if(curve===0){percent=position/len;}else {var preLen=lenghts[curve-1];percent=(position-preLen)/(len-preLen);}break;}if(curve!==preCurve){preCurve=curve;if(isClosed&&curve===curveCount){this._computeVertices(verticesLength-4,4,0,curveVertices);this._computeVertices(0,4,4,curveVertices);}else {this._computeVertices(curve*6+2,8,0,curveVertices);}}this.addCurvePosition(percent,curveVertices[0],curveVertices[1],curveVertices[2],curveVertices[3],curveVertices[4],curveVertices[5],curveVertices[6],curveVertices[7],positions,o,tangents);}return;}if(isClosed){verticesLength+=2;curveVertices.length=vertexCount;this._computeVertices(2,verticesLength-4,0,curveVertices);this._computeVertices(0,2,verticesLength-4,curveVertices);curveVertices[verticesLength-2]=curveVertices[0];curveVertices[verticesLength-1]=curveVertices[1];}else {curveCount--;verticesLength-=4;curveVertices.length=verticesLength;this._computeVertices(2,verticesLength,0,curveVertices);}var curves=new Array(curveCount);pathLength=0;var x1=curveVertices[0],y1=curveVertices[1],cx1=0,cy1=0,cx2=0,cy2=0,x2=0,y2=0;var tmpx,tmpy,dddfx,dddfy,ddfx,ddfy,dfx,dfy;for(var i=0,w=2;i<curveCount;i++,w+=6){cx1=curveVertices[w];cy1=curveVertices[w+1];cx2=curveVertices[w+2];cy2=curveVertices[w+3];x2=curveVertices[w+4];y2=curveVertices[w+5];tmpx=(x1-cx1*2+cx2)*0.1875;tmpy=(y1-cy1*2+cy2)*0.1875;dddfx=((cx1-cx2)*3-x1+x2)*0.09375;dddfy=((cy1-cy2)*3-y1+y2)*0.09375;ddfx=tmpx*2+dddfx;ddfy=tmpy*2+dddfy;dfx=(cx1-x1)*0.75+tmpx+dddfx*0.16666667;dfy=(cy1-y1)*0.75+tmpy+dddfy*0.16666667;pathLength+=Math.sqrt(dfx*dfx+dfy*dfy);dfx+=ddfx;dfy+=ddfy;ddfx+=dddfx;ddfy+=dddfy;pathLength+=Math.sqrt(dfx*dfx+dfy*dfy);dfx+=ddfx;dfy+=ddfy;pathLength+=Math.sqrt(dfx*dfx+dfy*dfy);dfx+=ddfx+dddfx;dfy+=ddfy+dddfy;pathLength+=Math.sqrt(dfx*dfx+dfy*dfy);curves[i]=pathLength;x1=x2;y1=y2;}if(percentPosition){position*=pathLength;}if(percentSpacing){for(var i=0;i<spaceCount;i++){spaces[i]*=pathLength;}}var segments=this._segments;var curveLength=0;for(var i=0,o=0,curve=0,segment=0;i<spaceCount;i++,o+=3){var space=spaces[i];position+=space;var p=position;if(isClosed){p%=pathLength;if(p<0)p+=pathLength;curve=0;}else if(p<0){continue;}else if(p>pathLength){continue;}for(;;curve++){var length_1=curves[curve];if(p>length_1)continue;if(curve===0)p/=length_1;else {var prev=curves[curve-1];p=(p-prev)/(length_1-prev);}break;}if(curve!==preCurve){preCurve=curve;var ii=curve*6;x1=curveVertices[ii];y1=curveVertices[ii+1];cx1=curveVertices[ii+2];cy1=curveVertices[ii+3];cx2=curveVertices[ii+4];cy2=curveVertices[ii+5];x2=curveVertices[ii+6];y2=curveVertices[ii+7];tmpx=(x1-cx1*2+cx2)*0.03;tmpy=(y1-cy1*2+cy2)*0.03;dddfx=((cx1-cx2)*3-x1+x2)*0.006;dddfy=((cy1-cy2)*3-y1+y2)*0.006;ddfx=tmpx*2+dddfx;ddfy=tmpy*2+dddfy;dfx=(cx1-x1)*0.3+tmpx+dddfx*0.16666667;dfy=(cy1-y1)*0.3+tmpy+dddfy*0.16666667;curveLength=Math.sqrt(dfx*dfx+dfy*dfy);segments[0]=curveLength;for(ii=1;ii<8;ii++){dfx+=ddfx;dfy+=ddfy;ddfx+=dddfx;ddfy+=dddfy;curveLength+=Math.sqrt(dfx*dfx+dfy*dfy);segments[ii]=curveLength;}dfx+=ddfx;dfy+=ddfy;curveLength+=Math.sqrt(dfx*dfx+dfy*dfy);segments[8]=curveLength;dfx+=ddfx+dddfx;dfy+=ddfy+dddfy;curveLength+=Math.sqrt(dfx*dfx+dfy*dfy);segments[9]=curveLength;segment=0;}p*=curveLength;for(;;segment++){var length_2=segments[segment];if(p>length_2)continue;if(segment===0)p/=length_2;else {var prev=segments[segment-1];p=segment+(p-prev)/(length_2-prev);}break;}this.addCurvePosition(p*0.1,x1,y1,cx1,cy1,cx2,cy2,x2,y2,positions,o,tangents);}};PathConstraint.prototype.addCurvePosition=function(t,x1,y1,cx1,cy1,cx2,cy2,x2,y2,out,offset,tangents){if(t===0){out[offset]=x1;out[offset+1]=y1;out[offset+2]=0;return;}if(t===1){out[offset]=x2;out[offset+1]=y2;out[offset+2]=0;return;}var mt=1-t;var mt2=mt*mt;var t2=t*t;var a=mt2*mt;var b=mt2*t*3;var c=mt*t2*3;var d=t*t2;var x=a*x1+b*cx1+c*cx2+d*x2;var y=a*y1+b*cy1+c*cy2+d*y2;out[offset]=x;out[offset+1]=y;if(tangents){out[offset+2]=Math.atan2(y-(a*y1+b*cy1+c*cy2),x-(a*x1+b*cx1+c*cx2));}else {out[offset+2]=0;}};PathConstraint.prototype.init=function(constraintData,armature){this._constraintData=constraintData;this._armature=armature;var data=constraintData;this.pathOffset=data.pathDisplayData.vertices.offset;this.position=data.position;this.spacing=data.spacing;this.rotateOffset=data.rotateOffset;this.rotateMix=data.rotateMix;this.translateMix=data.translateMix;this._root=this._armature.getBone(data.root.name);this._target=this._armature.getBone(data.target.name);this._pathSlot=this._armature.getSlot(data.pathSlot.name);for(var i=0,l=data.bones.length;i<l;i++){var bone=this._armature.getBone(data.bones[i].name);if(bone!==null){this._bones.push(bone);}}if(data.rotateMode===2){this._boneLengths.length=this._bones.length;}this._root._hasConstraint=true;};PathConstraint.prototype.update=function(){var pathSlot=this._pathSlot;if(pathSlot._deformVertices===null||pathSlot._deformVertices.verticesData===null||pathSlot._deformVertices.verticesData.offset!==this.pathOffset){return;}var constraintData=this._constraintData;var pathDisplayData=pathSlot._displayData;var isPathVerticeDirty=false;var deformVertices=pathSlot._deformVertices;if(this._root._childrenTransformDirty){this._updatePathVertices(pathDisplayData.vertices);isPathVerticeDirty=true;}else if(deformVertices!==null&&(deformVertices.verticesDirty||deformVertices.isBonesUpdate())){this._updatePathVertices(pathDisplayData.vertices);deformVertices.verticesDirty=false;isPathVerticeDirty=true;}if(!isPathVerticeDirty&&!this.dirty){return;}var positionMode=constraintData.positionMode;var spacingMode=constraintData.spacingMode;var rotateMode=constraintData.rotateMode;var bones=this._bones;var isLengthMode=spacingMode===0;var isChainScaleMode=rotateMode===2;var isTangentMode=rotateMode===0;var boneCount=bones.length;var spacesCount=isTangentMode?boneCount:boneCount+1;var spacing=this.spacing;var spaces=this._spaces;spaces.length=spacesCount;if(isChainScaleMode||isLengthMode){spaces[0]=0;for(var i=0,l=spacesCount-1;i<l;i++){var bone=bones[i];bone.updateByConstraint();var boneLength=bone._boneData.length;var matrix=bone.globalTransformMatrix;var x=boneLength*matrix.a;var y=boneLength*matrix.b;var len=Math.sqrt(x*x+y*y);if(isChainScaleMode){this._boneLengths[i]=len;}spaces[i+1]=(boneLength+spacing)*len/boneLength;}}else {for(var i=0;i<spacesCount;i++){spaces[i]=spacing;}}this._computeBezierCurve(pathDisplayData,spacesCount,isTangentMode,positionMode===1,spacingMode===2);var positions=this._positions;var rotateOffset=this.rotateOffset;var boneX=positions[0],boneY=positions[1];var tip;if(rotateOffset===0){tip=rotateMode===1;}else {tip=false;var bone=pathSlot.parent;if(bone!==null){var matrix=bone.globalTransformMatrix;rotateOffset*=matrix.a*matrix.d-matrix.b*matrix.c>0?dragonBones.Transform.DEG_RAD:-dragonBones.Transform.DEG_RAD;}}var rotateMix=this.rotateMix;var translateMix=this.translateMix;for(var i=0,p=3;i<boneCount;i++,p+=3){var bone=bones[i];bone.updateByConstraint();var matrix=bone.globalTransformMatrix;matrix.tx+=(boneX-matrix.tx)*translateMix;matrix.ty+=(boneY-matrix.ty)*translateMix;var x=positions[p],y=positions[p+1];var dx=x-boneX,dy=y-boneY;if(isChainScaleMode){var lenght=this._boneLengths[i];var s=(Math.sqrt(dx*dx+dy*dy)/lenght-1)*rotateMix+1;matrix.a*=s;matrix.b*=s;}boneX=x;boneY=y;if(rotateMix>0){var a=matrix.a,b=matrix.b,c=matrix.c,d=matrix.d,r=void 0,cos=void 0,sin=void 0;if(isTangentMode){r=positions[p-1];}else {r=Math.atan2(dy,dx);}r-=Math.atan2(b,a);if(tip){cos=Math.cos(r);sin=Math.sin(r);var length_3=bone._boneData.length;boneX+=(length_3*(cos*a-sin*b)-dx)*rotateMix;boneY+=(length_3*(sin*a+cos*b)-dy)*rotateMix;}else {r+=rotateOffset;}if(r>dragonBones.Transform.PI){r-=dragonBones.Transform.PI_D;}else if(r<-dragonBones.Transform.PI){r+=dragonBones.Transform.PI_D;}r*=rotateMix;cos=Math.cos(r);sin=Math.sin(r);matrix.a=cos*a-sin*b;matrix.b=sin*a+cos*b;matrix.c=cos*c-sin*d;matrix.d=sin*c+cos*d;}bone.global.fromMatrix(matrix);}this.dirty=false;};PathConstraint.prototype.invalidUpdate=function(){};return PathConstraint;}(Constraint);dragonBones.PathConstraint=PathConstraint;})(dragonBones||(dragonBones={}));(function(dragonBones){var WorldClock=function(){function WorldClock(time){if(time===void 0){time=0.0;}this.time=0.0;this.timeScale=1.0;this._systemTime=0.0;this._animatebles=[];this._clock=null;this.time=time;this._systemTime=new Date().getTime()*0.001;}WorldClock.prototype.advanceTime=function(passedTime){if(passedTime!==passedTime){passedTime=0.0;}var currentTime=Date.now()*0.001;if(passedTime<0.0){passedTime=currentTime-this._systemTime;}this._systemTime=currentTime;if(this.timeScale!==1.0){passedTime*=this.timeScale;}if(passedTime===0.0){return;}if(passedTime<0.0){this.time-=passedTime;}else {this.time+=passedTime;}var i=0,r=0,l=this._animatebles.length;for(;i<l;++i){var animatable=this._animatebles[i];if(animatable!==null){if(r>0){this._animatebles[i-r]=animatable;this._animatebles[i]=null;}animatable.advanceTime(passedTime);}else {r++;}}if(r>0){l=this._animatebles.length;for(;i<l;++i){var animateble=this._animatebles[i];if(animateble!==null){this._animatebles[i-r]=animateble;}else {r++;}}this._animatebles.length-=r;}};WorldClock.prototype.contains=function(value){if(value===this){return false;}var ancestor=value;while(ancestor!==this&&ancestor!==null){ancestor=ancestor.clock;}return ancestor===this;};WorldClock.prototype.add=function(value){if(this._animatebles.indexOf(value)<0){this._animatebles.push(value);value.clock=this;}};WorldClock.prototype.remove=function(value){var index=this._animatebles.indexOf(value);if(index>=0){this._animatebles[index]=null;value.clock=null;}};WorldClock.prototype.clear=function(){for(var _i=0,_a=this._animatebles;_i<_a.length;_i++){var animatable=_a[_i];if(animatable!==null){animatable.clock=null;}}};Object.defineProperty(WorldClock.prototype,"clock",{get:function get(){return this._clock;},set:function set(value){if(this._clock===value){return;}if(this._clock!==null){this._clock.remove(this);}this._clock=value;if(this._clock!==null){this._clock.add(this);}},enumerable:true,configurable:true});WorldClock.clock=new WorldClock();return WorldClock;}();dragonBones.WorldClock=WorldClock;})(dragonBones||(dragonBones={}));(function(dragonBones){var Animation=function(_super){__extends(Animation,_super);function Animation(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._animationNames=[];_this._animationStates=[];_this._animations={};_this._animationConfig=null;return _this;}Animation.toString=function(){return "[class dragonBones.Animation]";};Animation.prototype._onClear=function(){for(var _i=0,_a=this._animationStates;_i<_a.length;_i++){var animationState=_a[_i];animationState.returnToPool();}for(var k in this._animations){delete this._animations[k];}if(this._animationConfig!==null){this._animationConfig.returnToPool();}this.timeScale=1.0;this._lockUpdate=false;this._animationDirty=false;this._inheritTimeScale=1.0;this._animationNames.length=0;this._animationStates.length=0;this._armature=null;this._animationConfig=null;this._lastAnimationState=null;};Animation.prototype._fadeOut=function(animationConfig){switch(animationConfig.fadeOutMode){case 1:for(var _i=0,_a=this._animationStates;_i<_a.length;_i++){var animationState=_a[_i];if(animationState._parent!==null){continue;}if(animationState.layer===animationConfig.layer){animationState.fadeOut(animationConfig.fadeOutTime,animationConfig.pauseFadeOut);}}break;case 2:for(var _b=0,_c=this._animationStates;_b<_c.length;_b++){var animationState=_c[_b];if(animationState._parent!==null){continue;}if(animationState.group===animationConfig.group){animationState.fadeOut(animationConfig.fadeOutTime,animationConfig.pauseFadeOut);}}break;case 3:for(var _d=0,_e=this._animationStates;_d<_e.length;_d++){var animationState=_e[_d];if(animationState._parent!==null){continue;}if(animationState.layer===animationConfig.layer&&animationState.group===animationConfig.group){animationState.fadeOut(animationConfig.fadeOutTime,animationConfig.pauseFadeOut);}}break;case 4:for(var _f=0,_g=this._animationStates;_f<_g.length;_f++){var animationState=_g[_f];if(animationState._parent!==null){continue;}animationState.fadeOut(animationConfig.fadeOutTime,animationConfig.pauseFadeOut);}break;}};Animation.prototype.init=function(armature){if(this._armature!==null){return;}this._armature=armature;this._animationConfig=dragonBones.BaseObject.borrowObject(dragonBones.AnimationConfig);};Animation.prototype.advanceTime=function(passedTime){if(passedTime<0.0){passedTime=-passedTime;}if(this._armature.inheritAnimation&&this._armature._parent!==null){this._inheritTimeScale=this._armature._parent._armature.animation._inheritTimeScale*this.timeScale;}else {this._inheritTimeScale=this.timeScale;}if(this._inheritTimeScale!==1.0){passedTime*=this._inheritTimeScale;}var animationStateCount=this._animationStates.length;if(animationStateCount===1){var animationState=this._animationStates[0];if(animationState._fadeState>0&&animationState._subFadeState>0){this._armature._dragonBones.bufferObject(animationState);this._animationStates.length=0;this._lastAnimationState=null;}else {var animationData=animationState._animationData;var cacheFrameRate=animationData.cacheFrameRate;if(this._animationDirty&&cacheFrameRate>0.0){this._animationDirty=false;for(var _i=0,_a=this._armature.getBones();_i<_a.length;_i++){var bone=_a[_i];bone._cachedFrameIndices=animationData.getBoneCachedFrameIndices(bone.name);}for(var _b=0,_c=this._armature.getSlots();_b<_c.length;_b++){var slot=_c[_b];var rawDisplayDatas=slot.rawDisplayDatas;if(rawDisplayDatas!==null&&rawDisplayDatas.length>0){var rawDsplayData=rawDisplayDatas[0];if(rawDsplayData!==null){if(rawDsplayData.parent===this._armature.armatureData.defaultSkin){slot._cachedFrameIndices=animationData.getSlotCachedFrameIndices(slot.name);continue;}}}slot._cachedFrameIndices=null;}}animationState.advanceTime(passedTime,cacheFrameRate);}}else if(animationStateCount>1){for(var i=0,r=0;i<animationStateCount;++i){var animationState=this._animationStates[i];if(animationState._fadeState>0&&animationState._subFadeState>0){r++;this._armature._dragonBones.bufferObject(animationState);this._animationDirty=true;if(this._lastAnimationState===animationState){this._lastAnimationState=null;}}else {if(r>0){this._animationStates[i-r]=animationState;}animationState.advanceTime(passedTime,0.0);}if(i===animationStateCount-1&&r>0){this._animationStates.length-=r;if(this._lastAnimationState===null&&this._animationStates.length>0){this._lastAnimationState=this._animationStates[this._animationStates.length-1];}}}this._armature._cacheFrameIndex=-1;}else {this._armature._cacheFrameIndex=-1;}};Animation.prototype.reset=function(){for(var _i=0,_a=this._animationStates;_i<_a.length;_i++){var animationState=_a[_i];animationState.returnToPool();}this._animationDirty=false;this._animationConfig.clear();this._animationStates.length=0;this._lastAnimationState=null;};Animation.prototype.stop=function(animationName){if(animationName===void 0){animationName=null;}if(animationName!==null){var animationState=this.getState(animationName);if(animationState!==null){animationState.stop();}}else {for(var _i=0,_a=this._animationStates;_i<_a.length;_i++){var animationState=_a[_i];animationState.stop();}}};Animation.prototype.playConfig=function(animationConfig){var animationName=animationConfig.animation;if(!(animationName in this._animations)){console.warn("Non-existent animation.\n","DragonBones name: "+this._armature.armatureData.parent.name,"Armature name: "+this._armature.name,"Animation name: "+animationName);return null;}var animationData=this._animations[animationName];if(animationConfig.fadeOutMode===5){for(var _i=0,_a=this._animationStates;_i<_a.length;_i++){var animationState_1=_a[_i];if(animationState_1._animationData===animationData){return animationState_1;}}}if(this._animationStates.length===0){animationConfig.fadeInTime=0.0;}else if(animationConfig.fadeInTime<0.0){animationConfig.fadeInTime=animationData.fadeInTime;}if(animationConfig.fadeOutTime<0.0){animationConfig.fadeOutTime=animationConfig.fadeInTime;}if(animationConfig.timeScale<=-100.0){animationConfig.timeScale=1.0/animationData.scale;}if(animationData.frameCount>1){if(animationConfig.position<0.0){animationConfig.position%=animationData.duration;animationConfig.position=animationData.duration-animationConfig.position;}else if(animationConfig.position===animationData.duration){animationConfig.position-=0.000001;}else if(animationConfig.position>animationData.duration){animationConfig.position%=animationData.duration;}if(animationConfig.duration>0.0&&animationConfig.position+animationConfig.duration>animationData.duration){animationConfig.duration=animationData.duration-animationConfig.position;}if(animationConfig.playTimes<0){animationConfig.playTimes=animationData.playTimes;}}else {animationConfig.playTimes=1;animationConfig.position=0.0;if(animationConfig.duration>0.0){animationConfig.duration=0.0;}}if(animationConfig.duration===0.0){animationConfig.duration=-1.0;}this._fadeOut(animationConfig);var animationState=dragonBones.BaseObject.borrowObject(dragonBones.AnimationState);animationState.init(this._armature,animationData,animationConfig);this._animationDirty=true;this._armature._cacheFrameIndex=-1;if(this._animationStates.length>0){var added=false;for(var i=0,l=this._animationStates.length;i<l;++i){if(animationState.layer>this._animationStates[i].layer){added=true;this._animationStates.splice(i,0,animationState);break;}else if(i!==l-1&&animationState.layer>this._animationStates[i+1].layer){added=true;this._animationStates.splice(i+1,0,animationState);break;}}if(!added){this._animationStates.push(animationState);}}else {this._animationStates.push(animationState);}for(var _b=0,_c=this._armature.getSlots();_b<_c.length;_b++){var slot=_c[_b];var childArmature=slot.childArmature;if(childArmature!==null&&childArmature.inheritAnimation&&childArmature.animation.hasAnimation(animationName)&&childArmature.animation.getState(animationName)===null){childArmature.animation.fadeIn(animationName);}}var isLocked=false;for(var k in animationData.animationTimelines){if(!this._lockUpdate){isLocked=true;this._lockUpdate=true;}var childAnimatiionState=this.fadeIn(k,animationConfig.fadeInTime,1,animationState.layer,null,0);if(childAnimatiionState!==null){childAnimatiionState.resetToPose=false;childAnimatiionState._parent=animationState;childAnimatiionState.stop();}}if(isLocked){this._lockUpdate=false;}if(!this._lockUpdate){if(animationConfig.fadeInTime<=0.0){this._armature.advanceTime(0.0);}this._lastAnimationState=animationState;}return animationState;};Animation.prototype.play=function(animationName,playTimes){if(animationName===void 0){animationName=null;}if(playTimes===void 0){playTimes=-1;}this._animationConfig.clear();this._animationConfig.resetToPose=true;this._animationConfig.playTimes=playTimes;this._animationConfig.fadeInTime=0.0;this._animationConfig.animation=animationName!==null?animationName:"";if(animationName!==null&&animationName.length>0){this.playConfig(this._animationConfig);}else if(this._lastAnimationState===null){var defaultAnimation=this._armature.armatureData.defaultAnimation;if(defaultAnimation!==null){this._animationConfig.animation=defaultAnimation.name;this.playConfig(this._animationConfig);}}else if(!this._lastAnimationState.isPlaying&&!this._lastAnimationState.isCompleted){this._lastAnimationState.play();}else {this._animationConfig.animation=this._lastAnimationState.name;this.playConfig(this._animationConfig);}return this._lastAnimationState;};Animation.prototype.fadeIn=function(animationName,fadeInTime,playTimes,layer,group,fadeOutMode){if(fadeInTime===void 0){fadeInTime=-1.0;}if(playTimes===void 0){playTimes=-1;}if(layer===void 0){layer=0;}if(group===void 0){group=null;}if(fadeOutMode===void 0){fadeOutMode=3;}this._animationConfig.clear();this._animationConfig.fadeOutMode=fadeOutMode;this._animationConfig.playTimes=playTimes;this._animationConfig.layer=layer;this._animationConfig.fadeInTime=fadeInTime;this._animationConfig.animation=animationName;this._animationConfig.group=group!==null?group:"";return this.playConfig(this._animationConfig);};Animation.prototype.gotoAndPlayByTime=function(animationName,time,playTimes){if(time===void 0){time=0.0;}if(playTimes===void 0){playTimes=-1;}this._animationConfig.clear();this._animationConfig.resetToPose=true;this._animationConfig.playTimes=playTimes;this._animationConfig.position=time;this._animationConfig.fadeInTime=0.0;this._animationConfig.animation=animationName;return this.playConfig(this._animationConfig);};Animation.prototype.gotoAndPlayByFrame=function(animationName,frame,playTimes){if(frame===void 0){frame=0;}if(playTimes===void 0){playTimes=-1;}this._animationConfig.clear();this._animationConfig.resetToPose=true;this._animationConfig.playTimes=playTimes;this._animationConfig.fadeInTime=0.0;this._animationConfig.animation=animationName;var animationData=animationName in this._animations?this._animations[animationName]:null;if(animationData!==null){this._animationConfig.position=animationData.duration*frame/animationData.frameCount;}return this.playConfig(this._animationConfig);};Animation.prototype.gotoAndPlayByProgress=function(animationName,progress,playTimes){if(progress===void 0){progress=0.0;}if(playTimes===void 0){playTimes=-1;}this._animationConfig.clear();this._animationConfig.resetToPose=true;this._animationConfig.playTimes=playTimes;this._animationConfig.fadeInTime=0.0;this._animationConfig.animation=animationName;var animationData=animationName in this._animations?this._animations[animationName]:null;if(animationData!==null){this._animationConfig.position=animationData.duration*(progress>0.0?progress:0.0);}return this.playConfig(this._animationConfig);};Animation.prototype.gotoAndStopByTime=function(animationName,time){if(time===void 0){time=0.0;}var animationState=this.gotoAndPlayByTime(animationName,time,1);if(animationState!==null){animationState.stop();}return animationState;};Animation.prototype.gotoAndStopByFrame=function(animationName,frame){if(frame===void 0){frame=0;}var animationState=this.gotoAndPlayByFrame(animationName,frame,1);if(animationState!==null){animationState.stop();}return animationState;};Animation.prototype.gotoAndStopByProgress=function(animationName,progress){if(progress===void 0){progress=0.0;}var animationState=this.gotoAndPlayByProgress(animationName,progress,1);if(animationState!==null){animationState.stop();}return animationState;};Animation.prototype.getState=function(animationName){var i=this._animationStates.length;while(i--){var animationState=this._animationStates[i];if(animationState.name===animationName){return animationState;}}return null;};Animation.prototype.hasAnimation=function(animationName){return animationName in this._animations;};Animation.prototype.getStates=function(){return this._animationStates;};Object.defineProperty(Animation.prototype,"isPlaying",{get:function get(){for(var _i=0,_a=this._animationStates;_i<_a.length;_i++){var animationState=_a[_i];if(animationState.isPlaying){return true;}}return false;},enumerable:true,configurable:true});Object.defineProperty(Animation.prototype,"isCompleted",{get:function get(){for(var _i=0,_a=this._animationStates;_i<_a.length;_i++){var animationState=_a[_i];if(!animationState.isCompleted){return false;}}return this._animationStates.length>0;},enumerable:true,configurable:true});Object.defineProperty(Animation.prototype,"lastAnimationName",{get:function get(){return this._lastAnimationState!==null?this._lastAnimationState.name:"";},enumerable:true,configurable:true});Object.defineProperty(Animation.prototype,"animationNames",{get:function get(){return this._animationNames;},enumerable:true,configurable:true});Object.defineProperty(Animation.prototype,"animations",{get:function get(){return this._animations;},set:function set(value){if(this._animations===value){return;}this._animationNames.length=0;for(var k in this._animations){delete this._animations[k];}for(var k in value){this._animationNames.push(k);this._animations[k]=value[k];}},enumerable:true,configurable:true});Object.defineProperty(Animation.prototype,"animationConfig",{get:function get(){this._animationConfig.clear();return this._animationConfig;},enumerable:true,configurable:true});Object.defineProperty(Animation.prototype,"lastAnimationState",{get:function get(){return this._lastAnimationState;},enumerable:true,configurable:true});Animation.prototype.gotoAndPlay=function(animationName,fadeInTime,duration,playTimes,layer,group,fadeOutMode,pauseFadeOut,pauseFadeIn){if(fadeInTime===void 0){fadeInTime=-1;}if(duration===void 0){duration=-1;}if(playTimes===void 0){playTimes=-1;}if(layer===void 0){layer=0;}if(group===void 0){group=null;}if(fadeOutMode===void 0){fadeOutMode=3;}console.warn("Deprecated.");this._animationConfig.clear();this._animationConfig.resetToPose=true;this._animationConfig.fadeOutMode=fadeOutMode;this._animationConfig.playTimes=playTimes;this._animationConfig.layer=layer;this._animationConfig.fadeInTime=fadeInTime;this._animationConfig.animation=animationName;this._animationConfig.group=group!==null?group:"";var animationData=this._animations[animationName];if(animationData&&duration>0.0){this._animationConfig.timeScale=animationData.duration/duration;}return this.playConfig(this._animationConfig);};Animation.prototype.gotoAndStop=function(animationName,time){if(time===void 0){time=0;}console.warn("Deprecated.");return this.gotoAndStopByTime(animationName,time);};Object.defineProperty(Animation.prototype,"animationList",{get:function get(){console.warn("Deprecated.");return this._animationNames;},enumerable:true,configurable:true});Object.defineProperty(Animation.prototype,"animationDataList",{get:function get(){console.warn("Deprecated.");var list=[];for(var i=0,l=this._animationNames.length;i<l;++i){list.push(this._animations[this._animationNames[i]]);}return list;},enumerable:true,configurable:true});return Animation;}(dragonBones.BaseObject);dragonBones.Animation=Animation;})(dragonBones||(dragonBones={}));(function(dragonBones){var AnimationState=function(_super){__extends(AnimationState,_super);function AnimationState(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._blendState=new BlendState();_this._boneMask=[];_this._boneTimelines=[];_this._surfaceTimelines=[];_this._slotTimelines=[];_this._constraintTimelines=[];_this._animationTimelines=[];_this._poseTimelines=[];_this._bonePoses={};_this._actionTimeline=null;_this._zOrderTimeline=null;_this._parent=null;return _this;}AnimationState.toString=function(){return "[class dragonBones.AnimationState]";};AnimationState.prototype._onClear=function(){for(var _i=0,_a=this._boneTimelines;_i<_a.length;_i++){var timeline=_a[_i];timeline.returnToPool();}for(var _b=0,_c=this._surfaceTimelines;_b<_c.length;_b++){var timeline=_c[_b];timeline.returnToPool();}for(var _d=0,_e=this._slotTimelines;_d<_e.length;_d++){var timeline=_e[_d];timeline.returnToPool();}for(var _f=0,_g=this._constraintTimelines;_f<_g.length;_f++){var timeline=_g[_f];timeline.returnToPool();}for(var _h=0,_j=this._animationTimelines;_h<_j.length;_h++){var timeline=_j[_h];timeline.returnToPool();}for(var k in this._bonePoses){this._bonePoses[k].returnToPool();delete this._bonePoses[k];}if(this._actionTimeline!==null){this._actionTimeline.returnToPool();}if(this._zOrderTimeline!==null){this._zOrderTimeline.returnToPool();}this.actionEnabled=false;this.additiveBlending=false;this.displayControl=false;this.resetToPose=false;this.playTimes=1;this.layer=0;this.timeScale=1.0;this.weight=1.0;this.autoFadeOutTime=0.0;this.fadeTotalTime=0.0;this.name="";this.group="";this._timelineDirty=2;this._playheadState=0;this._fadeState=-1;this._subFadeState=-1;this._position=0.0;this._duration=0.0;this._fadeTime=0.0;this._time=0.0;this._fadeProgress=0.0;this._weightResult=0.0;this._blendState.clear();this._boneMask.length=0;this._boneTimelines.length=0;this._surfaceTimelines.length=0;this._slotTimelines.length=0;this._constraintTimelines.length=0;this._animationTimelines.length=0;this._poseTimelines.length=0;this._animationData=null;this._armature=null;this._actionTimeline=null;this._zOrderTimeline=null;this._parent=null;};AnimationState.prototype._updateTimelines=function(){{for(var _i=0,_a=this._armature._constraints;_i<_a.length;_i++){var constraint=_a[_i];var timelineDatas=this._animationData.getConstraintTimelines(constraint.name);if(timelineDatas!==null){for(var _b=0,timelineDatas_1=timelineDatas;_b<timelineDatas_1.length;_b++){var timelineData=timelineDatas_1[_b];switch(timelineData.type){case 30:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.IKConstraintTimelineState);timeline.constraint=constraint;timeline.init(this._armature,this,timelineData);this._constraintTimelines.push(timeline);break;}}}}else if(this.resetToPose){var timeline=dragonBones.BaseObject.borrowObject(dragonBones.IKConstraintTimelineState);timeline.constraint=constraint;timeline.init(this._armature,this,null);this._constraintTimelines.push(timeline);this._poseTimelines.push(timeline);}}}{for(var _c=0,_d=this._armature.animation.getStates();_c<_d.length;_c++){var animationState=_d[_c];if(animationState._parent!==this){continue;}var timelineDatas=this._animationData.getAnimationTimelines(animationState.name);if(timelineDatas===null){continue;}for(var _e=0,timelineDatas_2=timelineDatas;_e<timelineDatas_2.length;_e++){var timelineData=timelineDatas_2[_e];switch(timelineData.type){case 40:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.AnimationTimelineState);timeline.animationState=animationState;timeline.init(this._armature,this,timelineData);this._animationTimelines.push(timeline);break;}}}}}};AnimationState.prototype._updateBoneAndSlotTimelines=function(){{var boneTimelines={};for(var _i=0,_a=this._boneTimelines;_i<_a.length;_i++){var timeline=_a[_i];var timelineName=timeline.bone.name;if(!(timelineName in boneTimelines)){boneTimelines[timelineName]=[];}boneTimelines[timelineName].push(timeline);}for(var _b=0,_c=this._armature.getBones();_b<_c.length;_b++){var bone=_c[_b];var timelineName=bone.name;if(!this.containsBoneMask(timelineName)){continue;}if(timelineName in boneTimelines){delete boneTimelines[timelineName];}else if(bone._boneData.type===0){var timelineDatas=this._animationData.getBoneTimelines(timelineName);var bonePose=timelineName in this._bonePoses?this._bonePoses[timelineName]:this._bonePoses[timelineName]=dragonBones.BaseObject.borrowObject(BonePose);if(timelineDatas!==null){for(var _d=0,timelineDatas_3=timelineDatas;_d<timelineDatas_3.length;_d++){var timelineData=timelineDatas_3[_d];switch(timelineData.type){case 10:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.BoneAllTimelineState);timeline.bone=bone;timeline.bonePose=bonePose;timeline.init(this._armature,this,timelineData);this._boneTimelines.push(timeline);break;}case 11:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.BoneTranslateTimelineState);timeline.bone=bone;timeline.bonePose=bonePose;timeline.init(this._armature,this,timelineData);this._boneTimelines.push(timeline);break;}case 12:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.BoneRotateTimelineState);timeline.bone=bone;timeline.bonePose=bonePose;timeline.init(this._armature,this,timelineData);this._boneTimelines.push(timeline);break;}case 13:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.BoneScaleTimelineState);timeline.bone=bone;timeline.bonePose=bonePose;timeline.init(this._armature,this,timelineData);this._boneTimelines.push(timeline);break;}}}}else if(this.resetToPose){var timeline=dragonBones.BaseObject.borrowObject(dragonBones.BoneAllTimelineState);timeline.bone=bone;timeline.bonePose=bonePose;timeline.init(this._armature,this,null);this._boneTimelines.push(timeline);this._poseTimelines.push(timeline);}}else if(bone._boneData.type===1){var timelineDatas=this._animationData.getSurfaceTimelines(timelineName);if(timelineDatas!==null){for(var _e=0,timelineDatas_4=timelineDatas;_e<timelineDatas_4.length;_e++){var timelineData=timelineDatas_4[_e];switch(timelineData.type){case 50:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.SurfaceTimelineState);timeline.surface=bone;timeline.init(this._armature,this,timelineData);this._surfaceTimelines.push(timeline);break;}}}}else if(this.resetToPose){var timeline=dragonBones.BaseObject.borrowObject(dragonBones.SurfaceTimelineState);timeline.surface=bone;timeline.init(this._armature,this,null);this._surfaceTimelines.push(timeline);this._poseTimelines.push(timeline);}}}for(var k in boneTimelines){for(var _f=0,_g=boneTimelines[k];_f<_g.length;_f++){var timeline=_g[_f];this._boneTimelines.splice(this._boneTimelines.indexOf(timeline),1);timeline.returnToPool();}}}{var slotTimelines={};var ffdFlags=[];for(var _h=0,_j=this._slotTimelines;_h<_j.length;_h++){var timeline=_j[_h];var timelineName=timeline.slot.name;if(!(timelineName in slotTimelines)){slotTimelines[timelineName]=[];}slotTimelines[timelineName].push(timeline);}for(var _k=0,_l=this._armature.getSlots();_k<_l.length;_k++){var slot=_l[_k];var boneName=slot.parent.name;if(!this.containsBoneMask(boneName)){continue;}var timelineName=slot.name;var timelineDatas=this._animationData.getSlotTimelines(timelineName);if(timelineName in slotTimelines){delete slotTimelines[timelineName];}else {var displayIndexFlag=false;var colorFlag=false;ffdFlags.length=0;if(timelineDatas!==null){for(var _m=0,timelineDatas_5=timelineDatas;_m<timelineDatas_5.length;_m++){var timelineData=timelineDatas_5[_m];switch(timelineData.type){case 20:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.SlotDislayTimelineState);timeline.slot=slot;timeline.init(this._armature,this,timelineData);this._slotTimelines.push(timeline);displayIndexFlag=true;break;}case 21:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.SlotColorTimelineState);timeline.slot=slot;timeline.init(this._armature,this,timelineData);this._slotTimelines.push(timeline);colorFlag=true;break;}case 22:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.DeformTimelineState);timeline.slot=slot;timeline.init(this._armature,this,timelineData);this._slotTimelines.push(timeline);ffdFlags.push(timeline.vertexOffset);break;}}}}if(this.resetToPose){if(!displayIndexFlag){var timeline=dragonBones.BaseObject.borrowObject(dragonBones.SlotDislayTimelineState);timeline.slot=slot;timeline.init(this._armature,this,null);this._slotTimelines.push(timeline);this._poseTimelines.push(timeline);}if(!colorFlag){var timeline=dragonBones.BaseObject.borrowObject(dragonBones.SlotColorTimelineState);timeline.slot=slot;timeline.init(this._armature,this,null);this._slotTimelines.push(timeline);this._poseTimelines.push(timeline);}if(slot.rawDisplayDatas!==null){for(var _o=0,_p=slot.rawDisplayDatas;_o<_p.length;_o++){var displayData=_p[_o];if(displayData!==null&&displayData.type===2){var meshOffset=displayData.vertices.offset;if(ffdFlags.indexOf(meshOffset)<0){var timeline=dragonBones.BaseObject.borrowObject(dragonBones.DeformTimelineState);timeline.vertexOffset=meshOffset;timeline.slot=slot;timeline.init(this._armature,this,null);this._slotTimelines.push(timeline);this._poseTimelines.push(timeline);}}}}}}}for(var k in slotTimelines){for(var _q=0,_r=slotTimelines[k];_q<_r.length;_q++){var timeline=_r[_q];this._slotTimelines.splice(this._slotTimelines.indexOf(timeline),1);timeline.returnToPool();}}}};AnimationState.prototype._advanceFadeTime=function(passedTime){var isFadeOut=this._fadeState>0;if(this._subFadeState<0){this._subFadeState=0;var eventType=isFadeOut?dragonBones.EventObject.FADE_OUT:dragonBones.EventObject.FADE_IN;if(this._armature.eventDispatcher.hasDBEventListener(eventType)){var eventObject=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);eventObject.type=eventType;eventObject.armature=this._armature;eventObject.animationState=this;this._armature._dragonBones.bufferEvent(eventObject);}}if(passedTime<0.0){passedTime=-passedTime;}this._fadeTime+=passedTime;if(this._fadeTime>=this.fadeTotalTime){this._subFadeState=1;this._fadeProgress=isFadeOut?0.0:1.0;}else if(this._fadeTime>0.0){this._fadeProgress=isFadeOut?1.0-this._fadeTime/this.fadeTotalTime:this._fadeTime/this.fadeTotalTime;}else {this._fadeProgress=isFadeOut?1.0:0.0;}if(this._subFadeState>0){if(!isFadeOut){this._playheadState|=1;this._fadeState=0;}var eventType=isFadeOut?dragonBones.EventObject.FADE_OUT_COMPLETE:dragonBones.EventObject.FADE_IN_COMPLETE;if(this._armature.eventDispatcher.hasDBEventListener(eventType)){var eventObject=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);eventObject.type=eventType;eventObject.armature=this._armature;eventObject.animationState=this;this._armature._dragonBones.bufferEvent(eventObject);}}};AnimationState.prototype.init=function(armature,animationData,animationConfig){if(this._armature!==null){return;}this._armature=armature;this._animationData=animationData;this.resetToPose=animationConfig.resetToPose;this.additiveBlending=animationConfig.additiveBlending;this.displayControl=animationConfig.displayControl;this.actionEnabled=animationConfig.actionEnabled;this.layer=animationConfig.layer;this.playTimes=animationConfig.playTimes;this.timeScale=animationConfig.timeScale;this.fadeTotalTime=animationConfig.fadeInTime;this.autoFadeOutTime=animationConfig.autoFadeOutTime;this.weight=animationConfig.weight;this.name=animationConfig.name.length>0?animationConfig.name:animationConfig.animation;this.group=animationConfig.group;if(animationConfig.pauseFadeIn){this._playheadState=2;}else {this._playheadState=3;}if(animationConfig.duration<0.0){this._position=0.0;this._duration=this._animationData.duration;if(animationConfig.position!==0.0){if(this.timeScale>=0.0){this._time=animationConfig.position;}else {this._time=animationConfig.position-this._duration;}}else {this._time=0.0;}}else {this._position=animationConfig.position;this._duration=animationConfig.duration;this._time=0.0;}if(this.timeScale<0.0&&this._time===0.0){this._time=-0.000001;}if(this.fadeTotalTime<=0.0){this._fadeProgress=0.999999;}if(animationConfig.boneMask.length>0){this._boneMask.length=animationConfig.boneMask.length;for(var i=0,l=this._boneMask.length;i<l;++i){this._boneMask[i]=animationConfig.boneMask[i];}}this._actionTimeline=dragonBones.BaseObject.borrowObject(dragonBones.ActionTimelineState);this._actionTimeline.init(this._armature,this,this._animationData.actionTimeline);this._actionTimeline.currentTime=this._time;if(this._actionTimeline.currentTime<0.0){this._actionTimeline.currentTime=this._duration-this._actionTimeline.currentTime;}if(this._animationData.zOrderTimeline!==null){this._zOrderTimeline=dragonBones.BaseObject.borrowObject(dragonBones.ZOrderTimelineState);this._zOrderTimeline.init(this._armature,this,this._animationData.zOrderTimeline);}};AnimationState.prototype.advanceTime=function(passedTime,cacheFrameRate){this._blendState.dirty=false;if(this._fadeState!==0||this._subFadeState!==0){this._advanceFadeTime(passedTime);}if(this._playheadState===3){if(this.timeScale!==1.0){passedTime*=this.timeScale;}this._time+=passedTime;}if(this._timelineDirty!==0){if(this._timelineDirty===2){this._updateTimelines();}this._timelineDirty=0;this._updateBoneAndSlotTimelines();}if(this.weight===0.0){return;}var isCacheEnabled=this._fadeState===0&&cacheFrameRate>0.0;var isUpdateTimeline=true;var isUpdateBoneTimeline=true;var time=this._time;this._weightResult=this.weight*this._fadeProgress;if(this._parent!==null){this._weightResult*=this._parent._weightResult/this._parent._fadeProgress;}if(this._actionTimeline.playState<=0){this._actionTimeline.update(time);}if(isCacheEnabled){var internval=cacheFrameRate*2.0;this._actionTimeline.currentTime=Math.floor(this._actionTimeline.currentTime*internval)/internval;}if(this._zOrderTimeline!==null&&this._zOrderTimeline.playState<=0){this._zOrderTimeline.update(time);}if(isCacheEnabled){var cacheFrameIndex=Math.floor(this._actionTimeline.currentTime*cacheFrameRate);if(this._armature._cacheFrameIndex===cacheFrameIndex){isUpdateTimeline=false;isUpdateBoneTimeline=false;}else {this._armature._cacheFrameIndex=cacheFrameIndex;if(this._animationData.cachedFrames[cacheFrameIndex]){isUpdateBoneTimeline=false;}else {this._animationData.cachedFrames[cacheFrameIndex]=true;}}}if(isUpdateTimeline){if(isUpdateBoneTimeline){for(var i=0,l=this._boneTimelines.length;i<l;++i){var timeline=this._boneTimelines[i];if(timeline.playState<=0){timeline.update(time);}if(i===l-1||timeline.bone!==this._boneTimelines[i+1].bone){var state=timeline.bone._blendState.update(this._weightResult,this.layer);if(state!==0){timeline.blend(state);}}}}for(var i=0,l=this._surfaceTimelines.length;i<l;++i){var timeline=this._surfaceTimelines[i];var state=timeline.surface._blendState.update(this._weightResult,this.layer);if(timeline.playState<=0){timeline.update(time);}if(state!==0){timeline.blend(state);}}if(this.displayControl){for(var i=0,l=this._slotTimelines.length;i<l;++i){var timeline=this._slotTimelines[i];var displayController=timeline.slot.displayController;if(displayController===null||displayController===this.name||displayController===this.group){if(timeline.playState<=0){timeline.update(time);}}}}for(var i=0,l=this._constraintTimelines.length;i<l;++i){var timeline=this._constraintTimelines[i];if(timeline.playState<=0){timeline.update(time);}}for(var i=0,l=this._animationTimelines.length;i<l;++i){var timeline=this._animationTimelines[i];var state=timeline.animationState._blendState.update(this._weightResult,this.layer);if(timeline.playState<=0){timeline.update(time);}if(state!==0){timeline.blend(state);}}}if(this._fadeState===0){if(this._subFadeState>0){this._subFadeState=0;if(this._poseTimelines.length>0){for(var _i=0,_a=this._poseTimelines;_i<_a.length;_i++){var timeline=_a[_i];if(timeline instanceof dragonBones.BoneTimelineState){this._boneTimelines.splice(this._boneTimelines.indexOf(timeline),1);}else if(timeline instanceof dragonBones.SurfaceTimelineState){this._surfaceTimelines.splice(this._surfaceTimelines.indexOf(timeline),1);}else if(timeline instanceof dragonBones.SlotTimelineState){this._slotTimelines.splice(this._slotTimelines.indexOf(timeline),1);}else if(timeline instanceof dragonBones.ConstraintTimelineState){this._constraintTimelines.splice(this._constraintTimelines.indexOf(timeline),1);}timeline.returnToPool();}this._poseTimelines.length=0;}}if(this._actionTimeline.playState>0){if(this.autoFadeOutTime>=0.0){this.fadeOut(this.autoFadeOutTime);}}}};AnimationState.prototype.play=function(){this._playheadState=3;};AnimationState.prototype.stop=function(){this._playheadState&=1;};AnimationState.prototype.fadeOut=function(fadeOutTime,pausePlayhead){if(pausePlayhead===void 0){pausePlayhead=true;}if(fadeOutTime<0.0){fadeOutTime=0.0;}if(pausePlayhead){this._playheadState&=2;}if(this._fadeState>0){if(fadeOutTime>this.fadeTotalTime-this._fadeTime){return;}}else {this._fadeState=1;this._subFadeState=-1;if(fadeOutTime<=0.0||this._fadeProgress<=0.0){this._fadeProgress=0.000001;}for(var _i=0,_a=this._boneTimelines;_i<_a.length;_i++){var timeline=_a[_i];timeline.fadeOut();}for(var _b=0,_c=this._surfaceTimelines;_b<_c.length;_b++){var timeline=_c[_b];timeline.fadeOut();}for(var _d=0,_e=this._slotTimelines;_d<_e.length;_d++){var timeline=_e[_d];timeline.fadeOut();}for(var _f=0,_g=this._constraintTimelines;_f<_g.length;_f++){var timeline=_g[_f];timeline.fadeOut();}for(var _h=0,_j=this._animationTimelines;_h<_j.length;_h++){var timeline=_j[_h];timeline.animationState.fadeOut(fadeOutTime,pausePlayhead);timeline.fadeOut();}}this.displayControl=false;this.fadeTotalTime=this._fadeProgress>0.000001?fadeOutTime/this._fadeProgress:0.0;this._fadeTime=this.fadeTotalTime*(1.0-this._fadeProgress);};AnimationState.prototype.containsBoneMask=function(boneName){return this._boneMask.length===0||this._boneMask.indexOf(boneName)>=0;};AnimationState.prototype.addBoneMask=function(boneName,recursive){if(recursive===void 0){recursive=true;}var currentBone=this._armature.getBone(boneName);if(currentBone===null){return;}if(this._boneMask.indexOf(boneName)<0){this._boneMask.push(boneName);}if(recursive){for(var _i=0,_a=this._armature.getBones();_i<_a.length;_i++){var bone=_a[_i];if(this._boneMask.indexOf(bone.name)<0&&currentBone.contains(bone)){this._boneMask.push(bone.name);}}}this._timelineDirty=1;};AnimationState.prototype.removeBoneMask=function(boneName,recursive){if(recursive===void 0){recursive=true;}var index=this._boneMask.indexOf(boneName);if(index>=0){this._boneMask.splice(index,1);}if(recursive){var currentBone=this._armature.getBone(boneName);if(currentBone!==null){var bones=this._armature.getBones();if(this._boneMask.length>0){for(var _i=0,bones_1=bones;_i<bones_1.length;_i++){var bone=bones_1[_i];var index_2=this._boneMask.indexOf(bone.name);if(index_2>=0&&currentBone.contains(bone)){this._boneMask.splice(index_2,1);}}}else {for(var _a=0,bones_2=bones;_a<bones_2.length;_a++){var bone=bones_2[_a];if(bone===currentBone){continue;}if(!currentBone.contains(bone)){this._boneMask.push(bone.name);}}}}}this._timelineDirty=1;};AnimationState.prototype.removeAllBoneMask=function(){this._boneMask.length=0;this._timelineDirty=1;};Object.defineProperty(AnimationState.prototype,"isFadeIn",{get:function get(){return this._fadeState<0;},enumerable:true,configurable:true});Object.defineProperty(AnimationState.prototype,"isFadeOut",{get:function get(){return this._fadeState>0;},enumerable:true,configurable:true});Object.defineProperty(AnimationState.prototype,"isFadeComplete",{get:function get(){return this._fadeState===0;},enumerable:true,configurable:true});Object.defineProperty(AnimationState.prototype,"isPlaying",{get:function get(){return (this._playheadState&2)!==0&&this._actionTimeline.playState<=0;},enumerable:true,configurable:true});Object.defineProperty(AnimationState.prototype,"isCompleted",{get:function get(){return this._actionTimeline.playState>0;},enumerable:true,configurable:true});Object.defineProperty(AnimationState.prototype,"currentPlayTimes",{get:function get(){return this._actionTimeline.currentPlayTimes;},enumerable:true,configurable:true});Object.defineProperty(AnimationState.prototype,"totalTime",{get:function get(){return this._duration;},enumerable:true,configurable:true});Object.defineProperty(AnimationState.prototype,"currentTime",{get:function get(){return this._actionTimeline.currentTime;},set:function set(value){var currentPlayTimes=this._actionTimeline.currentPlayTimes-(this._actionTimeline.playState>0?1:0);if(value<0||this._duration<value){value=value%this._duration+currentPlayTimes*this._duration;if(value<0){value+=this._duration;}}if(this.playTimes>0&&currentPlayTimes===this.playTimes-1&&value===this._duration){value=this._duration-0.000001;}if(this._time===value){return;}this._time=value;this._actionTimeline.setCurrentTime(this._time);if(this._zOrderTimeline!==null){this._zOrderTimeline.playState=-1;}for(var _i=0,_a=this._boneTimelines;_i<_a.length;_i++){var timeline=_a[_i];timeline.playState=-1;}for(var _b=0,_c=this._slotTimelines;_b<_c.length;_b++){var timeline=_c[_b];timeline.playState=-1;}},enumerable:true,configurable:true});Object.defineProperty(AnimationState.prototype,"animationData",{get:function get(){return this._animationData;},enumerable:true,configurable:true});return AnimationState;}(dragonBones.BaseObject);dragonBones.AnimationState=AnimationState;var BonePose=function(_super){__extends(BonePose,_super);function BonePose(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.current=new dragonBones.Transform();_this.delta=new dragonBones.Transform();_this.result=new dragonBones.Transform();return _this;}BonePose.toString=function(){return "[class dragonBones.BonePose]";};BonePose.prototype._onClear=function(){this.current.identity();this.delta.identity();this.result.identity();};return BonePose;}(dragonBones.BaseObject);dragonBones.BonePose=BonePose;var BlendState=function(){function BlendState(){}BlendState.prototype.update=function(weight,p_layer){if(this.dirty){if(this.leftWeight>0.0){if(this.layer!==p_layer){if(this.layerWeight>=this.leftWeight){this.leftWeight=0.0;return 0;}else {this.layer=p_layer;this.leftWeight-=this.layerWeight;this.layerWeight=0.0;}}}else {return 0;}weight*=this.leftWeight;this.layerWeight+=weight;this.blendWeight=weight;return 2;}this.dirty=true;this.layer=p_layer;this.layerWeight=weight;this.leftWeight=1.0;this.blendWeight=weight;return 1;};BlendState.prototype.clear=function(){this.dirty=false;this.layer=0;this.leftWeight=0.0;this.layerWeight=0.0;this.blendWeight=0.0;};return BlendState;}();dragonBones.BlendState=BlendState;})(dragonBones||(dragonBones={}));(function(dragonBones){var TimelineState=function(_super){__extends(TimelineState,_super);function TimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}TimelineState.prototype._onClear=function(){this.playState=-1;this.currentPlayTimes=-1;this.currentTime=-1.0;this._tweenState=0;this._frameRate=0;this._frameValueOffset=0;this._frameCount=0;this._frameOffset=0;this._frameIndex=-1;this._frameRateR=0.0;this._position=0.0;this._duration=0.0;this._timeScale=1.0;this._timeOffset=0.0;this._dragonBonesData=null;this._animationData=null;this._timelineData=null;this._armature=null;this._animationState=null;this._actionTimeline=null;this._frameArray=null;this._frameIntArray=null;this._frameFloatArray=null;this._timelineArray=null;this._frameIndices=null;};TimelineState.prototype._setCurrentTime=function(passedTime){var prevState=this.playState;var prevPlayTimes=this.currentPlayTimes;var prevTime=this.currentTime;if(this._actionTimeline!==null&&this._frameCount<=1){this.playState=this._actionTimeline.playState>=0?1:-1;this.currentPlayTimes=1;this.currentTime=this._actionTimeline.currentTime;}else if(this._actionTimeline===null||this._timeScale!==1.0||this._timeOffset!==0.0){var playTimes=this._animationState.playTimes;var totalTime=playTimes*this._duration;passedTime*=this._timeScale;if(this._timeOffset!==0.0){passedTime+=this._timeOffset*this._animationData.duration;}if(playTimes>0&&(passedTime>=totalTime||passedTime<=-totalTime)){if(this.playState<=0&&this._animationState._playheadState===3){this.playState=1;}this.currentPlayTimes=playTimes;if(passedTime<0.0){this.currentTime=0.0;}else {this.currentTime=this._duration+0.000001;}}else {if(this.playState!==0&&this._animationState._playheadState===3){this.playState=0;}if(passedTime<0.0){passedTime=-passedTime;this.currentPlayTimes=Math.floor(passedTime/this._duration);this.currentTime=this._duration-passedTime%this._duration;}else {this.currentPlayTimes=Math.floor(passedTime/this._duration);this.currentTime=passedTime%this._duration;}}this.currentTime+=this._position;}else {this.playState=this._actionTimeline.playState;this.currentPlayTimes=this._actionTimeline.currentPlayTimes;this.currentTime=this._actionTimeline.currentTime;}if(this.currentPlayTimes===prevPlayTimes&&this.currentTime===prevTime){return false;}if(prevState<0&&this.playState!==prevState||this.playState<=0&&this.currentPlayTimes!==prevPlayTimes){this._frameIndex=-1;}return true;};TimelineState.prototype.init=function(armature,animationState,timelineData){this._armature=armature;this._animationState=animationState;this._timelineData=timelineData;this._actionTimeline=this._animationState._actionTimeline;if(this===this._actionTimeline){this._actionTimeline=null;}this._animationData=this._animationState._animationData;this._frameRate=this._animationData.parent.frameRate;this._frameRateR=1.0/this._frameRate;this._position=this._animationState._position;this._duration=this._animationState._duration;this._dragonBonesData=this._animationData.parent.parent;if(this._timelineData!==null){this._frameIntArray=this._dragonBonesData.frameIntArray;this._frameFloatArray=this._dragonBonesData.frameFloatArray;this._frameArray=this._dragonBonesData.frameArray;this._timelineArray=this._dragonBonesData.timelineArray;this._frameIndices=this._dragonBonesData.frameIndices;this._frameCount=this._timelineArray[this._timelineData.offset+2];this._frameValueOffset=this._timelineArray[this._timelineData.offset+4];this._timeScale=100.0/this._timelineArray[this._timelineData.offset+0];this._timeOffset=this._timelineArray[this._timelineData.offset+1]*0.01;}};TimelineState.prototype.fadeOut=function(){};TimelineState.prototype.update=function(passedTime){if(this._setCurrentTime(passedTime)){if(this._frameCount>1){var timelineFrameIndex=Math.floor(this.currentTime*this._frameRate);var frameIndex=this._frameIndices[this._timelineData.frameIndicesOffset+timelineFrameIndex];if(this._frameIndex!==frameIndex){this._frameIndex=frameIndex;this._frameOffset=this._animationData.frameOffset+this._timelineArray[this._timelineData.offset+5+this._frameIndex];this._onArriveAtFrame();}}else if(this._frameIndex<0){this._frameIndex=0;if(this._timelineData!==null){this._frameOffset=this._animationData.frameOffset+this._timelineArray[this._timelineData.offset+5];}this._onArriveAtFrame();}if(this._tweenState!==0){this._onUpdateFrame();}}};return TimelineState;}(dragonBones.BaseObject);dragonBones.TimelineState=TimelineState;var TweenTimelineState=function(_super){__extends(TweenTimelineState,_super);function TweenTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}TweenTimelineState._getEasingValue=function(tweenType,progress,easing){var value=progress;switch(tweenType){case 3:value=Math.pow(progress,2.0);break;case 4:value=1.0-Math.pow(1.0-progress,2.0);break;case 5:value=0.5*(1.0-Math.cos(progress*Math.PI));break;}return (value-progress)*easing+progress;};TweenTimelineState._getEasingCurveValue=function(progress,samples,count,offset){if(progress<=0.0){return 0.0;}else if(progress>=1.0){return 1.0;}var segmentCount=count+1;var valueIndex=Math.floor(progress*segmentCount);var fromValue=valueIndex===0?0.0:samples[offset+valueIndex-1];var toValue=valueIndex===segmentCount-1?10000.0:samples[offset+valueIndex];return (fromValue+(toValue-fromValue)*(progress*segmentCount-valueIndex))*0.0001;};TweenTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this._tweenType=0;this._curveCount=0;this._framePosition=0.0;this._frameDurationR=0.0;this._tweenProgress=0.0;this._tweenEasing=0.0;};TweenTimelineState.prototype._onArriveAtFrame=function(){if(this._frameCount>1&&(this._frameIndex!==this._frameCount-1||this._animationState.playTimes===0||this._animationState.currentPlayTimes<this._animationState.playTimes-1)){this._tweenType=this._frameArray[this._frameOffset+1];this._tweenState=this._tweenType===0?1:2;if(this._tweenType===2){this._curveCount=this._frameArray[this._frameOffset+2];}else if(this._tweenType!==0&&this._tweenType!==1){this._tweenEasing=this._frameArray[this._frameOffset+2]*0.01;}this._framePosition=this._frameArray[this._frameOffset]*this._frameRateR;if(this._frameIndex===this._frameCount-1){this._frameDurationR=1.0/(this._animationData.duration-this._framePosition);}else {var nextFrameOffset=this._animationData.frameOffset+this._timelineArray[this._timelineData.offset+5+this._frameIndex+1];var frameDuration=this._frameArray[nextFrameOffset]*this._frameRateR-this._framePosition;if(frameDuration>0){this._frameDurationR=1.0/frameDuration;}else {this._frameDurationR=0.0;}}}else {this._tweenState=1;}};TweenTimelineState.prototype._onUpdateFrame=function(){if(this._tweenState===2){this._tweenProgress=(this.currentTime-this._framePosition)*this._frameDurationR;if(this._tweenType===2){this._tweenProgress=TweenTimelineState._getEasingCurveValue(this._tweenProgress,this._frameArray,this._curveCount,this._frameOffset+3);}else if(this._tweenType!==1){this._tweenProgress=TweenTimelineState._getEasingValue(this._tweenType,this._tweenProgress,this._tweenEasing);}}else {this._tweenProgress=0.0;}};return TweenTimelineState;}(TimelineState);dragonBones.TweenTimelineState=TweenTimelineState;var BoneTimelineState=function(_super){__extends(BoneTimelineState,_super);function BoneTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}BoneTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this.bone=null;this.bonePose=null;};BoneTimelineState.prototype.blend=function(state){var blendWeight=this.bone._blendState.blendWeight;var animationPose=this.bone.animationPose;var result=this.bonePose.result;if(state===2){animationPose.x+=result.x*blendWeight;animationPose.y+=result.y*blendWeight;animationPose.rotation+=result.rotation*blendWeight;animationPose.skew+=result.skew*blendWeight;animationPose.scaleX+=(result.scaleX-1.0)*blendWeight;animationPose.scaleY+=(result.scaleY-1.0)*blendWeight;}else if(blendWeight!==1.0){animationPose.x=result.x*blendWeight;animationPose.y=result.y*blendWeight;animationPose.rotation=result.rotation*blendWeight;animationPose.skew=result.skew*blendWeight;animationPose.scaleX=(result.scaleX-1.0)*blendWeight+1.0;animationPose.scaleY=(result.scaleY-1.0)*blendWeight+1.0;}else {animationPose.x=result.x;animationPose.y=result.y;animationPose.rotation=result.rotation;animationPose.skew=result.skew;animationPose.scaleX=result.scaleX;animationPose.scaleY=result.scaleY;}if(this._animationState._fadeState!==0||this._animationState._subFadeState!==0){this.bone._transformDirty=true;}};return BoneTimelineState;}(TweenTimelineState);dragonBones.BoneTimelineState=BoneTimelineState;var SlotTimelineState=function(_super){__extends(SlotTimelineState,_super);function SlotTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}SlotTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this.slot=null;};return SlotTimelineState;}(TweenTimelineState);dragonBones.SlotTimelineState=SlotTimelineState;var ConstraintTimelineState=function(_super){__extends(ConstraintTimelineState,_super);function ConstraintTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}ConstraintTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this.constraint=null;};return ConstraintTimelineState;}(TweenTimelineState);dragonBones.ConstraintTimelineState=ConstraintTimelineState;})(dragonBones||(dragonBones={}));(function(dragonBones){var ActionTimelineState=function(_super){__extends(ActionTimelineState,_super);function ActionTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}ActionTimelineState.toString=function(){return "[class dragonBones.ActionTimelineState]";};ActionTimelineState.prototype._onCrossFrame=function(frameIndex){var eventDispatcher=this._armature.eventDispatcher;if(this._animationState.actionEnabled){var frameOffset=this._animationData.frameOffset+this._timelineArray[this._timelineData.offset+5+frameIndex];var actionCount=this._frameArray[frameOffset+1];var actions=this._animationData.parent.actions;for(var i=0;i<actionCount;++i){var actionIndex=this._frameArray[frameOffset+2+i];var action=actions[actionIndex];if(action.type===0){var eventObject=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);eventObject.time=this._frameArray[frameOffset]/this._frameRate;eventObject.animationState=this._animationState;dragonBones.EventObject.actionDataToInstance(action,eventObject,this._armature);this._armature._bufferAction(eventObject,true);}else {var eventType=action.type===10?dragonBones.EventObject.FRAME_EVENT:dragonBones.EventObject.SOUND_EVENT;if(action.type===11||eventDispatcher.hasDBEventListener(eventType)){var eventObject=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);eventObject.time=this._frameArray[frameOffset]/this._frameRate;eventObject.animationState=this._animationState;dragonBones.EventObject.actionDataToInstance(action,eventObject,this._armature);this._armature._dragonBones.bufferEvent(eventObject);}}}}};ActionTimelineState.prototype._onArriveAtFrame=function(){};ActionTimelineState.prototype._onUpdateFrame=function(){};ActionTimelineState.prototype.update=function(passedTime){var prevState=this.playState;var prevPlayTimes=this.currentPlayTimes;var prevTime=this.currentTime;if(this._setCurrentTime(passedTime)){var eventDispatcher=this._armature.eventDispatcher;if(prevState<0){if(this.playState!==prevState){if(this._animationState.displayControl&&this._animationState.resetToPose){this._armature._sortZOrder(null,0);}prevPlayTimes=this.currentPlayTimes;if(eventDispatcher.hasDBEventListener(dragonBones.EventObject.START)){var eventObject=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);eventObject.type=dragonBones.EventObject.START;eventObject.armature=this._armature;eventObject.animationState=this._animationState;this._armature._dragonBones.bufferEvent(eventObject);}}else {return;}}var isReverse=this._animationState.timeScale<0.0;var loopCompleteEvent=null;var completeEvent=null;if(this.currentPlayTimes!==prevPlayTimes){if(eventDispatcher.hasDBEventListener(dragonBones.EventObject.LOOP_COMPLETE)){loopCompleteEvent=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);loopCompleteEvent.type=dragonBones.EventObject.LOOP_COMPLETE;loopCompleteEvent.armature=this._armature;loopCompleteEvent.animationState=this._animationState;}if(this.playState>0){if(eventDispatcher.hasDBEventListener(dragonBones.EventObject.COMPLETE)){completeEvent=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);completeEvent.type=dragonBones.EventObject.COMPLETE;completeEvent.armature=this._armature;completeEvent.animationState=this._animationState;}}}if(this._frameCount>1){var timelineData=this._timelineData;var timelineFrameIndex=Math.floor(this.currentTime*this._frameRate);var frameIndex=this._frameIndices[timelineData.frameIndicesOffset+timelineFrameIndex];if(this._frameIndex!==frameIndex){var crossedFrameIndex=this._frameIndex;this._frameIndex=frameIndex;if(this._timelineArray!==null){this._frameOffset=this._animationData.frameOffset+this._timelineArray[timelineData.offset+5+this._frameIndex];if(isReverse){if(crossedFrameIndex<0){var prevFrameIndex=Math.floor(prevTime*this._frameRate);crossedFrameIndex=this._frameIndices[timelineData.frameIndicesOffset+prevFrameIndex];if(this.currentPlayTimes===prevPlayTimes){if(crossedFrameIndex===frameIndex){crossedFrameIndex=-1;}}}while(crossedFrameIndex>=0){var frameOffset=this._animationData.frameOffset+this._timelineArray[timelineData.offset+5+crossedFrameIndex];var framePosition=this._frameArray[frameOffset]/this._frameRate;if(this._position<=framePosition&&framePosition<=this._position+this._duration){this._onCrossFrame(crossedFrameIndex);}if(loopCompleteEvent!==null&&crossedFrameIndex===0){this._armature._dragonBones.bufferEvent(loopCompleteEvent);loopCompleteEvent=null;}if(crossedFrameIndex>0){crossedFrameIndex--;}else {crossedFrameIndex=this._frameCount-1;}if(crossedFrameIndex===frameIndex){break;}}}else {if(crossedFrameIndex<0){var prevFrameIndex=Math.floor(prevTime*this._frameRate);crossedFrameIndex=this._frameIndices[timelineData.frameIndicesOffset+prevFrameIndex];var frameOffset=this._animationData.frameOffset+this._timelineArray[timelineData.offset+5+crossedFrameIndex];var framePosition=this._frameArray[frameOffset]/this._frameRate;if(this.currentPlayTimes===prevPlayTimes){if(prevTime<=framePosition){if(crossedFrameIndex>0){crossedFrameIndex--;}else {crossedFrameIndex=this._frameCount-1;}}else if(crossedFrameIndex===frameIndex){crossedFrameIndex=-1;}}}while(crossedFrameIndex>=0){if(crossedFrameIndex<this._frameCount-1){crossedFrameIndex++;}else {crossedFrameIndex=0;}var frameOffset=this._animationData.frameOffset+this._timelineArray[timelineData.offset+5+crossedFrameIndex];var framePosition=this._frameArray[frameOffset]/this._frameRate;if(this._position<=framePosition&&framePosition<=this._position+this._duration){this._onCrossFrame(crossedFrameIndex);}if(loopCompleteEvent!==null&&crossedFrameIndex===0){this._armature._dragonBones.bufferEvent(loopCompleteEvent);loopCompleteEvent=null;}if(crossedFrameIndex===frameIndex){break;}}}}}}else if(this._frameIndex<0){this._frameIndex=0;if(this._timelineData!==null){this._frameOffset=this._animationData.frameOffset+this._timelineArray[this._timelineData.offset+5];var framePosition=this._frameArray[this._frameOffset]/this._frameRate;if(this.currentPlayTimes===prevPlayTimes){if(prevTime<=framePosition){this._onCrossFrame(this._frameIndex);}}else if(this._position<=framePosition){if(!isReverse&&loopCompleteEvent!==null){this._armature._dragonBones.bufferEvent(loopCompleteEvent);loopCompleteEvent=null;}this._onCrossFrame(this._frameIndex);}}}if(loopCompleteEvent!==null){this._armature._dragonBones.bufferEvent(loopCompleteEvent);}if(completeEvent!==null){this._armature._dragonBones.bufferEvent(completeEvent);}}};ActionTimelineState.prototype.setCurrentTime=function(value){this._setCurrentTime(value);this._frameIndex=-1;};return ActionTimelineState;}(dragonBones.TimelineState);dragonBones.ActionTimelineState=ActionTimelineState;var ZOrderTimelineState=function(_super){__extends(ZOrderTimelineState,_super);function ZOrderTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}ZOrderTimelineState.toString=function(){return "[class dragonBones.ZOrderTimelineState]";};ZOrderTimelineState.prototype._onArriveAtFrame=function(){if(this.playState>=0){var count=this._frameArray[this._frameOffset+1];if(count>0){this._armature._sortZOrder(this._frameArray,this._frameOffset+2);}else {this._armature._sortZOrder(null,0);}}};ZOrderTimelineState.prototype._onUpdateFrame=function(){};return ZOrderTimelineState;}(dragonBones.TimelineState);dragonBones.ZOrderTimelineState=ZOrderTimelineState;var BoneAllTimelineState=function(_super){__extends(BoneAllTimelineState,_super);function BoneAllTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}BoneAllTimelineState.toString=function(){return "[class dragonBones.BoneAllTimelineState]";};BoneAllTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);if(this._timelineData!==null){var valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset+this._frameIndex*6;var scale=this._armature._armatureData.scale;var frameFloatArray=this._frameFloatArray;var current=this.bonePose.current;var delta=this.bonePose.delta;current.x=frameFloatArray[valueOffset++]*scale;current.y=frameFloatArray[valueOffset++]*scale;current.rotation=frameFloatArray[valueOffset++];current.skew=frameFloatArray[valueOffset++];current.scaleX=frameFloatArray[valueOffset++];current.scaleY=frameFloatArray[valueOffset++];if(this._tweenState===2){if(this._frameIndex===this._frameCount-1){valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset;}delta.x=frameFloatArray[valueOffset++]*scale-current.x;delta.y=frameFloatArray[valueOffset++]*scale-current.y;delta.rotation=frameFloatArray[valueOffset++]-current.rotation;delta.skew=frameFloatArray[valueOffset++]-current.skew;delta.scaleX=frameFloatArray[valueOffset++]-current.scaleX;delta.scaleY=frameFloatArray[valueOffset++]-current.scaleY;}else {delta.x=0.0;delta.y=0.0;delta.rotation=0.0;delta.skew=0.0;delta.scaleX=0.0;delta.scaleY=0.0;}}else {var current=this.bonePose.current;var delta=this.bonePose.delta;current.x=0.0;current.y=0.0;current.rotation=0.0;current.skew=0.0;current.scaleX=1.0;current.scaleY=1.0;delta.x=0.0;delta.y=0.0;delta.rotation=0.0;delta.skew=0.0;delta.scaleX=0.0;delta.scaleY=0.0;}};BoneAllTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);var current=this.bonePose.current;var delta=this.bonePose.delta;var result=this.bonePose.result;this.bone._transformDirty=true;if(this._tweenState!==2){this._tweenState=0;}result.x=current.x+delta.x*this._tweenProgress;result.y=current.y+delta.y*this._tweenProgress;result.rotation=current.rotation+delta.rotation*this._tweenProgress;result.skew=current.skew+delta.skew*this._tweenProgress;result.scaleX=current.scaleX+delta.scaleX*this._tweenProgress;result.scaleY=current.scaleY+delta.scaleY*this._tweenProgress;};BoneAllTimelineState.prototype.fadeOut=function(){var result=this.bonePose.result;result.rotation=dragonBones.Transform.normalizeRadian(result.rotation);result.skew=dragonBones.Transform.normalizeRadian(result.skew);};return BoneAllTimelineState;}(dragonBones.BoneTimelineState);dragonBones.BoneAllTimelineState=BoneAllTimelineState;var BoneTranslateTimelineState=function(_super){__extends(BoneTranslateTimelineState,_super);function BoneTranslateTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}BoneTranslateTimelineState.toString=function(){return "[class dragonBones.BoneTranslateTimelineState]";};BoneTranslateTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);if(this._timelineData!==null){var valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset+this._frameIndex*2;var scale=this._armature._armatureData.scale;var frameFloatArray=this._frameFloatArray;var current=this.bonePose.current;var delta=this.bonePose.delta;current.x=frameFloatArray[valueOffset++]*scale;current.y=frameFloatArray[valueOffset++]*scale;if(this._tweenState===2){if(this._frameIndex===this._frameCount-1){valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset;}delta.x=frameFloatArray[valueOffset++]*scale-current.x;delta.y=frameFloatArray[valueOffset++]*scale-current.y;}else {delta.x=0.0;delta.y=0.0;}}else {var current=this.bonePose.current;var delta=this.bonePose.delta;current.x=0.0;current.y=0.0;delta.x=0.0;delta.y=0.0;}};BoneTranslateTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);var current=this.bonePose.current;var delta=this.bonePose.delta;var result=this.bonePose.result;this.bone._transformDirty=true;if(this._tweenState!==2){this._tweenState=0;}result.x=current.x+delta.x*this._tweenProgress;result.y=current.y+delta.y*this._tweenProgress;};return BoneTranslateTimelineState;}(dragonBones.BoneTimelineState);dragonBones.BoneTranslateTimelineState=BoneTranslateTimelineState;var BoneRotateTimelineState=function(_super){__extends(BoneRotateTimelineState,_super);function BoneRotateTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}BoneRotateTimelineState.toString=function(){return "[class dragonBones.BoneRotateTimelineState]";};BoneRotateTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);if(this._timelineData!==null){var valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset+this._frameIndex*2;var frameFloatArray=this._frameFloatArray;var current=this.bonePose.current;var delta=this.bonePose.delta;current.rotation=frameFloatArray[valueOffset++];current.skew=frameFloatArray[valueOffset++];if(this._tweenState===2){if(this._frameIndex===this._frameCount-1){valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset;delta.rotation=dragonBones.Transform.normalizeRadian(frameFloatArray[valueOffset++]-current.rotation);}else {delta.rotation=frameFloatArray[valueOffset++]-current.rotation;}delta.skew=frameFloatArray[valueOffset++]-current.skew;}else {delta.rotation=0.0;delta.skew=0.0;}}else {var current=this.bonePose.current;var delta=this.bonePose.delta;current.rotation=0.0;current.skew=0.0;delta.rotation=0.0;delta.skew=0.0;}};BoneRotateTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);var current=this.bonePose.current;var delta=this.bonePose.delta;var result=this.bonePose.result;this.bone._transformDirty=true;if(this._tweenState!==2){this._tweenState=0;}result.rotation=current.rotation+delta.rotation*this._tweenProgress;result.skew=current.skew+delta.skew*this._tweenProgress;};BoneRotateTimelineState.prototype.fadeOut=function(){var result=this.bonePose.result;result.rotation=dragonBones.Transform.normalizeRadian(result.rotation);result.skew=dragonBones.Transform.normalizeRadian(result.skew);};return BoneRotateTimelineState;}(dragonBones.BoneTimelineState);dragonBones.BoneRotateTimelineState=BoneRotateTimelineState;var BoneScaleTimelineState=function(_super){__extends(BoneScaleTimelineState,_super);function BoneScaleTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}BoneScaleTimelineState.toString=function(){return "[class dragonBones.BoneScaleTimelineState]";};BoneScaleTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);if(this._timelineData!==null){var valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset+this._frameIndex*2;var frameFloatArray=this._frameFloatArray;var current=this.bonePose.current;var delta=this.bonePose.delta;current.scaleX=frameFloatArray[valueOffset++];current.scaleY=frameFloatArray[valueOffset++];if(this._tweenState===2){if(this._frameIndex===this._frameCount-1){valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset;}delta.scaleX=frameFloatArray[valueOffset++]-current.scaleX;delta.scaleY=frameFloatArray[valueOffset++]-current.scaleY;}else {delta.scaleX=0.0;delta.scaleY=0.0;}}else {var current=this.bonePose.current;var delta=this.bonePose.delta;current.scaleX=1.0;current.scaleY=1.0;delta.scaleX=0.0;delta.scaleY=0.0;}};BoneScaleTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);var current=this.bonePose.current;var delta=this.bonePose.delta;var result=this.bonePose.result;this.bone._transformDirty=true;if(this._tweenState!==2){this._tweenState=0;}result.scaleX=current.scaleX+delta.scaleX*this._tweenProgress;result.scaleY=current.scaleY+delta.scaleY*this._tweenProgress;};return BoneScaleTimelineState;}(dragonBones.BoneTimelineState);dragonBones.BoneScaleTimelineState=BoneScaleTimelineState;var SurfaceTimelineState=function(_super){__extends(SurfaceTimelineState,_super);function SurfaceTimelineState(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._current=[];_this._delta=[];_this._result=[];return _this;}SurfaceTimelineState.toString=function(){return "[class dragonBones.SurfaceTimelineState]";};SurfaceTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this.surface=null;this._frameFloatOffset=0;this._valueCount=0;this._deformCount=0;this._valueOffset=0;this._current.length=0;this._delta.length=0;this._result.length=0;};SurfaceTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);if(this._timelineData!==null){var valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset+this._frameIndex*this._valueCount;var scale=this._armature._armatureData.scale;var frameFloatArray=this._frameFloatArray;if(this._tweenState===2){var nextValueOffset=valueOffset+this._valueCount;if(this._frameIndex===this._frameCount-1){nextValueOffset=this._animationData.frameFloatOffset+this._frameValueOffset;}for(var i=0;i<this._valueCount;++i){this._delta[i]=frameFloatArray[nextValueOffset+i]*scale-(this._current[i]=frameFloatArray[valueOffset+i]*scale);}}else {for(var i=0;i<this._valueCount;++i){this._current[i]=frameFloatArray[valueOffset+i]*scale;}}}else {for(var i=0;i<this._valueCount;++i){this._current[i]=0.0;}}};SurfaceTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);this.surface._transformDirty=true;if(this._tweenState!==2){this._tweenState=0;}for(var i=0;i<this._valueCount;++i){this._result[i]=this._current[i]+this._delta[i]*this._tweenProgress;}};SurfaceTimelineState.prototype.init=function(armature,animationState,timelineData){_super.prototype.init.call(this,armature,animationState,timelineData);if(this._timelineData!==null){var frameIntOffset=this._animationData.frameIntOffset+this._timelineArray[this._timelineData.offset+3];this._deformCount=this._frameIntArray[frameIntOffset+1];this._valueCount=this._frameIntArray[frameIntOffset+2];this._valueOffset=this._frameIntArray[frameIntOffset+3];this._frameFloatOffset=this._frameIntArray[frameIntOffset+4]+this._animationData.frameFloatOffset;}else {this._deformCount=this.surface._deformVertices.length;this._valueCount=this._deformCount;this._valueOffset=0;this._frameFloatOffset=0;}this._current.length=this._valueCount;this._delta.length=this._valueCount;this._result.length=this._valueCount;for(var i=0;i<this._valueCount;++i){this._delta[i]=0.0;}};SurfaceTimelineState.prototype.blend=function(state){var blendWeight=this.surface._blendState.blendWeight;var result=this.surface._deformVertices;for(var i=0;i<this._deformCount;++i){var value=0.0;if(i<this._valueOffset){value=this._frameFloatArray[this._frameFloatOffset+i];}else if(i<this._valueOffset+this._valueCount){value=this._result[i-this._valueOffset];}else {value=this._frameFloatArray[this._frameFloatOffset+i-this._valueCount];}if(state===2){result[i]+=value*blendWeight;}else if(blendWeight!==1.0){result[i]=value*blendWeight;}else {result[i]=value;}}if(this._animationState._fadeState!==0||this._animationState._subFadeState!==0){this.surface._transformDirty=true;}};return SurfaceTimelineState;}(dragonBones.TweenTimelineState);dragonBones.SurfaceTimelineState=SurfaceTimelineState;var SlotDislayTimelineState=function(_super){__extends(SlotDislayTimelineState,_super);function SlotDislayTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}SlotDislayTimelineState.toString=function(){return "[class dragonBones.SlotDislayTimelineState]";};SlotDislayTimelineState.prototype._onArriveAtFrame=function(){if(this.playState>=0){var displayIndex=this._timelineData!==null?this._frameArray[this._frameOffset+1]:this.slot._slotData.displayIndex;if(this.slot.displayIndex!==displayIndex){this.slot._setDisplayIndex(displayIndex,true);}}};return SlotDislayTimelineState;}(dragonBones.SlotTimelineState);dragonBones.SlotDislayTimelineState=SlotDislayTimelineState;var SlotColorTimelineState=function(_super){__extends(SlotColorTimelineState,_super);function SlotColorTimelineState(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._current=[0,0,0,0,0,0,0,0];_this._delta=[0,0,0,0,0,0,0,0];_this._result=[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0];return _this;}SlotColorTimelineState.toString=function(){return "[class dragonBones.SlotColorTimelineState]";};SlotColorTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this._dirty=false;};SlotColorTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);if(this._timelineData!==null){var intArray=this._dragonBonesData.intArray;var frameIntArray=this._frameIntArray;var valueOffset=this._animationData.frameIntOffset+this._frameValueOffset+this._frameIndex*1;var colorOffset=frameIntArray[valueOffset];if(colorOffset<0){colorOffset+=65536;}this._current[0]=intArray[colorOffset++];this._current[1]=intArray[colorOffset++];this._current[2]=intArray[colorOffset++];this._current[3]=intArray[colorOffset++];this._current[4]=intArray[colorOffset++];this._current[5]=intArray[colorOffset++];this._current[6]=intArray[colorOffset++];this._current[7]=intArray[colorOffset++];if(this._tweenState===2){if(this._frameIndex===this._frameCount-1){colorOffset=frameIntArray[this._animationData.frameIntOffset+this._frameValueOffset];}else {colorOffset=frameIntArray[valueOffset+1*1];}if(colorOffset<0){colorOffset+=65536;}this._delta[0]=intArray[colorOffset++]-this._current[0];this._delta[1]=intArray[colorOffset++]-this._current[1];this._delta[2]=intArray[colorOffset++]-this._current[2];this._delta[3]=intArray[colorOffset++]-this._current[3];this._delta[4]=intArray[colorOffset++]-this._current[4];this._delta[5]=intArray[colorOffset++]-this._current[5];this._delta[6]=intArray[colorOffset++]-this._current[6];this._delta[7]=intArray[colorOffset++]-this._current[7];}}else {var color=this.slot._slotData.color;this._current[0]=color.alphaMultiplier*100.0;this._current[1]=color.redMultiplier*100.0;this._current[2]=color.greenMultiplier*100.0;this._current[3]=color.blueMultiplier*100.0;this._current[4]=color.alphaOffset;this._current[5]=color.redOffset;this._current[6]=color.greenOffset;this._current[7]=color.blueOffset;}};SlotColorTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);this._dirty=true;if(this._tweenState!==2){this._tweenState=0;}this._result[0]=(this._current[0]+this._delta[0]*this._tweenProgress)*0.01;this._result[1]=(this._current[1]+this._delta[1]*this._tweenProgress)*0.01;this._result[2]=(this._current[2]+this._delta[2]*this._tweenProgress)*0.01;this._result[3]=(this._current[3]+this._delta[3]*this._tweenProgress)*0.01;this._result[4]=this._current[4]+this._delta[4]*this._tweenProgress;this._result[5]=this._current[5]+this._delta[5]*this._tweenProgress;this._result[6]=this._current[6]+this._delta[6]*this._tweenProgress;this._result[7]=this._current[7]+this._delta[7]*this._tweenProgress;};SlotColorTimelineState.prototype.fadeOut=function(){this._tweenState=0;this._dirty=false;};SlotColorTimelineState.prototype.update=function(passedTime){_super.prototype.update.call(this,passedTime);if(this._tweenState!==0||this._dirty){var result=this.slot._colorTransform;if(this._animationState._fadeState!==0||this._animationState._subFadeState!==0){if(result.alphaMultiplier!==this._result[0]||result.redMultiplier!==this._result[1]||result.greenMultiplier!==this._result[2]||result.blueMultiplier!==this._result[3]||result.alphaOffset!==this._result[4]||result.redOffset!==this._result[5]||result.greenOffset!==this._result[6]||result.blueOffset!==this._result[7]){var fadeProgress=Math.pow(this._animationState._fadeProgress,4);result.alphaMultiplier+=(this._result[0]-result.alphaMultiplier)*fadeProgress;result.redMultiplier+=(this._result[1]-result.redMultiplier)*fadeProgress;result.greenMultiplier+=(this._result[2]-result.greenMultiplier)*fadeProgress;result.blueMultiplier+=(this._result[3]-result.blueMultiplier)*fadeProgress;result.alphaOffset+=(this._result[4]-result.alphaOffset)*fadeProgress;result.redOffset+=(this._result[5]-result.redOffset)*fadeProgress;result.greenOffset+=(this._result[6]-result.greenOffset)*fadeProgress;result.blueOffset+=(this._result[7]-result.blueOffset)*fadeProgress;this.slot._colorDirty=true;}}else if(this._dirty){this._dirty=false;if(result.alphaMultiplier!==this._result[0]||result.redMultiplier!==this._result[1]||result.greenMultiplier!==this._result[2]||result.blueMultiplier!==this._result[3]||result.alphaOffset!==this._result[4]||result.redOffset!==this._result[5]||result.greenOffset!==this._result[6]||result.blueOffset!==this._result[7]){result.alphaMultiplier=this._result[0];result.redMultiplier=this._result[1];result.greenMultiplier=this._result[2];result.blueMultiplier=this._result[3];result.alphaOffset=this._result[4];result.redOffset=this._result[5];result.greenOffset=this._result[6];result.blueOffset=this._result[7];this.slot._colorDirty=true;}}}};return SlotColorTimelineState;}(dragonBones.SlotTimelineState);dragonBones.SlotColorTimelineState=SlotColorTimelineState;var DeformTimelineState=function(_super){__extends(DeformTimelineState,_super);function DeformTimelineState(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._current=[];_this._delta=[];_this._result=[];return _this;}DeformTimelineState.toString=function(){return "[class dragonBones.DeformTimelineState]";};DeformTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this.vertexOffset=0;this._dirty=false;this._frameFloatOffset=0;this._valueCount=0;this._deformCount=0;this._valueOffset=0;this._current.length=0;this._delta.length=0;this._result.length=0;};DeformTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);if(this._timelineData!==null){var valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset+this._frameIndex*this._valueCount;var scale=this._armature._armatureData.scale;var frameFloatArray=this._frameFloatArray;if(this._tweenState===2){var nextValueOffset=valueOffset+this._valueCount;if(this._frameIndex===this._frameCount-1){nextValueOffset=this._animationData.frameFloatOffset+this._frameValueOffset;}for(var i=0;i<this._valueCount;++i){this._delta[i]=frameFloatArray[nextValueOffset+i]*scale-(this._current[i]=frameFloatArray[valueOffset+i]*scale);}}else {for(var i=0;i<this._valueCount;++i){this._current[i]=frameFloatArray[valueOffset+i]*scale;}}}else {for(var i=0;i<this._valueCount;++i){this._current[i]=0.0;}}};DeformTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);this._dirty=true;if(this._tweenState!==2){this._tweenState=0;}for(var i=0;i<this._valueCount;++i){this._result[i]=this._current[i]+this._delta[i]*this._tweenProgress;}};DeformTimelineState.prototype.init=function(armature,animationState,timelineData){_super.prototype.init.call(this,armature,animationState,timelineData);if(this._timelineData!==null){var frameIntOffset=this._animationData.frameIntOffset+this._timelineArray[this._timelineData.offset+3];this.vertexOffset=this._frameIntArray[frameIntOffset+0];if(this.vertexOffset<0){this.vertexOffset+=65536;}this._deformCount=this._frameIntArray[frameIntOffset+1];this._valueCount=this._frameIntArray[frameIntOffset+2];this._valueOffset=this._frameIntArray[frameIntOffset+3];this._frameFloatOffset=this._frameIntArray[frameIntOffset+4]+this._animationData.frameFloatOffset;}else {var deformVertices=this.slot._deformVertices;this._deformCount=deformVertices!==null?deformVertices.vertices.length:0;this._valueCount=this._deformCount;this._valueOffset=0;this._frameFloatOffset=0;}this._current.length=this._valueCount;this._delta.length=this._valueCount;this._result.length=this._valueCount;for(var i=0;i<this._valueCount;++i){this._delta[i]=0.0;}};DeformTimelineState.prototype.fadeOut=function(){this._tweenState=0;this._dirty=false;};DeformTimelineState.prototype.update=function(passedTime){var deformVertices=this.slot._deformVertices;if(deformVertices===null||deformVertices.verticesData===null||deformVertices.verticesData.offset!==this.vertexOffset){return;}_super.prototype.update.call(this,passedTime);if(this._tweenState!==0||this._dirty){var result=deformVertices.vertices;if(this._animationState._fadeState!==0||this._animationState._subFadeState!==0){var fadeProgress=Math.pow(this._animationState._fadeProgress,2);for(var i=0;i<this._deformCount;++i){if(i<this._valueOffset){result[i]+=(this._frameFloatArray[this._frameFloatOffset+i]-result[i])*fadeProgress;}else if(i<this._valueOffset+this._valueCount){result[i]+=(this._result[i-this._valueOffset]-result[i])*fadeProgress;}else {result[i]+=(this._frameFloatArray[this._frameFloatOffset+i-this._valueCount]-result[i])*fadeProgress;}}deformVertices.verticesDirty=true;}else if(this._dirty){this._dirty=false;for(var i=0;i<this._deformCount;++i){if(i<this._valueOffset){result[i]=this._frameFloatArray[this._frameFloatOffset+i];}else if(i<this._valueOffset+this._valueCount){result[i]=this._result[i-this._valueOffset];}else {result[i]=this._frameFloatArray[this._frameFloatOffset+i-this._valueCount];}}deformVertices.verticesDirty=true;}}};return DeformTimelineState;}(dragonBones.SlotTimelineState);dragonBones.DeformTimelineState=DeformTimelineState;var IKConstraintTimelineState=function(_super){__extends(IKConstraintTimelineState,_super);function IKConstraintTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}IKConstraintTimelineState.toString=function(){return "[class dragonBones.IKConstraintTimelineState]";};IKConstraintTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this._current=0.0;this._delta=0.0;};IKConstraintTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);var ikConstraint=this.constraint;if(this._timelineData!==null){var valueOffset=this._animationData.frameIntOffset+this._frameValueOffset+this._frameIndex*2;var frameIntArray=this._frameIntArray;var bendPositive=frameIntArray[valueOffset++]!==0;this._current=frameIntArray[valueOffset++]*0.01;if(this._tweenState===2){if(this._frameIndex===this._frameCount-1){valueOffset=this._animationData.frameIntOffset+this._frameValueOffset;}this._delta=frameIntArray[valueOffset+1]*0.01-this._current;}else {this._delta=0.0;}ikConstraint._bendPositive=bendPositive;}else {var ikConstraintData=ikConstraint._constraintData;this._current=ikConstraintData.weight;this._delta=0.0;ikConstraint._bendPositive=ikConstraintData.bendPositive;}ikConstraint.invalidUpdate();};IKConstraintTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);if(this._tweenState!==2){this._tweenState=0;}var ikConstraint=this.constraint;ikConstraint._weight=this._current+this._delta*this._tweenProgress;ikConstraint.invalidUpdate();};return IKConstraintTimelineState;}(dragonBones.ConstraintTimelineState);dragonBones.IKConstraintTimelineState=IKConstraintTimelineState;var AnimationTimelineState=function(_super){__extends(AnimationTimelineState,_super);function AnimationTimelineState(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._floats=[0.0,0.0,0.0,0.0,0.0,0.0];return _this;}AnimationTimelineState.toString=function(){return "[class dragonBones.AnimationTimelineState]";};AnimationTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this.animationState=null;};AnimationTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);if(this._timelineData===null){return;}var valueOffset=this._animationData.frameIntOffset+this._frameValueOffset+this._frameIndex*2;var frameRateR=1.0/this.animationState._animationData.parent.frameRate;var frameIntArray=this._frameIntArray;this._floats[0]=frameIntArray[valueOffset++]*frameRateR;this._floats[3]=frameIntArray[valueOffset++]*0.01;if(this._tweenState===2){if(this._frameIndex===this._frameCount-1){valueOffset=this._animationData.frameIntOffset+this._frameValueOffset;}this._floats[1]=frameIntArray[valueOffset++]*frameRateR-this._floats[0];this._floats[4]=frameIntArray[valueOffset++]*0.01-this._floats[3];}else {this._floats[1]=0.0;this._floats[4]=0.0;}};AnimationTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);if(this._tweenState!==2){this._tweenState=0;}if(this._floats[0]>=0.0){this._floats[2]=this._floats[0]+this._floats[1]*this._tweenProgress;}this._floats[5]=this._floats[3]+this._floats[4]*this._tweenProgress;};AnimationTimelineState.prototype.blend=function(state){var animationState=this.animationState;var blendWeight=animationState._blendState.blendWeight;if(state===2){animationState.weight+=this._floats[5]*blendWeight;animationState.currentTime+=this._floats[2]*blendWeight;}else {animationState.weight=this._floats[5]*blendWeight;animationState.currentTime=this._floats[2]*blendWeight;}};return AnimationTimelineState;}(dragonBones.TweenTimelineState);dragonBones.AnimationTimelineState=AnimationTimelineState;})(dragonBones||(dragonBones={}));(function(dragonBones){var EventObject=function(_super){__extends(EventObject,_super);function EventObject(){return _super!==null&&_super.apply(this,arguments)||this;}EventObject.actionDataToInstance=function(data,instance,armature){if(data.type===0){instance.type=EventObject.FRAME_EVENT;}else {instance.type=data.type===10?EventObject.FRAME_EVENT:EventObject.SOUND_EVENT;}instance.name=data.name;instance.armature=armature;instance.actionData=data;instance.data=data.data;if(data.bone!==null){instance.bone=armature.getBone(data.bone.name);}if(data.slot!==null){instance.slot=armature.getSlot(data.slot.name);}};EventObject.toString=function(){return "[class dragonBones.EventObject]";};EventObject.prototype._onClear=function(){this.time=0.0;this.type="";this.name="";this.armature=null;this.bone=null;this.slot=null;this.animationState=null;this.actionData=null;this.data=null;};EventObject.START="start";EventObject.LOOP_COMPLETE="loopComplete";EventObject.COMPLETE="complete";EventObject.FADE_IN="fadeIn";EventObject.FADE_IN_COMPLETE="fadeInComplete";EventObject.FADE_OUT="fadeOut";EventObject.FADE_OUT_COMPLETE="fadeOutComplete";EventObject.FRAME_EVENT="frameEvent";EventObject.SOUND_EVENT="soundEvent";return EventObject;}(dragonBones.BaseObject);dragonBones.EventObject=EventObject;})(dragonBones||(dragonBones={}));(function(dragonBones){var DataParser=function(){function DataParser(){}DataParser._getArmatureType=function(value){switch(value.toLowerCase()){case"stage":return 2;case"armature":return 0;case"movieclip":return 1;default:return 0;}};DataParser._getBoneType=function(value){switch(value.toLowerCase()){case"bone":return 0;case"surface":return 1;default:return 0;}};DataParser._getDisplayType=function(value){switch(value.toLowerCase()){case"image":return 0;case"mesh":return 2;case"armature":return 1;case"boundingbox":return 3;case"path":return 4;default:return 0;}};DataParser._getBoundingBoxType=function(value){switch(value.toLowerCase()){case"rectangle":return 0;case"ellipse":return 1;case"polygon":return 2;default:return 0;}};DataParser._getActionType=function(value){switch(value.toLowerCase()){case"play":return 0;case"frame":return 10;case"sound":return 11;default:return 0;}};DataParser._getBlendMode=function(value){switch(value.toLowerCase()){case"normal":return 0;case"add":return 1;case"alpha":return 2;case"darken":return 3;case"difference":return 4;case"erase":return 5;case"hardlight":return 6;case"invert":return 7;case"layer":return 8;case"lighten":return 9;case"multiply":return 10;case"overlay":return 11;case"screen":return 12;case"subtract":return 13;default:return 0;}};DataParser._getPositionMode=function(value){switch(value.toLocaleLowerCase()){case"percent":return 1;case"fixed":return 0;default:return 1;}};DataParser._getSpacingMode=function(value){switch(value.toLocaleLowerCase()){case"length":return 0;case"percent":return 2;case"fixed":return 1;default:return 0;}};DataParser._getRotateMode=function(value){switch(value.toLocaleLowerCase()){case"tangent":return 0;case"chain":return 1;case"chainscale":return 2;default:return 0;}};DataParser.parseDragonBonesData=function(rawData){console.warn("Deprecated.");if(rawData instanceof ArrayBuffer){return dragonBones.BinaryDataParser.getInstance().parseDragonBonesData(rawData);}else {return dragonBones.ObjectDataParser.getInstance().parseDragonBonesData(rawData);}};DataParser.parseTextureAtlasData=function(rawData,scale){if(scale===void 0){scale=1;}console.warn("已废弃");var textureAtlasData={};var subTextureList=rawData[DataParser.SUB_TEXTURE];for(var i=0,len=subTextureList.length;i<len;i++){var subTextureObject=subTextureList[i];var subTextureName=subTextureObject[DataParser.NAME];var subTextureRegion=new dragonBones.Rectangle();var subTextureFrame=null;subTextureRegion.x=subTextureObject[DataParser.X]/scale;subTextureRegion.y=subTextureObject[DataParser.Y]/scale;subTextureRegion.width=subTextureObject[DataParser.WIDTH]/scale;subTextureRegion.height=subTextureObject[DataParser.HEIGHT]/scale;if(DataParser.FRAME_WIDTH in subTextureObject){subTextureFrame=new dragonBones.Rectangle();subTextureFrame.x=subTextureObject[DataParser.FRAME_X]/scale;subTextureFrame.y=subTextureObject[DataParser.FRAME_Y]/scale;subTextureFrame.width=subTextureObject[DataParser.FRAME_WIDTH]/scale;subTextureFrame.height=subTextureObject[DataParser.FRAME_HEIGHT]/scale;}textureAtlasData[subTextureName]={region:subTextureRegion,frame:subTextureFrame,rotated:false};}return textureAtlasData;};DataParser.DATA_VERSION_2_3="2.3";DataParser.DATA_VERSION_3_0="3.0";DataParser.DATA_VERSION_4_0="4.0";DataParser.DATA_VERSION_4_5="4.5";DataParser.DATA_VERSION_5_0="5.0";DataParser.DATA_VERSION_5_5="5.5";DataParser.DATA_VERSION=DataParser.DATA_VERSION_5_5;DataParser.DATA_VERSIONS=[DataParser.DATA_VERSION_4_0,DataParser.DATA_VERSION_4_5,DataParser.DATA_VERSION_5_0,DataParser.DATA_VERSION_5_5];DataParser.TEXTURE_ATLAS="textureAtlas";DataParser.SUB_TEXTURE="SubTexture";DataParser.FORMAT="format";DataParser.IMAGE_PATH="imagePath";DataParser.WIDTH="width";DataParser.HEIGHT="height";DataParser.ROTATED="rotated";DataParser.FRAME_X="frameX";DataParser.FRAME_Y="frameY";DataParser.FRAME_WIDTH="frameWidth";DataParser.FRAME_HEIGHT="frameHeight";DataParser.DRADON_BONES="dragonBones";DataParser.USER_DATA="userData";DataParser.ARMATURE="armature";DataParser.BONE="bone";DataParser.SURFACE="surface";DataParser.SLOT="slot";DataParser.CONSTRAINT="constraint";DataParser.IK="ik";DataParser.PATH_CONSTRAINT="path";DataParser.SKIN="skin";DataParser.DISPLAY="display";DataParser.ANIMATION="animation";DataParser.Z_ORDER="zOrder";DataParser.FFD="ffd";DataParser.FRAME="frame";DataParser.TRANSLATE_FRAME="translateFrame";DataParser.ROTATE_FRAME="rotateFrame";DataParser.SCALE_FRAME="scaleFrame";DataParser.DISPLAY_FRAME="displayFrame";DataParser.COLOR_FRAME="colorFrame";DataParser.DEFAULT_ACTIONS="defaultActions";DataParser.ACTIONS="actions";DataParser.EVENTS="events";DataParser.INTS="ints";DataParser.FLOATS="floats";DataParser.STRINGS="strings";DataParser.CANVAS="canvas";DataParser.TRANSFORM="transform";DataParser.PIVOT="pivot";DataParser.AABB="aabb";DataParser.COLOR="color";DataParser.VERSION="version";DataParser.COMPATIBLE_VERSION="compatibleVersion";DataParser.FRAME_RATE="frameRate";DataParser.TYPE="type";DataParser.SUB_TYPE="subType";DataParser.NAME="name";DataParser.PARENT="parent";DataParser.TARGET="target";DataParser.STAGE="stage";DataParser.SHARE="share";DataParser.PATH="path";DataParser.LENGTH="length";DataParser.DISPLAY_INDEX="displayIndex";DataParser.BLEND_MODE="blendMode";DataParser.INHERIT_TRANSLATION="inheritTranslation";DataParser.INHERIT_ROTATION="inheritRotation";DataParser.INHERIT_SCALE="inheritScale";DataParser.INHERIT_REFLECTION="inheritReflection";DataParser.INHERIT_ANIMATION="inheritAnimation";DataParser.INHERIT_DEFORM="inheritDeform";DataParser.SEGMENT_X="segmentX";DataParser.SEGMENT_Y="segmentY";DataParser.BEND_POSITIVE="bendPositive";DataParser.CHAIN="chain";DataParser.WEIGHT="weight";DataParser.FADE_IN_TIME="fadeInTime";DataParser.PLAY_TIMES="playTimes";DataParser.SCALE="scale";DataParser.OFFSET="offset";DataParser.POSITION="position";DataParser.DURATION="duration";DataParser.TWEEN_EASING="tweenEasing";DataParser.TWEEN_ROTATE="tweenRotate";DataParser.TWEEN_SCALE="tweenScale";DataParser.CLOCK_WISE="clockwise";DataParser.CURVE="curve";DataParser.SOUND="sound";DataParser.EVENT="event";DataParser.ACTION="action";DataParser.X="x";DataParser.Y="y";DataParser.SKEW_X="skX";DataParser.SKEW_Y="skY";DataParser.SCALE_X="scX";DataParser.SCALE_Y="scY";DataParser.VALUE="value";DataParser.ROTATE="rotate";DataParser.SKEW="skew";DataParser.ALPHA_OFFSET="aO";DataParser.RED_OFFSET="rO";DataParser.GREEN_OFFSET="gO";DataParser.BLUE_OFFSET="bO";DataParser.ALPHA_MULTIPLIER="aM";DataParser.RED_MULTIPLIER="rM";DataParser.GREEN_MULTIPLIER="gM";DataParser.BLUE_MULTIPLIER="bM";DataParser.UVS="uvs";DataParser.VERTICES="vertices";DataParser.TRIANGLES="triangles";DataParser.WEIGHTS="weights";DataParser.SLOT_POSE="slotPose";DataParser.BONE_POSE="bonePose";DataParser.GLUE_WEIGHTS="glueWeights";DataParser.GLUE_MESHES="glueMeshes";DataParser.BONES="bones";DataParser.POSITION_MODE="positionMode";DataParser.SPACING_MODE="spacingMode";DataParser.ROTATE_MODE="rotateMode";DataParser.SPACING="spacing";DataParser.ROTATE_OFFSET="rotateOffset";DataParser.ROTATE_MIX="rotateMix";DataParser.TRANSLATE_MIX="translateMix";DataParser.TARGET_DISPLAY="targetDisplay";DataParser.CLOSED="closed";DataParser.CONSTANT_SPEED="constantSpeed";DataParser.VERTEX_COUNT="vertexCount";DataParser.LENGTHS="lengths";DataParser.GOTO_AND_PLAY="gotoAndPlay";DataParser.DEFAULT_NAME="default";return DataParser;}();dragonBones.DataParser=DataParser;})(dragonBones||(dragonBones={}));(function(dragonBones){var ObjectDataParser=function(_super){__extends(ObjectDataParser,_super);function ObjectDataParser(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._rawTextureAtlasIndex=0;_this._rawBones=[];_this._data=null;_this._armature=null;_this._bone=null;_this._surface=null;_this._slot=null;_this._skin=null;_this._mesh=null;_this._animation=null;_this._timeline=null;_this._rawTextureAtlases=null;_this._defaultColorOffset=-1;_this._prevClockwise=0;_this._prevRotation=0.0;_this._helpMatrixA=new dragonBones.Matrix();_this._helpMatrixB=new dragonBones.Matrix();_this._helpTransform=new dragonBones.Transform();_this._helpColorTransform=new dragonBones.ColorTransform();_this._helpPoint=new dragonBones.Point();_this._helpArray=[];_this._intArray=[];_this._floatArray=[];_this._frameIntArray=[];_this._frameFloatArray=[];_this._frameArray=[];_this._timelineArray=[];_this._cacheRawMeshes=[];_this._cacheMeshes=[];_this._actionFrames=[];_this._weightSlotPose={};_this._weightBonePoses={};_this._cacheBones={};_this._slotChildActions={};return _this;}ObjectDataParser._getBoolean=function(rawData,key,defaultValue){if(key in rawData){var value=rawData[key];var type=typeof value;if(type==="boolean"){return value;}else if(type==="string"){switch(value){case"0":case"NaN":case"":case"false":case"null":case"undefined":return false;default:return true;}}else {return !!value;}}return defaultValue;};ObjectDataParser._getNumber=function(rawData,key,defaultValue){if(key in rawData){var value=rawData[key];if(value===null||value==="NaN"){return defaultValue;}return +value||0;}return defaultValue;};ObjectDataParser._getString=function(rawData,key,defaultValue){if(key in rawData){var value=rawData[key];var type=typeof value;if(type==="string"){if(dragonBones.DragonBones.webAssembly){for(var i=0,l=value.length;i<l;++i){if(value.charCodeAt(i)>255){return encodeURI(value);}}}return value;}return String(value);}return defaultValue;};ObjectDataParser.prototype._getCurvePoint=function(x1,y1,x2,y2,x3,y3,x4,y4,t,result){var l_t=1.0-t;var powA=l_t*l_t;var powB=t*t;var kA=l_t*powA;var kB=3.0*t*powA;var kC=3.0*l_t*powB;var kD=t*powB;result.x=kA*x1+kB*x2+kC*x3+kD*x4;result.y=kA*y1+kB*y2+kC*y3+kD*y4;};ObjectDataParser.prototype._samplingEasingCurve=function(curve,samples){var curveCount=curve.length;var stepIndex=-2;for(var i=0,l=samples.length;i<l;++i){var t=(i+1)/(l+1);while((stepIndex+6<curveCount?curve[stepIndex+6]:1)<t){stepIndex+=6;}var isInCurve=stepIndex>=0&&stepIndex+6<curveCount;var x1=isInCurve?curve[stepIndex]:0.0;var y1=isInCurve?curve[stepIndex+1]:0.0;var x2=curve[stepIndex+2];var y2=curve[stepIndex+3];var x3=curve[stepIndex+4];var y3=curve[stepIndex+5];var x4=isInCurve?curve[stepIndex+6]:1.0;var y4=isInCurve?curve[stepIndex+7]:1.0;var lower=0.0;var higher=1.0;while(higher-lower>0.0001){var percentage=(higher+lower)*0.5;this._getCurvePoint(x1,y1,x2,y2,x3,y3,x4,y4,percentage,this._helpPoint);if(t-this._helpPoint.x>0.0){lower=percentage;}else {higher=percentage;}}samples[i]=this._helpPoint.y;}};ObjectDataParser.prototype._parseActionDataInFrame=function(rawData,frameStart,bone,slot){if(dragonBones.DataParser.EVENT in rawData){this._mergeActionFrame(rawData[dragonBones.DataParser.EVENT],frameStart,10,bone,slot);}if(dragonBones.DataParser.SOUND in rawData){this._mergeActionFrame(rawData[dragonBones.DataParser.SOUND],frameStart,11,bone,slot);}if(dragonBones.DataParser.ACTION in rawData){this._mergeActionFrame(rawData[dragonBones.DataParser.ACTION],frameStart,0,bone,slot);}if(dragonBones.DataParser.EVENTS in rawData){this._mergeActionFrame(rawData[dragonBones.DataParser.EVENTS],frameStart,10,bone,slot);}if(dragonBones.DataParser.ACTIONS in rawData){this._mergeActionFrame(rawData[dragonBones.DataParser.ACTIONS],frameStart,0,bone,slot);}};ObjectDataParser.prototype._mergeActionFrame=function(rawData,frameStart,type,bone,slot){var actionOffset=dragonBones.DragonBones.webAssembly?this._armature.actions.size():this._armature.actions.length;var actions=this._parseActionData(rawData,type,bone,slot);var frameIndex=0;var frame=null;for(var _i=0,actions_2=actions;_i<actions_2.length;_i++){var action=actions_2[_i];this._armature.addAction(action,false);}if(this._actionFrames.length===0){frame=new ActionFrame();frame.frameStart=0;this._actionFrames.push(frame);frame=null;}for(var _a=0,_b=this._actionFrames;_a<_b.length;_a++){var eachFrame=_b[_a];if(eachFrame.frameStart===frameStart){frame=eachFrame;break;}else if(eachFrame.frameStart>frameStart){break;}frameIndex++;}if(frame===null){frame=new ActionFrame();frame.frameStart=frameStart;this._actionFrames.splice(frameIndex+1,0,frame);}for(var i=0;i<actions.length;++i){frame.actions.push(actionOffset+i);}};ObjectDataParser.prototype._parseArmature=function(rawData,scale){var armature=dragonBones.BaseObject.borrowObject(dragonBones.ArmatureData);armature.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");armature.frameRate=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.FRAME_RATE,this._data.frameRate);armature.scale=scale;if(dragonBones.DataParser.TYPE in rawData&&typeof rawData[dragonBones.DataParser.TYPE]==="string"){armature.type=dragonBones.DataParser._getArmatureType(rawData[dragonBones.DataParser.TYPE]);}else {armature.type=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.TYPE,0);}if(armature.frameRate===0){armature.frameRate=24;}this._armature=armature;if(dragonBones.DataParser.CANVAS in rawData){var rawCanvas=rawData[dragonBones.DataParser.CANVAS];var canvas=dragonBones.BaseObject.borrowObject(dragonBones.CanvasData);if(dragonBones.DataParser.COLOR in rawCanvas){canvas.hasBackground=true;}else {canvas.hasBackground=false;}canvas.color=ObjectDataParser._getNumber(rawCanvas,dragonBones.DataParser.COLOR,0);canvas.x=ObjectDataParser._getNumber(rawCanvas,dragonBones.DataParser.X,0)*armature.scale;canvas.y=ObjectDataParser._getNumber(rawCanvas,dragonBones.DataParser.Y,0)*armature.scale;canvas.width=ObjectDataParser._getNumber(rawCanvas,dragonBones.DataParser.WIDTH,0)*armature.scale;canvas.height=ObjectDataParser._getNumber(rawCanvas,dragonBones.DataParser.HEIGHT,0)*armature.scale;armature.canvas=canvas;}if(dragonBones.DataParser.AABB in rawData){var rawAABB=rawData[dragonBones.DataParser.AABB];armature.aabb.x=ObjectDataParser._getNumber(rawAABB,dragonBones.DataParser.X,0.0)*armature.scale;armature.aabb.y=ObjectDataParser._getNumber(rawAABB,dragonBones.DataParser.Y,0.0)*armature.scale;armature.aabb.width=ObjectDataParser._getNumber(rawAABB,dragonBones.DataParser.WIDTH,0.0)*armature.scale;armature.aabb.height=ObjectDataParser._getNumber(rawAABB,dragonBones.DataParser.HEIGHT,0.0)*armature.scale;}if(dragonBones.DataParser.BONE in rawData){var rawBones=rawData[dragonBones.DataParser.BONE];for(var _i=0,rawBones_1=rawBones;_i<rawBones_1.length;_i++){var rawBone=rawBones_1[_i];var parentName=ObjectDataParser._getString(rawBone,dragonBones.DataParser.PARENT,"");var bone=this._parseBone(rawBone);if(parentName.length>0){var parent_1=armature.getBone(parentName);if(parent_1!==null){bone.parent=parent_1;}else {if(!(parentName in this._cacheBones)){this._cacheBones[parentName]=[];}this._cacheBones[parentName].push(bone);}}if(bone.name in this._cacheBones){for(var _a=0,_b=this._cacheBones[bone.name];_a<_b.length;_a++){var child=_b[_a];child.parent=bone;}delete this._cacheBones[bone.name];}armature.addBone(bone);this._rawBones.push(bone);}}if(dragonBones.DataParser.IK in rawData){var rawIKS=rawData[dragonBones.DataParser.IK];for(var _c=0,rawIKS_1=rawIKS;_c<rawIKS_1.length;_c++){var rawIK=rawIKS_1[_c];var constraint=this._parseIKConstraint(rawIK);if(constraint){armature.addConstraint(constraint);}}}armature.sortBones();if(dragonBones.DataParser.SLOT in rawData){var zOrder=0;var rawSlots=rawData[dragonBones.DataParser.SLOT];for(var _d=0,rawSlots_1=rawSlots;_d<rawSlots_1.length;_d++){var rawSlot=rawSlots_1[_d];armature.addSlot(this._parseSlot(rawSlot,zOrder++));}}if(dragonBones.DataParser.SKIN in rawData){var rawSkins=rawData[dragonBones.DataParser.SKIN];for(var _e=0,rawSkins_1=rawSkins;_e<rawSkins_1.length;_e++){var rawSkin=rawSkins_1[_e];armature.addSkin(this._parseSkin(rawSkin));}}if(dragonBones.DataParser.PATH_CONSTRAINT in rawData){var rawPaths=rawData[dragonBones.DataParser.PATH_CONSTRAINT];for(var _f=0,rawPaths_1=rawPaths;_f<rawPaths_1.length;_f++){var rawPath=rawPaths_1[_f];var constraint=this._parsePathConstraint(rawPath);if(constraint){armature.addConstraint(constraint);}}}for(var i=0,l=this._cacheRawMeshes.length;i<l;++i){var rawMeshData=this._cacheRawMeshes[i];if(!(dragonBones.DataParser.GLUE_WEIGHTS in rawMeshData)||!(dragonBones.DataParser.GLUE_MESHES in rawMeshData)){continue;}this._parseMeshGlue(rawMeshData,this._cacheMeshes[i]);}for(var i=0,l=this._cacheRawMeshes.length;i<l;++i){var rawData_1=this._cacheRawMeshes[i];var shareName=ObjectDataParser._getString(rawData_1,dragonBones.DataParser.SHARE,"");if(shareName.length===0){continue;}var skinName=ObjectDataParser._getString(rawData_1,dragonBones.DataParser.SKIN,dragonBones.DataParser.DEFAULT_NAME);if(skinName.length===0){skinName=dragonBones.DataParser.DEFAULT_NAME;}var shareMesh=armature.getMesh(skinName,"",shareName);if(shareMesh===null){continue;}var mesh=this._cacheMeshes[i];mesh.vertices.shareFrom(shareMesh.vertices);}if(dragonBones.DataParser.ANIMATION in rawData){var rawAnimations=rawData[dragonBones.DataParser.ANIMATION];for(var _g=0,rawAnimations_1=rawAnimations;_g<rawAnimations_1.length;_g++){var rawAnimation=rawAnimations_1[_g];var animation=this._parseAnimation(rawAnimation);armature.addAnimation(animation);}}if(dragonBones.DataParser.DEFAULT_ACTIONS in rawData){var actions=this._parseActionData(rawData[dragonBones.DataParser.DEFAULT_ACTIONS],0,null,null);for(var _h=0,actions_3=actions;_h<actions_3.length;_h++){var action=actions_3[_h];armature.addAction(action,true);if(action.type===0){var animation=armature.getAnimation(action.name);if(animation!==null){armature.defaultAnimation=animation;}}}}if(dragonBones.DataParser.ACTIONS in rawData){var actions=this._parseActionData(rawData[dragonBones.DataParser.ACTIONS],0,null,null);for(var _j=0,actions_4=actions;_j<actions_4.length;_j++){var action=actions_4[_j];armature.addAction(action,false);}}this._rawBones.length=0;this._cacheRawMeshes.length=0;this._cacheMeshes.length=0;this._armature=null;for(var k in this._weightSlotPose){delete this._weightSlotPose[k];}for(var k in this._weightBonePoses){delete this._weightBonePoses[k];}for(var k in this._cacheBones){delete this._cacheBones[k];}for(var k in this._slotChildActions){delete this._slotChildActions[k];}return armature;};ObjectDataParser.prototype._parseBone=function(rawData){var type=0;var scale=this._armature.scale;if(dragonBones.DataParser.TYPE in rawData&&typeof rawData[dragonBones.DataParser.TYPE]==="string"){type=dragonBones.DataParser._getBoneType(rawData[dragonBones.DataParser.TYPE]);}else {type=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.TYPE,0);}if(type===0){var bone=dragonBones.BaseObject.borrowObject(dragonBones.BoneData);bone.inheritTranslation=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.INHERIT_TRANSLATION,true);bone.inheritRotation=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.INHERIT_ROTATION,true);bone.inheritScale=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.INHERIT_SCALE,true);bone.inheritReflection=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.INHERIT_REFLECTION,true);bone.length=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.LENGTH,0)*scale;bone.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");if(dragonBones.DataParser.TRANSFORM in rawData){this._parseTransform(rawData[dragonBones.DataParser.TRANSFORM],bone.transform,scale);}return bone;}var surface=dragonBones.BaseObject.borrowObject(dragonBones.SurfaceData);surface.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");surface.segmentX=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SEGMENT_X,0);surface.segmentY=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SEGMENT_Y,0);surface.vertices.length=(surface.segmentX+1)*(surface.segmentY+1)*2;if(dragonBones.DataParser.VERTICES in rawData){var rawVertices=rawData[dragonBones.DataParser.VERTICES];for(var i=0,l=surface.vertices.length;i<l;++i){if(i<rawVertices.length){surface.vertices[i]=rawVertices[i]*scale;}else {surface.vertices[i]=0.0;}}}return surface;};ObjectDataParser.prototype._parseIKConstraint=function(rawData){var bone=this._armature.getBone(ObjectDataParser._getString(rawData,dragonBones.DataParser.BONE,""));if(bone===null){return null;}var target=this._armature.getBone(ObjectDataParser._getString(rawData,dragonBones.DataParser.TARGET,""));if(target===null){return null;}var constraint=dragonBones.BaseObject.borrowObject(dragonBones.IKConstraintData);constraint.scaleEnabled=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.SCALE,false);constraint.bendPositive=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.BEND_POSITIVE,true);constraint.weight=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.WEIGHT,1.0);constraint.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");constraint.type=0;constraint.target=target;var chain=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.CHAIN,0);if(chain>0&&bone.parent!==null){constraint.root=bone.parent;constraint.bone=bone;}else {constraint.root=bone;constraint.bone=null;}return constraint;};ObjectDataParser.prototype._parsePathConstraint=function(rawData){var target=this._armature.getSlot(ObjectDataParser._getString(rawData,dragonBones.DataParser.TARGET,""));if(target===null){return null;}var defaultSkin=this._armature.defaultSkin;if(defaultSkin===null){return null;}var targetDisplay=defaultSkin.getDisplay(target.name,ObjectDataParser._getString(rawData,dragonBones.DataParser.TARGET_DISPLAY,target.name));if(targetDisplay===null||!(targetDisplay instanceof dragonBones.PathDisplayData)){return null;}var bones=rawData[dragonBones.DataParser.BONES];if(bones===null||bones.length===0){return null;}var constraint=dragonBones.BaseObject.borrowObject(dragonBones.PathConstraintData);constraint.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");constraint.type=1;constraint.pathSlot=target;constraint.pathDisplayData=targetDisplay;constraint.target=target.parent;constraint.positionMode=dragonBones.DataParser._getPositionMode(ObjectDataParser._getString(rawData,dragonBones.DataParser.POSITION_MODE,""));constraint.spacingMode=dragonBones.DataParser._getSpacingMode(ObjectDataParser._getString(rawData,dragonBones.DataParser.SPACING_MODE,""));constraint.rotateMode=dragonBones.DataParser._getRotateMode(ObjectDataParser._getString(rawData,dragonBones.DataParser.ROTATE_MODE,""));constraint.position=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.POSITION,0);constraint.spacing=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SPACING,0);constraint.rotateOffset=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.ROTATE_OFFSET,0);constraint.rotateMix=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.ROTATE_MIX,1);constraint.translateMix=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.TRANSLATE_MIX,1);for(var _i=0,bones_3=bones;_i<bones_3.length;_i++){var boneName=bones_3[_i];var bone=this._armature.getBone(boneName);if(bone!==null){constraint.AddBone(bone);if(constraint.root===null){constraint.root=bone;}}}return constraint;};ObjectDataParser.prototype._parseSlot=function(rawData,zOrder){var slot=dragonBones.BaseObject.borrowObject(dragonBones.SlotData);slot.displayIndex=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.DISPLAY_INDEX,0);slot.zOrder=zOrder;slot.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");slot.parent=this._armature.getBone(ObjectDataParser._getString(rawData,dragonBones.DataParser.PARENT,""));if(dragonBones.DataParser.BLEND_MODE in rawData&&typeof rawData[dragonBones.DataParser.BLEND_MODE]==="string"){slot.blendMode=dragonBones.DataParser._getBlendMode(rawData[dragonBones.DataParser.BLEND_MODE]);}else {slot.blendMode=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.BLEND_MODE,0);}if(dragonBones.DataParser.COLOR in rawData){slot.color=dragonBones.SlotData.createColor();this._parseColorTransform(rawData[dragonBones.DataParser.COLOR],slot.color);}else {slot.color=dragonBones.SlotData.DEFAULT_COLOR;}if(dragonBones.DataParser.ACTIONS in rawData){this._slotChildActions[slot.name]=this._parseActionData(rawData[dragonBones.DataParser.ACTIONS],0,null,null);}return slot;};ObjectDataParser.prototype._parseSkin=function(rawData){var skin=dragonBones.BaseObject.borrowObject(dragonBones.SkinData);skin.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,dragonBones.DataParser.DEFAULT_NAME);if(skin.name.length===0){skin.name=dragonBones.DataParser.DEFAULT_NAME;}if(dragonBones.DataParser.SLOT in rawData){var rawSlots=rawData[dragonBones.DataParser.SLOT];this._skin=skin;for(var _i=0,rawSlots_2=rawSlots;_i<rawSlots_2.length;_i++){var rawSlot=rawSlots_2[_i];var slotName=ObjectDataParser._getString(rawSlot,dragonBones.DataParser.NAME,"");var slot=this._armature.getSlot(slotName);if(slot!==null){this._slot=slot;if(dragonBones.DataParser.DISPLAY in rawSlot){var rawDisplays=rawSlot[dragonBones.DataParser.DISPLAY];for(var _a=0,rawDisplays_1=rawDisplays;_a<rawDisplays_1.length;_a++){var rawDisplay=rawDisplays_1[_a];if(rawDisplay){skin.addDisplay(slotName,this._parseDisplay(rawDisplay));}else {skin.addDisplay(slotName,null);}}}this._slot=null;}}this._skin=null;}return skin;};ObjectDataParser.prototype._parseDisplay=function(rawData){var name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");var path=ObjectDataParser._getString(rawData,dragonBones.DataParser.PATH,"");var type=0;var display=null;if(dragonBones.DataParser.TYPE in rawData&&typeof rawData[dragonBones.DataParser.TYPE]==="string"){type=dragonBones.DataParser._getDisplayType(rawData[dragonBones.DataParser.TYPE]);}else {type=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.TYPE,type);}switch(type){case 0:var imageDisplay=display=dragonBones.BaseObject.borrowObject(dragonBones.ImageDisplayData);imageDisplay.name=name;imageDisplay.path=path.length>0?path:name;this._parsePivot(rawData,imageDisplay);break;case 1:var armatureDisplay=display=dragonBones.BaseObject.borrowObject(dragonBones.ArmatureDisplayData);armatureDisplay.name=name;armatureDisplay.path=path.length>0?path:name;armatureDisplay.inheritAnimation=true;if(dragonBones.DataParser.ACTIONS in rawData){var actions=this._parseActionData(rawData[dragonBones.DataParser.ACTIONS],0,null,null);for(var _i=0,actions_5=actions;_i<actions_5.length;_i++){var action=actions_5[_i];armatureDisplay.addAction(action);}}else if(this._slot.name in this._slotChildActions){var displays=this._skin.getDisplays(this._slot.name);if(displays===null?this._slot.displayIndex===0:this._slot.displayIndex===displays.length){for(var _a=0,_b=this._slotChildActions[this._slot.name];_a<_b.length;_a++){var action=_b[_a];armatureDisplay.addAction(action);}delete this._slotChildActions[this._slot.name];}}break;case 2:var meshDisplay=display=dragonBones.BaseObject.borrowObject(dragonBones.MeshDisplayData);meshDisplay.vertices.inheritDeform=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.INHERIT_DEFORM,true);meshDisplay.name=name;meshDisplay.path=path.length>0?path:name;meshDisplay.vertices.data=this._data;if(dragonBones.DataParser.SHARE in rawData){this._cacheRawMeshes.push(rawData);this._cacheMeshes.push(meshDisplay);}else {this._parseMesh(rawData,meshDisplay);}if(dragonBones.DataParser.GLUE_WEIGHTS in rawData&&dragonBones.DataParser.GLUE_MESHES in rawData){this._cacheRawMeshes.push(rawData);this._cacheMeshes.push(meshDisplay);}break;case 3:var boundingBox=this._parseBoundingBox(rawData);if(boundingBox!==null){var boundingBoxDisplay=display=dragonBones.BaseObject.borrowObject(dragonBones.BoundingBoxDisplayData);boundingBoxDisplay.name=name;boundingBoxDisplay.path=path.length>0?path:name;boundingBoxDisplay.boundingBox=boundingBox;}break;case 4:var rawCurveLengths=rawData[dragonBones.DataParser.LENGTHS];var pathDisplay=display=dragonBones.BaseObject.borrowObject(dragonBones.PathDisplayData);pathDisplay.closed=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.CLOSED,false);pathDisplay.constantSpeed=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.CONSTANT_SPEED,false);pathDisplay.name=name;pathDisplay.path=path.length>0?path:name;pathDisplay.vertices.data=this._data;pathDisplay.curveLengths.length=rawCurveLengths.length;for(var i=0,l=rawCurveLengths.length;i<l;++i){pathDisplay.curveLengths[i]=rawCurveLengths[i];}this._parsePath(rawData,pathDisplay);break;}if(display!==null&&dragonBones.DataParser.TRANSFORM in rawData){this._parseTransform(rawData[dragonBones.DataParser.TRANSFORM],display.transform,this._armature.scale);}return display;};ObjectDataParser.prototype._parsePath=function(rawData,display){var rawVertices=rawData[dragonBones.DataParser.VERTICES];var vertexCount=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.VERTEX_COUNT,0);var vertexOffset=this._floatArray.length;var pathOffset=this._intArray.length;display.vertices.offset=pathOffset;this._intArray.length+=1+1;this._intArray[pathOffset+0]=vertexCount;this._intArray[pathOffset+2]=vertexOffset;if(!(dragonBones.DataParser.WEIGHTS in rawData)){this._floatArray.length+=rawVertices.length;for(var i=0,l=rawVertices.length;i<l;++i){this._floatArray[vertexOffset+i]=rawVertices[i];}}else {var rawWeights=rawData[dragonBones.DataParser.WEIGHTS];var rawBones=rawData[dragonBones.DataParser.BONES];var weightBoneCount=rawBones.length;var weightCount=Math.floor(rawWeights.length-vertexCount)/2;var weightOffset=this._intArray.length;var floatOffset=this._floatArray.length;var sortedBones=this._armature.sortedBones;var weight=dragonBones.BaseObject.borrowObject(dragonBones.WeightData);weight.count=weightCount;weight.offset=weightOffset;this._intArray.length+=1+1+weightBoneCount+vertexCount+weightCount;this._intArray[weightOffset+0]=weightBoneCount;this._intArray[weightOffset+1]=floatOffset;for(var i=0;i<weightBoneCount;i++){var rawBoneIndex=rawBones[i];var bone=this._rawBones[rawBoneIndex];weight.addBone(bone);this._intArray[weightOffset+2+i]=sortedBones.indexOf(bone);}this._floatArray.length+=weightCount*3;for(var i=0,iW=0,iV=0,iB=weightOffset+2+weightBoneCount,iF=floatOffset;i<weightCount;i++){var boneCount=rawWeights[iW++];this._intArray[iB++]=boneCount;for(var j=0;j<boneCount;j++){var boneIndex=rawWeights[iW++];var boneWeight=rawWeights[iW++];var x=rawVertices[iV++];var y=rawVertices[iV++];this._intArray[iB++]=rawBones.indexOf(boneIndex);this._floatArray[iF++]=boneWeight;this._floatArray[iF++]=x;this._floatArray[iF++]=y;}}display.vertices.weight=weight;}};ObjectDataParser.prototype._parsePivot=function(rawData,display){if(dragonBones.DataParser.PIVOT in rawData){var rawPivot=rawData[dragonBones.DataParser.PIVOT];display.pivot.x=ObjectDataParser._getNumber(rawPivot,dragonBones.DataParser.X,0.0);display.pivot.y=ObjectDataParser._getNumber(rawPivot,dragonBones.DataParser.Y,0.0);}else {display.pivot.x=0.5;display.pivot.y=0.5;}};ObjectDataParser.prototype._parseMesh=function(rawData,mesh){var rawVertices=rawData[dragonBones.DataParser.VERTICES];var rawUVs=rawData[dragonBones.DataParser.UVS];var rawTriangles=rawData[dragonBones.DataParser.TRIANGLES];var vertexCount=Math.floor(rawVertices.length/2);var triangleCount=Math.floor(rawTriangles.length/3);var vertexOffset=this._floatArray.length;var uvOffset=vertexOffset+vertexCount*2;var meshOffset=this._intArray.length;var meshName=this._skin.name+"_"+this._slot.name+"_"+mesh.name;mesh.vertices.offset=meshOffset;this._intArray.length+=1+1+1+1+triangleCount*3;this._intArray[meshOffset+0]=vertexCount;this._intArray[meshOffset+1]=triangleCount;this._intArray[meshOffset+2]=vertexOffset;for(var i=0,l=triangleCount*3;i<l;++i){this._intArray[meshOffset+4+i]=rawTriangles[i];}this._floatArray.length+=vertexCount*2+vertexCount*2;for(var i=0,l=vertexCount*2;i<l;++i){this._floatArray[vertexOffset+i]=rawVertices[i];this._floatArray[uvOffset+i]=rawUVs[i];}if(dragonBones.DataParser.WEIGHTS in rawData){var rawWeights=rawData[dragonBones.DataParser.WEIGHTS];var rawSlotPose=rawData[dragonBones.DataParser.SLOT_POSE];var rawBonePoses=rawData[dragonBones.DataParser.BONE_POSE];var sortedBones=this._armature.sortedBones;var weightBoneIndices=new Array();var weightBoneCount=Math.floor(rawBonePoses.length/7);var floatOffset=this._floatArray.length;var weightCount=Math.floor(rawWeights.length-vertexCount)/2;var weightOffset=this._intArray.length;var weight=dragonBones.BaseObject.borrowObject(dragonBones.WeightData);weight.count=weightCount;weight.offset=weightOffset;weightBoneIndices.length=weightBoneCount;this._intArray.length+=1+1+weightBoneCount+vertexCount+weightCount;this._intArray[weightOffset+1]=floatOffset;for(var i=0;i<weightBoneCount;++i){var rawBoneIndex=rawBonePoses[i*7];var bone=this._rawBones[rawBoneIndex];weight.addBone(bone);weightBoneIndices[i]=rawBoneIndex;this._intArray[weightOffset+2+i]=sortedBones.indexOf(bone);}this._floatArray.length+=weightCount*3;this._helpMatrixA.copyFromArray(rawSlotPose,0);for(var i=0,iW=0,iB=weightOffset+2+weightBoneCount,iV=floatOffset;i<vertexCount;++i){var iD=i*2;var vertexBoneCount=this._intArray[iB++]=rawWeights[iW++];var x=this._floatArray[vertexOffset+iD];var y=this._floatArray[vertexOffset+iD+1];this._helpMatrixA.transformPoint(x,y,this._helpPoint);x=this._helpPoint.x;y=this._helpPoint.y;for(var j=0;j<vertexBoneCount;++j){var rawBoneIndex=rawWeights[iW++];var boneIndex=weightBoneIndices.indexOf(rawBoneIndex);this._helpMatrixB.copyFromArray(rawBonePoses,boneIndex*7+1);this._helpMatrixB.invert();this._helpMatrixB.transformPoint(x,y,this._helpPoint);this._intArray[iB++]=boneIndex;this._floatArray[iV++]=rawWeights[iW++];this._floatArray[iV++]=this._helpPoint.x;this._floatArray[iV++]=this._helpPoint.y;}}mesh.vertices.weight=weight;this._weightSlotPose[meshName]=rawSlotPose;this._weightBonePoses[meshName]=rawBonePoses;}};ObjectDataParser.prototype._parseMeshGlue=function(rawData,mesh){};ObjectDataParser.prototype._parseBoundingBox=function(rawData){var boundingBox=null;var type=0;if(dragonBones.DataParser.SUB_TYPE in rawData&&typeof rawData[dragonBones.DataParser.SUB_TYPE]==="string"){type=dragonBones.DataParser._getBoundingBoxType(rawData[dragonBones.DataParser.SUB_TYPE]);}else {type=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SUB_TYPE,type);}switch(type){case 0:boundingBox=dragonBones.BaseObject.borrowObject(dragonBones.RectangleBoundingBoxData);break;case 1:boundingBox=dragonBones.BaseObject.borrowObject(dragonBones.EllipseBoundingBoxData);break;case 2:boundingBox=this._parsePolygonBoundingBox(rawData);break;}if(boundingBox!==null){boundingBox.color=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.COLOR,0x000000);if(boundingBox.type===0||boundingBox.type===1){boundingBox.width=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.WIDTH,0.0);boundingBox.height=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.HEIGHT,0.0);}}return boundingBox;};ObjectDataParser.prototype._parsePolygonBoundingBox=function(rawData){var polygonBoundingBox=dragonBones.BaseObject.borrowObject(dragonBones.PolygonBoundingBoxData);if(dragonBones.DataParser.VERTICES in rawData){var scale=this._armature.scale;var rawVertices=rawData[dragonBones.DataParser.VERTICES];var vertices=polygonBoundingBox.vertices;if(dragonBones.DragonBones.webAssembly){vertices.resize(rawVertices.length,0.0);}else {vertices.length=rawVertices.length;}for(var i=0,l=rawVertices.length;i<l;i+=2){var x=rawVertices[i]*scale;var y=rawVertices[i+1]*scale;if(dragonBones.DragonBones.webAssembly){vertices.set(i,x);vertices.set(i+1,y);}else {vertices[i]=x;vertices[i+1]=y;}if(i===0){polygonBoundingBox.x=x;polygonBoundingBox.y=y;polygonBoundingBox.width=x;polygonBoundingBox.height=y;}else {if(x<polygonBoundingBox.x){polygonBoundingBox.x=x;}else if(x>polygonBoundingBox.width){polygonBoundingBox.width=x;}if(y<polygonBoundingBox.y){polygonBoundingBox.y=y;}else if(y>polygonBoundingBox.height){polygonBoundingBox.height=y;}}}polygonBoundingBox.width-=polygonBoundingBox.x;polygonBoundingBox.height-=polygonBoundingBox.y;}else {console.warn("Data error.\n Please reexport DragonBones Data to fixed the bug.");}return polygonBoundingBox;};ObjectDataParser.prototype._parseAnimation=function(rawData){var animation=dragonBones.BaseObject.borrowObject(dragonBones.AnimationData);animation.frameCount=Math.max(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.DURATION,1),1);animation.playTimes=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.PLAY_TIMES,1);animation.duration=animation.frameCount/this._armature.frameRate;animation.fadeInTime=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.FADE_IN_TIME,0.0);animation.scale=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SCALE,1.0);animation.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,dragonBones.DataParser.DEFAULT_NAME);if(animation.name.length===0){animation.name=dragonBones.DataParser.DEFAULT_NAME;}animation.frameIntOffset=this._frameIntArray.length;animation.frameFloatOffset=this._frameFloatArray.length;animation.frameOffset=this._frameArray.length;this._animation=animation;if(dragonBones.DataParser.FRAME in rawData){var rawFrames=rawData[dragonBones.DataParser.FRAME];var keyFrameCount=rawFrames.length;if(keyFrameCount>0){for(var i=0,frameStart=0;i<keyFrameCount;++i){var rawFrame=rawFrames[i];this._parseActionDataInFrame(rawFrame,frameStart,null,null);frameStart+=ObjectDataParser._getNumber(rawFrame,dragonBones.DataParser.DURATION,1);}}}if(dragonBones.DataParser.Z_ORDER in rawData){this._animation.zOrderTimeline=this._parseTimeline(rawData[dragonBones.DataParser.Z_ORDER],null,dragonBones.DataParser.FRAME,1,false,false,0,this._parseZOrderFrame);}if(dragonBones.DataParser.BONE in rawData){var rawTimelines=rawData[dragonBones.DataParser.BONE];for(var _i=0,rawTimelines_1=rawTimelines;_i<rawTimelines_1.length;_i++){var rawTimeline=rawTimelines_1[_i];this._parseBoneTimeline(rawTimeline);}}if(dragonBones.DataParser.SURFACE in rawData){var rawTimelines=rawData[dragonBones.DataParser.SURFACE];for(var _a=0,rawTimelines_2=rawTimelines;_a<rawTimelines_2.length;_a++){var rawTimeline=rawTimelines_2[_a];var surfaceName=ObjectDataParser._getString(rawTimeline,dragonBones.DataParser.NAME,"");this._surface=this._armature.getBone(surfaceName);if(this._surface===null){continue;}var timeline=this._parseTimeline(rawTimeline,null,dragonBones.DataParser.FRAME,50,false,true,0,this._parseSurfaceFrame);if(timeline!==null){this._animation.addSurfaceTimeline(this._surface,timeline);}this._surface=null;}}if(dragonBones.DataParser.SLOT in rawData){var rawTimelines=rawData[dragonBones.DataParser.SLOT];for(var _b=0,rawTimelines_3=rawTimelines;_b<rawTimelines_3.length;_b++){var rawTimeline=rawTimelines_3[_b];this._parseSlotTimeline(rawTimeline);}}if(dragonBones.DataParser.FFD in rawData){var rawTimelines=rawData[dragonBones.DataParser.FFD];for(var _c=0,rawTimelines_4=rawTimelines;_c<rawTimelines_4.length;_c++){var rawTimeline=rawTimelines_4[_c];var skinName=ObjectDataParser._getString(rawTimeline,dragonBones.DataParser.SKIN,dragonBones.DataParser.DEFAULT_NAME);var slotName=ObjectDataParser._getString(rawTimeline,dragonBones.DataParser.SLOT,"");var displayName=ObjectDataParser._getString(rawTimeline,dragonBones.DataParser.NAME,"");if(skinName.length===0){skinName=dragonBones.DataParser.DEFAULT_NAME;}this._slot=this._armature.getSlot(slotName);this._mesh=this._armature.getMesh(skinName,slotName,displayName);if(this._slot===null||this._mesh===null){continue;}var timeline=this._parseTimeline(rawTimeline,null,dragonBones.DataParser.FRAME,22,false,true,0,this._parseSlotFFDFrame);if(timeline!==null){this._animation.addSlotTimeline(this._slot,timeline);}this._slot=null;this._mesh=null;}}if(dragonBones.DataParser.IK in rawData){var rawTimelines=rawData[dragonBones.DataParser.IK];for(var _d=0,rawTimelines_5=rawTimelines;_d<rawTimelines_5.length;_d++){var rawTimeline=rawTimelines_5[_d];var constraintName=ObjectDataParser._getString(rawTimeline,dragonBones.DataParser.NAME,"");var constraint=this._armature.getConstraint(constraintName);if(constraint===null){continue;}var timeline=this._parseTimeline(rawTimeline,null,dragonBones.DataParser.FRAME,30,true,false,2,this._parseIKConstraintFrame);if(timeline!==null){this._animation.addConstraintTimeline(constraint,timeline);}}}if(dragonBones.DataParser.ANIMATION in rawData){var rawTimelines=rawData[dragonBones.DataParser.ANIMATION];for(var _e=0,rawTimelines_6=rawTimelines;_e<rawTimelines_6.length;_e++){var rawTimeline=rawTimelines_6[_e];var animationName=ObjectDataParser._getString(rawTimeline,dragonBones.DataParser.NAME,"");var timeline=this._parseTimeline(rawTimeline,null,dragonBones.DataParser.FRAME,40,true,false,2,this._parseAnimationFrame);if(timeline!==null){this._animation.addAnimationTimeline(animationName,timeline);}}}if(this._actionFrames.length>0){this._animation.actionTimeline=this._parseTimeline(null,this._actionFrames,"",0,false,false,0,this._parseActionFrame);this._actionFrames.length=0;}this._animation=null;return animation;};ObjectDataParser.prototype._parseTimeline=function(rawData,rawFrames,framesKey,type,addIntOffset,addFloatOffset,frameValueCount,frameParser){if(rawData!==null&&framesKey.length>0&&framesKey in rawData){rawFrames=rawData[framesKey];}if(rawFrames===null){return null;}var keyFrameCount=rawFrames.length;if(keyFrameCount===0){return null;}var frameIntArrayLength=this._frameIntArray.length;var frameFloatArrayLength=this._frameFloatArray.length;var timeline=dragonBones.BaseObject.borrowObject(dragonBones.TimelineData);var timelineOffset=this._timelineArray.length;this._timelineArray.length+=1+1+1+1+1+keyFrameCount;if(rawData!==null){this._timelineArray[timelineOffset+0]=Math.round(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SCALE,1.0)*100);this._timelineArray[timelineOffset+1]=Math.round(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.OFFSET,0.0)*100);}else {this._timelineArray[timelineOffset+0]=100;this._timelineArray[timelineOffset+1]=0;}this._timelineArray[timelineOffset+2]=keyFrameCount;this._timelineArray[timelineOffset+3]=frameValueCount;if(addIntOffset){this._timelineArray[timelineOffset+4]=frameIntArrayLength-this._animation.frameIntOffset;}else if(addFloatOffset){this._timelineArray[timelineOffset+4]=frameFloatArrayLength-this._animation.frameFloatOffset;}else {this._timelineArray[timelineOffset+4]=0;}this._timeline=timeline;timeline.type=type;timeline.offset=timelineOffset;if(keyFrameCount===1){timeline.frameIndicesOffset=-1;this._timelineArray[timelineOffset+5+0]=frameParser.call(this,rawFrames[0],0,0)-this._animation.frameOffset;}else {var totalFrameCount=this._animation.frameCount+1;var frameIndices=this._data.frameIndices;var frameIndicesOffset=0;if(dragonBones.DragonBones.webAssembly){frameIndicesOffset=frameIndices.size();frameIndices.resize(frameIndicesOffset+totalFrameCount,0);}else {frameIndicesOffset=frameIndices.length;frameIndices.length+=totalFrameCount;}timeline.frameIndicesOffset=frameIndicesOffset;for(var i=0,iK=0,frameStart=0,frameCount=0;i<totalFrameCount;++i){if(frameStart+frameCount<=i&&iK<keyFrameCount){var rawFrame=rawFrames[iK];frameStart=i;if(iK===keyFrameCount-1){frameCount=this._animation.frameCount-frameStart;}else {if(rawFrame instanceof ActionFrame){frameCount=this._actionFrames[iK+1].frameStart-frameStart;}else {frameCount=ObjectDataParser._getNumber(rawFrame,dragonBones.DataParser.DURATION,1);}}this._timelineArray[timelineOffset+5+iK]=frameParser.call(this,rawFrame,frameStart,frameCount)-this._animation.frameOffset;iK++;}if(dragonBones.DragonBones.webAssembly){frameIndices.set(frameIndicesOffset+i,iK-1);}else {frameIndices[frameIndicesOffset+i]=iK-1;}}}this._timeline=null;return timeline;};ObjectDataParser.prototype._parseBoneTimeline=function(rawData){var bone=this._armature.getBone(ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,""));if(bone===null){return;}this._bone=bone;this._slot=this._armature.getSlot(this._bone.name);if(dragonBones.DataParser.TRANSLATE_FRAME in rawData){var timeline=this._parseTimeline(rawData,null,dragonBones.DataParser.TRANSLATE_FRAME,11,false,true,2,this._parseBoneTranslateFrame);if(timeline!==null){this._animation.addBoneTimeline(bone,timeline);}}if(dragonBones.DataParser.ROTATE_FRAME in rawData){var timeline=this._parseTimeline(rawData,null,dragonBones.DataParser.ROTATE_FRAME,12,false,true,2,this._parseBoneRotateFrame);if(timeline!==null){this._animation.addBoneTimeline(bone,timeline);}}if(dragonBones.DataParser.SCALE_FRAME in rawData){var timeline=this._parseTimeline(rawData,null,dragonBones.DataParser.SCALE_FRAME,13,false,true,2,this._parseBoneScaleFrame);if(timeline!==null){this._animation.addBoneTimeline(bone,timeline);}}if(dragonBones.DataParser.FRAME in rawData){var timeline=this._parseTimeline(rawData,null,dragonBones.DataParser.FRAME,10,false,true,6,this._parseBoneAllFrame);if(timeline!==null){this._animation.addBoneTimeline(bone,timeline);}}this._bone=null;this._slot=null;};ObjectDataParser.prototype._parseSlotTimeline=function(rawData){var slot=this._armature.getSlot(ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,""));if(slot===null){return;}this._slot=slot;var displayTimeline=null;if(dragonBones.DataParser.DISPLAY_FRAME in rawData){displayTimeline=this._parseTimeline(rawData,null,dragonBones.DataParser.DISPLAY_FRAME,20,false,false,0,this._parseSlotDisplayFrame);}else {displayTimeline=this._parseTimeline(rawData,null,dragonBones.DataParser.FRAME,20,false,false,0,this._parseSlotDisplayFrame);}if(displayTimeline!==null){this._animation.addSlotTimeline(slot,displayTimeline);}var colorTimeline=null;if(dragonBones.DataParser.COLOR_FRAME in rawData){colorTimeline=this._parseTimeline(rawData,null,dragonBones.DataParser.COLOR_FRAME,21,true,false,1,this._parseSlotColorFrame);}else {colorTimeline=this._parseTimeline(rawData,null,dragonBones.DataParser.FRAME,21,true,false,1,this._parseSlotColorFrame);}if(colorTimeline!==null){this._animation.addSlotTimeline(slot,colorTimeline);}this._slot=null;};ObjectDataParser.prototype._parseFrame=function(rawData,frameStart,frameCount){var frameOffset=this._frameArray.length;this._frameArray.length+=1;this._frameArray[frameOffset+0]=frameStart;return frameOffset;};ObjectDataParser.prototype._parseTweenFrame=function(rawData,frameStart,frameCount){var frameOffset=this._parseFrame(rawData,frameStart,frameCount);if(frameCount>0){if(dragonBones.DataParser.CURVE in rawData){var sampleCount=frameCount+1;this._helpArray.length=sampleCount;this._samplingEasingCurve(rawData[dragonBones.DataParser.CURVE],this._helpArray);this._frameArray.length+=1+1+this._helpArray.length;this._frameArray[frameOffset+1]=2;this._frameArray[frameOffset+2]=sampleCount;for(var i=0;i<sampleCount;++i){this._frameArray[frameOffset+3+i]=Math.round(this._helpArray[i]*10000.0);}}else {var noTween=-2.0;var tweenEasing=noTween;if(dragonBones.DataParser.TWEEN_EASING in rawData){tweenEasing=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.TWEEN_EASING,noTween);}if(tweenEasing===noTween){this._frameArray.length+=1;this._frameArray[frameOffset+1]=0;}else if(tweenEasing===0.0){this._frameArray.length+=1;this._frameArray[frameOffset+1]=1;}else if(tweenEasing<0.0){this._frameArray.length+=1+1;this._frameArray[frameOffset+1]=3;this._frameArray[frameOffset+2]=Math.round(-tweenEasing*100.0);}else if(tweenEasing<=1.0){this._frameArray.length+=1+1;this._frameArray[frameOffset+1]=4;this._frameArray[frameOffset+2]=Math.round(tweenEasing*100.0);}else {this._frameArray.length+=1+1;this._frameArray[frameOffset+1]=5;this._frameArray[frameOffset+2]=Math.round(tweenEasing*100.0-100.0);}}}else {this._frameArray.length+=1;this._frameArray[frameOffset+1]=0;}return frameOffset;};ObjectDataParser.prototype._parseActionFrame=function(frame,frameStart,frameCount){var frameOffset=this._frameArray.length;var actionCount=frame.actions.length;this._frameArray.length+=1+1+actionCount;this._frameArray[frameOffset+0]=frameStart;this._frameArray[frameOffset+0+1]=actionCount;for(var i=0;i<actionCount;++i){this._frameArray[frameOffset+0+2+i]=frame.actions[i];}return frameOffset;};ObjectDataParser.prototype._parseZOrderFrame=function(rawData,frameStart,frameCount){var frameOffset=this._parseFrame(rawData,frameStart,frameCount);if(dragonBones.DataParser.Z_ORDER in rawData){var rawZOrder=rawData[dragonBones.DataParser.Z_ORDER];if(rawZOrder.length>0){var slotCount=this._armature.sortedSlots.length;var unchanged=new Array(slotCount-rawZOrder.length/2);var zOrders=new Array(slotCount);for(var i_1=0;i_1<unchanged.length;++i_1){unchanged[i_1]=0;}for(var i_2=0;i_2<slotCount;++i_2){zOrders[i_2]=-1;}var originalIndex=0;var unchangedIndex=0;for(var i_3=0,l=rawZOrder.length;i_3<l;i_3+=2){var slotIndex=rawZOrder[i_3];var zOrderOffset=rawZOrder[i_3+1];while(originalIndex!==slotIndex){unchanged[unchangedIndex++]=originalIndex++;}var index=originalIndex+zOrderOffset;zOrders[index]=originalIndex++;}while(originalIndex<slotCount){unchanged[unchangedIndex++]=originalIndex++;}this._frameArray.length+=1+slotCount;this._frameArray[frameOffset+1]=slotCount;var i=slotCount;while(i--){if(zOrders[i]===-1){this._frameArray[frameOffset+2+i]=unchanged[--unchangedIndex]||0;}else {this._frameArray[frameOffset+2+i]=zOrders[i]||0;}}return frameOffset;}}this._frameArray.length+=1;this._frameArray[frameOffset+1]=0;return frameOffset;};ObjectDataParser.prototype._parseBoneAllFrame=function(rawData,frameStart,frameCount){this._helpTransform.identity();if(dragonBones.DataParser.TRANSFORM in rawData){this._parseTransform(rawData[dragonBones.DataParser.TRANSFORM],this._helpTransform,1.0);}var rotation=this._helpTransform.rotation;if(frameStart!==0){if(this._prevClockwise===0){rotation=this._prevRotation+dragonBones.Transform.normalizeRadian(rotation-this._prevRotation);}else {if(this._prevClockwise>0?rotation>=this._prevRotation:rotation<=this._prevRotation){this._prevClockwise=this._prevClockwise>0?this._prevClockwise-1:this._prevClockwise+1;}rotation=this._prevRotation+rotation-this._prevRotation+dragonBones.Transform.PI_D*this._prevClockwise;}}this._prevClockwise=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.TWEEN_ROTATE,0.0);this._prevRotation=rotation;var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var frameFloatOffset=this._frameFloatArray.length;this._frameFloatArray.length+=6;this._frameFloatArray[frameFloatOffset++]=this._helpTransform.x;this._frameFloatArray[frameFloatOffset++]=this._helpTransform.y;this._frameFloatArray[frameFloatOffset++]=rotation;this._frameFloatArray[frameFloatOffset++]=this._helpTransform.skew;this._frameFloatArray[frameFloatOffset++]=this._helpTransform.scaleX;this._frameFloatArray[frameFloatOffset++]=this._helpTransform.scaleY;this._parseActionDataInFrame(rawData,frameStart,this._bone,this._slot);return frameOffset;};ObjectDataParser.prototype._parseBoneTranslateFrame=function(rawData,frameStart,frameCount){var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var frameFloatOffset=this._frameFloatArray.length;this._frameFloatArray.length+=2;this._frameFloatArray[frameFloatOffset++]=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.X,0.0);this._frameFloatArray[frameFloatOffset++]=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.Y,0.0);return frameOffset;};ObjectDataParser.prototype._parseBoneRotateFrame=function(rawData,frameStart,frameCount){var rotation=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.ROTATE,0.0)*dragonBones.Transform.DEG_RAD;if(frameStart!==0){if(this._prevClockwise===0){rotation=this._prevRotation+dragonBones.Transform.normalizeRadian(rotation-this._prevRotation);}else {if(this._prevClockwise>0?rotation>=this._prevRotation:rotation<=this._prevRotation){this._prevClockwise=this._prevClockwise>0?this._prevClockwise-1:this._prevClockwise+1;}rotation=this._prevRotation+rotation-this._prevRotation+dragonBones.Transform.PI_D*this._prevClockwise;}}this._prevClockwise=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.CLOCK_WISE,0);this._prevRotation=rotation;var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var frameFloatOffset=this._frameFloatArray.length;this._frameFloatArray.length+=2;this._frameFloatArray[frameFloatOffset++]=rotation;this._frameFloatArray[frameFloatOffset++]=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SKEW,0.0)*dragonBones.Transform.DEG_RAD;return frameOffset;};ObjectDataParser.prototype._parseBoneScaleFrame=function(rawData,frameStart,frameCount){var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var frameFloatOffset=this._frameFloatArray.length;this._frameFloatArray.length+=2;this._frameFloatArray[frameFloatOffset++]=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.X,1.0);this._frameFloatArray[frameFloatOffset++]=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.Y,1.0);return frameOffset;};ObjectDataParser.prototype._parseSurfaceFrame=function(rawData,frameStart,frameCount){var frameFloatOffset=this._frameFloatArray.length;var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var rawVertices=rawData[dragonBones.DataParser.VERTICES];var offset=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.OFFSET,0);var vertexCount=this._surface.vertices.length/2;var x=0.0;var y=0.0;this._frameFloatArray.length+=vertexCount*2;for(var i=0;i<vertexCount*2;i+=2){if(i<offset||i-offset>=rawVertices.length){x=0.0;}else {x=rawVertices[i-offset];}if(i+1<offset||i+1-offset>=rawVertices.length){y=0.0;}else {y=rawVertices[i+1-offset];}this._frameFloatArray[frameFloatOffset+i]=x;this._frameFloatArray[frameFloatOffset+i+1]=y;}if(frameStart===0){var frameIntOffset=this._frameIntArray.length;this._frameIntArray.length+=1+1+1+1+1;this._frameIntArray[frameIntOffset+0]=0;this._frameIntArray[frameIntOffset+1]=this._frameFloatArray.length-frameFloatOffset;this._frameIntArray[frameIntOffset+2]=this._frameFloatArray.length-frameFloatOffset;this._frameIntArray[frameIntOffset+3]=0;this._frameIntArray[frameIntOffset+4]=frameFloatOffset-this._animation.frameFloatOffset;this._timelineArray[this._timeline.offset+3]=frameIntOffset-this._animation.frameIntOffset;}return frameOffset;};ObjectDataParser.prototype._parseSlotDisplayFrame=function(rawData,frameStart,frameCount){var frameOffset=this._parseFrame(rawData,frameStart,frameCount);this._frameArray.length+=1;if(dragonBones.DataParser.VALUE in rawData){this._frameArray[frameOffset+1]=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.VALUE,0);}else {this._frameArray[frameOffset+1]=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.DISPLAY_INDEX,0);}this._parseActionDataInFrame(rawData,frameStart,this._slot.parent,this._slot);return frameOffset;};ObjectDataParser.prototype._parseSlotColorFrame=function(rawData,frameStart,frameCount){var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var colorOffset=-1;if(dragonBones.DataParser.VALUE in rawData||dragonBones.DataParser.COLOR in rawData){var rawColor=dragonBones.DataParser.VALUE in rawData?rawData[dragonBones.DataParser.VALUE]:rawData[dragonBones.DataParser.COLOR];for(var k in rawColor){this._parseColorTransform(rawColor,this._helpColorTransform);colorOffset=this._intArray.length;this._intArray.length+=8;this._intArray[colorOffset++]=Math.round(this._helpColorTransform.alphaMultiplier*100);this._intArray[colorOffset++]=Math.round(this._helpColorTransform.redMultiplier*100);this._intArray[colorOffset++]=Math.round(this._helpColorTransform.greenMultiplier*100);this._intArray[colorOffset++]=Math.round(this._helpColorTransform.blueMultiplier*100);this._intArray[colorOffset++]=Math.round(this._helpColorTransform.alphaOffset);this._intArray[colorOffset++]=Math.round(this._helpColorTransform.redOffset);this._intArray[colorOffset++]=Math.round(this._helpColorTransform.greenOffset);this._intArray[colorOffset++]=Math.round(this._helpColorTransform.blueOffset);colorOffset-=8;break;}}if(colorOffset<0){if(this._defaultColorOffset<0){this._defaultColorOffset=colorOffset=this._intArray.length;this._intArray.length+=8;this._intArray[colorOffset++]=100;this._intArray[colorOffset++]=100;this._intArray[colorOffset++]=100;this._intArray[colorOffset++]=100;this._intArray[colorOffset++]=0;this._intArray[colorOffset++]=0;this._intArray[colorOffset++]=0;this._intArray[colorOffset++]=0;}colorOffset=this._defaultColorOffset;}var frameIntOffset=this._frameIntArray.length;this._frameIntArray.length+=1;this._frameIntArray[frameIntOffset]=colorOffset;return frameOffset;};ObjectDataParser.prototype._parseSlotFFDFrame=function(rawData,frameStart,frameCount){var frameFloatOffset=this._frameFloatArray.length;var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var rawVertices=dragonBones.DataParser.VERTICES in rawData?rawData[dragonBones.DataParser.VERTICES]:null;var offset=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.OFFSET,0);var vertexCount=this._intArray[this._mesh.vertices.offset+0];var meshName=this._mesh.parent.name+"_"+this._slot.name+"_"+this._mesh.name;var weight=this._mesh.vertices.weight;var x=0.0;var y=0.0;var iB=0;var iV=0;if(weight!==null){var rawSlotPose=this._weightSlotPose[meshName];this._helpMatrixA.copyFromArray(rawSlotPose,0);this._frameFloatArray.length+=weight.count*2;iB=weight.offset+2+weight.bones.length;}else {this._frameFloatArray.length+=vertexCount*2;}for(var i=0;i<vertexCount*2;i+=2){if(rawVertices===null){x=0.0;y=0.0;}else {if(i<offset||i-offset>=rawVertices.length){x=0.0;}else {x=rawVertices[i-offset];}if(i+1<offset||i+1-offset>=rawVertices.length){y=0.0;}else {y=rawVertices[i+1-offset];}}if(weight!==null){var rawBonePoses=this._weightBonePoses[meshName];var vertexBoneCount=this._intArray[iB++];this._helpMatrixA.transformPoint(x,y,this._helpPoint,true);x=this._helpPoint.x;y=this._helpPoint.y;for(var j=0;j<vertexBoneCount;++j){var boneIndex=this._intArray[iB++];this._helpMatrixB.copyFromArray(rawBonePoses,boneIndex*7+1);this._helpMatrixB.invert();this._helpMatrixB.transformPoint(x,y,this._helpPoint,true);this._frameFloatArray[frameFloatOffset+iV++]=this._helpPoint.x;this._frameFloatArray[frameFloatOffset+iV++]=this._helpPoint.y;}}else {this._frameFloatArray[frameFloatOffset+i]=x;this._frameFloatArray[frameFloatOffset+i+1]=y;}}if(frameStart===0){var frameIntOffset=this._frameIntArray.length;this._frameIntArray.length+=1+1+1+1+1;this._frameIntArray[frameIntOffset+0]=this._mesh.vertices.offset;this._frameIntArray[frameIntOffset+1]=this._frameFloatArray.length-frameFloatOffset;this._frameIntArray[frameIntOffset+2]=this._frameFloatArray.length-frameFloatOffset;this._frameIntArray[frameIntOffset+3]=0;this._frameIntArray[frameIntOffset+4]=frameFloatOffset-this._animation.frameFloatOffset;this._timelineArray[this._timeline.offset+3]=frameIntOffset-this._animation.frameIntOffset;}return frameOffset;};ObjectDataParser.prototype._parseIKConstraintFrame=function(rawData,frameStart,frameCount){var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var frameIntOffset=this._frameIntArray.length;this._frameIntArray.length+=2;this._frameIntArray[frameIntOffset++]=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.BEND_POSITIVE,true)?1:0;this._frameIntArray[frameIntOffset++]=Math.round(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.WEIGHT,1.0)*100.0);return frameOffset;};ObjectDataParser.prototype._parseAnimationFrame=function(rawData,frameStart,frameCount){var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var frameIntOffset=this._frameIntArray.length;this._frameIntArray.length+=2;this._frameIntArray[frameIntOffset++]=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.VALUE,0);this._frameIntArray[frameIntOffset++]=Math.round(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.WEIGHT,1.0)*100.0);return frameOffset;};ObjectDataParser.prototype._parseActionData=function(rawData,type,bone,slot){var actions=new Array();if(typeof rawData==="string"){var action=dragonBones.BaseObject.borrowObject(dragonBones.ActionData);action.type=type;action.name=rawData;action.bone=bone;action.slot=slot;actions.push(action);}else if(rawData instanceof Array){for(var _i=0,rawData_2=rawData;_i<rawData_2.length;_i++){var rawAction=rawData_2[_i];var action=dragonBones.BaseObject.borrowObject(dragonBones.ActionData);if(dragonBones.DataParser.GOTO_AND_PLAY in rawAction){action.type=0;action.name=ObjectDataParser._getString(rawAction,dragonBones.DataParser.GOTO_AND_PLAY,"");}else {if(dragonBones.DataParser.TYPE in rawAction&&typeof rawAction[dragonBones.DataParser.TYPE]==="string"){action.type=dragonBones.DataParser._getActionType(rawAction[dragonBones.DataParser.TYPE]);}else {action.type=ObjectDataParser._getNumber(rawAction,dragonBones.DataParser.TYPE,type);}action.name=ObjectDataParser._getString(rawAction,dragonBones.DataParser.NAME,"");}if(dragonBones.DataParser.BONE in rawAction){var boneName=ObjectDataParser._getString(rawAction,dragonBones.DataParser.BONE,"");action.bone=this._armature.getBone(boneName);}else {action.bone=bone;}if(dragonBones.DataParser.SLOT in rawAction){var slotName=ObjectDataParser._getString(rawAction,dragonBones.DataParser.SLOT,"");action.slot=this._armature.getSlot(slotName);}else {action.slot=slot;}var userData=null;if(dragonBones.DataParser.INTS in rawAction){if(userData===null){userData=dragonBones.BaseObject.borrowObject(dragonBones.UserData);}var rawInts=rawAction[dragonBones.DataParser.INTS];for(var _a=0,rawInts_1=rawInts;_a<rawInts_1.length;_a++){var rawValue=rawInts_1[_a];userData.addInt(rawValue);}}if(dragonBones.DataParser.FLOATS in rawAction){if(userData===null){userData=dragonBones.BaseObject.borrowObject(dragonBones.UserData);}var rawFloats=rawAction[dragonBones.DataParser.FLOATS];for(var _b=0,rawFloats_1=rawFloats;_b<rawFloats_1.length;_b++){var rawValue=rawFloats_1[_b];userData.addFloat(rawValue);}}if(dragonBones.DataParser.STRINGS in rawAction){if(userData===null){userData=dragonBones.BaseObject.borrowObject(dragonBones.UserData);}var rawStrings=rawAction[dragonBones.DataParser.STRINGS];for(var _c=0,rawStrings_1=rawStrings;_c<rawStrings_1.length;_c++){var rawValue=rawStrings_1[_c];userData.addString(rawValue);}}action.data=userData;actions.push(action);}}return actions;};ObjectDataParser.prototype._parseTransform=function(rawData,transform,scale){transform.x=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.X,0.0)*scale;transform.y=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.Y,0.0)*scale;if(dragonBones.DataParser.ROTATE in rawData||dragonBones.DataParser.SKEW in rawData){transform.rotation=dragonBones.Transform.normalizeRadian(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.ROTATE,0.0)*dragonBones.Transform.DEG_RAD);transform.skew=dragonBones.Transform.normalizeRadian(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SKEW,0.0)*dragonBones.Transform.DEG_RAD);}else if(dragonBones.DataParser.SKEW_X in rawData||dragonBones.DataParser.SKEW_Y in rawData){transform.rotation=dragonBones.Transform.normalizeRadian(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SKEW_Y,0.0)*dragonBones.Transform.DEG_RAD);transform.skew=dragonBones.Transform.normalizeRadian(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SKEW_X,0.0)*dragonBones.Transform.DEG_RAD)-transform.rotation;}transform.scaleX=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SCALE_X,1.0);transform.scaleY=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SCALE_Y,1.0);};ObjectDataParser.prototype._parseColorTransform=function(rawData,color){color.alphaMultiplier=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.ALPHA_MULTIPLIER,100)*0.01;color.redMultiplier=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.RED_MULTIPLIER,100)*0.01;color.greenMultiplier=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.GREEN_MULTIPLIER,100)*0.01;color.blueMultiplier=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.BLUE_MULTIPLIER,100)*0.01;color.alphaOffset=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.ALPHA_OFFSET,0);color.redOffset=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.RED_OFFSET,0);color.greenOffset=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.GREEN_OFFSET,0);color.blueOffset=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.BLUE_OFFSET,0);};ObjectDataParser.prototype._parseArray=function(rawData){this._intArray.length=0;this._floatArray.length=0;this._frameIntArray.length=0;this._frameFloatArray.length=0;this._frameArray.length=0;this._timelineArray.length=0;};ObjectDataParser.prototype._modifyArray=function(){if(this._intArray.length%Int16Array.BYTES_PER_ELEMENT!==0){this._intArray.push(0);}if(this._frameIntArray.length%Int16Array.BYTES_PER_ELEMENT!==0){this._frameIntArray.push(0);}if(this._frameArray.length%Int16Array.BYTES_PER_ELEMENT!==0){this._frameArray.push(0);}if(this._timelineArray.length%Uint16Array.BYTES_PER_ELEMENT!==0){this._timelineArray.push(0);}var l1=this._intArray.length*Int16Array.BYTES_PER_ELEMENT;var l2=this._floatArray.length*Float32Array.BYTES_PER_ELEMENT;var l3=this._frameIntArray.length*Int16Array.BYTES_PER_ELEMENT;var l4=this._frameFloatArray.length*Float32Array.BYTES_PER_ELEMENT;var l5=this._frameArray.length*Int16Array.BYTES_PER_ELEMENT;var l6=this._timelineArray.length*Uint16Array.BYTES_PER_ELEMENT;var lTotal=l1+l2+l3+l4+l5+l6;if(dragonBones.DragonBones.webAssembly){var shareBuffer=dragonBones.webAssemblyModule.HEAP16.buffer;var bufferPointer=dragonBones.webAssemblyModule._malloc(lTotal);var intArray=new Int16Array(shareBuffer,bufferPointer,this._intArray.length);var floatArray=new Float32Array(shareBuffer,bufferPointer+l1,this._floatArray.length);var frameIntArray=new Int16Array(shareBuffer,bufferPointer+l1+l2,this._frameIntArray.length);var frameFloatArray=new Float32Array(shareBuffer,bufferPointer+l1+l2+l3,this._frameFloatArray.length);var frameArray=new Int16Array(shareBuffer,bufferPointer+l1+l2+l3+l4,this._frameArray.length);var timelineArray=new Uint16Array(shareBuffer,bufferPointer+l1+l2+l3+l4+l5,this._timelineArray.length);for(var i=0,l=this._intArray.length;i<l;++i){intArray[i]=this._intArray[i];}for(var i=0,l=this._floatArray.length;i<l;++i){floatArray[i]=this._floatArray[i];}for(var i=0,l=this._frameIntArray.length;i<l;++i){frameIntArray[i]=this._frameIntArray[i];}for(var i=0,l=this._frameFloatArray.length;i<l;++i){frameFloatArray[i]=this._frameFloatArray[i];}for(var i=0,l=this._frameArray.length;i<l;++i){frameArray[i]=this._frameArray[i];}for(var i=0,l=this._timelineArray.length;i<l;++i){timelineArray[i]=this._timelineArray[i];}dragonBones.webAssemblyModule.setDataBinary(this._data,bufferPointer,l1,l2,l3,l4,l5,l6);}else {var binary=new ArrayBuffer(lTotal);var intArray=new Int16Array(binary,0,this._intArray.length);var floatArray=new Float32Array(binary,l1,this._floatArray.length);var frameIntArray=new Int16Array(binary,l1+l2,this._frameIntArray.length);var frameFloatArray=new Float32Array(binary,l1+l2+l3,this._frameFloatArray.length);var frameArray=new Int16Array(binary,l1+l2+l3+l4,this._frameArray.length);var timelineArray=new Uint16Array(binary,l1+l2+l3+l4+l5,this._timelineArray.length);for(var i=0,l=this._intArray.length;i<l;++i){intArray[i]=this._intArray[i];}for(var i=0,l=this._floatArray.length;i<l;++i){floatArray[i]=this._floatArray[i];}for(var i=0,l=this._frameIntArray.length;i<l;++i){frameIntArray[i]=this._frameIntArray[i];}for(var i=0,l=this._frameFloatArray.length;i<l;++i){frameFloatArray[i]=this._frameFloatArray[i];}for(var i=0,l=this._frameArray.length;i<l;++i){frameArray[i]=this._frameArray[i];}for(var i=0,l=this._timelineArray.length;i<l;++i){timelineArray[i]=this._timelineArray[i];}this._data.binary=binary;this._data.intArray=intArray;this._data.floatArray=floatArray;this._data.frameIntArray=frameIntArray;this._data.frameFloatArray=frameFloatArray;this._data.frameArray=frameArray;this._data.timelineArray=timelineArray;}this._defaultColorOffset=-1;};ObjectDataParser.prototype.parseDragonBonesData=function(rawData,scale){if(scale===void 0){scale=1;}console.assert(rawData!==null&&rawData!==undefined,"Data error.");var version=ObjectDataParser._getString(rawData,dragonBones.DataParser.VERSION,"");var compatibleVersion=ObjectDataParser._getString(rawData,dragonBones.DataParser.COMPATIBLE_VERSION,"");if(dragonBones.DataParser.DATA_VERSIONS.indexOf(version)>=0||dragonBones.DataParser.DATA_VERSIONS.indexOf(compatibleVersion)>=0){var data=dragonBones.BaseObject.borrowObject(dragonBones.DragonBonesData);data.version=version;data.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");data.frameRate=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.FRAME_RATE,24);if(data.frameRate===0){data.frameRate=24;}if(dragonBones.DataParser.ARMATURE in rawData){this._data=data;this._parseArray(rawData);var rawArmatures=rawData[dragonBones.DataParser.ARMATURE];for(var _i=0,rawArmatures_1=rawArmatures;_i<rawArmatures_1.length;_i++){var rawArmature=rawArmatures_1[_i];data.addArmature(this._parseArmature(rawArmature,scale));}if(!this._data.binary){this._modifyArray();}if(dragonBones.DataParser.STAGE in rawData){data.stage=data.getArmature(ObjectDataParser._getString(rawData,dragonBones.DataParser.STAGE,""));}else if(data.armatureNames.length>0){data.stage=data.getArmature(data.armatureNames[0]);}this._data=null;}if(dragonBones.DataParser.TEXTURE_ATLAS in rawData){this._rawTextureAtlases=rawData[dragonBones.DataParser.TEXTURE_ATLAS];}return data;}else {console.assert(false,"Nonsupport data version: "+version+"\n"+"Please convert DragonBones data to support version.\n"+"Read more: https://github.com/DragonBones/Tools/");}return null;};ObjectDataParser.prototype.parseTextureAtlasData=function(rawData,textureAtlasData,scale){if(scale===void 0){scale=1.0;}console.assert(rawData!==undefined);if(rawData===null){if(this._rawTextureAtlases===null||this._rawTextureAtlases.length===0){return false;}var rawTextureAtlas=this._rawTextureAtlases[this._rawTextureAtlasIndex++];this.parseTextureAtlasData(rawTextureAtlas,textureAtlasData,scale);if(this._rawTextureAtlasIndex>=this._rawTextureAtlases.length){this._rawTextureAtlasIndex=0;this._rawTextureAtlases=null;}return true;}textureAtlasData.width=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.WIDTH,0);textureAtlasData.height=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.HEIGHT,0);textureAtlasData.scale=scale===1.0?1.0/ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SCALE,1.0):scale;textureAtlasData.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");textureAtlasData.imagePath=ObjectDataParser._getString(rawData,dragonBones.DataParser.IMAGE_PATH,"");if(dragonBones.DataParser.SUB_TEXTURE in rawData){var rawTextures=rawData[dragonBones.DataParser.SUB_TEXTURE];for(var i=0,l=rawTextures.length;i<l;++i){var rawTexture=rawTextures[i];var textureData=textureAtlasData.createTexture();textureData.rotated=ObjectDataParser._getBoolean(rawTexture,dragonBones.DataParser.ROTATED,false);textureData.name=ObjectDataParser._getString(rawTexture,dragonBones.DataParser.NAME,"");textureData.region.x=ObjectDataParser._getNumber(rawTexture,dragonBones.DataParser.X,0.0);textureData.region.y=ObjectDataParser._getNumber(rawTexture,dragonBones.DataParser.Y,0.0);textureData.region.width=ObjectDataParser._getNumber(rawTexture,dragonBones.DataParser.WIDTH,0.0);textureData.region.height=ObjectDataParser._getNumber(rawTexture,dragonBones.DataParser.HEIGHT,0.0);var frameWidth=ObjectDataParser._getNumber(rawTexture,dragonBones.DataParser.FRAME_WIDTH,-1.0);var frameHeight=ObjectDataParser._getNumber(rawTexture,dragonBones.DataParser.FRAME_HEIGHT,-1.0);if(frameWidth>0.0&&frameHeight>0.0){textureData.frame=dragonBones.TextureData.createRectangle();textureData.frame.x=ObjectDataParser._getNumber(rawTexture,dragonBones.DataParser.FRAME_X,0.0);textureData.frame.y=ObjectDataParser._getNumber(rawTexture,dragonBones.DataParser.FRAME_Y,0.0);textureData.frame.width=frameWidth;textureData.frame.height=frameHeight;}textureAtlasData.addTexture(textureData);}}return true;};ObjectDataParser.getInstance=function(){if(ObjectDataParser._objectDataParserInstance===null){ObjectDataParser._objectDataParserInstance=new ObjectDataParser();}return ObjectDataParser._objectDataParserInstance;};ObjectDataParser._objectDataParserInstance=null;return ObjectDataParser;}(dragonBones.DataParser);dragonBones.ObjectDataParser=ObjectDataParser;var ActionFrame=function(){function ActionFrame(){this.frameStart=0;this.actions=[];}return ActionFrame;}();dragonBones.ActionFrame=ActionFrame;})(dragonBones||(dragonBones={}));(function(dragonBones){var BinaryDataParser=function(_super){__extends(BinaryDataParser,_super);function BinaryDataParser(){return _super!==null&&_super.apply(this,arguments)||this;}BinaryDataParser.prototype._inRange=function(a,min,max){return min<=a&&a<=max;};BinaryDataParser.prototype._decodeUTF8=function(data){var EOF_byte=-1;var EOF_code_point=-1;var FATAL_POINT=0xFFFD;var pos=0;var result="";var code_point;var utf8_code_point=0;var utf8_bytes_needed=0;var utf8_bytes_seen=0;var utf8_lower_boundary=0;while(data.length>pos){var _byte=data[pos++];if(_byte===EOF_byte){if(utf8_bytes_needed!==0){code_point=FATAL_POINT;}else {code_point=EOF_code_point;}}else {if(utf8_bytes_needed===0){if(this._inRange(_byte,0x00,0x7F)){code_point=_byte;}else {if(this._inRange(_byte,0xC2,0xDF)){utf8_bytes_needed=1;utf8_lower_boundary=0x80;utf8_code_point=_byte-0xC0;}else if(this._inRange(_byte,0xE0,0xEF)){utf8_bytes_needed=2;utf8_lower_boundary=0x800;utf8_code_point=_byte-0xE0;}else if(this._inRange(_byte,0xF0,0xF4)){utf8_bytes_needed=3;utf8_lower_boundary=0x10000;utf8_code_point=_byte-0xF0;}else;utf8_code_point=utf8_code_point*Math.pow(64,utf8_bytes_needed);code_point=null;}}else if(!this._inRange(_byte,0x80,0xBF)){utf8_code_point=0;utf8_bytes_needed=0;utf8_bytes_seen=0;utf8_lower_boundary=0;pos--;code_point=_byte;}else {utf8_bytes_seen+=1;utf8_code_point=utf8_code_point+(_byte-0x80)*Math.pow(64,utf8_bytes_needed-utf8_bytes_seen);if(utf8_bytes_seen!==utf8_bytes_needed){code_point=null;}else {var cp=utf8_code_point;var lower_boundary=utf8_lower_boundary;utf8_code_point=0;utf8_bytes_needed=0;utf8_bytes_seen=0;utf8_lower_boundary=0;if(this._inRange(cp,lower_boundary,0x10FFFF)&&!this._inRange(cp,0xD800,0xDFFF)){code_point=cp;}else {code_point=_byte;}}}}if(code_point!==null&&code_point!==EOF_code_point){if(code_point<=0xFFFF){if(code_point>0)result+=String.fromCharCode(code_point);}else {code_point-=0x10000;result+=String.fromCharCode(0xD800+(code_point>>10&0x3ff));result+=String.fromCharCode(0xDC00+(code_point&0x3ff));}}}return result;};BinaryDataParser.prototype._getUTF16Key=function(value){for(var i=0,l=value.length;i<l;++i){if(value.charCodeAt(i)>255){return encodeURI(value);}}return value;};BinaryDataParser.prototype._parseBinaryTimeline=function(type,offset,timelineData){if(timelineData===void 0){timelineData=null;}var timeline=timelineData!==null?timelineData:dragonBones.BaseObject.borrowObject(dragonBones.TimelineData);timeline.type=type;timeline.offset=offset;this._timeline=timeline;var keyFrameCount=this._timelineArrayBuffer[timeline.offset+2];if(keyFrameCount===1){timeline.frameIndicesOffset=-1;}else {var frameIndicesOffset=0;var totalFrameCount=this._animation.frameCount+1;var frameIndices=this._data.frameIndices;if(dragonBones.DragonBones.webAssembly){frameIndicesOffset=frameIndices.size();frameIndices.resize(frameIndicesOffset+totalFrameCount,0);}else {frameIndicesOffset=frameIndices.length;frameIndices.length+=totalFrameCount;}timeline.frameIndicesOffset=frameIndicesOffset;for(var i=0,iK=0,frameStart=0,frameCount=0;i<totalFrameCount;++i){if(frameStart+frameCount<=i&&iK<keyFrameCount){frameStart=this._frameArrayBuffer[this._animation.frameOffset+this._timelineArrayBuffer[timeline.offset+5+iK]];if(iK===keyFrameCount-1){frameCount=this._animation.frameCount-frameStart;}else {frameCount=this._frameArrayBuffer[this._animation.frameOffset+this._timelineArrayBuffer[timeline.offset+5+iK+1]]-frameStart;}iK++;}if(dragonBones.DragonBones.webAssembly){frameIndices.set(frameIndicesOffset+i,iK-1);}else {frameIndices[frameIndicesOffset+i]=iK-1;}}}this._timeline=null;return timeline;};BinaryDataParser.prototype._parseVertices=function(rawData,vertices){vertices.offset=rawData[dragonBones.DataParser.OFFSET];var weightOffset=this._intArrayBuffer[vertices.offset+3];if(weightOffset>=0){var weight=dragonBones.BaseObject.borrowObject(dragonBones.WeightData);var vertexCount=this._intArrayBuffer[vertices.offset+0];var boneCount=this._intArrayBuffer[weightOffset+0];weight.offset=weightOffset;for(var i=0;i<boneCount;++i){var boneIndex=this._intArrayBuffer[weightOffset+2+i];weight.addBone(this._rawBones[boneIndex]);}var boneIndicesOffset=weightOffset+2+boneCount;var weightCount=0;for(var i=0,l=vertexCount;i<l;++i){var vertexBoneCount=this._intArrayBuffer[boneIndicesOffset++];weightCount+=vertexBoneCount;boneIndicesOffset+=vertexBoneCount;}weight.count=weightCount;vertices.weight=weight;}};BinaryDataParser.prototype._parseMesh=function(rawData,mesh){this._parseVertices(rawData,mesh.vertices);};BinaryDataParser.prototype._parsePath=function(rawData,path){this._parseVertices(rawData,path.vertices);};BinaryDataParser.prototype._parseAnimation=function(rawData){var animation=dragonBones.BaseObject.borrowObject(dragonBones.AnimationData);animation.frameCount=Math.max(dragonBones.ObjectDataParser._getNumber(rawData,dragonBones.DataParser.DURATION,1),1);animation.playTimes=dragonBones.ObjectDataParser._getNumber(rawData,dragonBones.DataParser.PLAY_TIMES,1);animation.duration=animation.frameCount/this._armature.frameRate;animation.fadeInTime=dragonBones.ObjectDataParser._getNumber(rawData,dragonBones.DataParser.FADE_IN_TIME,0.0);animation.scale=dragonBones.ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SCALE,1.0);animation.name=dragonBones.ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,dragonBones.DataParser.DEFAULT_NAME);if(animation.name.length===0){animation.name=dragonBones.DataParser.DEFAULT_NAME;}var offsets=rawData[dragonBones.DataParser.OFFSET];animation.frameIntOffset=offsets[0];animation.frameFloatOffset=offsets[1];animation.frameOffset=offsets[2];this._animation=animation;if(dragonBones.DataParser.ACTION in rawData){animation.actionTimeline=this._parseBinaryTimeline(0,rawData[dragonBones.DataParser.ACTION]);}if(dragonBones.DataParser.Z_ORDER in rawData){animation.zOrderTimeline=this._parseBinaryTimeline(1,rawData[dragonBones.DataParser.Z_ORDER]);}if(dragonBones.DataParser.BONE in rawData){var rawTimeliness=rawData[dragonBones.DataParser.BONE];for(var k in rawTimeliness){var rawTimelines=rawTimeliness[k];if(dragonBones.DragonBones.webAssembly){k=this._getUTF16Key(k);}var bone=this._armature.getBone(k);if(bone===null){continue;}for(var i=0,l=rawTimelines.length;i<l;i+=2){var timelineType=rawTimelines[i];var timelineOffset=rawTimelines[i+1];var timeline=this._parseBinaryTimeline(timelineType,timelineOffset);this._animation.addBoneTimeline(bone,timeline);}}}if(dragonBones.DataParser.SURFACE in rawData){var rawTimeliness=rawData[dragonBones.DataParser.SURFACE];for(var k in rawTimeliness){var rawTimelines=rawTimeliness[k];if(dragonBones.DragonBones.webAssembly){k=this._getUTF16Key(k);}var surface=this._armature.getBone(k);if(surface===null){continue;}for(var i=0,l=rawTimelines.length;i<l;i+=2){var timelineType=rawTimelines[i];var timelineOffset=rawTimelines[i+1];var timeline=this._parseBinaryTimeline(timelineType,timelineOffset);this._animation.addSurfaceTimeline(surface,timeline);}}}if(dragonBones.DataParser.SLOT in rawData){var rawTimeliness=rawData[dragonBones.DataParser.SLOT];for(var k in rawTimeliness){var rawTimelines=rawTimeliness[k];if(dragonBones.DragonBones.webAssembly){k=this._getUTF16Key(k);}var slot=this._armature.getSlot(k);if(slot===null){continue;}for(var i=0,l=rawTimelines.length;i<l;i+=2){var timelineType=rawTimelines[i];var timelineOffset=rawTimelines[i+1];var timeline=this._parseBinaryTimeline(timelineType,timelineOffset);this._animation.addSlotTimeline(slot,timeline);}}}if(dragonBones.DataParser.CONSTRAINT in rawData){var rawTimeliness=rawData[dragonBones.DataParser.CONSTRAINT];for(var k in rawTimeliness){var rawTimelines=rawTimeliness[k];if(dragonBones.DragonBones.webAssembly){k=this._getUTF16Key(k);}var constraint=this._armature.getConstraint(k);if(constraint===null){continue;}for(var i=0,l=rawTimelines.length;i<l;i+=2){var timelineType=rawTimelines[i];var timelineOffset=rawTimelines[i+1];var timeline=this._parseBinaryTimeline(timelineType,timelineOffset);this._animation.addConstraintTimeline(constraint,timeline);}}}if(dragonBones.DataParser.ANIMATION in rawData){var rawTimeliness=rawData[dragonBones.DataParser.ANIMATION];for(var k in rawTimeliness){var rawTimelines=rawTimeliness[k];if(dragonBones.DragonBones.webAssembly){k=this._getUTF16Key(k);}for(var i=0,l=rawTimelines.length;i<l;i+=2){var timelineType=rawTimelines[i];var timelineOffset=rawTimelines[i+1];var timeline=this._parseBinaryTimeline(timelineType,timelineOffset);this._animation.addAnimationTimeline(k,timeline);}}}this._animation=null;return animation;};BinaryDataParser.prototype._parseArray=function(rawData){var offsets=rawData[dragonBones.DataParser.OFFSET];var l1=offsets[1];var l2=offsets[3];var l3=offsets[5];var l4=offsets[7];var l5=offsets[9];var l6=offsets[11];var intArray=new Int16Array(this._binary,this._binaryOffset+offsets[0],l1/Int16Array.BYTES_PER_ELEMENT);var floatArray=new Float32Array(this._binary,this._binaryOffset+offsets[2],l2/Float32Array.BYTES_PER_ELEMENT);var frameIntArray=new Int16Array(this._binary,this._binaryOffset+offsets[4],l3/Int16Array.BYTES_PER_ELEMENT);var frameFloatArray=new Float32Array(this._binary,this._binaryOffset+offsets[6],l4/Float32Array.BYTES_PER_ELEMENT);var frameArray=new Int16Array(this._binary,this._binaryOffset+offsets[8],l5/Int16Array.BYTES_PER_ELEMENT);var timelineArray=new Uint16Array(this._binary,this._binaryOffset+offsets[10],l6/Uint16Array.BYTES_PER_ELEMENT);if(dragonBones.DragonBones.webAssembly){var lTotal=l1+l2+l3+l4+l5+l6;var bufferPointer=dragonBones.webAssemblyModule._malloc(lTotal);var rawArray=new Uint8Array(this._binary,this._binaryOffset,lTotal/Uint8Array.BYTES_PER_ELEMENT);var copyArray=new Uint8Array(dragonBones.webAssemblyModule.HEAP16.buffer,bufferPointer,rawArray.length);for(var i=0,l=rawArray.length;i<l;++i){copyArray[i]=rawArray[i];}dragonBones.webAssemblyModule.setDataBinary(this._data,bufferPointer,l1,l2,l3,l4,l5,l6);this._intArrayBuffer=intArray;this._floatArrayBuffer=floatArray;this._frameIntArrayBuffer=frameIntArray;this._frameFloatArrayBuffer=frameFloatArray;this._frameArrayBuffer=frameArray;this._timelineArrayBuffer=timelineArray;}else {this._data.binary=this._binary;this._data.intArray=this._intArrayBuffer=intArray;this._data.floatArray=this._floatArrayBuffer=floatArray;this._data.frameIntArray=this._frameIntArrayBuffer=frameIntArray;this._data.frameFloatArray=this._frameFloatArrayBuffer=frameFloatArray;this._data.frameArray=this._frameArrayBuffer=frameArray;this._data.timelineArray=this._timelineArrayBuffer=timelineArray;}};BinaryDataParser.prototype.parseDragonBonesData=function(rawData,scale){if(scale===void 0){scale=1;}console.assert(rawData!==null&&rawData!==undefined&&rawData instanceof ArrayBuffer,"Data error.");var tag=new Uint8Array(rawData,0,8);if(tag[0]!=="D".charCodeAt(0)||tag[1]!=="B".charCodeAt(0)||tag[2]!=="D".charCodeAt(0)||tag[3]!=="T".charCodeAt(0)){console.assert(false,"Nonsupport data.");return null;}var headerLength=new Uint32Array(rawData,8,1)[0];var headerBytes=new Uint8Array(rawData,8+4,headerLength);var headerString=this._decodeUTF8(headerBytes);var header=JSON.parse(headerString);this._binaryOffset=8+4+headerLength;this._binary=rawData;return _super.prototype.parseDragonBonesData.call(this,header,scale);};BinaryDataParser.getInstance=function(){if(BinaryDataParser._binaryDataParserInstance===null){BinaryDataParser._binaryDataParserInstance=new BinaryDataParser();}return BinaryDataParser._binaryDataParserInstance;};BinaryDataParser._binaryDataParserInstance=null;return BinaryDataParser;}(dragonBones.ObjectDataParser);dragonBones.BinaryDataParser=BinaryDataParser;})(dragonBones||(dragonBones={}));(function(dragonBones){var BaseFactory=function(){function BaseFactory(dataParser){if(dataParser===void 0){dataParser=null;}this.autoSearch=false;this._dragonBonesDataMap={};this._textureAtlasDataMap={};this._dragonBones=null;this._dataParser=null;if(BaseFactory._objectParser===null){BaseFactory._objectParser=new dragonBones.ObjectDataParser();}if(BaseFactory._binaryParser===null){BaseFactory._binaryParser=new dragonBones.BinaryDataParser();}this._dataParser=dataParser!==null?dataParser:BaseFactory._objectParser;}BaseFactory.prototype._isSupportMesh=function(){return true;};BaseFactory.prototype._getTextureData=function(textureAtlasName,textureName){if(textureAtlasName in this._textureAtlasDataMap){for(var _i=0,_a=this._textureAtlasDataMap[textureAtlasName];_i<_a.length;_i++){var textureAtlasData=_a[_i];var textureData=textureAtlasData.getTexture(textureName);if(textureData!==null){return textureData;}}}if(this.autoSearch){for(var k in this._textureAtlasDataMap){for(var _b=0,_c=this._textureAtlasDataMap[k];_b<_c.length;_b++){var textureAtlasData=_c[_b];if(textureAtlasData.autoSearch){var textureData=textureAtlasData.getTexture(textureName);if(textureData!==null){return textureData;}}}}}return null;};BaseFactory.prototype._fillBuildArmaturePackage=function(dataPackage,dragonBonesName,armatureName,skinName,textureAtlasName){var dragonBonesData=null;var armatureData=null;if(dragonBonesName.length>0){if(dragonBonesName in this._dragonBonesDataMap){dragonBonesData=this._dragonBonesDataMap[dragonBonesName];armatureData=dragonBonesData.getArmature(armatureName);}}if(armatureData===null&&(dragonBonesName.length===0||this.autoSearch)){for(var k in this._dragonBonesDataMap){dragonBonesData=this._dragonBonesDataMap[k];if(dragonBonesName.length===0||dragonBonesData.autoSearch){armatureData=dragonBonesData.getArmature(armatureName);if(armatureData!==null){dragonBonesName=k;break;}}}}if(armatureData!==null){dataPackage.dataName=dragonBonesName;dataPackage.textureAtlasName=textureAtlasName;dataPackage.data=dragonBonesData;dataPackage.armature=armatureData;dataPackage.skin=null;if(skinName.length>0){dataPackage.skin=armatureData.getSkin(skinName);if(dataPackage.skin===null&&this.autoSearch){for(var k in this._dragonBonesDataMap){var skinDragonBonesData=this._dragonBonesDataMap[k];var skinArmatureData=skinDragonBonesData.getArmature(skinName);if(skinArmatureData!==null){dataPackage.skin=skinArmatureData.defaultSkin;break;}}}}if(dataPackage.skin===null){dataPackage.skin=armatureData.defaultSkin;}return true;}return false;};BaseFactory.prototype._buildBones=function(dataPackage,armature){for(var _i=0,_a=dataPackage.armature.sortedBones;_i<_a.length;_i++){var boneData=_a[_i];var bone=dragonBones.BaseObject.borrowObject(boneData.type===0?dragonBones.Bone:dragonBones.Surface);bone.init(boneData,armature);}};BaseFactory.prototype._buildSlots=function(dataPackage,armature){var currentSkin=dataPackage.skin;var defaultSkin=dataPackage.armature.defaultSkin;if(currentSkin===null||defaultSkin===null){return;}var skinSlots={};for(var k in defaultSkin.displays){var displays=defaultSkin.getDisplays(k);skinSlots[k]=displays;}if(currentSkin!==defaultSkin){for(var k in currentSkin.displays){var displays=currentSkin.getDisplays(k);skinSlots[k]=displays;}}for(var _i=0,_a=dataPackage.armature.sortedSlots;_i<_a.length;_i++){var slotData=_a[_i];var displayDatas=slotData.name in skinSlots?skinSlots[slotData.name]:null;var slot=this._buildSlot(dataPackage,slotData,armature);slot.rawDisplayDatas=displayDatas;if(displayDatas!==null){var displayList=new Array();for(var i=0,l=dragonBones.DragonBones.webAssembly?displayDatas.size():displayDatas.length;i<l;++i){var displayData=dragonBones.DragonBones.webAssembly?displayDatas.get(i):displayDatas[i];if(displayData!==null){displayList.push(this._getSlotDisplay(dataPackage,displayData,null,slot));}else {displayList.push(null);}}slot._setDisplayList(displayList);}slot._setDisplayIndex(slotData.displayIndex,true);}};BaseFactory.prototype._buildConstraints=function(dataPackage,armature){var constraints=dataPackage.armature.constraints;for(var k in constraints){var constraintData=constraints[k];switch(constraintData.type){case 0:var ikConstraint=dragonBones.BaseObject.borrowObject(dragonBones.IKConstraint);ikConstraint.init(constraintData,armature);armature._addConstraint(ikConstraint);break;case 1:var pathConstraint=dragonBones.BaseObject.borrowObject(dragonBones.PathConstraint);pathConstraint.init(constraintData,armature);armature._addConstraint(pathConstraint);break;default:var constraint=dragonBones.BaseObject.borrowObject(dragonBones.IKConstraint);constraint.init(constraintData,armature);armature._addConstraint(constraint);break;}}};BaseFactory.prototype._buildChildArmature=function(dataPackage,slot,displayData){return this.buildArmature(displayData.path,dataPackage!==null?dataPackage.dataName:"","",dataPackage!==null?dataPackage.textureAtlasName:"");};BaseFactory.prototype._getSlotDisplay=function(dataPackage,displayData,rawDisplayData,slot){var dataName=dataPackage!==null?dataPackage.dataName:displayData.parent.parent.parent.name;var display=null;switch(displayData.type){case 0:{var imageDisplayData=displayData;if(dataPackage!==null&&dataPackage.textureAtlasName.length>0){imageDisplayData.texture=this._getTextureData(dataPackage.textureAtlasName,displayData.path);}if(imageDisplayData.texture===null){imageDisplayData.texture=this._getTextureData(dataName,displayData.path);}if(rawDisplayData!==null&&rawDisplayData.type===2&&this._isSupportMesh()){display=slot.meshDisplay;}else {display=slot.rawDisplay;}break;}case 2:{var meshDisplayData=displayData;if(dataPackage!==null&&dataPackage.textureAtlasName.length>0){meshDisplayData.texture=this._getTextureData(dataPackage.textureAtlasName,meshDisplayData.path);}if(meshDisplayData.texture===null){meshDisplayData.texture=this._getTextureData(dataName,meshDisplayData.path);}if(this._isSupportMesh()){display=slot.meshDisplay;}else {display=slot.rawDisplay;}break;}case 1:{var armatureDisplayData=displayData;var childArmature=this._buildChildArmature(dataPackage,slot,displayData);if(childArmature!==null){childArmature.inheritAnimation=armatureDisplayData.inheritAnimation;if(!childArmature.inheritAnimation){var actions=armatureDisplayData.actions.length>0?armatureDisplayData.actions:childArmature.armatureData.defaultActions;if(actions.length>0){for(var _i=0,actions_6=actions;_i<actions_6.length;_i++){var action=actions_6[_i];var eventObject=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);dragonBones.EventObject.actionDataToInstance(action,eventObject,slot.armature);eventObject.slot=slot;slot.armature._bufferAction(eventObject,false);}}else {childArmature.animation.play();}}armatureDisplayData.armature=childArmature.armatureData;}display=childArmature;break;}}return display;};BaseFactory.prototype.parseDragonBonesData=function(rawData,name,scale){if(name===void 0){name=null;}if(scale===void 0){scale=1.0;}var dataParser=rawData instanceof ArrayBuffer?BaseFactory._binaryParser:this._dataParser;var dragonBonesData=dataParser.parseDragonBonesData(rawData,scale);while(true){var textureAtlasData=this._buildTextureAtlasData(null,null);if(dataParser.parseTextureAtlasData(null,textureAtlasData,scale)){this.addTextureAtlasData(textureAtlasData,name);}else {textureAtlasData.returnToPool();break;}}if(dragonBonesData!==null){this.addDragonBonesData(dragonBonesData,name);}return dragonBonesData;};BaseFactory.prototype.parseTextureAtlasData=function(rawData,textureAtlas,name,scale){if(name===void 0){name=null;}if(scale===void 0){scale=1.0;}var textureAtlasData=this._buildTextureAtlasData(null,null);this._dataParser.parseTextureAtlasData(rawData,textureAtlasData,scale);this._buildTextureAtlasData(textureAtlasData,textureAtlas||null);this.addTextureAtlasData(textureAtlasData,name);return textureAtlasData;};BaseFactory.prototype.updateTextureAtlasData=function(name,textureAtlases){var textureAtlasDatas=this.getTextureAtlasData(name);if(textureAtlasDatas!==null){for(var i=0,l=textureAtlasDatas.length;i<l;++i){if(i<textureAtlases.length){this._buildTextureAtlasData(textureAtlasDatas[i],textureAtlases[i]);}}}};BaseFactory.prototype.getDragonBonesData=function(name){return name in this._dragonBonesDataMap?this._dragonBonesDataMap[name]:null;};BaseFactory.prototype.addDragonBonesData=function(data,name){if(name===void 0){name=null;}name=name!==null?name:data.name;if(name in this._dragonBonesDataMap){if(this._dragonBonesDataMap[name]===data){return;}console.warn("Can not add same name data: "+name);return;}this._dragonBonesDataMap[name]=data;};BaseFactory.prototype.removeDragonBonesData=function(name,disposeData){if(disposeData===void 0){disposeData=true;}if(name in this._dragonBonesDataMap){if(disposeData){this._dragonBones.bufferObject(this._dragonBonesDataMap[name]);}delete this._dragonBonesDataMap[name];}};BaseFactory.prototype.getTextureAtlasData=function(name){return name in this._textureAtlasDataMap?this._textureAtlasDataMap[name]:null;};BaseFactory.prototype.addTextureAtlasData=function(data,name){if(name===void 0){name=null;}name=name!==null?name:data.name;var textureAtlasList=name in this._textureAtlasDataMap?this._textureAtlasDataMap[name]:this._textureAtlasDataMap[name]=[];if(textureAtlasList.indexOf(data)<0){textureAtlasList.push(data);}};BaseFactory.prototype.removeTextureAtlasData=function(name,disposeData){if(disposeData===void 0){disposeData=true;}if(name in this._textureAtlasDataMap){var textureAtlasDataList=this._textureAtlasDataMap[name];if(disposeData){for(var _i=0,textureAtlasDataList_1=textureAtlasDataList;_i<textureAtlasDataList_1.length;_i++){var textureAtlasData=textureAtlasDataList_1[_i];this._dragonBones.bufferObject(textureAtlasData);}}delete this._textureAtlasDataMap[name];}};BaseFactory.prototype.getArmatureData=function(name,dragonBonesName){if(dragonBonesName===void 0){dragonBonesName="";}var dataPackage=new BuildArmaturePackage();if(!this._fillBuildArmaturePackage(dataPackage,dragonBonesName,name,"","")){return null;}return dataPackage.armature;};BaseFactory.prototype.clear=function(disposeData){if(disposeData===void 0){disposeData=true;}for(var k in this._dragonBonesDataMap){if(disposeData){this._dragonBones.bufferObject(this._dragonBonesDataMap[k]);}delete this._dragonBonesDataMap[k];}for(var k in this._textureAtlasDataMap){if(disposeData){var textureAtlasDataList=this._textureAtlasDataMap[k];for(var _i=0,textureAtlasDataList_2=textureAtlasDataList;_i<textureAtlasDataList_2.length;_i++){var textureAtlasData=textureAtlasDataList_2[_i];this._dragonBones.bufferObject(textureAtlasData);}}delete this._textureAtlasDataMap[k];}};BaseFactory.prototype.buildArmature=function(armatureName,dragonBonesName,skinName,textureAtlasName){if(dragonBonesName===void 0){dragonBonesName="";}if(skinName===void 0){skinName="";}if(textureAtlasName===void 0){textureAtlasName="";}var dataPackage=new BuildArmaturePackage();if(!this._fillBuildArmaturePackage(dataPackage,dragonBonesName||"",armatureName,skinName||"",textureAtlasName||"")){console.warn("No armature data: "+armatureName+", "+(dragonBonesName!==null?dragonBonesName:""));return null;}var armature=this._buildArmature(dataPackage);this._buildBones(dataPackage,armature);this._buildSlots(dataPackage,armature);this._buildConstraints(dataPackage,armature);armature.invalidUpdate(null,true);armature.advanceTime(0.0);return armature;};BaseFactory.prototype.replaceDisplay=function(slot,displayData,displayIndex){if(displayIndex===void 0){displayIndex=-1;}if(displayIndex<0){displayIndex=slot.displayIndex;}if(displayIndex<0){displayIndex=0;}slot.replaceDisplayData(displayData,displayIndex);var displayList=slot.displayList;if(displayList.length<=displayIndex){displayList.length=displayIndex+1;for(var i=0,l=displayList.length;i<l;++i){if(!displayList[i]){displayList[i]=null;}}}if(displayData!==null){var rawDisplayDatas=slot.rawDisplayDatas;var rawDisplayData=null;if(rawDisplayDatas){if(dragonBones.DragonBones.webAssembly){if(displayIndex<rawDisplayDatas.size()){rawDisplayData=rawDisplayDatas.get(displayIndex);}}else {if(displayIndex<rawDisplayDatas.length){rawDisplayData=rawDisplayDatas[displayIndex];}}}displayList[displayIndex]=this._getSlotDisplay(null,displayData,rawDisplayData,slot);}else {displayList[displayIndex]=null;}slot.displayList=displayList;};BaseFactory.prototype.replaceSlotDisplay=function(dragonBonesName,armatureName,slotName,displayName,slot,displayIndex){if(displayIndex===void 0){displayIndex=-1;}var armatureData=this.getArmatureData(armatureName,dragonBonesName||"");if(!armatureData||!armatureData.defaultSkin){return false;}var displayData=armatureData.defaultSkin.getDisplay(slotName,displayName);if(!displayData){return false;}this.replaceDisplay(slot,displayData,displayIndex);return true;};BaseFactory.prototype.replaceSlotDisplayList=function(dragonBonesName,armatureName,slotName,slot){var armatureData=this.getArmatureData(armatureName,dragonBonesName||"");if(!armatureData||!armatureData.defaultSkin){return false;}var displays=armatureData.defaultSkin.getDisplays(slotName);if(!displays){return false;}var displayIndex=0;for(var i=0,l=dragonBones.DragonBones.webAssembly?displays.size():displays.length;i<l;++i){var displayData=dragonBones.DragonBones.webAssembly?displays.get(i):displays[i];this.replaceDisplay(slot,displayData,displayIndex++);}return true;};BaseFactory.prototype.replaceSkin=function(armature,skin,isOverride,exclude){if(isOverride===void 0){isOverride=false;}if(exclude===void 0){exclude=null;}var success=false;var defaultSkin=skin.parent.defaultSkin;for(var _i=0,_a=armature.getSlots();_i<_a.length;_i++){var slot=_a[_i];if(exclude!==null&&exclude.indexOf(slot.name)>=0){continue;}var displays=skin.getDisplays(slot.name);if(!displays){if(defaultSkin!==null&&skin!==defaultSkin){displays=defaultSkin.getDisplays(slot.name);}if(!displays){if(isOverride){slot.rawDisplayDatas=null;slot.displayList=[];}continue;}}var displayCount=dragonBones.DragonBones.webAssembly?displays.size():displays.length;var displayList=slot.displayList;displayList.length=displayCount;for(var i=0,l=displayCount;i<l;++i){var displayData=dragonBones.DragonBones.webAssembly?displays.get(i):displays[i];if(displayData!==null){displayList[i]=this._getSlotDisplay(null,displayData,null,slot);}else {displayList[i]=null;}}success=true;slot.rawDisplayDatas=displays;slot.displayList=displayList;}return success;};BaseFactory.prototype.replaceAnimation=function(armature,armatureData,isOverride){if(isOverride===void 0){isOverride=true;}var skinData=armatureData.defaultSkin;if(skinData===null){return false;}if(isOverride){armature.animation.animations=armatureData.animations;}else {var rawAnimations=armature.animation.animations;var animations={};for(var k in rawAnimations){animations[k]=rawAnimations[k];}for(var k in armatureData.animations){animations[k]=armatureData.animations[k];}armature.animation.animations=animations;}for(var _i=0,_a=armature.getSlots();_i<_a.length;_i++){var slot=_a[_i];var index=0;for(var _b=0,_c=slot.displayList;_b<_c.length;_b++){var display=_c[_b];if(display instanceof dragonBones.Armature){var displayDatas=skinData.getDisplays(slot.name);if(displayDatas!==null&&index<(dragonBones.DragonBones.webAssembly?displayDatas.size():displayDatas.length)){var displayData=dragonBones.DragonBones.webAssembly?displayDatas.get(index):displayDatas[index];if(displayData!==null&&displayData.type===1){var childArmatureData=this.getArmatureData(displayData.path,displayData.parent.parent.parent.name);if(childArmatureData){this.replaceAnimation(display,childArmatureData,isOverride);}}}}index++;}}return true;};BaseFactory.prototype.getAllDragonBonesData=function(){return this._dragonBonesDataMap;};BaseFactory.prototype.getAllTextureAtlasData=function(){return this._textureAtlasDataMap;};Object.defineProperty(BaseFactory.prototype,"clock",{get:function get(){return this._dragonBones.clock;},enumerable:true,configurable:true});Object.defineProperty(BaseFactory.prototype,"dragonBones",{get:function get(){return this._dragonBones;},enumerable:true,configurable:true});BaseFactory.prototype.changeSkin=function(armature,skin,exclude){if(exclude===void 0){exclude=null;}return this.replaceSkin(armature,skin,false,exclude);};BaseFactory.prototype.copyAnimationsToArmature=function(toArmature,fromArmatreName,fromSkinName,fromDragonBonesDataName,replaceOriginalAnimation){if(fromDragonBonesDataName===void 0){fromDragonBonesDataName="";}if(replaceOriginalAnimation===void 0){replaceOriginalAnimation=true;}var armatureData=this.getArmatureData(fromArmatreName,fromDragonBonesDataName);if(!armatureData){return false;}return this.replaceAnimation(toArmature,armatureData,replaceOriginalAnimation);};BaseFactory._objectParser=null;BaseFactory._binaryParser=null;return BaseFactory;}();dragonBones.BaseFactory=BaseFactory;var BuildArmaturePackage=function(){function BuildArmaturePackage(){this.dataName="";this.textureAtlasName="";this.skin=null;}return BuildArmaturePackage;}();dragonBones.BuildArmaturePackage=BuildArmaturePackage;})(dragonBones||(dragonBones={}));(function(dragonBones){dragonBones.BinaryOffset={WeigthBoneCount:0,WeigthFloatOffset:1,WeigthBoneIndices:2,MeshVertexCount:0,MeshTriangleCount:1,MeshFloatOffset:2,MeshWeightOffset:3,MeshVertexIndices:4,TimelineScale:0,TimelineOffset:1,TimelineKeyFrameCount:2,TimelineFrameValueCount:3,TimelineFrameValueOffset:4,TimelineFrameOffset:5,FramePosition:0,FrameTweenType:1,FrameTweenEasingOrCurveSampleCount:2,FrameCurveSamples:3,DeformMeshOffset:0,DeformCount:1,DeformValueCount:2,DeformValueOffset:3,DeformFloatOffset:4};dragonBones.ArmatureType={Armature:0,MovieClip:1,Stage:2};dragonBones.BoneType={Bone:0,Surface:1};dragonBones.DisplayType={Image:0,Armature:1,Mesh:2,BoundingBox:3};dragonBones.BoundingBoxType={Rectangle:0,Ellipse:1,Polygon:2};dragonBones.ActionType={Play:0,Stop:1,GotoAndPlay:2,GotoAndStop:3,FadeIn:4,FadeOut:5,Frame:10,Sound:11};dragonBones.BlendMode={Normal:0,Add:1,Alpha:2,Darken:3,Difference:4,Erase:5,HardLight:6,Invert:7,Layer:8,Lighten:9,Multiply:10,Overlay:11,Screen:12,Subtract:13};dragonBones.TweenType={None:0,Line:1,Curve:2,QuadIn:3,QuadOut:4,QuadInOut:5};dragonBones.TimelineType={Action:0,ZOrder:1,BoneAll:10,BoneTranslate:11,BoneRotate:12,BoneScale:13,Surface:50,SlotDisplay:20,SlotColor:21,SlotFFD:22,IKConstraint:30,AnimationTime:40,AnimationWeight:41};})(dragonBones||(dragonBones={}));var DragonBones=dragonBones.DragonBones;var BaseObject=dragonBones.BaseObject;var Matrix=dragonBones.Matrix;var Transform=dragonBones.Transform;var ColorTransform=dragonBones.ColorTransform;var Point$1=dragonBones.Point;var Rectangle=dragonBones.Rectangle;var UserData=dragonBones.UserData;var ActionData=dragonBones.ActionData;var DragonBonesData=dragonBones.DragonBonesData;var ArmatureData=dragonBones.ArmatureData;var BoneData=dragonBones.BoneData;var SurfaceData=dragonBones.SurfaceData;var SlotData=dragonBones.SlotData;var ConstraintData=dragonBones.ConstraintData;var IKConstraintData=dragonBones.IKConstraintData;var PathConstraintData=dragonBones.PathConstraintData;var CanvasData=dragonBones.CanvasData;var SkinData=dragonBones.SkinData;var VerticesData=dragonBones.VerticesData;var DisplayData=dragonBones.DisplayData;var ImageDisplayData=dragonBones.ImageDisplayData;var ArmatureDisplayData=dragonBones.ArmatureDisplayData;var MeshDisplayData=dragonBones.MeshDisplayData;var BoundingBoxDisplayData=dragonBones.BoundingBoxDisplayData;var PathDisplayData=dragonBones.PathDisplayData;var WeightData=dragonBones.WeightData;var BoundingBoxData=dragonBones.BoundingBoxData;var RectangleBoundingBoxData=dragonBones.RectangleBoundingBoxData;var EllipseBoundingBoxData=dragonBones.EllipseBoundingBoxData;var PolygonBoundingBoxData=dragonBones.PolygonBoundingBoxData;var AnimationData=dragonBones.AnimationData;var TimelineData=dragonBones.TimelineData;var AnimationConfig=dragonBones.AnimationConfig;var TextureAtlasData=dragonBones.TextureAtlasData;var TextureData=dragonBones.TextureData;var DeformVertices=dragonBones.DeformVertices;var Armature=dragonBones.Armature;var TransformObject=dragonBones.TransformObject;var Bone=dragonBones.Bone;var Surface=dragonBones.Surface;var Slot=dragonBones.Slot;var Constraint=dragonBones.Constraint;var IKConstraint=dragonBones.IKConstraint;var PathConstraint=dragonBones.PathConstraint;var WorldClock=dragonBones.WorldClock;var Animation$1=dragonBones.Animation;var AnimationState$1=dragonBones.AnimationState;var BonePose=dragonBones.BonePose;var BlendState=dragonBones.BlendState;var TimelineState=dragonBones.TimelineState;var TweenTimelineState=dragonBones.TweenTimelineState;var BoneTimelineState=dragonBones.BoneTimelineState;var SlotTimelineState=dragonBones.SlotTimelineState;var ConstraintTimelineState=dragonBones.ConstraintTimelineState;var ActionTimelineState=dragonBones.ActionTimelineState;var ZOrderTimelineState=dragonBones.ZOrderTimelineState;var BoneAllTimelineState=dragonBones.BoneAllTimelineState;var BoneTranslateTimelineState=dragonBones.BoneTranslateTimelineState;var BoneRotateTimelineState=dragonBones.BoneRotateTimelineState;var BoneScaleTimelineState=dragonBones.BoneScaleTimelineState;var SurfaceTimelineState=dragonBones.SurfaceTimelineState;var SlotDislayTimelineState=dragonBones.SlotDislayTimelineState;var SlotColorTimelineState=dragonBones.SlotColorTimelineState;var DeformTimelineState=dragonBones.DeformTimelineState;var IKConstraintTimelineState=dragonBones.IKConstraintTimelineState;var AnimationTimelineState=dragonBones.AnimationTimelineState;var EventObject=dragonBones.EventObject;var DataParser=dragonBones.DataParser;var ObjectDataParser=dragonBones.ObjectDataParser;var ActionFrame=dragonBones.ActionFrame;var BinaryDataParser=dragonBones.BinaryDataParser;var BaseFactory=dragonBones.BaseFactory;var BuildArmaturePackage=dragonBones.BuildArmaturePackage;var BinaryOffset=dragonBones.BinaryOffset;var ArmatureType=dragonBones.ArmatureType;var BoneType=dragonBones.BoneType;var DisplayType=dragonBones.DisplayType;var BoundingBoxType=dragonBones.BoundingBoxType;var ActionType=dragonBones.ActionType;var BlendMode=dragonBones.BlendMode;var TweenType=dragonBones.TweenType;var TimelineType=dragonBones.TimelineType;

            var _dec$15, _class$18, _dec2$N, _class3$e;
            var ccclass$e = ccclass$p;
            var CCTextureAtlasData = (_dec$15 = ccclass$e('dragonBones.CCTextureAtlasData'), _dec$15(_class$18 = function (_TextureAtlasData) {
              _inheritsLoose(CCTextureAtlasData, _TextureAtlasData);

              function CCTextureAtlasData() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _TextureAtlasData.call.apply(_TextureAtlasData, [this].concat(args)) || this;
                _this._renderTexture = null;
                return _this;
              }

              CCTextureAtlasData.toString = function toString() {
                return '[class dragonBones.CCTextureAtlasData]';
              };

              var _proto = CCTextureAtlasData.prototype;

              _proto.createTexture = function createTexture() {
                return BaseObject.borrowObject(CCTextureData);
              };

              _proto._onClear = function _onClear() {
                _TextureAtlasData.prototype._onClear.call(this);

                this.renderTexture = null;
              };

              _createClass(CCTextureAtlasData, [{
                key: "renderTexture",
                get: function get() {
                  return this._renderTexture;
                },
                set: function set(value) {
                  this._renderTexture = value;

                  if (value) {
                    for (var k in this.textures) {
                      var textureData = this.textures[k];

                      if (!textureData.spriteFrame) {
                        var rect = null;

                        if (textureData.rotated) {
                          rect = new Rect$1(textureData.region.x, textureData.region.y, textureData.region.height, textureData.region.width);
                        } else {
                          rect = new Rect$1(textureData.region.x, textureData.region.y, textureData.region.width, textureData.region.height);
                          textureData.spriteFrame = new SpriteFrame();
                          textureData.spriteFrame.texture = value;
                          textureData.spriteFrame.rect = rect;
                        }
                      }
                    }
                  } else {
                    for (var _k in this.textures) {
                      var _textureData = this.textures[_k];
                      _textureData.spriteFrame = null;
                    }
                  }
                }
              }]);

              return CCTextureAtlasData;
            }(TextureAtlasData)) || _class$18);
            var CCTextureData = (_dec2$N = ccclass$e('dragonBones.CCTextureData'), _dec2$N(_class3$e = function (_TextureData) {
              _inheritsLoose(CCTextureData, _TextureData);

              function CCTextureData() {
                var _this2;

                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args[_key3] = arguments[_key3];
                }

                _this2 = _TextureData.call.apply(_TextureData, [this].concat(args)) || this;
                _this2.spriteFrame = null;
                return _this2;
              }

              CCTextureData.toString = function toString() {
                return '[class dragonBones.CCTextureData]';
              };

              var _proto2 = CCTextureData.prototype;

              _proto2._onClear = function _onClear() {
                _TextureData.prototype._onClear.call(this);

                this.spriteFrame = null;
              };

              return CCTextureData;
            }(TextureData)) || _class3$e);

            var _dec$16, _class$19;
            var ccclass$f = ccclass$p;
            var CCSlot = (_dec$16 = ccclass$f('dragonBones.CCSlot'), _dec$16(_class$19 = function (_Slot) {
              _inheritsLoose(CCSlot, _Slot);

              CCSlot.toString = function toString() {
                return '[class dragonBones.CCSlot]';
              };

              function CCSlot() {
                var _this;

                _this = _Slot.call(this) || this;
                _this._localVertices = void 0;
                _this._indices = void 0;
                _this._matrix = void 0;
                _this._worldMatrix = void 0;
                _this._worldMatrixDirty = void 0;
                _this._color = void 0;
                _this._localVertices = [];
                _this._indices = [];
                _this._matrix = new Mat4();
                _this._worldMatrix = new Mat4();
                _this._worldMatrixDirty = true;
                _this._visible = false;
                _this._color = new Color$1();
                return _this;
              }

              var _proto = CCSlot.prototype;

              _proto.getTexture = function getTexture() {
                if (this._textureData) {
                  var sp = this._textureData.spriteFrame;
                  var tex = sp.texture;
                  return tex;
                }

                return null;
              };

              _proto.calculWorldMatrix = function calculWorldMatrix() {
                var parent = this._armature._parent;

                if (parent) {
                  this._mulMat(this._worldMatrix, parent._worldMatrix, this._matrix);
                } else {
                  Mat4.copy(this._worldMatrix, this._matrix);
                }

                this._worldMatrixDirty = false;
              };

              _proto._onClear = function _onClear() {
                _Slot.prototype._onClear.call(this);

                this._localVertices.length = 0;
                this._indices.length = 0;
                Mat4.identity(this._matrix);
                Mat4.identity(this._worldMatrix);
                this._worldMatrixDirty = true;
                this._color = new Color$1();
                this._visible = false;
              };

              _proto._onUpdateDisplay = function _onUpdateDisplay() {};

              _proto._initDisplay = function _initDisplay(value) {};

              _proto._addDisplay = function _addDisplay() {
                this._visible = true;
              };

              _proto._replaceDisplay = function _replaceDisplay(value) {};

              _proto._removeDisplay = function _removeDisplay() {
                this._visible = false;
              };

              _proto._disposeDisplay = function _disposeDisplay(object) {};

              _proto._updateVisible = function _updateVisible() {
                this._visible = this.parent.visible;
              };

              _proto._updateGlueMesh = function _updateGlueMesh() {};

              _proto._updateZOrder = function _updateZOrder() {};

              _proto._updateBlendMode = function _updateBlendMode() {
                if (this._childArmature) {
                  var childSlots = this._childArmature.getSlots();

                  for (var i = 0, l = childSlots.length; i < l; i++) {
                    var slot = childSlots[i];
                    slot._blendMode = this._blendMode;

                    slot._updateBlendMode();
                  }
                }
              };

              _proto._updateColor = function _updateColor() {
                var c = this._color;
                c.r = this._colorTransform.redMultiplier * 255;
                c.g = this._colorTransform.greenMultiplier * 255;
                c.b = this._colorTransform.blueMultiplier * 255;
                c.a = this._colorTransform.alphaMultiplier * 255;
              };

              _proto._updateFrame = function _updateFrame() {
                this._indices.length = 0;
                var indices = this._indices;
                var localVertices = this._localVertices;
                var indexOffset = 0;
                var vfOffset = 0;
                var currentTextureData = this._textureData;
                if (!this._display || this._displayIndex < 0 || !currentTextureData || !currentTextureData.spriteFrame) return;
                var texture = currentTextureData.spriteFrame.texture;
                var textureAtlasWidth = texture.width;
                var textureAtlasHeight = texture.height;
                var region = currentTextureData.region;

                if (textureAtlasWidth === 0 || textureAtlasHeight === 0) {
                  console.error("SpriteFrame " + currentTextureData.spriteFrame.name + " incorrect size " + textureAtlasWidth + " x " + textureAtlasHeight);
                  return;
                }

                var currentVerticesData = this._deformVertices !== null && this._display === this._meshDisplay ? this._deformVertices.verticesData : null;

                if (currentVerticesData) {
                  var data = currentVerticesData.data;
                  var intArray = data.intArray;
                  var floatArray = data.floatArray;
                  var vertexCount = intArray[currentVerticesData.offset + BinaryOffset.MeshVertexCount];
                  var triangleCount = intArray[currentVerticesData.offset + BinaryOffset.MeshTriangleCount];
                  var vertexOffset = intArray[currentVerticesData.offset + BinaryOffset.MeshFloatOffset];

                  if (vertexOffset < 0) {
                    vertexOffset += 65536;
                  }

                  var uvOffset = vertexOffset + vertexCount * 2;
                  var scale = this._armature._armatureData.scale;

                  for (var i = 0, l = vertexCount * 2; i < l; i += 2) {
                    localVertices[vfOffset++] = floatArray[vertexOffset + i] * scale;
                    localVertices[vfOffset++] = -floatArray[vertexOffset + i + 1] * scale;

                    if (currentVerticesData.rotated) {
                      localVertices[vfOffset++] = (region.x + (1.0 - floatArray[uvOffset + i]) * region.width) / textureAtlasWidth;
                      localVertices[vfOffset++] = (region.y + floatArray[uvOffset + i + 1] * region.height) / textureAtlasHeight;
                    } else {
                      localVertices[vfOffset++] = (region.x + floatArray[uvOffset + i] * region.width) / textureAtlasWidth;
                      localVertices[vfOffset++] = (region.y + floatArray[uvOffset + i + 1] * region.height) / textureAtlasHeight;
                    }
                  }

                  for (var _i = 0; _i < triangleCount * 3; ++_i) {
                    indices[indexOffset++] = intArray[currentVerticesData.offset + BinaryOffset.MeshVertexIndices + _i];
                  }

                  localVertices.length = vfOffset;
                  indices.length = indexOffset;
                  var isSkinned = !!currentVerticesData.weight;

                  if (isSkinned) {
                    this._identityTransform();
                  }
                } else {
                  var _l = region.x / textureAtlasWidth;

                  var b = (region.y + region.height) / textureAtlasHeight;
                  var r = (region.x + region.width) / textureAtlasWidth;
                  var t = region.y / textureAtlasHeight;
                  localVertices[vfOffset++] = 0;
                  localVertices[vfOffset++] = 0;
                  localVertices[vfOffset++] = _l;
                  localVertices[vfOffset++] = b;
                  localVertices[vfOffset++] = region.width;
                  localVertices[vfOffset++] = 0;
                  localVertices[vfOffset++] = r;
                  localVertices[vfOffset++] = b;
                  localVertices[vfOffset++] = 0;
                  localVertices[vfOffset++] = region.height;
                  localVertices[vfOffset++] = _l;
                  localVertices[vfOffset++] = t;
                  localVertices[vfOffset++] = region.width;
                  localVertices[vfOffset++] = region.height;
                  localVertices[vfOffset++] = r;
                  localVertices[vfOffset++] = t;
                  indices[0] = 0;
                  indices[1] = 1;
                  indices[2] = 2;
                  indices[3] = 1;
                  indices[4] = 3;
                  indices[5] = 2;
                  localVertices.length = vfOffset;
                  indices.length = 6;
                }

                this._visibleDirty = true;
                this._blendModeDirty = true;
                this._colorDirty = true;
              };

              _proto._updateMesh = function _updateMesh() {
                var scale = this._armature._armatureData.scale;
                var deformVertices = this._deformVertices.vertices;
                var bones = this._deformVertices.bones;
                var verticesData = this._deformVertices.verticesData;
                var weightData = verticesData.weight;
                var hasDeform = deformVertices.length > 0 && verticesData.inheritDeform;
                var localVertices = this._localVertices;

                if (weightData) {
                  var data = verticesData.data;
                  var intArray = data.intArray;
                  var floatArray = data.floatArray;
                  var vertexCount = intArray[verticesData.offset + BinaryOffset.MeshVertexCount];
                  var weightFloatOffset = intArray[weightData.offset + BinaryOffset.WeigthFloatOffset];

                  if (weightFloatOffset < 0) {
                    weightFloatOffset += 65536;
                  }

                  for (var i = 0, iB = weightData.offset + BinaryOffset.WeigthBoneIndices + bones.length, iV = weightFloatOffset, iF = 0, lvi = 0; i < vertexCount; i++, lvi += 4) {
                    var boneCount = intArray[iB++];
                    var xG = 0.0;
                    var yG = 0.0;

                    for (var j = 0; j < boneCount; ++j) {
                      var boneIndex = intArray[iB++];
                      var bone = bones[boneIndex];

                      if (bone !== null) {
                        var matrix = bone.globalTransformMatrix;
                        var weight = floatArray[iV++];
                        var xL = floatArray[iV++] * scale;
                        var yL = floatArray[iV++] * scale;

                        if (hasDeform) {
                          xL += deformVertices[iF++];
                          yL += deformVertices[iF++];
                        }

                        xG += (matrix.a * xL + matrix.c * yL + matrix.tx) * weight;
                        yG += (matrix.b * xL + matrix.d * yL + matrix.ty) * weight;
                      }
                    }

                    localVertices[lvi] = xG;
                    localVertices[lvi + 1] = -yG;
                  }
                } else if (hasDeform) {
                  var isSurface = this._parent._boneData.type !== BoneType.Bone;
                  var _data = verticesData.data;
                  var _intArray = _data.intArray;
                  var _floatArray = _data.floatArray;
                  var _vertexCount = _intArray[verticesData.offset + BinaryOffset.MeshVertexCount];
                  var vertexOffset = _intArray[verticesData.offset + BinaryOffset.MeshFloatOffset];

                  if (vertexOffset < 0) {
                    vertexOffset += 65536;
                  }

                  for (var _i2 = 0, l = _vertexCount, _lvi = 0; _i2 < l; _i2++, _lvi += 4) {
                    var x = _floatArray[vertexOffset + _i2 * 2] * scale + deformVertices[_i2 * 2];
                    var y = _floatArray[vertexOffset + _i2 * 2 + 1] * scale + deformVertices[_i2 * 2 + 1];

                    if (isSurface) {
                      var _matrix = this._parent._getGlobalTransformMatrix(x, y);

                      localVertices[_lvi] = _matrix.a * x + _matrix.c * y + _matrix.tx;
                      localVertices[_lvi + 1] = -_matrix.b * x + _matrix.d * y + _matrix.ty;
                    } else {
                      localVertices[_lvi] = x;
                      localVertices[_lvi + 1] = -y;
                    }
                  }
                }

                if (weightData) {
                  this._identityTransform();
                }
              };

              _proto._identityTransform = function _identityTransform() {
                var m = this._matrix;
                m.m00 = 1.0;
                m.m01 = 0.0;
                m.m04 = -0.0;
                m.m05 = -1.0;
                m.m12 = 0.0;
                m.m13 = 0.0;
                this._worldMatrixDirty = true;
              };

              _proto._updateTransform = function _updateTransform() {
                var m = this._matrix;
                m.m00 = this.globalTransformMatrix.a;
                m.m01 = this.globalTransformMatrix.b;
                m.m04 = -this.globalTransformMatrix.c;
                m.m05 = -this.globalTransformMatrix.d;

                if (this._childArmature) {
                  m.m12 = this.globalTransformMatrix.tx;
                  m.m13 = this.globalTransformMatrix.ty;
                } else {
                  m.m12 = this.globalTransformMatrix.tx - (this.globalTransformMatrix.a * this._pivotX - this.globalTransformMatrix.c * this._pivotY);
                  m.m13 = this.globalTransformMatrix.ty - (this.globalTransformMatrix.b * this._pivotX - this.globalTransformMatrix.d * this._pivotY);
                }

                this._worldMatrixDirty = true;
              };

              _proto.updateWorldMatrix = function updateWorldMatrix() {
                if (!this._armature) return;
                var parentSlot = this._armature._parent;

                if (parentSlot) {
                  parentSlot.updateWorldMatrix();
                }

                if (this._worldMatrixDirty) {
                  this.calculWorldMatrix();
                  var childArmature = this.childArmature;
                  if (!childArmature) return;
                  var slots = childArmature.getSlots();

                  for (var i = 0, n = slots.length; i < n; i++) {
                    var slot = slots[i];

                    if (slot) {
                      slot._worldMatrixDirty = true;
                    }
                  }
                }
              };

              _proto._mulMat = function _mulMat(out, a, b) {
                var aa = a.m00;
                var ab = a.m01;
                var ac = a.m04;
                var ad = a.m05;
                var atx = a.m12;
                var aty = a.m13;
                var ba = b.m00;
                var bb = b.m01;
                var bc = b.m04;
                var bd = b.m05;
                var btx = b.m12;
                var bty = b.m13;

                if (ab !== 0 || ac !== 0) {
                  out.m00 = ba * aa + bb * ac;
                  out.m01 = ba * ab + bb * ad;
                  out.m04 = bc * aa + bd * ac;
                  out.m05 = bc * ab + bd * ad;
                  out.m12 = aa * btx + ac * bty + atx;
                  out.m13 = ab * btx + ad * bty + aty;
                } else {
                  out.m00 = ba * aa;
                  out.m01 = bb * ad;
                  out.m04 = bc * aa;
                  out.m05 = bd * ad;
                  out.m12 = aa * btx + atx;
                  out.m13 = ad * bty + aty;
                }
              };

              return CCSlot;
            }(Slot)) || _class$19);

            var _dec$17, _class$1a;
            var ccclass$g = ccclass$p;
            var CCArmatureDisplay = (_dec$17 = ccclass$g('dragonBones.CCArmatureDisplay'), _dec$17(_class$1a = function (_DisplayData) {
              _inheritsLoose(CCArmatureDisplay, _DisplayData);

              function CCArmatureDisplay() {
                var _this;

                _this = _DisplayData.call(this) || this;
                _this.shouldAdvanced = false;
                _this._ccNode = null;
                _this._ccComponent = null;
                _this._eventTarget = void 0;
                _this._armature = null;
                _this._eventTarget = new EventTarget();
                return _this;
              }

              var _proto = CCArmatureDisplay.prototype;

              _proto.hasEvent = function hasEvent(type) {
                console.warn('Method not implemented.');
                return false;
              };

              _proto.addEvent = function addEvent(type, listener, thisObject) {
                console.warn('Method not implemented.');
              };

              _proto.removeEvent = function removeEvent(type, listener, thisObject) {
                console.warn('Method not implemented.');
              };

              _proto.setEventTarget = function setEventTarget(eventTarget) {
                this._eventTarget = eventTarget;
              };

              _proto.getRootDisplay = function getRootDisplay() {
                var parentSlot = this._armature._parent;

                if (!parentSlot) {
                  return this;
                }

                var slot;

                while (parentSlot) {
                  slot = parentSlot;
                  parentSlot = parentSlot._armature._parent;
                }

                return slot._armature.display;
              };

              _proto.convertToRootSpace = function convertToRootSpace(pos) {
                var slot = this._armature._parent;

                if (!slot) {
                  return pos;
                }

                slot.updateWorldMatrix();
                var worldMatrix = slot._worldMatrix;
                var newPos = new Vec3(0, 0);
                newPos.x = pos.x * worldMatrix.m00 + pos.y * worldMatrix.m04 + worldMatrix.m12;
                newPos.y = pos.x * worldMatrix.m01 + pos.y * worldMatrix.m05 + worldMatrix.m13;
                return newPos;
              };

              _proto.convertToWorldSpace = function convertToWorldSpace(point) {
                var _ccNode$_uiProps$uiTr;

                var newPos = this.convertToRootSpace(point);
                var ccNode = this.getRootNode();
                return ccNode === null || ccNode === void 0 ? void 0 : (_ccNode$_uiProps$uiTr = ccNode._uiProps.uiTransformComp) === null || _ccNode$_uiProps$uiTr === void 0 ? void 0 : _ccNode$_uiProps$uiTr.convertToWorldSpaceAR(newPos);
              };

              _proto.getRootNode = function getRootNode() {
                var rootDisplay = this.getRootDisplay();
                return rootDisplay && rootDisplay._ccNode;
              };

              _proto.dbInit = function dbInit(armature) {
                this._armature = armature;
              };

              _proto.dbClear = function dbClear() {
                this._armature = null;
              };

              _proto.dbUpdate = function dbUpdate() {
                if (this._ccComponent) {
                  this._ccComponent.markForUpdateRenderData();
                }
              };

              _proto.advanceTimeBySelf = function advanceTimeBySelf(on) {
                this.shouldAdvanced = !!on;
              };

              _proto.hasDBEventListener = function hasDBEventListener(type) {
                return this._eventTarget.hasEventListener(type);
              };

              _proto.addDBEventListener = function addDBEventListener(type, listener, target) {
                this._eventTarget.on(type, listener, target);
              };

              _proto.removeDBEventListener = function removeDBEventListener(type, listener, target) {
                this._eventTarget.off(type, listener, target);
              };

              _proto.dispatchDBEvent = function dispatchDBEvent(type, eventObject) {
                this._eventTarget.emit(type, eventObject);
              };

              _createClass(CCArmatureDisplay, [{
                key: "node",
                get: function get() {
                  return this;
                }
              }]);

              return CCArmatureDisplay;
            }(DisplayData)) || _class$1a);

            var _dec$18, _class$1b, _class2$Y, _temp$l;
            var ccclass$h = ccclass$p;
            var CCFactory = (_dec$18 = ccclass$h('CCFactory'), _dec$18(_class$1b = (_temp$l = _class2$Y = function (_BaseFactory) {
              _inheritsLoose(CCFactory, _BaseFactory);

              CCFactory.getInstance = function getInstance() {
                if (!CCFactory._factory) {
                  CCFactory._factory = new CCFactory();
                }

                return CCFactory._factory;
              };

              function CCFactory() {
                var _this;

                _this = _BaseFactory.call(this) || this;
                _this.id = void 0;
                _this.uuid = void 0;
                _this._slots = void 0;
                var eventManager = new CCArmatureDisplay();
                _this._dragonBones = new DragonBones(eventManager);

                if (director.getScheduler()) {
                  game.on(Game.EVENT_RESTART, _this.onRestart, _assertThisInitialized(_this));

                  _this.initUpdate();
                }

                _this.id = _this.uuid = 'CCFactory';
                return _this;
              }

              var _proto = CCFactory.prototype;

              _proto.onRestart = function onRestart() {
                CCFactory._factory = null;
              };

              _proto.initUpdate = function initUpdate(dt) {
                Scheduler.enableForTarget(this);
                director.getScheduler().scheduleUpdate(this, System.Priority.HIGH, false);
              };

              _proto.update = function update(dt) {

                this._dragonBones.advanceTime(dt);
              };

              _proto.getDragonBonesDataByRawData = function getDragonBonesDataByRawData(rawData) {
                var dataParser = rawData instanceof ArrayBuffer ? BaseFactory._binaryParser : this._dataParser;
                return dataParser.parseDragonBonesData(rawData, 1.0);
              };

              _proto.buildArmatureDisplay = function buildArmatureDisplay(armatureName, dragonBonesName, skinName, textureAtlasName) {
                var armature = this.buildArmature(armatureName, dragonBonesName, skinName, textureAtlasName);
                return armature ? armature._display : null;
              };

              _proto.createArmatureNode = function createArmatureNode(comp, armatureName, node) {
                node = node || new Node();
                var display = node.getComponent('dragonBones.ArmatureDisplay');

                if (!display) {
                  display = node.addComponent('dragonBones.ArmatureDisplay');
                }

                node.name = armatureName;
                display._armatureName = armatureName;
                display._dragonAsset = comp.dragonAsset;
                display._dragonAtlasAsset = comp.dragonAtlasAsset;

                display._init();

                return display;
              };

              _proto._buildTextureAtlasData = function _buildTextureAtlasData(textureAtlasData, textureAtlas) {
                if (textureAtlasData) {
                  textureAtlasData.renderTexture = textureAtlas;
                } else {
                  textureAtlasData = BaseObject.borrowObject(CCTextureAtlasData);
                }

                return textureAtlasData;
              };

              _proto._sortSlots = function _sortSlots() {
                var slots = this._slots;
                var sortedSlots = [];

                for (var i = 0, l = slots.length; i < l; i++) {
                  var slot = slots[i];
                  var zOrder = slot._zOrder;
                  var inserted = false;

                  for (var j = sortedSlots.length - 1; j >= 0; j--) {
                    if (zOrder >= sortedSlots[j]._zOrder) {
                      sortedSlots.splice(j + 1, 0, slot);
                      inserted = true;
                      break;
                    }
                  }

                  if (!inserted) {
                    sortedSlots.unshift(slot);
                  }
                }

                this._slots = sortedSlots;
              };

              _proto._buildArmature = function _buildArmature(dataPackage) {
                var armature = BaseObject.borrowObject(Armature);
                armature._skinData = dataPackage.skin;
                armature._animation = BaseObject.borrowObject(Animation$1);
                armature._animation._armature = armature;
                armature._animation.animations = dataPackage.armature.animations;
                armature._isChildArmature = false;
                var display = new CCArmatureDisplay();
                armature.init(dataPackage.armature, display, display, this._dragonBones);
                return armature;
              };

              _proto._buildSlot = function _buildSlot(dataPackage, slotData, displays) {
                var slot = BaseObject.borrowObject(CCSlot);
                var display = slot;
                slot.init(slotData, displays, display, display);
                return slot;
              };

              _proto.getDragonBonesDataByUUID = function getDragonBonesDataByUUID(uuid) {
                for (var name in this._dragonBonesDataMap) {
                  if (name.indexOf(uuid) !== -1) {
                    return this._dragonBonesDataMap[name];
                  }
                }

                return null;
              };

              _proto.removeDragonBonesDataByUUID = function removeDragonBonesDataByUUID(uuid, disposeData) {
                if (disposeData === undefined) {
                  disposeData = true;
                }

                for (var name in this._dragonBonesDataMap) {
                  if (name.indexOf(uuid) === -1) continue;

                  if (disposeData) {
                    this._dragonBones.bufferObject(this._dragonBonesDataMap[name]);
                  }

                  delete this._dragonBonesDataMap[name];
                }
              };

              return CCFactory;
            }(BaseFactory), _class2$Y._factory = null, _temp$l)) || _class$1b);

            var MaxCacheTime = 30;
            var FrameTime = 1 / 60;
            var _vertices$1 = [];
            var _indices = [];
            var _boneInfoOffset = 0;
            var _indexOffset = 0;
            var _vfOffset = 0;
            var _preTexUrl = null;
            var _preBlendMode = null;
            var _segVCount = 0;
            var _segICount = 0;
            var _segOffset = 0;
            var _colorOffset = 0;
            var _preColor = 0;

            var _x;

            var _y;

            var PER_VERTEX_SIZE = 5;
            var EXPORT_VERTEX_SIZE = 9;
            var AnimationCache = function () {
              function AnimationCache() {
                this.maxVertexCount = 0;
                this.maxIndexCount = 0;
                this._privateMode = false;
                this._inited = false;
                this._invalid = true;
                this._enableCacheAttachedInfo = false;
                this.frames = [];
                this.totalTime = 0;
                this.isCompleted = false;
                this._frameIdx = -1;
                this._armatureInfo = null;
                this._animationName = null;
                this._tempSegments = null;
                this._tempColors = null;
                this._tempBoneInfos = null;
              }

              var _proto = AnimationCache.prototype;

              _proto.init = function init(armatureInfo, animationName) {
                this._inited = true;
                this._armatureInfo = armatureInfo;
                this._animationName = animationName;
              };

              _proto.clear = function clear() {
                this._inited = false;

                for (var i = 0, n = this.frames.length; i < n; i++) {
                  var frame = this.frames[i];
                  frame.segments.length = 0;
                }

                this.invalidAllFrame();
              };

              _proto.begin = function begin() {
                if (!this._invalid) return;
                var armatureInfo = this._armatureInfo;
                var curAnimationCache = armatureInfo.curAnimationCache;

                if (curAnimationCache && curAnimationCache !== this) {
                  if (this._privateMode) {
                    curAnimationCache.invalidAllFrame();
                  } else {
                    curAnimationCache.updateToFrame();
                  }
                }

                var armature = armatureInfo.armature;
                var animation = armature.animation;
                animation.play(this._animationName, 1);
                armatureInfo.curAnimationCache = this;
                this._invalid = false;
                this._frameIdx = -1;
                this.totalTime = 0;
                this.isCompleted = false;
              };

              _proto.end = function end() {
                if (!this._needToUpdate()) {
                  this._armatureInfo.curAnimationCache = null;
                  this.frames.length = this._frameIdx + 1;
                  this.isCompleted = true;
                }
              };

              _proto._needToUpdate = function _needToUpdate(toFrameIdx) {
                var armatureInfo = this._armatureInfo;
                var armature = armatureInfo.armature;
                var animation = armature.animation;
                return !animation.isCompleted && this.totalTime < MaxCacheTime && (toFrameIdx === undefined || this._frameIdx < toFrameIdx);
              };

              _proto.updateToFrame = function updateToFrame(toFrameIdx) {
                if (!this._inited) return;
                this.begin();
                if (!this._needToUpdate(toFrameIdx)) return;
                var armatureInfo = this._armatureInfo;
                var armature = armatureInfo.armature;

                do {
                  armature.advanceTime(FrameTime);
                  this._frameIdx++;
                  this.updateFrame(armature, this._frameIdx);
                  this.totalTime += FrameTime;
                } while (this._needToUpdate(toFrameIdx));

                this.end();
              };

              _proto.isInited = function isInited() {
                return this._inited;
              };

              _proto.isInvalid = function isInvalid() {
                return this._invalid;
              };

              _proto.invalidAllFrame = function invalidAllFrame() {
                this.isCompleted = false;
                this._invalid = true;
              };

              _proto.updateAllFrame = function updateAllFrame() {
                this.invalidAllFrame();
                this.updateToFrame();
              };

              _proto.enableCacheAttachedInfo = function enableCacheAttachedInfo() {
                if (!this._enableCacheAttachedInfo) {
                  this._enableCacheAttachedInfo = true;
                  this.invalidAllFrame();
                }
              };

              _proto.updateFrame = function updateFrame(armature, index) {
                _vfOffset = 0;
                _boneInfoOffset = 0;
                _indexOffset = 0;
                _preTexUrl = null;
                _preBlendMode = null;
                _segVCount = 0;
                _segICount = 0;
                _segOffset = 0;
                _colorOffset = 0;
                _preColor = 0;
                this.frames[index] = this.frames[index] || {
                  segments: [],
                  colors: [],
                  boneInfos: [],
                  vertices: null,
                  uintVert: null,
                  indices: null
                };
                var frame = this.frames[index];
                var segments = this._tempSegments = frame.segments;
                var colors = this._tempColors = frame.colors;
                var boneInfos = this._tempBoneInfos = frame.boneInfos;

                this._traverseArmature(armature, 1.0);

                if (_colorOffset > 0) {
                  colors[_colorOffset - 1].vfOffset = _vfOffset;
                }

                colors.length = _colorOffset;
                boneInfos.length = _boneInfoOffset;
                var preSegOffset = _segOffset - 1;

                if (preSegOffset >= 0) {
                  if (_segICount > 0) {
                    var preSegInfo = segments[preSegOffset];
                    preSegInfo.indexCount = _segICount;
                    preSegInfo.vfCount = _segVCount * EXPORT_VERTEX_SIZE;
                    preSegInfo.vertexCount = _segVCount;
                    segments.length = _segOffset;
                  } else {
                    segments.length = _segOffset - 1;
                  }
                }

                if (segments.length === 0) return;
                var vertices = frame.vertices;
                var vertexCount = _vfOffset / PER_VERTEX_SIZE;
                var copyOutVerticeSize = vertexCount * EXPORT_VERTEX_SIZE;

                if (!vertices || vertices.length < _vfOffset) {
                  vertices = frame.vertices = new Float32Array(copyOutVerticeSize);
                }

                var colorI32;

                for (var i = 0, j = 0; i < copyOutVerticeSize;) {
                  vertices[i] = _vertices$1[j++];
                  vertices[i + 1] = _vertices$1[j++];
                  vertices[i + 3] = _vertices$1[j++];
                  vertices[i + 4] = _vertices$1[j++];
                  colorI32 = _vertices$1[j++];
                  vertices[i + 5] = (colorI32 & 0xff) / 255.0;
                  vertices[i + 6] = (colorI32 >> 8 & 0xff) / 255.0;
                  vertices[i + 7] = (colorI32 >> 16 & 0xff) / 255.0;
                  vertices[i + 8] = (colorI32 >> 24 & 0xff) / 255.0;
                  i += EXPORT_VERTEX_SIZE;
                }

                var indices = frame.indices;

                if (!indices || indices.length < _indexOffset) {
                  indices = frame.indices = new Uint16Array(_indexOffset);
                }

                for (var _i = 0; _i < _indexOffset; _i++) {
                  indices[_i] = _indices[_i];
                }

                frame.vertices = vertices;
                frame.indices = indices;
                this.maxVertexCount = vertexCount > this.maxVertexCount ? vertexCount : this.maxVertexCount;
                this.maxIndexCount = indices.length > this.maxIndexCount ? indices.length : this.maxIndexCount;
              };

              _proto._traverseArmature = function _traverseArmature(armature, parentOpacity) {
                var colors = this._tempColors;
                var segments = this._tempSegments;
                var boneInfos = this._tempBoneInfos;
                var slots = armature._slots;
                var slotVertices;
                var slotIndices;
                var slot;
                var slotMatrix;
                var slotColor;
                var colorVal;
                var texture;
                var preSegOffset;
                var preSegInfo;
                var bones = armature._bones;

                if (this._enableCacheAttachedInfo) {
                  for (var i = 0, l = bones.length; i < l; i++, _boneInfoOffset++) {
                    var bone = bones[i];
                    var boneInfo = boneInfos[_boneInfoOffset];

                    if (!boneInfo) {
                      boneInfo = boneInfos[_boneInfoOffset] = {
                        globalTransformMatrix: new Matrix()
                      };
                    }

                    var boneMat = bone.globalTransformMatrix;
                    var cacheBoneMat = boneInfo.globalTransformMatrix;
                    cacheBoneMat.copyFrom(boneMat);
                  }
                }

                for (var _i2 = 0, _l = slots.length; _i2 < _l; _i2++) {
                  slot = slots[_i2];
                  if (!slot._visible || !slot._displayData) continue;
                  slot.updateWorldMatrix();
                  slotColor = slot._color;

                  if (slot.childArmature) {
                    this._traverseArmature(slot.childArmature, parentOpacity * slotColor.a / 255);

                    continue;
                  }

                  texture = slot.getTexture();
                  if (!texture) continue;

                  if (_preTexUrl !== texture.nativeUrl || _preBlendMode !== slot._blendMode) {
                    _preTexUrl = texture.nativeUrl;
                    _preBlendMode = slot._blendMode;
                    preSegOffset = _segOffset - 1;

                    if (preSegOffset >= 0) {
                      if (_segICount > 0) {
                        preSegInfo = segments[preSegOffset];
                        preSegInfo.indexCount = _segICount;
                        preSegInfo.vertexCount = _segVCount;
                        preSegInfo.vfCount = _segVCount * EXPORT_VERTEX_SIZE;
                      } else {
                        _segOffset--;
                      }
                    }

                    segments[_segOffset] = {
                      tex: texture,
                      blendMode: slot._blendMode,
                      indexCount: 0,
                      vertexCount: 0,
                      vfCount: 0
                    };
                    _segOffset++;
                    _segICount = 0;
                    _segVCount = 0;
                  }

                  colorVal = (slotColor.a * parentOpacity << 24 >>> 0) + (slotColor.b << 16) + (slotColor.g << 8) + slotColor.r;

                  if (_preColor !== colorVal) {
                    _preColor = colorVal;

                    if (_colorOffset > 0) {
                      colors[_colorOffset - 1].vfOffset = _vfOffset;
                    }

                    colors[_colorOffset++] = {
                      r: slotColor.r,
                      g: slotColor.g,
                      b: slotColor.b,
                      a: slotColor.a * parentOpacity,
                      vfOffset: 0
                    };
                  }

                  slotVertices = slot._localVertices;
                  slotIndices = slot._indices;
                  slotMatrix = slot._worldMatrix;

                  for (var j = 0, vl = slotVertices.length; j < vl;) {
                    _x = slotVertices[j++];
                    _y = slotVertices[j++];
                    _vertices$1[_vfOffset++] = _x * slotMatrix.m00 + _y * slotMatrix.m04 + slotMatrix.m12;
                    _vertices$1[_vfOffset++] = _x * slotMatrix.m01 + _y * slotMatrix.m05 + slotMatrix.m13;
                    _vertices$1[_vfOffset++] = slotVertices[j++];
                    _vertices$1[_vfOffset++] = slotVertices[j++];
                    _vertices$1[_vfOffset++] = colorVal;
                  }

                  for (var ii = 0, il = slotIndices.length; ii < il; ii++) {
                    _indices[_indexOffset++] = _segVCount + slotIndices[ii];
                  }

                  _segICount += slotIndices.length;
                  _segVCount += slotVertices.length / 4;
                }
              };

              return AnimationCache;
            }();
            var ArmatureCache = function () {
              function ArmatureCache() {
                this._privateMode = false;
                this._animationPool = {};
                this._armatureCache = {};
              }

              var _proto2 = ArmatureCache.prototype;

              _proto2.enablePrivateMode = function enablePrivateMode() {
                this._privateMode = true;
              };

              _proto2.dispose = function dispose() {
                for (var _key in this._armatureCache) {
                  var armatureInfo = this._armatureCache[_key];

                  if (armatureInfo) {
                    var armature = armatureInfo.armature;
                    if (armature) armature.dispose();
                  }
                }

                this._armatureCache = {};
                this._animationPool = {};
              };

              _proto2._removeArmature = function _removeArmature(armatureKey) {
                var armatureInfo = this._armatureCache[armatureKey];
                var animationsCache = armatureInfo.animationsCache;

                for (var aniKey in animationsCache) {
                  var animationCache = animationsCache[aniKey];
                  if (!animationCache) continue;
                  this._animationPool[armatureKey + "#" + aniKey] = animationCache;
                  animationCache.clear();
                }

                var armature = armatureInfo.armature;
                if (armature) armature.dispose();
                delete this._armatureCache[armatureKey];
              };

              _proto2.resetArmature = function resetArmature(uuid) {
                for (var armatureKey in this._armatureCache) {
                  if (armatureKey.indexOf(uuid) === -1) continue;

                  this._removeArmature(armatureKey);
                }
              };

              _proto2.getArmatureCache = function getArmatureCache(armatureName, armatureKey, atlasUUID) {
                var armatureInfo = this._armatureCache[armatureKey];
                var armature;

                if (!armatureInfo) {
                  var factory = CCFactory.getInstance();
                  var proxy = factory.buildArmatureDisplay(armatureName, armatureKey, '', atlasUUID);
                  if (!proxy || !proxy._armature) return null;
                  armature = proxy._armature;

                  if (!ArmatureCache.canCache(armature)) {
                    armature.dispose();
                    return null;
                  }

                  this._armatureCache[armatureKey] = {
                    armature: armature,
                    animationsCache: {},
                    curAnimationCache: null
                  };
                } else {
                  armature = armatureInfo.armature;
                }

                return armature;
              };

              _proto2.getAnimationCache = function getAnimationCache(armatureKey, animationName) {
                var armatureInfo = this._armatureCache[armatureKey];
                if (!armatureInfo) return null;
                var animationsCache = armatureInfo.animationsCache;
                return animationsCache[animationName];
              };

              _proto2.initAnimationCache = function initAnimationCache(armatureKey, animationName) {
                if (!animationName) return null;
                var armatureInfo = this._armatureCache[armatureKey];
                var armature = armatureInfo && armatureInfo.armature;
                if (!armature) return null;
                var animation = armature.animation;
                var hasAni = animation.hasAnimation(animationName);
                if (!hasAni) return null;
                var animationsCache = armatureInfo.animationsCache;
                var animationCache = animationsCache[animationName];

                if (!animationCache) {
                  var poolKey = armatureKey + "#" + animationName;
                  animationCache = this._animationPool[poolKey];

                  if (animationCache) {
                    delete this._animationPool[poolKey];
                  } else {
                    animationCache = new AnimationCache();
                    animationCache._privateMode = this._privateMode;
                  }

                  animationCache.init(armatureInfo, animationName);
                  animationsCache[animationName] = animationCache;
                }

                return animationCache;
              };

              _proto2.invalidAnimationCache = function invalidAnimationCache(armatureKey) {
                var armatureInfo = this._armatureCache[armatureKey];
                var armature = armatureInfo && armatureInfo.armature;
                if (!armature) return;
                var animationsCache = armatureInfo.animationsCache;

                for (var aniKey in animationsCache) {
                  var animationCache = animationsCache[aniKey];
                  animationCache.invalidAllFrame();
                }
              };

              _proto2.updateAnimationCache = function updateAnimationCache(armatureKey, animationName) {
                if (animationName) {
                  var animationCache = this.initAnimationCache(armatureKey, animationName);
                  if (!animationCache) return;
                  animationCache.updateAllFrame();
                } else {
                  var armatureInfo = this._armatureCache[armatureKey];
                  var armature = armatureInfo && armatureInfo.armature;
                  if (!armature) return;
                  var animationsCache = armatureInfo.animationsCache;

                  for (var aniKey in animationsCache) {
                    var _animationCache = animationsCache[aniKey];

                    _animationCache.updateAllFrame();
                  }
                }
              };

              ArmatureCache.canCache = function canCache(armature) {
                var slots = armature._slots;

                for (var i = 0, l = slots.length; i < l; i++) {
                  var slot = slots[i];

                  if (slot.childArmature) {
                    return false;
                  }
                }

                return true;
              };

              return ArmatureCache;
            }();
            ArmatureCache.FrameTime = FrameTime;
            ArmatureCache.sharedCache = new ArmatureCache();

            var _dec$19, _class$1c, _class2$Z, _initializer$V;
            var ccclass$i = ccclass$p,
                serializable$d = serializable$j;
            var DragonBonesAsset = (_dec$19 = ccclass$i('dragonBones.DragonBonesAsset'), _dec$19(_class$1c = (_class2$Z = function (_Asset) {
              _inheritsLoose(DragonBonesAsset, _Asset);

              function DragonBonesAsset() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;
                _this._dragonBonesJson = _initializer$V && _initializer$V();
                _this._factory = null;
                _this._dragonBonesJsonData = void 0;
                _this._armaturesEnum = null;
                return _this;
              }

              var _proto = DragonBonesAsset.prototype;

              _proto.constructctor = function constructctor() {
                this.reset();
              };

              _proto.createNode = function createNode(callback) {
                var node = new Node(this.name);
                var armatureDisplay = node.addComponent('dragonBones.ArmatureDisplay');
                armatureDisplay.dragonAsset = this;
                return callback(null, node);
              };

              _proto.reset = function reset() {
                this._clear();
              };

              _proto.init = function init(factory, atlasUUID) {
                this._factory = factory || CCFactory.getInstance();

                if (!this._dragonBonesJsonData && this.dragonBonesJson) {
                  this._dragonBonesJsonData = JSON.parse(this.dragonBonesJson);
                }

                var rawData = null;

                if (this._dragonBonesJsonData) {
                  rawData = this._dragonBonesJsonData;
                } else {
                  rawData = this._nativeAsset;
                }

                if (!this._uuid) {
                  var dbData = this._factory.getDragonBonesDataByRawData(rawData);

                  if (dbData) {
                    this._uuid = dbData.name;
                  } else {
                    console.warn('dragonbones name is empty');
                  }
                }

                var armatureKey = this._uuid + "#" + atlasUUID;

                var dragonBonesData = this._factory.getDragonBonesData(armatureKey);

                if (dragonBonesData) return armatureKey;

                this._factory.parseDragonBonesData(rawData instanceof ArrayBuffer ? rawData : rawData.buffer instanceof ArrayBuffer ? rawData.buffer : rawData, armatureKey);

                return armatureKey;
              };

              _proto.getArmatureEnum = function getArmatureEnum() {
                if (this._armaturesEnum) {
                  return this._armaturesEnum;
                }

                this.init();

                var dragonBonesData = this._factory.getDragonBonesDataByUUID(this._uuid);

                if (dragonBonesData) {
                  var armatureNames = dragonBonesData.armatureNames;
                  var enumDef = {};

                  for (var i = 0; i < armatureNames.length; i++) {
                    var name = armatureNames[i];
                    enumDef[name] = i;
                  }

                  return this._armaturesEnum = Enum(enumDef);
                }

                return null;
              };

              _proto.getAnimsEnum = function getAnimsEnum(armatureName) {
                this.init();

                var dragonBonesData = this._factory.getDragonBonesDataByUUID(this._uuid);

                if (dragonBonesData) {
                  var armature = dragonBonesData.getArmature(armatureName);

                  if (!armature) {
                    return null;
                  }

                  var enumDef = {
                    '<None>': 0
                  };
                  var anims = armature.animations;
                  var i = 0;

                  for (var animName in anims) {
                    if (anims.hasOwnProperty(animName)) {
                      enumDef[animName] = i + 1;
                      i++;
                    }
                  }

                  return Enum(enumDef);
                }

                return null;
              };

              _proto.destroy = function destroy() {
                this._clear();

                return _Asset.prototype.destroy.call(this);
              };

              _proto._clear = function _clear() {
                if (this._factory) {
                  ArmatureCache.sharedCache.resetArmature(this._uuid);

                  this._factory.removeDragonBonesDataByUUID(this._uuid, true);
                }
              };

              _createClass(DragonBonesAsset, [{
                key: "dragonBonesJson",
                get: function get() {
                  return this._dragonBonesJson;
                },
                set: function set(value) {
                  this._dragonBonesJson = value;
                  this._dragonBonesJsonData = JSON.parse(value);
                  this.reset();
                }
              }]);

              return DragonBonesAsset;
            }(Asset), (_initializer$V = applyDecoratedInitializer(_class2$Z.prototype, "_dragonBonesJson", [serializable$d], function () {
              return '';
            })), _class2$Z)) || _class$1c);
            legacyCC.internal.DragonBonesAsset = DragonBonesAsset;

            var _dec$1a, _dec2$O, _class$1d, _class2$_, _initializer$W, _initializer2$K, _initializer3$x, _initializer4$s;
            var ccclass$j = ccclass$p,
                serializable$e = serializable$j,
                type$5 = type$8;
            var DragonBonesAtlasAsset = (_dec$1a = ccclass$j('dragonBones.DragonBonesAtlasAsset'), _dec2$O = type$5(Texture2D), _dec$1a(_class$1d = (_class2$_ = function (_Asset) {
              _inheritsLoose(DragonBonesAtlasAsset, _Asset);

              function DragonBonesAtlasAsset() {
                var _this;

                _this = _Asset.call(this) || this;
                _this._atlasJson = _initializer$W && _initializer$W();
                _this._texture = _initializer2$K && _initializer2$K();
                _this._atlasJsonData = _initializer3$x && _initializer3$x();
                _this._factory = null;
                _this._textureAtlasData = _initializer4$s && _initializer4$s();

                _this._clear();

                return _this;
              }

              var _proto = DragonBonesAtlasAsset.prototype;

              _proto.createNode = function createNode(callback) {
                var node = new Node(this.name);
                var armatureDisplay = node.addComponent('dragonBones.ArmatureDisplay');
                armatureDisplay.dragonAtlasAsset = this;
                return callback(null, node);
              };

              _proto.init = function init(factory) {
                this._factory = factory;

                if (!this._atlasJsonData) {
                  this._atlasJsonData = JSON.parse(this.atlasJson);
                }

                var atlasJsonObj = this._atlasJsonData;
                this._uuid = this._uuid || atlasJsonObj.name;

                if (this._textureAtlasData) {
                  factory.addTextureAtlasData(this._textureAtlasData, this._uuid);
                } else {
                  this._textureAtlasData = factory.parseTextureAtlasData(atlasJsonObj, this.texture, this._uuid);
                }
              };

              _proto.destroy = function destroy() {
                this._clear();

                return _Asset.prototype.destroy.call(this);
              };

              _proto._clear = function _clear() {

                if (this._factory) {
                  ArmatureCache.sharedCache.resetArmature(this._uuid);

                  this._factory.removeTextureAtlasData(this._uuid, true);

                  this._factory.removeDragonBonesDataByUUID(this._uuid, true);
                }

                this._textureAtlasData = null;
              };

              _createClass(DragonBonesAtlasAsset, [{
                key: "atlasJson",
                get: function get() {
                  return this._atlasJson;
                },
                set: function set(value) {
                  this._atlasJson = value;
                  this._atlasJsonData = JSON.parse(this.atlasJson);

                  this._clear();
                }
              }, {
                key: "texture",
                get: function get() {
                  return this._texture;
                },
                set: function set(value) {
                  this._texture = value;

                  this._clear();
                }
              }]);

              return DragonBonesAtlasAsset;
            }(Asset), (_initializer$W = applyDecoratedInitializer(_class2$_.prototype, "_atlasJson", [serializable$e], function () {
              return '';
            }), _initializer2$K = applyDecoratedInitializer(_class2$_.prototype, "_texture", [serializable$e, _dec2$O], function () {
              return null;
            }), _initializer3$x = applyDecoratedInitializer(_class2$_.prototype, "_atlasJsonData", [serializable$e], function () {
              return {};
            }), _initializer4$s = applyDecoratedInitializer(_class2$_.prototype, "_textureAtlasData", [serializable$e], function () {
              return null;
            })), _class2$_)) || _class$1d);
            legacyCC.internal.DragonBonesAtlasAsset = DragonBonesAtlasAsset;

            var _dec$1b, _class$1e;

            var _tempMat4 = new Mat4();

            var ccclass$k = ccclass$p;
            var AttachUtil = (_dec$1b = ccclass$k('dragonBones.AttachUtil'), _dec$1b(_class$1e = function () {
              function AttachUtil() {
                this._inited = false;
                this._armature = null;
                this._armatureNode = null;
                this._armatureDisplay = null;
              }

              var _proto = AttachUtil.prototype;

              _proto.init = function init(armatureDisplay) {
                this._inited = true;
                this._armature = armatureDisplay._armature;
                this._armatureNode = armatureDisplay.node;
                this._armatureDisplay = armatureDisplay;
              };

              _proto.reset = function reset() {
                this._inited = false;
                this._armature = null;
                this._armatureNode = null;
                this._armatureDisplay = null;
              };

              _proto._syncAttachedNode = function _syncAttachedNode() {
                if (!this._inited) return;
                var rootMatrix = this._armatureNode.worldMatrix;
                var boneInfos = null;

                var isCached = this._armatureDisplay.isAnimationCached();

                if (isCached && this._armatureDisplay) {
                  boneInfos = this._armatureDisplay._curFrame && this._armatureDisplay._curFrame.boneInfos;
                  if (!boneInfos) return;
                }

                var sockets = this._armatureDisplay.sockets;
                var socketNodes = this._armatureDisplay.socketNodes;

                var matrixHandle = function matrixHandle(node, boneMat) {
                  var tm = _tempMat4;
                  tm.m00 = boneMat.a;
                  tm.m01 = boneMat.b;
                  tm.m04 = -boneMat.c;
                  tm.m05 = -boneMat.d;
                  tm.m12 = boneMat.tx;
                  tm.m13 = boneMat.ty;
                  node.matrix = _tempMat4;
                };

                var bones = this._armature.getBones();

                for (var l = sockets.length - 1; l >= 0; l--) {
                  var sock = sockets[l];
                  var boneNode = sock.target;
                  if (!boneNode) continue;

                  if (!boneNode.isValid) {
                    socketNodes["delete"](sock.path);
                    sockets.splice(l, 1);
                    continue;
                  }

                  var bone = isCached ? boneInfos[sock.boneIndex] : bones[sock.boneIndex];
                  if (!bone) continue;
                  matrixHandle(boneNode, bone.globalTransformMatrix);
                }
              };

              return AttachUtil;
            }()) || _class$1e);

            var ArmatureSystem = function (_System) {
              _inheritsLoose(ArmatureSystem, _System);

              function ArmatureSystem() {
                var _this;

                _this = _System.call(this) || this;
                _this._armatures = new Set();
                return _this;
              }

              ArmatureSystem.getInstance = function getInstance() {
                if (!ArmatureSystem._instance) {
                  ArmatureSystem._instance = new ArmatureSystem();
                  director.registerSystem(ArmatureSystem.ID, ArmatureSystem._instance, System.Priority.HIGH);
                }

                return ArmatureSystem._instance;
              };

              var _proto = ArmatureSystem.prototype;

              _proto.add = function add(armature) {
                if (!armature) return;

                if (!this._armatures.has(armature)) {
                  this._armatures.add(armature);
                }
              };

              _proto.remove = function remove(armature) {
                if (!armature) return;

                if (this._armatures.has(armature)) {
                  this._armatures["delete"](armature);
                }
              };

              _proto.postUpdate = function postUpdate(dt) {
                if (!this._armatures) {
                  return;
                }

                this._armatures.forEach(function (armature) {
                  armature.updateAnimation(dt);
                  armature.syncAttachedNode();
                });
              };

              _proto.prepareRenderData = function prepareRenderData() {
                if (!this._armatures) {
                  return;
                }

                this._armatures.forEach(function (armature) {
                  armature.markForUpdateRenderData();
                });
              };

              return ArmatureSystem;
            }(System);
            ArmatureSystem.ID = 'ARMATURE';
            ArmatureSystem._instance = void 0;
            legacyCC.internal.ArmatureSystem = ArmatureSystem;

            var _dec$1c, _dec2$P, _class$1f, _class2$$, _initializer$X, _initializer2$L, _dec3$w, _dec4$j, _dec5$e, _dec6$c, _dec7$b, _dec8$7, _dec9$6, _class4$j, _class5$j, _initializer3$y, _initializer4$t, _initializer5$m, _initializer6$h, _initializer7$c, _initializer8$c, _initializer9$b, _initializer10$a, _initializer11$6, _initializer12$6, _initializer13$6, _initializer14$4, _initializer15$4, _initializer16$4, _class6$6, _temp$m;
            var DefaultArmaturesEnum;

            (function (DefaultArmaturesEnum) {
              DefaultArmaturesEnum[DefaultArmaturesEnum["default"] = -1] = "default";
            })(DefaultArmaturesEnum || (DefaultArmaturesEnum = {}));

            ccenum(DefaultArmaturesEnum);
            var DefaultAnimsEnum;

            (function (DefaultAnimsEnum) {
              DefaultAnimsEnum[DefaultAnimsEnum["<None>"] = 0] = "<None>";
            })(DefaultAnimsEnum || (DefaultAnimsEnum = {}));

            ccenum(DefaultAnimsEnum);
            var DefaultCacheMode;

            (function (DefaultCacheMode) {
              DefaultCacheMode[DefaultCacheMode["REALTIME"] = 0] = "REALTIME";
            })(DefaultCacheMode || (DefaultCacheMode = {}));

            ccenum(DefaultAnimsEnum);
            var timeScale = 1;
            var AnimationCacheMode;

            (function (AnimationCacheMode) {
              AnimationCacheMode[AnimationCacheMode["REALTIME"] = 0] = "REALTIME";
              AnimationCacheMode[AnimationCacheMode["SHARED_CACHE"] = 1] = "SHARED_CACHE";
              AnimationCacheMode[AnimationCacheMode["PRIVATE_CACHE"] = 2] = "PRIVATE_CACHE";
            })(AnimationCacheMode || (AnimationCacheMode = {}));

            ccenum(AnimationCacheMode);
            var ccclass$l = ccclass$p,
                serializable$f = serializable$j,
                type$6 = type$8,
                override = override$1;

            function setEnumAttr(obj, propName, enumDef) {
              CCClass.Attr.setClassAttr(obj, propName, 'type', 'Enum');
              CCClass.Attr.setClassAttr(obj, propName, 'enumList', Enum.getList(enumDef));
            }

            var DragonBoneSocket = (_dec$1c = ccclass$l('dragonBones.ArmatureDisplay.DragonBoneSocket'), _dec2$P = type$6(Node), _dec$1c(_class$1f = (_class2$$ = function DragonBoneSocket(path, target) {
              if (path === void 0) {
                path = '';
              }

              if (target === void 0) {
                target = null;
              }

              this.path = _initializer$X && _initializer$X();
              this.target = _initializer2$L && _initializer2$L();
              this.boneIndex = null;
              this.path = path;
              this.target = target;
            }, (_initializer$X = applyDecoratedInitializer(_class2$$.prototype, "path", [serializable$f], function () {
              return '';
            }), _initializer2$L = applyDecoratedInitializer(_class2$$.prototype, "target", [_dec2$P, serializable$f], function () {
              return null;
            })), _class2$$)) || _class$1f);
            setClassAlias(DragonBoneSocket, 'dragonBones.ArmatureDisplay.DragonBoneSocket');
            var ArmatureDisplay = (_dec3$w = ccclass$l('dragonBones.ArmatureDisplay'), _dec4$j = type$6(DragonBonesAsset), _dec5$e = type$6(DragonBonesAtlasAsset), _dec6$c = type$6(DefaultArmaturesEnum), _dec7$b = type$6(DefaultAnimsEnum), _dec8$7 = type$6([DragonBoneSocket]), _dec9$6 = type$6(Material), _dec3$w(_class4$j = (_class5$j = (_temp$m = _class6$6 = function (_UIRenderer) {
              _inheritsLoose(ArmatureDisplay, _UIRenderer);

              var _proto = ArmatureDisplay.prototype;

              _proto.requestDrawInfo = function requestDrawInfo(idx) {
                if (!this._drawInfoList[idx]) {
                  this._drawInfoList[idx] = new RenderDrawInfo();
                }

                return this._drawInfoList[idx];
              };

              function ArmatureDisplay() {
                var _this;

                _this = _UIRenderer.call(this) || this;
                _this.playTimes = _initializer3$y && _initializer3$y();
                _this.premultipliedAlpha = _initializer4$t && _initializer4$t();
                _this._armature = null;
                _this.attachUtil = void 0;
                _this._defaultArmatureIndexValue = _initializer5$m && _initializer5$m();
                _this._dragonAsset = _initializer6$h && _initializer6$h();
                _this._dragonAtlasAsset = _initializer7$c && _initializer7$c();
                _this._armatureName = _initializer8$c && _initializer8$c();
                _this._animationName = _initializer9$b && _initializer9$b();
                _this._animationIndexValue = _initializer10$a && _initializer10$a();
                _this._preCacheMode = -1;
                _this._cacheMode = AnimationCacheMode.REALTIME;
                _this._defaultCacheModeValue = _initializer11$6 && _initializer11$6();
                _this._timeScale = _initializer12$6 && _initializer12$6();
                _this._playTimes = _initializer13$6 && _initializer13$6();
                _this._debugBones = _initializer14$4 && _initializer14$4();
                _this._enableBatch = _initializer15$4 && _initializer15$4();
                _this._debugDraw = null;
                _this._armatureKey = '';
                _this._accTime = 0;
                _this._playCount = 0;
                _this._frameCache = null;
                _this._curFrame = null;
                _this._playing = false;
                _this._armatureCache = null;
                _this._eventTarget = void 0;
                _this._factory = null;
                _this._displayProxy = null;
                _this._drawIdx = 0;
                _this._drawList = new RecyclePool(function () {
                  return {
                    material: null,
                    texture: null,
                    indexOffset: 0,
                    indexCount: 0
                  };
                }, 1);
                _this.maxVertexCount = 0;
                _this.maxIndexCount = 0;
                _this._materialCache = {};
                _this._enumArmatures = Enum({});
                _this._enumAnimations = Enum({});
                _this._socketNodes = new Map();
                _this._cachedSockets = new Map();
                _this._sockets = _initializer16$4 && _initializer16$4();
                _this._inited = void 0;
                _this._drawInfoList = [];
                _this._cacheModeEnum = void 0;
                _this._eventTarget = new EventTarget();
                _this._inited = false;
                _this.attachUtil = new AttachUtil();

                _this.initFactory();

                setEnumAttr(_assertThisInitialized(_this), '_animationIndex', _this._enumAnimations);
                setEnumAttr(_assertThisInitialized(_this), '_defaultArmatureIndex', _this._enumArmatures);
                _this._useVertexOpacity = true;
                return _this;
              }

              _proto.initFactory = function initFactory() {
                this._factory = CCFactory.getInstance();
              };

              _proto.onLoad = function onLoad() {
                _UIRenderer.prototype.onLoad.call(this);
              };

              _proto._requestDrawData = function _requestDrawData(material, texture, indexOffset, indexCount) {
                var draw = this._drawList.add();

                draw.material = material;
                draw.texture = texture;
                draw.indexOffset = indexOffset;
                draw.indexCount = indexCount;
                return draw;
              };

              _proto.destroyRenderData = function destroyRenderData() {
                this._drawList.reset();

                _UIRenderer.prototype.destroyRenderData.call(this);
              };

              _proto.getMaterialTemplate = function getMaterialTemplate() {
                if (this.customMaterial !== null) return this.customMaterial;
                if (this.material) return this.material;
                this.updateMaterial();
                return this.material;
              };

              _proto.getMaterialForBlend = function getMaterialForBlend(src, dst) {
                var key = src + "/" + dst;
                var inst = this._materialCache[key];

                if (inst) {
                  return inst;
                }

                var material = this.getMaterialTemplate();
                var matInfo = {
                  parent: material,
                  subModelIdx: 0,
                  owner: this
                };
                inst = new MaterialInstance(matInfo);
                inst.recompileShaders({
                  TWO_COLORED: false,
                  USE_LOCAL: false
                });
                this._materialCache[key] = inst;
                inst.overridePipelineStates({
                  blendState: {
                    targets: [{
                      blendSrc: src,
                      blendDst: dst
                    }]
                  }
                });
                return inst;
              };

              _proto._updateBuiltinMaterial = function _updateBuiltinMaterial() {
                var material = builtinResMgr.get('default-spine-material');
                return material;
              };

              _proto.updateMaterial = function updateMaterial() {
                var mat;
                if (this._customMaterial) mat = this._customMaterial;else mat = this._updateBuiltinMaterial();
                this.setMaterial(mat, 0);

                this._cleanMaterialCache();
              };

              _proto._render = function _render(batcher) {
                var indicesCount = 0;

                if (this.renderData && this._drawList) {
                  var rd = this.renderData;
                  var chunk = rd.chunk;
                  var accessor = chunk.vertexAccessor;
                  var meshBuffer = rd.getMeshBuffer();
                  var origin = meshBuffer.indexOffset;

                  for (var i = 0; i < this._drawList.length; i++) {
                    this._drawIdx = i;
                    var dc = this._drawList.data[i];

                    if (dc.texture) {
                      batcher.commitMiddleware(this, meshBuffer, origin + dc.indexOffset, dc.indexCount, dc.texture, dc.material, this._enableBatch);
                    }

                    indicesCount += dc.indexCount;
                  }

                  var subIndices = rd.indices.subarray(0, indicesCount);
                  accessor.appendIndices(chunk.bufferId, subIndices);
                }
              };

              _proto.__preload = function __preload() {
                _UIRenderer.prototype.__preload.call(this);

                this._init();
              };

              _proto._init = function _init() {

                this._cacheMode = this._defaultCacheMode;
                if (this._inited) return;
                this._inited = true;

                this._parseDragonAtlasAsset();

                this._refresh();

                var children = this.node.children;

                for (var i = 0, n = children.length; i < n; i++) {
                  var child = children[i];

                  if (child && child.name === 'DEBUG_DRAW_NODE') {
                    child.destroy();
                  }
                }

                this._updateDebugDraw();

                this._indexBoneSockets();

                this._updateSocketBindings();
              };

              _proto.getArmatureKey = function getArmatureKey() {
                return this._armatureKey;
              };

              _proto.setAnimationCacheMode = function setAnimationCacheMode(cacheMode) {
                if (this._preCacheMode !== cacheMode) {
                  this._cacheMode = cacheMode;

                  this._buildArmature();

                  if (this._armature && !this.isAnimationCached()) {
                    this._factory._dragonBones.clock.add(this._armature);
                  }

                  this._updateSocketBindings();

                  this.markForUpdateRenderData();
                }
              };

              _proto.isAnimationCached = function isAnimationCached() {
                return this._cacheMode !== AnimationCacheMode.REALTIME;
              };

              _proto.onEnable = function onEnable() {
                _UIRenderer.prototype.onEnable.call(this);

                if (this._armature && !this.isAnimationCached()) {
                  this._factory._dragonBones.clock.add(this._armature);
                }

                this._flushAssembler();

                ArmatureSystem.getInstance().add(this);
              };

              _proto.onDisable = function onDisable() {
                _UIRenderer.prototype.onDisable.call(this);

                if (this._armature && !this.isAnimationCached()) {
                  this._factory._dragonBones.clock.remove(this._armature);
                }

                ArmatureSystem.getInstance().remove(this);
              };

              _proto._emitCacheCompleteEvent = function _emitCacheCompleteEvent() {
                this._eventTarget.emit(EventObject.LOOP_COMPLETE);

                this._eventTarget.emit(EventObject.COMPLETE);
              };

              _proto.updateAnimation = function updateAnimation(dt) {
                this.markForUpdateRenderData();
                if (!this.isAnimationCached()) return;
                if (!this._frameCache) return;
                var frameCache = this._frameCache;

                if (!frameCache.isInited()) {
                  return;
                }

                var frames = frameCache.frames;

                if (!this._playing) {
                  if (frameCache.isInvalid()) {
                    frameCache.updateToFrame();
                    this._curFrame = frames[frames.length - 1];

                    if (this.renderData && (this.renderData.vertexCount < frameCache.maxVertexCount || this.renderData.indexCount < frameCache.maxIndexCount)) {
                      this.maxVertexCount = frameCache.maxVertexCount > this.maxVertexCount ? frameCache.maxVertexCount : this.maxVertexCount;
                      this.maxIndexCount = frameCache.maxIndexCount > this.maxIndexCount ? frameCache.maxIndexCount : this.maxIndexCount;
                      this.renderData.resize(this.maxVertexCount, this.maxIndexCount);

                      if (!this.renderData.indices || this.maxIndexCount > this.renderData.indices.length) {
                        this.renderData.indices = new Uint16Array(this.maxIndexCount);
                      }
                    }
                  }

                  return;
                }

                var frameTime = ArmatureCache.FrameTime;

                if (this._accTime === 0 && this._playCount === 0) {
                  this._eventTarget.emit(EventObject.START);
                }

                var globalTimeScale = timeScale;
                this._accTime += dt * this.timeScale * globalTimeScale;
                var frameIdx = Math.floor(this._accTime / frameTime);

                if (!frameCache.isCompleted) {
                  frameCache.updateToFrame(frameIdx);

                  if (this.renderData && (this.renderData.vertexCount < frameCache.maxVertexCount || this.renderData.indexCount < frameCache.maxIndexCount)) {
                    this.maxVertexCount = frameCache.maxVertexCount > this.maxVertexCount ? frameCache.maxVertexCount : this.maxVertexCount;
                    this.maxIndexCount = frameCache.maxIndexCount > this.maxIndexCount ? frameCache.maxIndexCount : this.maxIndexCount;
                    this.renderData.resize(this.maxVertexCount, this.maxIndexCount);

                    if (!this.renderData.indices || this.maxIndexCount > this.renderData.indices.length) {
                      this.renderData.indices = new Uint16Array(this.maxIndexCount);
                    }
                  }
                }

                if (frameCache.isCompleted && frameIdx >= frames.length) {
                  this._playCount++;

                  if (this.playTimes > 0 && this._playCount >= this.playTimes) {
                    this._curFrame = frames[frames.length - 1];
                    this._accTime = 0;
                    this._playing = false;
                    this._playCount = 0;

                    this._emitCacheCompleteEvent();

                    this.attachUtil._syncAttachedNode();

                    return;
                  }

                  this._accTime = 0;
                  frameIdx = 0;

                  this._emitCacheCompleteEvent();
                }

                this._curFrame = frames[frameIdx];

                this.attachUtil._syncAttachedNode();
              };

              _proto.onDestroy = function onDestroy() {
                this._materialInstances = this._materialInstances.filter(function (instance) {
                  return !!instance;
                });
                this._inited = false;

                {
                  if (this._cacheMode === AnimationCacheMode.PRIVATE_CACHE) {
                    this._armatureCache.dispose();

                    this._armatureCache = null;
                    this._armature = null;
                  } else if (this._cacheMode === AnimationCacheMode.SHARED_CACHE) {
                    this._armatureCache = null;
                    this._armature = null;
                  } else if (this._armature) {
                    this._armature.dispose();

                    this._armature = null;
                  }
                }

                this._drawList.destroy();

                _UIRenderer.prototype.onDestroy.call(this);
              };

              _proto._updateDebugDraw = function _updateDebugDraw() {
                if (this.debugBones) {
                  if (!this._debugDraw) {
                    var debugDrawNode = new Node('DEBUG_DRAW_NODE');
                    debugDrawNode.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;
                    var debugDraw = debugDrawNode.addComponent(Graphics);
                    debugDraw.lineWidth = 1;
                    debugDraw.strokeColor = new Color$1(255, 0, 0, 255);
                    this._debugDraw = debugDraw;
                  }

                  this._debugDraw.node.parent = this.node;
                } else if (this._debugDraw) {
                  this._debugDraw.node.parent = null;
                }

                this.markForUpdateRenderData();
              };

              _proto._updateBatch = function _updateBatch() {
                this._cleanMaterialCache();

                this.markForUpdateRenderData();
              };

              _proto._buildArmature = function _buildArmature() {
                if (!this.dragonAsset || !this.dragonAtlasAsset || !this.armatureName) return;

                if (this._armature) {
                  {
                    if (this._preCacheMode === AnimationCacheMode.PRIVATE_CACHE) {
                      this._armatureCache.dispose();
                    } else if (this._preCacheMode === AnimationCacheMode.REALTIME) {
                      this._armature.dispose();
                    }
                  }

                  this._armatureCache = null;
                  this._armature = null;
                  this._displayProxy = null;
                  this._frameCache = null;
                  this._curFrame = null;
                  this._playing = false;
                  this._preCacheMode = -1;
                }

                {
                  if (this._cacheMode === AnimationCacheMode.SHARED_CACHE) {
                    this._armatureCache = ArmatureCache.sharedCache;
                  } else if (this._cacheMode === AnimationCacheMode.PRIVATE_CACHE) {
                    this._armatureCache = new ArmatureCache();

                    this._armatureCache.enablePrivateMode();
                  }
                }

                var atlasUUID = this.dragonAtlasAsset._uuid;
                this._armatureKey = this.dragonAsset.init(this._factory, atlasUUID);

                if (this.isAnimationCached()) {
                  this._armature = this._armatureCache.getArmatureCache(this.armatureName, this._armatureKey, atlasUUID);

                  if (!this._armature) {
                    this._cacheMode = AnimationCacheMode.REALTIME;
                  }
                }

                this._preCacheMode = this._cacheMode;

                if ( this._cacheMode === AnimationCacheMode.REALTIME) {
                  this._displayProxy = this._factory.buildArmatureDisplay(this.armatureName, this._armatureKey, '', atlasUUID);
                  if (!this._displayProxy) return;
                  this._displayProxy._ccNode = this.node;
                  this._displayProxy._ccComponent = this;

                  this._displayProxy.setEventTarget(this._eventTarget);

                  this._armature = this._displayProxy._armature;
                  this._armature.animation.timeScale = this.timeScale;
                }

                if (this._cacheMode !== AnimationCacheMode.REALTIME && this.debugBones) {
                  console.warn('Debug bones is invalid in cached mode');
                }

                if (this._armature) {
                  var armatureData = this._armature.armatureData;
                  var aabb = armatureData.aabb;

                  this.node._uiProps.uiTransformComp.setContentSize(aabb.width, aabb.height);
                }

                this.attachUtil.init(this);

                if (this.animationName) {
                  this.playAnimation(this.animationName, this.playTimes);
                }

                this._flushAssembler();
              };

              _proto.querySockets = function querySockets() {
                if (!this._armature) {
                  return [];
                }

                if (this._cachedSockets.size === 0) {
                  this._indexBoneSockets();
                }

                return Array.from(this._cachedSockets.keys()).sort();
              };

              _proto.querySocketPathByName = function querySocketPathByName(name) {
                var ret = [];

                for (var _iterator = _createForOfIteratorHelperLoose(this._cachedSockets.keys()), _step; !(_step = _iterator()).done;) {
                  var _key = _step.value;

                  if (_key.endsWith(name)) {
                    ret.push(_key);
                  }
                }

                return ret;
              };

              _proto._parseDragonAtlasAsset = function _parseDragonAtlasAsset() {
                if (this.dragonAtlasAsset) {
                  this.dragonAtlasAsset.init(this._factory);
                }
              };

              _proto._refresh = function _refresh() {
                this._buildArmature();

                this._indexBoneSockets();

                this.markForUpdateRenderData();
              };

              _proto._updateCacheModeEnum = function _updateCacheModeEnum() {
                this._cacheModeEnum = Enum({});

                if (this._armature) {
                  Object.assign(this._cacheModeEnum, AnimationCacheMode);
                } else {
                  Object.assign(this._cacheModeEnum, DefaultCacheMode);
                }

                setEnumAttr(this, '_defaultCacheMode', this._cacheModeEnum);
              };

              _proto._updateAnimEnum = function _updateAnimEnum() {
                var animEnum;

                if (this.dragonAsset) {
                  animEnum = this.dragonAsset.getAnimsEnum(this.armatureName);
                } else {
                  animEnum = DefaultAnimsEnum;
                }

                this._enumAnimations = Enum({});
                Object.assign(this._enumAnimations, animEnum || DefaultAnimsEnum);
                Enum.update(this._enumAnimations);
                setEnumAttr(this, '_animationIndex', this._enumAnimations);
              };

              _proto._updateArmatureEnum = function _updateArmatureEnum() {
                var armatureEnum;

                if (this.dragonAsset) {
                  armatureEnum = this.dragonAsset.getArmatureEnum();
                } else {
                  armatureEnum = DefaultArmaturesEnum;
                }

                this._enumArmatures = Enum({});
                Object.assign(this._enumArmatures, armatureEnum || DefaultArmaturesEnum);
                Enum.update(this._enumArmatures);
                setEnumAttr(this, '_defaultArmatureIndex', this._enumArmatures);
              };

              _proto._indexBoneSockets = function _indexBoneSockets() {
                if (!this._armature) {
                  return;
                }

                this._cachedSockets.clear();

                var nameToBone = this._cachedSockets;

                var cacheBoneName = function cacheBoneName(bi, bones, cache) {
                  if (cache.has(bi)) {
                    return cache.get(bi);
                  }

                  var bone = bones[bi];

                  if (!bone.parent) {
                    cache.set(bi, bone.name);
                    bone.path = bone.name;
                    return bone.name;
                  }

                  var name = cacheBoneName(bone.parent._boneIndex, bones, cache) + "/" + bone.name;
                  cache.set(bi, name);
                  bone.path = name;
                  return name;
                };

                var walkArmature = function walkArmature(prefix, armature) {
                  var bones = armature.getBones();
                  var boneToName = new Map();

                  for (var i = 0; i < bones.length; i++) {
                    bones[i]._boneIndex = i;
                  }

                  for (var _i = 0; _i < bones.length; _i++) {
                    cacheBoneName(_i, bones, boneToName);
                  }

                  for (var _iterator2 = _createForOfIteratorHelperLoose(boneToName.keys()), _step2; !(_step2 = _iterator2()).done;) {
                    var bone = _step2.value;
                    nameToBone.set("" + prefix + boneToName.get(bone), bone);
                  }

                  var slots = armature.getSlots();

                  for (var _i2 = 0; _i2 < slots.length; _i2++) {
                    if (slots[_i2].childArmature) {
                      walkArmature(slots[_i2].name, slots[_i2].childArmature);
                    }
                  }
                };

                walkArmature('', this._armature);
              };

              _proto.playAnimation = function playAnimation(animName, playTimes) {
                this.playTimes = playTimes === undefined ? -1 : playTimes;
                this.animationName = animName;

                if (this.isAnimationCached()) {
                  var cache = this._armatureCache.getAnimationCache(this._armatureKey, animName);

                  if (!cache) {
                    cache = this._armatureCache.initAnimationCache(this._armatureKey, animName);
                  }

                  if (cache) {
                    this._accTime = 0;
                    this._playCount = 0;
                    this._frameCache = cache;

                    if (this._sockets.length > 0) {
                      this._frameCache.enableCacheAttachedInfo();
                    }

                    this._frameCache.updateToFrame(0);

                    this._playing = true;
                    this._curFrame = this._frameCache.frames[0];
                  }
                } else if (this._armature) {
                  return this._armature.animation.play(animName, this.playTimes);
                }

                this.markForUpdateRenderData();
                return null;
              };

              _proto.updateAnimationCache = function updateAnimationCache(animName) {
                if (!this.isAnimationCached()) return;

                this._armatureCache.updateAnimationCache(this._armatureKey, animName);
              };

              _proto.invalidAnimationCache = function invalidAnimationCache() {
                if (!this.isAnimationCached()) return;

                this._armatureCache.invalidAnimationCache(this._armatureKey);
              };

              _proto.getArmatureNames = function getArmatureNames() {
                var dragonBonesData = this._factory.getDragonBonesData(this._armatureKey);

                return dragonBonesData && dragonBonesData.armatureNames || [];
              };

              _proto.getAnimationNames = function getAnimationNames(armatureName) {
                var ret = [];

                var dragonBonesData = this._factory.getDragonBonesData(this._armatureKey);

                if (dragonBonesData) {
                  var armatureData = dragonBonesData.getArmature(armatureName);

                  if (armatureData) {
                    for (var animName in armatureData.animations) {
                      if (armatureData.animations.hasOwnProperty(animName)) {
                        ret.push(animName);
                      }
                    }
                  }
                }

                return ret;
              };

              _proto.on = function on(eventType, listener, target) {
                this.addEventListener(eventType, listener, target);
              };

              _proto.off = function off(eventType, listener, target) {
                this.removeEventListener(eventType, listener, target);
              };

              _proto.once = function once(eventType, listener, target) {
                this._eventTarget.once(eventType, listener, target);
              };

              _proto.addEventListener = function addEventListener(eventType, listener, target) {
                this._eventTarget.on(eventType, listener, target);
              };

              _proto.removeEventListener = function removeEventListener(eventType, listener, target) {
                this._eventTarget.off(eventType, listener, target);
              };

              _proto.buildArmature = function buildArmature(armatureName, node) {
                return this._factory.createArmatureNode(this, armatureName, node);
              };

              _proto.armature = function armature() {
                return this._armature;
              };

              _proto._flushAssembler = function _flushAssembler() {
                var assembler = ArmatureDisplay.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this._assembler = assembler;
                }

                if (this._armature && this._assembler) {
                  this._renderData = this._assembler.createData(this);

                  if (this.renderData) {
                    this.maxVertexCount = this.renderData.vertexCount;
                    this.maxIndexCount = this.renderData.indexCount;
                  }

                  this.markForUpdateRenderData();

                  this._updateColor();
                }
              };

              _proto._updateSocketBindings = function _updateSocketBindings() {
                if (!this._armature) return;

                this._socketNodes.clear();

                for (var i = 0, l = this._sockets.length; i < l; i++) {
                  var socket = this._sockets[i];

                  if (socket.path && socket.target) {
                    var bone = this._cachedSockets.get(socket.path);

                    if (!bone) {
                      console.error("Skeleton data does not contain path " + socket.path);
                      continue;
                    }

                    socket.boneIndex = bone;

                    this._socketNodes.set(socket.path, socket.target);
                  }
                }
              };

              _proto._verifySockets = function _verifySockets(sockets) {
                for (var i = 0, l = sockets.length; i < l; i++) {
                  var target = sockets[i].target;

                  if (target) {
                    if (!target.parent || target.parent !== this.node) {
                      console.error("Target node " + target.name + " is expected to be a direct child of " + this.node.name);
                      continue;
                    }
                  }
                }
              };

              _proto._cleanMaterialCache = function _cleanMaterialCache() {
                for (var val in this._materialCache) {
                  this._materialCache[val].destroy();
                }

                this._materialCache = {};
              };

              _proto.createRenderEntity = function createRenderEntity() {
                var renderEntity = new RenderEntity(RenderEntityType.DYNAMIC);
                renderEntity.setUseLocal(false);
                return renderEntity;
              };

              _proto.markForUpdateRenderData = function markForUpdateRenderData(enable) {
                if (enable === void 0) {
                  enable = true;
                }

                _UIRenderer.prototype.markForUpdateRenderData.call(this, enable);

                if (this._debugDraw) {
                  this._debugDraw.markForUpdateRenderData(enable);
                }
              };

              _proto.syncAttachedNode = function syncAttachedNode() {
                this.attachUtil._syncAttachedNode();
              };

              _createClass(ArmatureDisplay, [{
                key: "dragonAsset",
                get: function get() {
                  return this._dragonAsset;
                },
                set: function set(value) {
                  this._dragonAsset = value;
                  this.destroyRenderData();

                  this._refresh();
                }
              }, {
                key: "dragonAtlasAsset",
                get: function get() {
                  return this._dragonAtlasAsset;
                },
                set: function set(value) {
                  this._dragonAtlasAsset = value;

                  this._parseDragonAtlasAsset();

                  this._refresh();
                }
              }, {
                key: "armatureName",
                get: function get() {
                  return this._armatureName;
                },
                set: function set(name) {
                  this._armatureName = name;
                  var animNames = this.getAnimationNames(this._armatureName);

                  if (!this.animationName || animNames.indexOf(this.animationName) < 0) {
                    {
                      this.animationName = '';
                    }
                  }

                  if (this._armature && !this.isAnimationCached()) {
                    this._factory._dragonBones.clock.remove(this._armature);
                  }

                  this._refresh();

                  if (this._armature && !this.isAnimationCached()) {
                    this._factory._dragonBones.clock.add(this._armature);
                  }
                }
              }, {
                key: "animationName",
                get: function get() {
                  return this._animationName;
                },
                set: function set(value) {
                  this._animationName = value;
                }
              }, {
                key: "_defaultArmatureIndex",
                get: function get() {
                  return this._defaultArmatureIndexValue;
                },
                set: function set(value) {
                  this._defaultArmatureIndexValue = value;
                  var armatureName = '';

                  if (this.dragonAsset) {
                    var armaturesEnum;

                    if (this.dragonAsset) {
                      armaturesEnum = this.dragonAsset.getArmatureEnum();
                    }

                    if (!armaturesEnum) {
                      errorID(7400, this.name);
                      return;
                    }

                    armatureName = armaturesEnum[this._defaultArmatureIndex];
                  }

                  if (armatureName !== undefined) {
                    this.armatureName = armatureName;
                  } else {
                    errorID(7401, this.name);
                  }

                  this.markForUpdateRenderData();
                }
              }, {
                key: "_animationIndex",
                get: function get() {
                  return this._animationIndexValue;
                },
                set: function set(value) {
                  this._animationIndexValue = value;

                  if (this._animationIndex === 0) {
                    this.animationName = '';
                    return;
                  }

                  var animsEnum;

                  if (this.dragonAsset) {
                    animsEnum = this.dragonAsset.getAnimsEnum(this.armatureName);
                  }

                  if (!animsEnum) {
                    return;
                  }

                  var animName = animsEnum[this._animationIndex];

                  if (animName !== undefined) {
                    this.playAnimation(animName, this.playTimes);
                  } else {
                    errorID(7402, this.name);
                  }
                }
              }, {
                key: "_defaultCacheMode",
                get: function get() {
                  return this._defaultCacheModeValue;
                },
                set: function set(value) {
                  this._defaultCacheModeValue = value;

                  if (this._defaultCacheMode !== AnimationCacheMode.REALTIME) {
                    if (this._armature && !ArmatureCache.canCache(this._armature)) {
                      this._defaultCacheMode = AnimationCacheMode.REALTIME;
                      console.warn('Animation cache mode doesn\'t support skeletal nesting');
                      return;
                    }
                  }

                  this.setAnimationCacheMode(this._defaultCacheMode);
                }
              }, {
                key: "timeScale",
                get: function get() {
                  return this._timeScale;
                },
                set: function set(value) {
                  this._timeScale = value;

                  if (this._armature && !this.isAnimationCached()) {
                    this._armature.animation.timeScale = this.timeScale;
                  }
                }
              }, {
                key: "debugBones",
                get: function get() {
                  return this._debugBones;
                },
                set: function set(value) {
                  this._debugBones = value;

                  this._updateDebugDraw();
                }
              }, {
                key: "enableBatch",
                get: function get() {
                  return this._enableBatch;
                },
                set: function set(value) {
                  if (value !== this._enableBatch) {
                    this._enableBatch = value;

                    this._updateBatch();
                  }
                }
              }, {
                key: "sockets",
                get: function get() {
                  return this._sockets;
                },
                set: function set(val) {
                  this._verifySockets(val);

                  this._sockets = val;

                  this._updateSocketBindings();

                  if (val.length > 0 && this._frameCache) {
                    this._frameCache.enableCacheAttachedInfo();
                  }
                }
              }, {
                key: "socketNodes",
                get: function get() {
                  return this._socketNodes;
                }
              }, {
                key: "drawList",
                get: function get() {
                  return this._drawList;
                }
              }, {
                key: "customMaterial",
                get: function get() {
                  return this._customMaterial;
                },
                set: function set(val) {
                  this._customMaterial = val;
                  this.updateMaterial();
                  this.markForUpdateRenderData();
                }
              }]);

              return ArmatureDisplay;
            }(UIRenderer), _class6$6.AnimationCacheMode = AnimationCacheMode, _temp$m), (_applyDecoratedDescriptor(_class5$j.prototype, "dragonAsset", [_dec4$j], Object.getOwnPropertyDescriptor(_class5$j.prototype, "dragonAsset"), _class5$j.prototype), _applyDecoratedDescriptor(_class5$j.prototype, "dragonAtlasAsset", [_dec5$e], Object.getOwnPropertyDescriptor(_class5$j.prototype, "dragonAtlasAsset"), _class5$j.prototype), _applyDecoratedDescriptor(_class5$j.prototype, "_defaultArmatureIndex", [_dec6$c], Object.getOwnPropertyDescriptor(_class5$j.prototype, "_defaultArmatureIndex"), _class5$j.prototype), _applyDecoratedDescriptor(_class5$j.prototype, "_animationIndex", [_dec7$b], Object.getOwnPropertyDescriptor(_class5$j.prototype, "_animationIndex"), _class5$j.prototype), _applyDecoratedDescriptor(_class5$j.prototype, "timeScale", [serializable$f], Object.getOwnPropertyDescriptor(_class5$j.prototype, "timeScale"), _class5$j.prototype), _initializer3$y = applyDecoratedInitializer(_class5$j.prototype, "playTimes", [serializable$f], function () {
              return -1;
            }), _initializer4$t = applyDecoratedInitializer(_class5$j.prototype, "premultipliedAlpha", [serializable$f], function () {
              return false;
            }), _applyDecoratedDescriptor(_class5$j.prototype, "sockets", [_dec8$7], Object.getOwnPropertyDescriptor(_class5$j.prototype, "sockets"), _class5$j.prototype), _initializer5$m = applyDecoratedInitializer(_class5$j.prototype, "_defaultArmatureIndexValue", [serializable$f], function () {
              return DefaultArmaturesEnum["default"];
            }), _initializer6$h = applyDecoratedInitializer(_class5$j.prototype, "_dragonAsset", [serializable$f], function () {
              return null;
            }), _initializer7$c = applyDecoratedInitializer(_class5$j.prototype, "_dragonAtlasAsset", [serializable$f], function () {
              return null;
            }), _initializer8$c = applyDecoratedInitializer(_class5$j.prototype, "_armatureName", [serializable$f], function () {
              return '';
            }), _initializer9$b = applyDecoratedInitializer(_class5$j.prototype, "_animationName", [serializable$f], function () {
              return '';
            }), _initializer10$a = applyDecoratedInitializer(_class5$j.prototype, "_animationIndexValue", [serializable$f], function () {
              return 0;
            }), _initializer11$6 = applyDecoratedInitializer(_class5$j.prototype, "_defaultCacheModeValue", [serializable$f], function () {
              return AnimationCacheMode.REALTIME;
            }), _initializer12$6 = applyDecoratedInitializer(_class5$j.prototype, "_timeScale", [serializable$f], function () {
              return 1;
            }), _initializer13$6 = applyDecoratedInitializer(_class5$j.prototype, "_playTimes", [serializable$f], function () {
              return -1;
            }), _initializer14$4 = applyDecoratedInitializer(_class5$j.prototype, "_debugBones", [serializable$f], function () {
              return false;
            }), _initializer15$4 = applyDecoratedInitializer(_class5$j.prototype, "_enableBatch", [serializable$f], function () {
              return false;
            }), _initializer16$4 = applyDecoratedInitializer(_class5$j.prototype, "_sockets", [serializable$f], function () {
              return [];
            }), _applyDecoratedDescriptor(_class5$j.prototype, "customMaterial", [override, _dec9$6], Object.getOwnPropertyDescriptor(_class5$j.prototype, "customMaterial"), _class5$j.prototype)), _class5$j)) || _class4$j);
            legacyCC.internal.ArmatureDisplay = ArmatureDisplay;

            var NEED_COLOR = 0x01;

            var _boneColor = new Color$1(255, 0, 0, 255);

            var _slotColor = new Color$1(0, 0, 255, 255);

            var _originColor = new Color$1(0, 255, 0, 255);

            var _nodeR;

            var _nodeG;

            var _nodeB;

            var _nodeA;

            var _premultipliedAlpha;

            var _mustFlush;

            var _renderData$1;

            var _ibuf;

            var _vbuf;

            var _node;

            var _comp$1;

            var _vertexFloatCount = 0;
            var _vertexCount = 0;
            var _vertexOffset = 0;
            var _vertexFloatOffset = 0;
            var _indexCount = 0;
            var _indexOffset$1 = 0;
            var _actualVCount = 0;
            var _actualICount = 0;
            var _prevDrawIndexOffset = 0;
            var LOCAL_FLOAT_PER_VERTEX = 4;
            var PER_VERTEX_SIZE$1 = 3 + 2 + 4;

            var _c = new Float32Array(4);

            var _handleVal;

            var _tempVecPos = new Vec3(0, 0, 0);

            var _slotMat = new Mat4();

            var _currentMaterial = null;
            var _currentTexture = null;

            function _getSlotMaterial(tex, blendMode) {
              if (!tex) return null;
              var src;
              var dst;

              switch (blendMode) {
                case 1:
                  src = _premultipliedAlpha ? BlendFactor.ONE : BlendFactor.SRC_ALPHA;
                  dst = BlendFactor.ONE;
                  break;

                case 10:
                  src = BlendFactor.DST_COLOR;
                  dst = BlendFactor.ONE_MINUS_SRC_ALPHA;
                  break;

                case 12:
                  src = BlendFactor.ONE;
                  dst = BlendFactor.ONE_MINUS_SRC_COLOR;
                  break;

                case 0:
                default:
                  src = _premultipliedAlpha ? BlendFactor.ONE : BlendFactor.SRC_ALPHA;
                  dst = BlendFactor.ONE_MINUS_SRC_ALPHA;
                  break;
              }

              return _comp$1.getMaterialForBlend(src, dst);
            }

            function _handleColor(color, parentOpacity) {
              var _a = color.a * parentOpacity * _nodeA;

              var _multiply = _premultipliedAlpha ? _a / 255.0 : 1.0;

              var _r = color.r * _nodeR * _multiply / 255.0;

              var _g = color.g * _nodeG * _multiply / 255.0;

              var _b = color.b * _nodeB * _multiply / 255.0;

              _c[0] = _r;
              _c[1] = _g;
              _c[2] = _b;
              _c[3] = _premultipliedAlpha ? 1.0 : _a / 255.0;
            }

            var _accessor = null;
            var simple$1 = {
              accessor: _accessor,
              vCount: 32767,
              ensureAccessor: function ensureAccessor() {
                if (!_accessor) {
                  var device = director.root.device;
                  var batcher = director.root.batcher2D;
                  var attributes = vfmtPosUvColor;
                  this.accessor = _accessor = new StaticVBAccessor(device, attributes, this.vCount);
                  batcher.registerBufferAccessor(Number.parseInt('DRAGONBONES', 36), _accessor);
                }

                return this.accessor;
              },
              createData: function createData(comp) {
                var rd = comp.renderData;

                if (!rd) {
                  this.ensureAccessor();
                  var slots = comp._armature._slots;
                  var vCount = 0;
                  var iCount = 0;

                  for (var i = 0; i < slots.length; ++i) {
                    var slot = slots[i];
                    var remainder = slot._localVertices.length % 4;

                    if (remainder === 0) {
                      vCount += slot._localVertices.length / LOCAL_FLOAT_PER_VERTEX;
                    } else {
                      vCount += (slot._localVertices.length - remainder) / LOCAL_FLOAT_PER_VERTEX + 1;
                    }

                    iCount += slot._indices.length;
                  }

                  rd = RenderData.add(vfmtPosUvColor, this.accessor);
                  rd.resize(vCount, iCount);

                  if (!rd.indices || iCount !== rd.indices.length) {
                    rd.indices = new Uint16Array(iCount);
                  }
                }

                return rd;
              },
              updateRenderData: function updateRenderData(comp, batcher) {
                _comp$1 = comp;
                var armature = comp._armature;

                if (armature) {
                  updateComponentRenderData(comp);
                }
              },
              updateColor: function updateColor(comp) {
                if (!comp) return;
                _comp$1 = comp;

                _comp$1.markForUpdateRenderData();
              }
            };

            function realTimeTraverse(armature, parentOpacity, worldMat) {
              var rd = _renderData$1;
              _vbuf = rd.chunk.vb;
              _ibuf = rd.indices;
              var slots = armature._slots;
              var material;
              var vertices;
              var indices;
              var slotColor;
              var slot;
              var cumulatedCount = 0;

              for (var i = 0, l = slots.length; i < l; i++) {
                slot = slots[i];
                slotColor = slot._color;
                if (!slot._visible || !slot._displayData) continue;

                if (worldMat) {
                  Mat4.multiply(slot._worldMatrix, worldMat, slot._matrix);
                } else {
                  Mat4.copy(slot._worldMatrix, slot._matrix);
                }

                if (slot.childArmature) {
                  realTimeTraverse(slot.childArmature, slotColor.a / 255, slot._worldMatrix);
                  continue;
                }

                material = _getSlotMaterial(slot.getTexture(), slot._blendMode);

                if (!material) {
                  continue;
                }

                if (!_currentMaterial) _currentMaterial = material;
                var texture = slot.getTexture();

                if (_mustFlush || material.hash !== _currentMaterial.hash || texture && _currentTexture !== texture) {
                  _mustFlush = false;

                  var _cumulatedCount = _indexOffset$1 - _prevDrawIndexOffset;

                  if (_cumulatedCount > 0) {
                    _comp$1._requestDrawData(_currentMaterial, _currentTexture, _prevDrawIndexOffset, _cumulatedCount);

                    _prevDrawIndexOffset = _indexOffset$1;
                  }

                  _currentTexture = texture;
                  _currentMaterial = material;
                }

                _handleColor(slotColor, parentOpacity);

                _slotMat.set(slot._worldMatrix);

                vertices = slot._localVertices;
                _vertexCount = vertices.length / LOCAL_FLOAT_PER_VERTEX;
                _vertexFloatCount = _vertexCount * PER_VERTEX_SIZE$1;
                indices = slot._indices;
                _indexCount = indices.length;
                var isResize = false;

                if (_vertexOffset + _vertexCount > _actualVCount) {
                  _actualVCount = _vertexOffset + _vertexCount;
                  isResize = true;
                }

                if (_indexOffset$1 + _indexCount > _actualICount) {
                  _actualICount = _indexOffset$1 + _indexCount;
                  isResize = true;
                }

                if (isResize) {
                  var oldIndices = _ibuf;
                  var oldChunkOffset = rd.chunk.vertexOffset;
                  rd.resizeAndCopy(_actualVCount, _actualICount > rd.indexCount ? _actualICount : rd.indexCount);
                  _vbuf = rd.chunk.vb;

                  if (_actualICount > _ibuf.length) {
                    _ibuf = rd.indices = new Uint16Array(_actualICount);
                  }

                  var correction = rd.chunk.vertexOffset - oldChunkOffset;

                  for (var _i = 0; _i < _indexOffset$1; ++_i) {
                    _ibuf[_i] = oldIndices[_i] + correction;
                  }
                }

                for (var vi = 0, vl = vertices.length, v = _vertexFloatOffset; vi < vl; v += PER_VERTEX_SIZE$1) {
                  _tempVecPos.x = vertices[vi++];
                  _tempVecPos.y = vertices[vi++];
                  _tempVecPos.z = 0;

                  _tempVecPos.transformMat4(_slotMat);

                  _vbuf[v] = _tempVecPos.x;
                  _vbuf[v + 1] = _tempVecPos.y;
                  _vbuf[v + 2] = _tempVecPos.z;
                  _vbuf[v + 3] = vertices[vi++];
                  _vbuf[v + 4] = vertices[vi++];

                  _vbuf.set(_c, v + 5);
                }

                var chunkOffset = rd.chunk.vertexOffset;

                for (var _i2 = 0, il = indices.length, ii = _indexOffset$1; _i2 < il; _i2++, ii++) {
                  _ibuf[ii] = _vertexOffset + indices[_i2] + chunkOffset;
                }

                _vertexFloatOffset += _vertexFloatCount;
                _vertexOffset += _vertexCount;
                _indexOffset$1 += _indexCount;
                _vertexCount = 0;
                _indexCount = 0;
              }

              cumulatedCount = _indexOffset$1 - _prevDrawIndexOffset;

              if (_currentTexture && cumulatedCount > 0) {
                _comp$1._requestDrawData(_currentMaterial, _currentTexture, _prevDrawIndexOffset, cumulatedCount);

                _prevDrawIndexOffset = _indexOffset$1;
              }

              if (_comp$1.maxIndexCount < _actualICount) {
                _comp$1.maxIndexCount = _actualICount;
              }

              if (_comp$1.maxVertexCount < _actualVCount) {
                _comp$1.maxVertexCount = _actualVCount;
              }
            }

            function cacheTraverse(frame, parentMat) {
              if (!frame) return;
              var segments = frame.segments;
              if (segments.length === 0) return;
              var material = null;
              var vertices = frame.vertices;
              var indices = frame.indices;
              var chunkOffset = 0;
              var frameVFOffset = 0;
              var frameIndexOffset = 0;
              var segVFCount = 0;
              var colorOffset = 0;
              var colors = frame.colors;
              var nowColor = colors[colorOffset++];
              var maxVFOffset = nowColor.vfOffset;

              _handleColor(nowColor, 1.0);

              var rd = _renderData$1;
              var vbuf = rd.chunk.vb;
              var ibuf = rd.indices;

              for (var i = 0, n = segments.length; i < n; i++) {
                var segInfo = segments[i];
                material = _getSlotMaterial(segInfo.tex, segInfo.blendMode);
                if (!material) continue;
                if (!_currentMaterial) _currentMaterial = material;

                if (_mustFlush || material.hash !== _currentMaterial.hash || segInfo.tex && segInfo.tex !== _currentTexture) {
                  _mustFlush = false;

                  var _cumulatedCount2 = _indexOffset$1 - _prevDrawIndexOffset;

                  if (_cumulatedCount2 > 0) {
                    _comp$1._requestDrawData(_currentMaterial, _currentTexture, _prevDrawIndexOffset, _cumulatedCount2);

                    _prevDrawIndexOffset = _indexOffset$1;
                  }

                  _currentMaterial = material;
                  _currentTexture = segInfo.tex;
                }

                _vertexCount = segInfo.vertexCount;
                _indexCount = segInfo.indexCount;
                chunkOffset = rd.chunk.vertexOffset;

                for (var ii = _indexOffset$1, il = _indexOffset$1 + _indexCount; ii < il; ii++) {
                  ibuf[ii] = chunkOffset + _vertexOffset + indices[frameIndexOffset++];
                }

                segVFCount = segInfo.vfCount;
                var subArray = vertices.subarray(frameVFOffset, segVFCount);
                vbuf.set(subArray, frameVFOffset);
                var offset = 0;

                if (parentMat) {
                  for (var _ii = 0, _il = _vertexCount; _ii < _il; _ii++) {
                    _tempVecPos.x = vbuf[offset];
                    _tempVecPos.y = vbuf[offset + 1];
                    _tempVecPos.z = 0;

                    _tempVecPos.transformMat4(parentMat);

                    vbuf[offset] = _tempVecPos.x;
                    vbuf[offset + 1] = _tempVecPos.y;
                    vbuf[offset + 2] = _tempVecPos.z;
                    offset += PER_VERTEX_SIZE$1;
                  }
                }

                if (_handleVal & NEED_COLOR) {
                  var frameColorOffset = frameVFOffset / 9 * 5;

                  for (var _ii2 = frameVFOffset, iEnd = frameVFOffset + segVFCount; _ii2 < iEnd; _ii2 += PER_VERTEX_SIZE$1, frameColorOffset += 5) {
                    if (frameColorOffset >= maxVFOffset) {
                      nowColor = colors[colorOffset++];

                      _handleColor(nowColor, 1.0);

                      maxVFOffset = nowColor.vfOffset;
                    }

                    vbuf.set(_c, _ii2 + 5);
                  }
                }

                frameVFOffset += segVFCount;
                _vertexOffset += _vertexCount;
                _indexOffset$1 += _indexCount;
                _vertexCount = 0;
                _indexCount = 0;
              }

              var cumulatedCount = _indexOffset$1 - _prevDrawIndexOffset;

              if (_currentTexture && cumulatedCount > 0) {
                _comp$1._requestDrawData(_currentMaterial, _currentTexture, _prevDrawIndexOffset, cumulatedCount);
              }
            }

            function updateComponentRenderData(comp, batcher) {
              var armature = comp._armature;
              if (!armature || comp.renderData === null) return;
              _mustFlush = true;
              _premultipliedAlpha = comp.premultipliedAlpha;
              comp.drawList.reset();
              _comp$1 = comp;
              _node = comp.node;
              _renderData$1 = comp.renderData;
              _comp$1 = comp;
              _handleVal = 0;
              _currentMaterial = null;
              var nodeColor = comp.color;
              _nodeR = nodeColor.r / 255;
              _nodeG = nodeColor.g / 255;
              _nodeB = nodeColor.b / 255;
              _nodeA = comp.node._uiProps.opacity;

              if (nodeColor._val !== 0xffffffff) {
                _handleVal |= NEED_COLOR;
              }

              var worldMat = comp.node.getWorldMatrix();
              _vertexFloatCount = 0;
              _vertexOffset = 0;
              _vertexFloatOffset = 0;
              _indexCount = 0;
              _indexOffset$1 = 0;
              _prevDrawIndexOffset = 0;
              _actualVCount = _comp$1.maxVertexCount;
              _actualICount = _comp$1.maxIndexCount;

              if (comp.isAnimationCached()) {
                cacheTraverse(comp._curFrame, worldMat);
              } else {
                realTimeTraverse(armature, 1.0, worldMat);
                var graphics = comp._debugDraw;

                if (comp.debugBones && graphics) {
                  graphics.clear();
                  graphics.lineWidth = 5;
                  graphics.strokeColor = _boneColor;
                  graphics.fillColor = _slotColor;
                  var bones = armature.getBones();

                  for (var i = 0, l = bones.length; i < l; i++) {
                    var bone = bones[i];
                    var boneLength = Math.max(bone.boneData.length, 5);
                    var startX = bone.globalTransformMatrix.tx;
                    var startY = bone.globalTransformMatrix.ty;
                    var endX = startX + bone.globalTransformMatrix.a * boneLength;
                    var endY = startY + bone.globalTransformMatrix.b * boneLength;
                    graphics.moveTo(startX, startY);
                    graphics.lineTo(endX, endY);
                    graphics.stroke();
                    graphics.circle(startX, startY, Math.PI * 2);
                    graphics.fill();

                    if (i === 0) {
                      graphics.fillColor = _originColor;
                    }
                  }
                }
              }

              _accessor.getMeshBuffer(_renderData$1.chunk.bufferId).setDirty();

              _node = undefined;
              _comp$1 = undefined;
            }

            legacyCC.internal.DragonBonesAssembler = simple$1;

            var simpleDragonBoneAssembler = {
              getAssembler: function getAssembler() {
                return simple$1;
              }
            };
            ArmatureDisplay.Assembler = simpleDragonBoneAssembler;

            var ExtensionType;

            (function (ExtensionType) {
              ExtensionType[ExtensionType["FFD"] = 0] = "FFD";
              ExtensionType[ExtensionType["AdjustColor"] = 10] = "AdjustColor";
              ExtensionType[ExtensionType["BevelFilter"] = 11] = "BevelFilter";
              ExtensionType[ExtensionType["BlurFilter"] = 12] = "BlurFilter";
              ExtensionType[ExtensionType["DropShadowFilter"] = 13] = "DropShadowFilter";
              ExtensionType[ExtensionType["GlowFilter"] = 14] = "GlowFilter";
              ExtensionType[ExtensionType["GradientBevelFilter"] = 15] = "GradientBevelFilter";
              ExtensionType[ExtensionType["GradientGlowFilter"] = 16] = "GradientGlowFilter";
            })(ExtensionType || (ExtensionType = {}));

            var EventType$2;

            (function (EventType) {
              EventType[EventType["Frame"] = 0] = "Frame";
              EventType[EventType["Sound"] = 1] = "Sound";
            })(EventType$2 || (EventType$2 = {}));

            var AnimationFadeOutMode;

            (function (AnimationFadeOutMode) {
              AnimationFadeOutMode[AnimationFadeOutMode["None"] = 0] = "None";
              AnimationFadeOutMode[AnimationFadeOutMode["SameLayer"] = 1] = "SameLayer";
              AnimationFadeOutMode[AnimationFadeOutMode["SameGroup"] = 2] = "SameGroup";
              AnimationFadeOutMode[AnimationFadeOutMode["SameLayerAndGroup"] = 3] = "SameLayerAndGroup";
              AnimationFadeOutMode[AnimationFadeOutMode["All"] = 4] = "All";
            })(AnimationFadeOutMode || (AnimationFadeOutMode = {}));

            var index$3 = /*#__PURE__*/Object.freeze({
                __proto__: null,
                get ExtensionType () { return ExtensionType; },
                get EventType () { return EventType$2; },
                get AnimationFadeOutMode () { return AnimationFadeOutMode; },
                CCFactory: CCFactory,
                CCSlot: CCSlot,
                CCTextureAtlasData: CCTextureAtlasData,
                CCTextureData: CCTextureData,
                CCArmatureDisplay: CCArmatureDisplay,
                AnimationCache: AnimationCache,
                ArmatureCache: ArmatureCache,
                DragonBonesAsset: DragonBonesAsset,
                DragonBonesAtlasAsset: DragonBonesAtlasAsset,
                timeScale: timeScale,
                get AnimationCacheMode () { return AnimationCacheMode; },
                DragonBoneSocket: DragonBoneSocket,
                ArmatureDisplay: ArmatureDisplay,
                AttachUtil: AttachUtil,
                simpleDragonBoneAssembler: simpleDragonBoneAssembler,
                DragonBones: DragonBones,
                BaseObject: BaseObject,
                Matrix: Matrix,
                Transform: Transform,
                ColorTransform: ColorTransform,
                Point: Point$1,
                Rectangle: Rectangle,
                UserData: UserData,
                ActionData: ActionData,
                DragonBonesData: DragonBonesData,
                ArmatureData: ArmatureData,
                BoneData: BoneData,
                SurfaceData: SurfaceData,
                SlotData: SlotData,
                ConstraintData: ConstraintData,
                IKConstraintData: IKConstraintData,
                PathConstraintData: PathConstraintData,
                CanvasData: CanvasData,
                SkinData: SkinData,
                VerticesData: VerticesData,
                DisplayData: DisplayData,
                ImageDisplayData: ImageDisplayData,
                ArmatureDisplayData: ArmatureDisplayData,
                MeshDisplayData: MeshDisplayData,
                BoundingBoxDisplayData: BoundingBoxDisplayData,
                PathDisplayData: PathDisplayData,
                WeightData: WeightData,
                BoundingBoxData: BoundingBoxData,
                RectangleBoundingBoxData: RectangleBoundingBoxData,
                EllipseBoundingBoxData: EllipseBoundingBoxData,
                PolygonBoundingBoxData: PolygonBoundingBoxData,
                AnimationData: AnimationData,
                TimelineData: TimelineData,
                AnimationConfig: AnimationConfig,
                TextureAtlasData: TextureAtlasData,
                TextureData: TextureData,
                DeformVertices: DeformVertices,
                Armature: Armature,
                TransformObject: TransformObject,
                Bone: Bone,
                Surface: Surface,
                Slot: Slot,
                Constraint: Constraint,
                IKConstraint: IKConstraint,
                PathConstraint: PathConstraint,
                WorldClock: WorldClock,
                Animation: Animation$1,
                AnimationState: AnimationState$1,
                BonePose: BonePose,
                BlendState: BlendState,
                TimelineState: TimelineState,
                TweenTimelineState: TweenTimelineState,
                BoneTimelineState: BoneTimelineState,
                SlotTimelineState: SlotTimelineState,
                ConstraintTimelineState: ConstraintTimelineState,
                ActionTimelineState: ActionTimelineState,
                ZOrderTimelineState: ZOrderTimelineState,
                BoneAllTimelineState: BoneAllTimelineState,
                BoneTranslateTimelineState: BoneTranslateTimelineState,
                BoneRotateTimelineState: BoneRotateTimelineState,
                BoneScaleTimelineState: BoneScaleTimelineState,
                SurfaceTimelineState: SurfaceTimelineState,
                SlotDislayTimelineState: SlotDislayTimelineState,
                SlotColorTimelineState: SlotColorTimelineState,
                DeformTimelineState: DeformTimelineState,
                IKConstraintTimelineState: IKConstraintTimelineState,
                AnimationTimelineState: AnimationTimelineState,
                EventObject: EventObject,
                DataParser: DataParser,
                ObjectDataParser: ObjectDataParser,
                ActionFrame: ActionFrame,
                BinaryDataParser: BinaryDataParser,
                BaseFactory: BaseFactory,
                BuildArmaturePackage: BuildArmaturePackage,
                BinaryOffset: BinaryOffset,
                ArmatureType: ArmatureType,
                BoneType: BoneType,
                DisplayType: DisplayType,
                BoundingBoxType: BoundingBoxType,
                ActionType: ActionType,
                BlendMode: BlendMode,
                TweenType: TweenType,
                TimelineType: TimelineType
            });
            exports('dragonBones', index$3);

            var WebGLDescriptorSet = function (_DescriptorSet) {
              _inheritsLoose(WebGLDescriptorSet, _DescriptorSet);

              function WebGLDescriptorSet() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _DescriptorSet.call.apply(_DescriptorSet, [this].concat(args)) || this;
                _this._gpuDescriptorSet = null;
                return _this;
              }

              var _proto = WebGLDescriptorSet.prototype;

              _proto.initialize = function initialize(info) {
                this._layout = info.layout;
                var _gpuDescriptorSetLayo = info.layout.gpuDescriptorSetLayout,
                    bindings = _gpuDescriptorSetLayo.bindings,
                    descriptorIndices = _gpuDescriptorSetLayo.descriptorIndices,
                    descriptorCount = _gpuDescriptorSetLayo.descriptorCount;
                this._buffers = Array(descriptorCount).fill(null);
                this._textures = Array(descriptorCount).fill(null);
                this._samplers = Array(descriptorCount).fill(null);
                var gpuDescriptors = [];
                this._gpuDescriptorSet = {
                  gpuDescriptors: gpuDescriptors,
                  descriptorIndices: descriptorIndices
                };

                for (var i = 0; i < bindings.length; ++i) {
                  var binding = bindings[i];

                  for (var j = 0; j < binding.count; j++) {
                    gpuDescriptors.push({
                      type: binding.descriptorType,
                      gpuBuffer: null,
                      gpuTexture: null,
                      gpuSampler: null
                    });
                  }
                }
              };

              _proto.destroy = function destroy() {
                this._layout = null;
                this._gpuDescriptorSet = null;
              };

              _proto.update = function update() {
                if (this._isDirty && this._gpuDescriptorSet) {
                  var descriptors = this._gpuDescriptorSet.gpuDescriptors;

                  for (var i = 0; i < descriptors.length; ++i) {
                    if (descriptors[i].type & DESCRIPTOR_BUFFER_TYPE) {
                      var buffer = this._buffers[i];

                      if (buffer) {
                        descriptors[i].gpuBuffer = buffer.gpuBuffer || buffer.gpuBufferView;
                      }
                    } else if (descriptors[i].type & DESCRIPTOR_SAMPLER_TYPE) {
                      if (this._textures[i]) {
                        descriptors[i].gpuTexture = this._textures[i].gpuTexture;
                      }

                      if (this._samplers[i]) {
                        descriptors[i].gpuSampler = this._samplers[i].gpuSampler;
                      }
                    }
                  }

                  this._isDirty = false;
                }
              };

              _createClass(WebGLDescriptorSet, [{
                key: "gpuDescriptorSet",
                get: function get() {
                  return this._gpuDescriptorSet;
                }
              }]);

              return WebGLDescriptorSet;
            }(DescriptorSet);

            var WebGLEXT;

            (function (WebGLEXT) {
              WebGLEXT[WebGLEXT["RGBA16F_EXT"] = 34842] = "RGBA16F_EXT";
              WebGLEXT[WebGLEXT["RGB16F_EXT"] = 34843] = "RGB16F_EXT";
              WebGLEXT[WebGLEXT["RGBA32F_EXT"] = 34836] = "RGBA32F_EXT";
              WebGLEXT[WebGLEXT["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT";
              WebGLEXT[WebGLEXT["UNSIGNED_NORMALIZED_EXT"] = 35863] = "UNSIGNED_NORMALIZED_EXT";
              WebGLEXT[WebGLEXT["UNSIGNED_INT_24_8_WEBGL"] = 34042] = "UNSIGNED_INT_24_8_WEBGL";
              WebGLEXT[WebGLEXT["HALF_FLOAT_OES"] = 36193] = "HALF_FLOAT_OES";
              WebGLEXT[WebGLEXT["SRGB_EXT"] = 35904] = "SRGB_EXT";
              WebGLEXT[WebGLEXT["SRGB_ALPHA_EXT"] = 35906] = "SRGB_ALPHA_EXT";
              WebGLEXT[WebGLEXT["SRGB8_ALPHA8_EXT"] = 35907] = "SRGB8_ALPHA8_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
              WebGLEXT[WebGLEXT["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
            })(WebGLEXT || (WebGLEXT = {}));

            var WebGLDeviceManager = function () {
              function WebGLDeviceManager() {}

              WebGLDeviceManager.setInstance = function setInstance(instance) {
                WebGLDeviceManager._instance = instance;
              };

              _createClass(WebGLDeviceManager, null, [{
                key: "instance",
                get: function get() {
                  return WebGLDeviceManager._instance;
                }
              }]);

              return WebGLDeviceManager;
            }();
            WebGLDeviceManager._instance = null;

            function GFXFormatToWebGLType(format, gl) {
              switch (format) {
                case Format.R8:
                  return gl.UNSIGNED_BYTE;

                case Format.R8SN:
                  return gl.BYTE;

                case Format.R8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.R8I:
                  return gl.BYTE;

                case Format.R16F:
                  return WebGLEXT.HALF_FLOAT_OES;

                case Format.R16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.R16I:
                  return gl.SHORT;

                case Format.R32F:
                  return gl.FLOAT;

                case Format.R32UI:
                  return gl.UNSIGNED_INT;

                case Format.R32I:
                  return gl.INT;

                case Format.RG8:
                  return gl.UNSIGNED_BYTE;

                case Format.RG8SN:
                  return gl.BYTE;

                case Format.RG8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RG8I:
                  return gl.BYTE;

                case Format.RG16F:
                  return WebGLEXT.HALF_FLOAT_OES;

                case Format.RG16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RG16I:
                  return gl.SHORT;

                case Format.RG32F:
                  return gl.FLOAT;

                case Format.RG32UI:
                  return gl.UNSIGNED_INT;

                case Format.RG32I:
                  return gl.INT;

                case Format.RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.SRGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGB8SN:
                  return gl.BYTE;

                case Format.RGB8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RGB8I:
                  return gl.BYTE;

                case Format.RGB16F:
                  return WebGLEXT.HALF_FLOAT_OES;

                case Format.RGB16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RGB16I:
                  return gl.SHORT;

                case Format.RGB32F:
                  return gl.FLOAT;

                case Format.RGB32UI:
                  return gl.UNSIGNED_INT;

                case Format.RGB32I:
                  return gl.INT;

                case Format.BGRA8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8:
                  return gl.UNSIGNED_BYTE;

                case Format.SRGB8_A8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8SN:
                  return gl.BYTE;

                case Format.RGBA8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8I:
                  return gl.BYTE;

                case Format.RGBA16F:
                  return WebGLEXT.HALF_FLOAT_OES;

                case Format.RGBA16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RGBA16I:
                  return gl.SHORT;

                case Format.RGBA32F:
                  return gl.FLOAT;

                case Format.RGBA32UI:
                  return gl.UNSIGNED_INT;

                case Format.RGBA32I:
                  return gl.INT;

                case Format.R5G6B5:
                  return gl.UNSIGNED_SHORT_5_6_5;

                case Format.R11G11B10F:
                  return gl.FLOAT;

                case Format.RGB5A1:
                  return gl.UNSIGNED_SHORT_5_5_5_1;

                case Format.RGBA4:
                  return gl.UNSIGNED_SHORT_4_4_4_4;

                case Format.RGB10A2:
                  return gl.UNSIGNED_BYTE;

                case Format.RGB10A2UI:
                  return gl.UNSIGNED_INT;

                case Format.RGB9E5:
                  return gl.UNSIGNED_BYTE;

                case Format.DEPTH:
                  return gl.UNSIGNED_INT;

                case Format.DEPTH_STENCIL:
                  return WebGLEXT.UNSIGNED_INT_24_8_WEBGL;

                case Format.BC1:
                  return gl.UNSIGNED_BYTE;

                case Format.BC1_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC2:
                  return gl.UNSIGNED_BYTE;

                case Format.BC2_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC3:
                  return gl.UNSIGNED_BYTE;

                case Format.BC3_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC4:
                  return gl.UNSIGNED_BYTE;

                case Format.BC4_SNORM:
                  return gl.BYTE;

                case Format.BC5:
                  return gl.UNSIGNED_BYTE;

                case Format.BC5_SNORM:
                  return gl.BYTE;

                case Format.BC6H_SF16:
                  return gl.FLOAT;

                case Format.BC6H_UF16:
                  return gl.FLOAT;

                case Format.BC7:
                  return gl.UNSIGNED_BYTE;

                case Format.BC7_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC_RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_SRGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_RGB8_A1:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_SRGB8_A1:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_R11:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_R11SN:
                  return gl.BYTE;

                case Format.EAC_RG11:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_RG11SN:
                  return gl.BYTE;

                case Format.PVRTC_RGB2:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGBA2:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGB4:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGBA4:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC2_2BPP:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC2_4BPP:
                  return gl.UNSIGNED_BYTE;

                case Format.ASTC_RGBA_4X4:
                case Format.ASTC_RGBA_5X4:
                case Format.ASTC_RGBA_5X5:
                case Format.ASTC_RGBA_6X5:
                case Format.ASTC_RGBA_6X6:
                case Format.ASTC_RGBA_8X5:
                case Format.ASTC_RGBA_8X6:
                case Format.ASTC_RGBA_8X8:
                case Format.ASTC_RGBA_10X5:
                case Format.ASTC_RGBA_10X6:
                case Format.ASTC_RGBA_10X8:
                case Format.ASTC_RGBA_10X10:
                case Format.ASTC_RGBA_12X10:
                case Format.ASTC_RGBA_12X12:
                case Format.ASTC_SRGBA_4X4:
                case Format.ASTC_SRGBA_5X4:
                case Format.ASTC_SRGBA_5X5:
                case Format.ASTC_SRGBA_6X5:
                case Format.ASTC_SRGBA_6X6:
                case Format.ASTC_SRGBA_8X5:
                case Format.ASTC_SRGBA_8X6:
                case Format.ASTC_SRGBA_8X8:
                case Format.ASTC_SRGBA_10X5:
                case Format.ASTC_SRGBA_10X6:
                case Format.ASTC_SRGBA_10X8:
                case Format.ASTC_SRGBA_10X10:
                case Format.ASTC_SRGBA_12X10:
                case Format.ASTC_SRGBA_12X12:
                  return gl.UNSIGNED_BYTE;

                default:
                  {
                    return gl.UNSIGNED_BYTE;
                  }
              }
            }
            function GFXFormatToWebGLInternalFormat(format, gl) {
              switch (format) {
                case Format.R5G6B5:
                  return gl.RGB565;

                case Format.RGB5A1:
                  return gl.RGB5_A1;

                case Format.RGBA4:
                  return gl.RGBA4;

                case Format.RGBA16F:
                  return WebGLEXT.RGBA16F_EXT;

                case Format.RGBA32F:
                  return WebGLEXT.RGBA32F_EXT;

                case Format.SRGB8_A8:
                  return WebGLEXT.SRGB8_ALPHA8_EXT;

                case Format.DEPTH:
                  return gl.DEPTH_COMPONENT16;

                case Format.DEPTH_STENCIL:
                  return gl.DEPTH_STENCIL;

                default:
                  {
                    console.error('Unsupported Format, convert to WebGL internal format failed.');
                    return gl.RGBA;
                  }
              }
            }
            function GFXFormatToWebGLFormat(format, gl) {
              switch (format) {
                case Format.A8:
                  return gl.ALPHA;

                case Format.L8:
                  return gl.LUMINANCE;

                case Format.LA8:
                  return gl.LUMINANCE_ALPHA;

                case Format.RGB8:
                  return gl.RGB;

                case Format.RGB16F:
                  return gl.RGB;

                case Format.RGB32F:
                  return gl.RGB;

                case Format.BGRA8:
                  return gl.RGBA;

                case Format.RGBA8:
                  return gl.RGBA;

                case Format.SRGB8_A8:
                  return gl.RGBA;

                case Format.RGBA16F:
                  return gl.RGBA;

                case Format.RGBA32F:
                  return gl.RGBA;

                case Format.R5G6B5:
                  return gl.RGB;

                case Format.RGB5A1:
                  return gl.RGBA;

                case Format.RGBA4:
                  return gl.RGBA;

                case Format.DEPTH:
                  return gl.DEPTH_COMPONENT;

                case Format.DEPTH_STENCIL:
                  return gl.DEPTH_STENCIL;

                case Format.BC1:
                  return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

                case Format.BC1_ALPHA:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

                case Format.BC1_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

                case Format.BC1_SRGB_ALPHA:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

                case Format.BC2:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

                case Format.BC2_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

                case Format.BC3:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                case Format.BC3_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

                case Format.ETC_RGB8:
                  return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

                case Format.ETC2_RGB8:
                  return WebGLEXT.COMPRESSED_RGB8_ETC2;

                case Format.ETC2_SRGB8:
                  return WebGLEXT.COMPRESSED_SRGB8_ETC2;

                case Format.ETC2_RGB8_A1:
                  return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_SRGB8_A1:
                  return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_RGBA8:
                  return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

                case Format.ETC2_SRGB8_A8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

                case Format.EAC_R11:
                  return WebGLEXT.COMPRESSED_R11_EAC;

                case Format.EAC_R11SN:
                  return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

                case Format.EAC_RG11:
                  return WebGLEXT.COMPRESSED_RG11_EAC;

                case Format.EAC_RG11SN:
                  return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

                case Format.PVRTC_RGB2:
                  return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGBA2:
                  return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGB4:
                  return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

                case Format.PVRTC_RGBA4:
                  return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                case Format.ASTC_RGBA_4X4:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_4x4_KHR;

                case Format.ASTC_RGBA_5X4:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_5x4_KHR;

                case Format.ASTC_RGBA_5X5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_5x5_KHR;

                case Format.ASTC_RGBA_6X5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_6x5_KHR;

                case Format.ASTC_RGBA_6X6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_6x6_KHR;

                case Format.ASTC_RGBA_8X5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x5_KHR;

                case Format.ASTC_RGBA_8X6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x6_KHR;

                case Format.ASTC_RGBA_8X8:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x8_KHR;

                case Format.ASTC_RGBA_10X5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x5_KHR;

                case Format.ASTC_RGBA_10X6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x6_KHR;

                case Format.ASTC_RGBA_10X8:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x8_KHR;

                case Format.ASTC_RGBA_10X10:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x10_KHR;

                case Format.ASTC_RGBA_12X10:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_12x10_KHR;

                case Format.ASTC_RGBA_12X12:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_12x12_KHR;

                case Format.ASTC_SRGBA_4X4:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

                case Format.ASTC_SRGBA_5X4:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

                case Format.ASTC_SRGBA_5X5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

                case Format.ASTC_SRGBA_6X5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

                case Format.ASTC_SRGBA_6X6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

                case Format.ASTC_SRGBA_8X5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

                case Format.ASTC_SRGBA_8X6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

                case Format.ASTC_SRGBA_8X8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

                case Format.ASTC_SRGBA_10X5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

                case Format.ASTC_SRGBA_10X6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

                case Format.ASTC_SRGBA_10X8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

                case Format.ASTC_SRGBA_10X10:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

                case Format.ASTC_SRGBA_12X10:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

                case Format.ASTC_SRGBA_12X12:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

                default:
                  {
                    console.error('Unsupported Format, convert to WebGL format failed.');
                    return gl.RGBA;
                  }
              }
            }

            function GFXTypeToWebGLType(type, gl) {
              switch (type) {
                case Type$1.BOOL:
                  return gl.BOOL;

                case Type$1.BOOL2:
                  return gl.BOOL_VEC2;

                case Type$1.BOOL3:
                  return gl.BOOL_VEC3;

                case Type$1.BOOL4:
                  return gl.BOOL_VEC4;

                case Type$1.INT:
                  return gl.INT;

                case Type$1.INT2:
                  return gl.INT_VEC2;

                case Type$1.INT3:
                  return gl.INT_VEC3;

                case Type$1.INT4:
                  return gl.INT_VEC4;

                case Type$1.UINT:
                  return gl.UNSIGNED_INT;

                case Type$1.FLOAT:
                  return gl.FLOAT;

                case Type$1.FLOAT2:
                  return gl.FLOAT_VEC2;

                case Type$1.FLOAT3:
                  return gl.FLOAT_VEC3;

                case Type$1.FLOAT4:
                  return gl.FLOAT_VEC4;

                case Type$1.MAT2:
                  return gl.FLOAT_MAT2;

                case Type$1.MAT3:
                  return gl.FLOAT_MAT3;

                case Type$1.MAT4:
                  return gl.FLOAT_MAT4;

                case Type$1.SAMPLER2D:
                  return gl.SAMPLER_2D;

                case Type$1.SAMPLER_CUBE:
                  return gl.SAMPLER_CUBE;

                default:
                  {
                    console.error('Unsupported GLType, convert to GL type failed.');
                    return Type$1.UNKNOWN;
                  }
              }
            }

            function GFXTypeToTypedArrayCtor(type) {
              switch (type) {
                case Type$1.BOOL:
                case Type$1.BOOL2:
                case Type$1.BOOL3:
                case Type$1.BOOL4:
                case Type$1.INT:
                case Type$1.INT2:
                case Type$1.INT3:
                case Type$1.INT4:
                case Type$1.UINT:
                  return Int32Array;

                case Type$1.FLOAT:
                case Type$1.FLOAT2:
                case Type$1.FLOAT3:
                case Type$1.FLOAT4:
                case Type$1.MAT2:
                case Type$1.MAT3:
                case Type$1.MAT4:
                  return Float32Array;

                default:
                  {
                    console.error('Unsupported GLType, convert to TypedArrayConstructor failed.');
                    return Float32Array;
                  }
              }
            }

            function WebGLTypeToGFXType(glType, gl) {
              switch (glType) {
                case gl.BOOL:
                  return Type$1.BOOL;

                case gl.BOOL_VEC2:
                  return Type$1.BOOL2;

                case gl.BOOL_VEC3:
                  return Type$1.BOOL3;

                case gl.BOOL_VEC4:
                  return Type$1.BOOL4;

                case gl.INT:
                  return Type$1.INT;

                case gl.INT_VEC2:
                  return Type$1.INT2;

                case gl.INT_VEC3:
                  return Type$1.INT3;

                case gl.INT_VEC4:
                  return Type$1.INT4;

                case gl.UNSIGNED_INT:
                  return Type$1.UINT;

                case gl.FLOAT:
                  return Type$1.FLOAT;

                case gl.FLOAT_VEC2:
                  return Type$1.FLOAT2;

                case gl.FLOAT_VEC3:
                  return Type$1.FLOAT3;

                case gl.FLOAT_VEC4:
                  return Type$1.FLOAT4;

                case gl.FLOAT_MAT2:
                  return Type$1.MAT2;

                case gl.FLOAT_MAT3:
                  return Type$1.MAT3;

                case gl.FLOAT_MAT4:
                  return Type$1.MAT4;

                case gl.SAMPLER_2D:
                  return Type$1.SAMPLER2D;

                case gl.SAMPLER_CUBE:
                  return Type$1.SAMPLER_CUBE;

                default:
                  {
                    console.error('Unsupported GLType, convert to Type failed.');
                    return Type$1.UNKNOWN;
                  }
              }
            }

            function WebGLGetTypeSize(glType, gl) {
              switch (glType) {
                case gl.BOOL:
                  return 4;

                case gl.BOOL_VEC2:
                  return 8;

                case gl.BOOL_VEC3:
                  return 12;

                case gl.BOOL_VEC4:
                  return 16;

                case gl.INT:
                  return 4;

                case gl.INT_VEC2:
                  return 8;

                case gl.INT_VEC3:
                  return 12;

                case gl.INT_VEC4:
                  return 16;

                case gl.UNSIGNED_INT:
                  return 4;

                case gl.FLOAT:
                  return 4;

                case gl.FLOAT_VEC2:
                  return 8;

                case gl.FLOAT_VEC3:
                  return 12;

                case gl.FLOAT_VEC4:
                  return 16;

                case gl.FLOAT_MAT2:
                  return 16;

                case gl.FLOAT_MAT3:
                  return 36;

                case gl.FLOAT_MAT4:
                  return 64;

                case gl.SAMPLER_2D:
                  return 4;

                case gl.SAMPLER_CUBE:
                  return 4;

                default:
                  {
                    console.error('Unsupported GLType, get type failed.');
                    return 0;
                  }
              }
            }

            function WebGLGetComponentCount(glType, gl) {
              switch (glType) {
                case gl.FLOAT_MAT2:
                  return 2;

                case gl.FLOAT_MAT3:
                  return 3;

                case gl.FLOAT_MAT4:
                  return 4;

                default:
                  {
                    return 1;
                  }
              }
            }

            var WebGLCmpFuncs = [0x0200, 0x0201, 0x0202, 0x0203, 0x0204, 0x0205, 0x0206, 0x0207];
            var WebGLStencilOps = [0x0000, 0x1E00, 0x1E01, 0x1E02, 0x1E03, 0x150A, 0x8507, 0x8508];
            var WebGLBlendOps = [0x8006, 0x800A, 0x800B, 0x8007, 0x8008];
            var WebGLBlendFactors = [0x0000, 0x0001, 0x0302, 0x0304, 0x0303, 0x0305, 0x0300, 0x0306, 0x0301, 0x0307, 0x0308, 0x8001, 0x8002, 0x8003, 0x8004];
            var WebGLCmd;

            (function (WebGLCmd) {
              WebGLCmd[WebGLCmd["BEGIN_RENDER_PASS"] = 0] = "BEGIN_RENDER_PASS";
              WebGLCmd[WebGLCmd["END_RENDER_PASS"] = 1] = "END_RENDER_PASS";
              WebGLCmd[WebGLCmd["BIND_STATES"] = 2] = "BIND_STATES";
              WebGLCmd[WebGLCmd["DRAW"] = 3] = "DRAW";
              WebGLCmd[WebGLCmd["UPDATE_BUFFER"] = 4] = "UPDATE_BUFFER";
              WebGLCmd[WebGLCmd["COPY_BUFFER_TO_TEXTURE"] = 5] = "COPY_BUFFER_TO_TEXTURE";
              WebGLCmd[WebGLCmd["BLIT_TEXTURE"] = 6] = "BLIT_TEXTURE";
              WebGLCmd[WebGLCmd["COUNT"] = 7] = "COUNT";
            })(WebGLCmd || (WebGLCmd = {}));

            var WebGLCmdObject = function WebGLCmdObject(type) {
              this.cmdType = void 0;
              this.refCount = 0;
              this.cmdType = type;
            };
            var WebGLCmdBeginRenderPass = function (_WebGLCmdObject) {
              _inheritsLoose(WebGLCmdBeginRenderPass, _WebGLCmdObject);

              function WebGLCmdBeginRenderPass() {
                var _this;

                _this = _WebGLCmdObject.call(this, WebGLCmd.BEGIN_RENDER_PASS) || this;
                _this.gpuRenderPass = null;
                _this.gpuFramebuffer = null;
                _this.renderArea = new Rect();
                _this.clearFlag = ClearFlagBit.NONE;
                _this.clearColors = [];
                _this.clearDepth = 1.0;
                _this.clearStencil = 0;
                return _this;
              }

              var _proto = WebGLCmdBeginRenderPass.prototype;

              _proto.clear = function clear() {
                this.gpuFramebuffer = null;
                this.clearColors.length = 0;
              };

              return WebGLCmdBeginRenderPass;
            }(WebGLCmdObject);
            var WebGLCmdBindStates = function (_WebGLCmdObject2) {
              _inheritsLoose(WebGLCmdBindStates, _WebGLCmdObject2);

              function WebGLCmdBindStates() {
                var _this2;

                _this2 = _WebGLCmdObject2.call(this, WebGLCmd.BIND_STATES) || this;
                _this2.gpuPipelineState = null;
                _this2.gpuInputAssembler = null;
                _this2.gpuDescriptorSets = [];
                _this2.dynamicOffsets = [];
                _this2.dynamicStates = new DynamicStates();
                return _this2;
              }

              var _proto2 = WebGLCmdBindStates.prototype;

              _proto2.clear = function clear() {
                this.gpuPipelineState = null;
                this.gpuDescriptorSets.length = 0;
                this.gpuInputAssembler = null;
                this.dynamicOffsets.length = 0;
              };

              return WebGLCmdBindStates;
            }(WebGLCmdObject);
            var WebGLCmdDraw = function (_WebGLCmdObject3) {
              _inheritsLoose(WebGLCmdDraw, _WebGLCmdObject3);

              function WebGLCmdDraw() {
                var _this3;

                _this3 = _WebGLCmdObject3.call(this, WebGLCmd.DRAW) || this;
                _this3.drawInfo = new DrawInfo();
                return _this3;
              }

              var _proto3 = WebGLCmdDraw.prototype;

              _proto3.clear = function clear() {};

              return WebGLCmdDraw;
            }(WebGLCmdObject);
            var WebGLCmdUpdateBuffer = function (_WebGLCmdObject4) {
              _inheritsLoose(WebGLCmdUpdateBuffer, _WebGLCmdObject4);

              function WebGLCmdUpdateBuffer() {
                var _this4;

                _this4 = _WebGLCmdObject4.call(this, WebGLCmd.UPDATE_BUFFER) || this;
                _this4.gpuBuffer = null;
                _this4.buffer = null;
                _this4.offset = 0;
                _this4.size = 0;
                return _this4;
              }

              var _proto4 = WebGLCmdUpdateBuffer.prototype;

              _proto4.clear = function clear() {
                this.gpuBuffer = null;
                this.buffer = null;
              };

              return WebGLCmdUpdateBuffer;
            }(WebGLCmdObject);
            var WebGLCmdCopyBufferToTexture = function (_WebGLCmdObject5) {
              _inheritsLoose(WebGLCmdCopyBufferToTexture, _WebGLCmdObject5);

              function WebGLCmdCopyBufferToTexture() {
                var _this5;

                _this5 = _WebGLCmdObject5.call(this, WebGLCmd.COPY_BUFFER_TO_TEXTURE) || this;
                _this5.gpuTexture = null;
                _this5.buffers = [];
                _this5.regions = [];
                return _this5;
              }

              var _proto5 = WebGLCmdCopyBufferToTexture.prototype;

              _proto5.clear = function clear() {
                this.gpuTexture = null;
                this.buffers.length = 0;
                this.regions.length = 0;
              };

              return WebGLCmdCopyBufferToTexture;
            }(WebGLCmdObject);
            var WebGLCmdBlitTexture = function (_WebGLCmdObject6) {
              _inheritsLoose(WebGLCmdBlitTexture, _WebGLCmdObject6);

              function WebGLCmdBlitTexture() {
                var _this6;

                _this6 = _WebGLCmdObject6.call(this, WebGLCmd.BLIT_TEXTURE) || this;
                _this6.srcTexture = null;
                _this6.dstTexture = null;
                _this6.regions = [];
                _this6.filter = Filter.LINEAR;
                return _this6;
              }

              var _proto6 = WebGLCmdBlitTexture.prototype;

              _proto6.clear = function clear() {
                this.srcTexture = null;
                this.dstTexture = null;
                this.regions.length = 0;
              };

              return WebGLCmdBlitTexture;
            }(WebGLCmdObject);
            var WebGLCmdPackage = function () {
              function WebGLCmdPackage() {
                this.cmds = new CachedArray(1);
                this.beginRenderPassCmds = new CachedArray(1);
                this.bindStatesCmds = new CachedArray(1);
                this.drawCmds = new CachedArray(1);
                this.updateBufferCmds = new CachedArray(1);
                this.copyBufferToTextureCmds = new CachedArray(1);
                this.blitTextureCmds = new CachedArray(1);
              }

              var _proto7 = WebGLCmdPackage.prototype;

              _proto7.clearCmds = function clearCmds(allocator) {
                if (this.beginRenderPassCmds.length) {
                  allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds);
                  this.beginRenderPassCmds.clear();
                }

                if (this.bindStatesCmds.length) {
                  allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds);
                  this.bindStatesCmds.clear();
                }

                if (this.drawCmds.length) {
                  allocator.drawCmdPool.freeCmds(this.drawCmds);
                  this.drawCmds.clear();
                }

                if (this.updateBufferCmds.length) {
                  allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds);
                  this.updateBufferCmds.clear();
                }

                if (this.copyBufferToTextureCmds.length) {
                  allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds);
                  this.copyBufferToTextureCmds.clear();
                }

                if (this.blitTextureCmds.length) {
                  allocator.blitTextureCmdPool.freeCmds(this.blitTextureCmds);
                  this.blitTextureCmds.clear();
                }

                this.cmds.clear();
              };

              return WebGLCmdPackage;
            }();
            function WebGLCmdFuncCreateBuffer(device, gpuBuffer) {
              var gl = device.gl;
              var cache = device.stateCache;
              var glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

              if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
                gpuBuffer.glTarget = gl.ARRAY_BUFFER;
                var glBuffer = gl.createBuffer();

                if (glBuffer) {
                  gpuBuffer.glBuffer = glBuffer;

                  if (gpuBuffer.size > 0) {
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                        cache.glVAO = null;
                      }
                    }

                    gfxStateCache.gpuInputAssembler = null;

                    if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                      device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
                    }

                    gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    device.stateCache.glArrayBuffer = null;
                  }
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
                gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;

                var _glBuffer = gl.createBuffer();

                if (_glBuffer) {
                  gpuBuffer.glBuffer = _glBuffer;

                  if (gpuBuffer.size > 0) {
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                        cache.glVAO = null;
                      }
                    }

                    gfxStateCache.gpuInputAssembler = null;

                    if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                      device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
                    }

                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    device.stateCache.glElementArrayBuffer = null;
                  }
                }
              } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
                gpuBuffer.glTarget = gl.NONE;

                if (gpuBuffer.buffer) {
                  gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer);
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
                gpuBuffer.glTarget = gl.NONE;
              } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_DST) {
                gpuBuffer.glTarget = gl.NONE;
              } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
                gpuBuffer.glTarget = gl.NONE;
              } else {
                console.error('Unsupported BufferType, create buffer failed.');
                gpuBuffer.glTarget = gl.NONE;
              }
            }
            function WebGLCmdFuncDestroyBuffer(device, gpuBuffer) {
              var gl = device.gl;
              var cache = device.stateCache;

              if (gpuBuffer.glBuffer) {
                switch (gpuBuffer.glTarget) {
                  case gl.ARRAY_BUFFER:
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                        device.stateCache.glVAO = null;
                      }
                    }

                    gfxStateCache.gpuInputAssembler = null;
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    device.stateCache.glArrayBuffer = null;
                    break;

                  case gl.ELEMENT_ARRAY_BUFFER:
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                        device.stateCache.glVAO = null;
                      }
                    }

                    gfxStateCache.gpuInputAssembler = null;
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    device.stateCache.glElementArrayBuffer = null;
                    break;
                }

                gl.deleteBuffer(gpuBuffer.glBuffer);
                gpuBuffer.glBuffer = null;
              }
            }
            function WebGLCmdFuncResizeBuffer(device, gpuBuffer) {
              var gl = device.gl;
              var cache = device.stateCache;
              var glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

              if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                    cache.glVAO = null;
                  }
                }

                gfxStateCache.gpuInputAssembler = null;

                if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                }

                if (gpuBuffer.buffer) {
                  gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
                } else {
                  gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                device.stateCache.glArrayBuffer = null;
              } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                    cache.glVAO = null;
                  }
                }

                gfxStateCache.gpuInputAssembler = null;

                if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                }

                if (gpuBuffer.buffer) {
                  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
                } else {
                  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
                }

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                device.stateCache.glElementArrayBuffer = null;
              } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
                if (gpuBuffer.buffer) {
                  gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer);
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT || gpuBuffer.usage & BufferUsageBit.TRANSFER_DST || gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
                gpuBuffer.glTarget = gl.NONE;
              } else {
                console.error('Unsupported BufferType, create buffer failed.');
                gpuBuffer.glTarget = gl.NONE;
              }
            }
            function WebGLCmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
              if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
                if (ArrayBuffer.isView(buffer)) {
                  gpuBuffer.vf32.set(buffer, offset / Float32Array.BYTES_PER_ELEMENT);
                } else {
                  gpuBuffer.vf32.set(new Float32Array(buffer), offset / Float32Array.BYTES_PER_ELEMENT);
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
                gpuBuffer.indirects.clearDraws();
                var drawInfos = buffer.drawInfos;

                for (var i = 0; i < drawInfos.length; ++i) {
                  gpuBuffer.indirects.setDrawInfo(offset + i, drawInfos[i]);
                }
              } else {
                var buff = buffer;
                var gl = device.gl;
                var cache = device.stateCache;

                switch (gpuBuffer.glTarget) {
                  case gl.ARRAY_BUFFER:
                    {
                      if (device.extensions.useVAO) {
                        if (cache.glVAO) {
                          device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                          cache.glVAO = null;
                        }
                      }

                      gfxStateCache.gpuInputAssembler = null;

                      if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                        device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
                      }

                      break;
                    }

                  case gl.ELEMENT_ARRAY_BUFFER:
                    {
                      if (device.extensions.useVAO) {
                        if (cache.glVAO) {
                          device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                          cache.glVAO = null;
                        }
                      }

                      gfxStateCache.gpuInputAssembler = null;

                      if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                        device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
                      }

                      break;
                    }

                  default:
                    {
                      console.error('Unsupported BufferType, update buffer failed.');
                      return;
                    }
                }

                if (size === buff.byteLength) {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                } else {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                }
              }
            }
            function WebGLCmdFuncCreateTexture(device, gpuTexture) {
              var gl = device.gl;
              gpuTexture.glFormat = gpuTexture.glInternalFmt = GFXFormatToWebGLFormat(gpuTexture.format, gl);
              gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format, gl);
              var w = gpuTexture.width;
              var h = gpuTexture.height;

              switch (gpuTexture.type) {
                case TextureType.TEX2D:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                    var maxSize = Math.max(w, h);

                    if (maxSize > device.capabilities.maxTextureSize) {
                      errorID(9100, maxSize, device.capabilities.maxTextureSize);
                    }

                    if (!device.textureExclusive[gpuTexture.format] && !device.extensions.WEBGL_depth_texture && FormatInfos[gpuTexture.format].hasDepth) {
                      gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format, gl);
                      gpuTexture.glRenderbuffer = gl.createRenderbuffer();

                      if (gpuTexture.size > 0) {
                        if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                          gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                          device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                        }

                        gl.renderbufferStorage(gl.RENDERBUFFER, gpuTexture.glInternalFmt, w, h);
                      }
                    } else {
                      gpuTexture.glTexture = gl.createTexture();

                      if (gpuTexture.size > 0) {
                        var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                          gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                          glTexUnit.glTexture = gpuTexture.glTexture;
                        }

                        if (FormatInfos[gpuTexture.format].isCompressed) {
                          for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                            var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                            var view = new Uint8Array(imgSize);
                            gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                            w = Math.max(1, w >> 1);
                            h = Math.max(1, h >> 1);
                          }
                        } else {
                          for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                            gl.texImage2D(gl.TEXTURE_2D, _i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                            w = Math.max(1, w >> 1);
                            h = Math.max(1, h >> 1);
                          }
                        }

                        if (gpuTexture.isPowerOf2) {
                          gpuTexture.glWrapS = gl.REPEAT;
                          gpuTexture.glWrapT = gl.REPEAT;
                        } else {
                          gpuTexture.glWrapS = gl.CLAMP_TO_EDGE;
                          gpuTexture.glWrapT = gl.CLAMP_TO_EDGE;
                        }

                        gpuTexture.glMinFilter = gl.LINEAR;
                        gpuTexture.glMagFilter = gl.LINEAR;
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS);
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT);
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter);
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                      }
                    }

                    break;
                  }

                case TextureType.CUBE:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;

                    var _maxSize = Math.max(w, h);

                    if (_maxSize > device.capabilities.maxCubeMapTextureSize) {
                      errorID(9100, _maxSize, device.capabilities.maxTextureSize);
                    }

                    gpuTexture.glTexture = gl.createTexture();

                    if (gpuTexture.size > 0) {
                      var _glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                      if (_glTexUnit.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                        _glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (var f = 0; f < 6; ++f) {
                          w = gpuTexture.width;
                          h = gpuTexture.height;

                          for (var _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) {
                            var _imgSize = FormatSize(gpuTexture.format, w, h, 1);

                            var _view = new Uint8Array(_imgSize);

                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i2, gpuTexture.glInternalFmt, w, h, 0, _view);
                            w = Math.max(1, w >> 1);
                            h = Math.max(1, h >> 1);
                          }
                        }
                      } else {
                        for (var _f = 0; _f < 6; ++_f) {
                          w = gpuTexture.width;
                          h = gpuTexture.height;

                          for (var _i3 = 0; _i3 < gpuTexture.mipLevel; ++_i3) {
                            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f, _i3, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                            w = Math.max(1, w >> 1);
                            h = Math.max(1, h >> 1);
                          }
                        }
                      }

                      if (gpuTexture.isPowerOf2) {
                        gpuTexture.glWrapS = gl.REPEAT;
                        gpuTexture.glWrapT = gl.REPEAT;
                      } else {
                        gpuTexture.glWrapS = gl.CLAMP_TO_EDGE;
                        gpuTexture.glWrapT = gl.CLAMP_TO_EDGE;
                      }

                      gpuTexture.glMinFilter = gl.LINEAR;
                      gpuTexture.glMagFilter = gl.LINEAR;
                      gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS);
                      gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT);
                      gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter);
                      gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported TextureType, create texture failed.');
                    gpuTexture.type = TextureType.TEX2D;
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                  }
              }
            }
            function WebGLCmdFuncDestroyTexture(device, gpuTexture) {
              var gl = device.gl;

              if (gpuTexture.glTexture) {
                var glTexUnits = device.stateCache.glTexUnits;
                var texUnit = device.stateCache.texUnit;
                gl.deleteTexture(gpuTexture.glTexture);

                for (var i = 0; i < glTexUnits.length; i++) {
                  if (glTexUnits[i].glTexture === gpuTexture.glTexture) {
                    gl.activeTexture(gl.TEXTURE0 + i);
                    texUnit = i;
                    gl.bindTexture(gpuTexture.glTarget, null);
                    glTexUnits[i].glTexture = null;
                  }
                }

                device.stateCache.texUnit = texUnit;
                gpuTexture.glTexture = null;
              }

              if (gpuTexture.glRenderbuffer) {
                var glRenderbuffer = device.stateCache.glRenderbuffer;
                gl.deleteRenderbuffer(gpuTexture.glRenderbuffer);

                if (glRenderbuffer === gpuTexture.glRenderbuffer) {
                  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                  glRenderbuffer = null;
                }

                gpuTexture.glRenderbuffer = null;
              }
            }
            function WebGLCmdFuncResizeTexture(device, gpuTexture) {
              if (!gpuTexture.size) return;
              var gl = device.gl;
              var w = gpuTexture.width;
              var h = gpuTexture.height;

              switch (gpuTexture.type) {
                case TextureType.TEX2D:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                    var maxSize = Math.max(w, h);

                    if (maxSize > device.capabilities.maxTextureSize) {
                      errorID(9100, maxSize, device.capabilities.maxTextureSize);
                    }

                    if (gpuTexture.glRenderbuffer) {
                      if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                        gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                        device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                      }

                      gl.renderbufferStorage(gl.RENDERBUFFER, gpuTexture.glInternalFmt, w, h);
                    } else if (gpuTexture.glTexture) {
                      var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                          var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                          var view = new Uint8Array(imgSize);
                          gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      } else {
                        for (var _i4 = 0; _i4 < gpuTexture.mipLevel; ++_i4) {
                          gl.texImage2D(gl.TEXTURE_2D, _i4, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      }
                    }

                    break;
                  }

                case TextureType.CUBE:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;

                    var _maxSize2 = Math.max(w, h);

                    if (_maxSize2 > device.capabilities.maxCubeMapTextureSize) {
                      errorID(9100, _maxSize2, device.capabilities.maxTextureSize);
                    }

                    var _glTexUnit2 = device.stateCache.glTexUnits[device.stateCache.texUnit];

                    if (_glTexUnit2.glTexture !== gpuTexture.glTexture) {
                      gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                      _glTexUnit2.glTexture = gpuTexture.glTexture;
                    }

                    if (FormatInfos[gpuTexture.format].isCompressed) {
                      for (var f = 0; f < 6; ++f) {
                        w = gpuTexture.width;
                        h = gpuTexture.height;

                        for (var _i5 = 0; _i5 < gpuTexture.mipLevel; ++_i5) {
                          var _imgSize2 = FormatSize(gpuTexture.format, w, h, 1);

                          var _view2 = new Uint8Array(_imgSize2);

                          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i5, gpuTexture.glInternalFmt, w, h, 0, _view2);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      }
                    } else {
                      for (var _f2 = 0; _f2 < 6; ++_f2) {
                        w = gpuTexture.width;
                        h = gpuTexture.height;

                        for (var _i6 = 0; _i6 < gpuTexture.mipLevel; ++_i6) {
                          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f2, _i6, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported TextureType, create texture failed.');
                    gpuTexture.type = TextureType.TEX2D;
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                  }
              }
            }
            function WebGLCmdFuncCreateFramebuffer(device, gpuFramebuffer) {
              for (var i = 0; i < gpuFramebuffer.gpuColorTextures.length; ++i) {
                var tex = gpuFramebuffer.gpuColorTextures[i];

                if (tex.isSwapchainTexture) {
                  gpuFramebuffer.isOffscreen = false;
                  return;
                }
              }

              var gl = device.gl;
              var attachments = [];
              var glFramebuffer = gl.createFramebuffer();

              if (glFramebuffer) {
                gpuFramebuffer.glFramebuffer = glFramebuffer;

                if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
                }

                for (var _i7 = 0; _i7 < gpuFramebuffer.gpuColorTextures.length; ++_i7) {
                  var gpuTexture = gpuFramebuffer.gpuColorTextures[_i7];

                  if (gpuTexture) {
                    if (gpuTexture.glTexture) {
                      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i7, gpuTexture.glTarget, gpuTexture.glTexture, 0);
                    } else {
                      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i7, gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                    }

                    attachments.push(gl.COLOR_ATTACHMENT0 + _i7);
                    gpuFramebuffer.width = Math.min(gpuFramebuffer.width, gpuTexture.width);
                    gpuFramebuffer.height = Math.min(gpuFramebuffer.height, gpuTexture.height);
                  }
                }

                var dst = gpuFramebuffer.gpuDepthStencilTexture;

                if (dst) {
                  var glAttachment = FormatInfos[dst.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;

                  if (dst.glTexture) {
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dst.glTarget, dst.glTexture, 0);
                  } else {
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dst.glRenderbuffer);
                  }

                  gpuFramebuffer.width = Math.min(gpuFramebuffer.width, dst.width);
                  gpuFramebuffer.height = Math.min(gpuFramebuffer.height, dst.height);
                }

                if (device.extensions.WEBGL_draw_buffers) {
                  device.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(attachments);
                }

                var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

                if (status !== gl.FRAMEBUFFER_COMPLETE) {
                  switch (status) {
                    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT');
                        break;
                      }

                    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT');
                        break;
                      }

                    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS');
                        break;
                      }

                    case gl.FRAMEBUFFER_UNSUPPORTED:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED');
                        break;
                      }
                  }
                }

                if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, device.stateCache.glFramebuffer);
                }
              }
            }
            function WebGLCmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
              if (gpuFramebuffer.glFramebuffer) {
                device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer);

                if (device.stateCache.glFramebuffer === gpuFramebuffer.glFramebuffer) {
                  device.gl.bindFramebuffer(device.gl.FRAMEBUFFER, null);
                  device.stateCache.glFramebuffer = null;
                }

                gpuFramebuffer.glFramebuffer = null;
              }
            }
            function WebGLCmdFuncCreateShader(device, gpuShader) {
              var gl = device.gl;

              var _loop = function _loop(k) {
                var gpuStage = gpuShader.gpuStages[k];
                var glShaderType = 0;
                var shaderTypeStr = '';
                var lineNumber = 1;

                switch (gpuStage.type) {
                  case ShaderStageFlagBit.VERTEX:
                    {
                      shaderTypeStr = 'VertexShader';
                      glShaderType = gl.VERTEX_SHADER;
                      break;
                    }

                  case ShaderStageFlagBit.FRAGMENT:
                    {
                      shaderTypeStr = 'FragmentShader';
                      glShaderType = gl.FRAGMENT_SHADER;
                      break;
                    }

                  default:
                    {
                      console.error('Unsupported ShaderType.');
                      return {
                        v: void 0
                      };
                    }
                }

                var glShader = gl.createShader(glShaderType);

                if (glShader) {
                  gpuStage.glShader = glShader;
                  gl.shaderSource(gpuStage.glShader, gpuStage.source);
                  gl.compileShader(gpuStage.glShader);

                  if (!gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS)) {
                    console.error(shaderTypeStr + " in '" + gpuShader.name + "' compilation failed.");
                    console.error('Shader source dump:', gpuStage.source.replace(/^|\n/g, function () {
                      return "\n" + lineNumber++ + " ";
                    }));
                    console.error(gl.getShaderInfoLog(gpuStage.glShader));

                    for (var l = 0; l < gpuShader.gpuStages.length; l++) {
                      var stage = gpuShader.gpuStages[k];

                      if (stage.glShader) {
                        gl.deleteShader(stage.glShader);
                        stage.glShader = null;
                      }
                    }

                    return {
                      v: void 0
                    };
                  }
                }
              };

              for (var k = 0; k < gpuShader.gpuStages.length; k++) {
                var _ret = _loop(k);

                if (typeof _ret === "object") return _ret.v;
              }

              var glProgram = gl.createProgram();

              if (!glProgram) {
                return;
              }

              gpuShader.glProgram = glProgram;

              for (var _k = 0; _k < gpuShader.gpuStages.length; _k++) {
                var gpuStage = gpuShader.gpuStages[_k];
                gl.attachShader(gpuShader.glProgram, gpuStage.glShader);
              }

              gl.linkProgram(gpuShader.glProgram);

              if (device.extensions.destroyShadersImmediately) {
                for (var _k2 = 0; _k2 < gpuShader.gpuStages.length; _k2++) {
                  var _gpuStage = gpuShader.gpuStages[_k2];

                  if (_gpuStage.glShader) {
                    gl.detachShader(gpuShader.glProgram, _gpuStage.glShader);
                    gl.deleteShader(_gpuStage.glShader);
                    _gpuStage.glShader = null;
                  }
                }
              }

              if (gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) {
                debug("Shader '" + gpuShader.name + "' compilation succeeded.");
              } else {
                console.error("Failed to link shader '" + gpuShader.name + "'.");
                console.error(gl.getProgramInfoLog(gpuShader.glProgram));
                return;
              }

              var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
              gpuShader.glInputs = new Array(activeAttribCount);

              for (var i = 0; i < activeAttribCount; ++i) {
                var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);

                if (attribInfo) {
                  var varName = void 0;
                  var nameOffset = attribInfo.name.indexOf('[');

                  if (nameOffset !== -1) {
                    varName = attribInfo.name.substr(0, nameOffset);
                  } else {
                    varName = attribInfo.name;
                  }

                  var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName);
                  var type = WebGLTypeToGFXType(attribInfo.type, gl);
                  var stride = WebGLGetTypeSize(attribInfo.type, gl);
                  gpuShader.glInputs[i] = {
                    binding: glLoc,
                    name: varName,
                    type: type,
                    stride: stride,
                    count: attribInfo.size,
                    size: stride * attribInfo.size,
                    glType: attribInfo.type,
                    glLoc: glLoc
                  };
                }
              }

              if (gpuShader.blocks.length > 0) {
                gpuShader.glBlocks = new Array(gpuShader.blocks.length);

                for (var _i8 = 0; _i8 < gpuShader.blocks.length; ++_i8) {
                  var block = gpuShader.blocks[_i8];
                  var glBlock = {
                    set: block.set,
                    binding: block.binding,
                    name: block.name,
                    size: 0,
                    glUniforms: new Array(block.members.length),
                    glActiveUniforms: []
                  };
                  gpuShader.glBlocks[_i8] = glBlock;

                  for (var u = 0; u < block.members.length; ++u) {
                    var uniform = block.members[u];
                    var glType = GFXTypeToWebGLType(uniform.type, gl);

                    var _stride = WebGLGetTypeSize(glType, gl);

                    var size = _stride * uniform.count;
                    glBlock.glUniforms[u] = {
                      binding: -1,
                      name: uniform.name,
                      type: uniform.type,
                      stride: _stride,
                      count: uniform.count,
                      size: size,
                      offset: 0,
                      glType: glType,
                      glLoc: null,
                      array: null
                    };
                  }
                }
              }

              for (var _i9 = 0; _i9 < gpuShader.subpassInputs.length; ++_i9) {
                var subpassInput = gpuShader.subpassInputs[_i9];
                gpuShader.samplerTextures.push(new UniformSamplerTexture(subpassInput.set, subpassInput.binding, subpassInput.name, Type$1.SAMPLER2D, subpassInput.count));
              }

              if (gpuShader.samplerTextures.length > 0) {
                gpuShader.glSamplerTextures = new Array(gpuShader.samplerTextures.length);

                for (var _i10 = 0; _i10 < gpuShader.samplerTextures.length; ++_i10) {
                  var sampler = gpuShader.samplerTextures[_i10];
                  gpuShader.glSamplerTextures[_i10] = {
                    set: sampler.set,
                    binding: sampler.binding,
                    name: sampler.name,
                    type: sampler.type,
                    count: sampler.count,
                    units: [],
                    glUnits: null,
                    glType: GFXTypeToWebGLType(sampler.type, gl),
                    glLoc: null
                  };
                }
              }

              var activeUniformCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORMS);

              for (var _i11 = 0; _i11 < activeUniformCount; ++_i11) {
                var uniformInfo = gl.getActiveUniform(gpuShader.glProgram, _i11);

                if (uniformInfo) {
                  var isSampler = uniformInfo.type === gl.SAMPLER_2D || uniformInfo.type === gl.SAMPLER_CUBE;

                  if (!isSampler) {
                    var _glLoc = gl.getUniformLocation(gpuShader.glProgram, uniformInfo.name);

                    if (device.extensions.isLocationActive(_glLoc)) {
                      var _varName = void 0;

                      var _nameOffset = uniformInfo.name.indexOf('[');

                      if (_nameOffset !== -1) {
                        _varName = uniformInfo.name.substr(0, _nameOffset);
                      } else {
                        _varName = uniformInfo.name;
                      }

                      for (var j = 0; j < gpuShader.glBlocks.length; j++) {
                        var _glBlock = gpuShader.glBlocks[j];

                        for (var _k3 = 0; _k3 < _glBlock.glUniforms.length; _k3++) {
                          var glUniform = _glBlock.glUniforms[_k3];

                          if (glUniform.name === _varName) {
                            glUniform.glLoc = _glLoc;
                            glUniform.count = uniformInfo.size;
                            glUniform.size = glUniform.stride * glUniform.count;
                            glUniform.array = new (GFXTypeToTypedArrayCtor(glUniform.type))(glUniform.size / 4);

                            _glBlock.glActiveUniforms.push(glUniform);

                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }

              for (var _j = 0; _j < gpuShader.glBlocks.length; _j++) {
                var _glBlock2 = gpuShader.glBlocks[_j];

                for (var _k4 = 0; _k4 < _glBlock2.glUniforms.length; _k4++) {
                  var _glUniform = _glBlock2.glUniforms[_k4];
                  _glUniform.offset = _glBlock2.size / 4;
                  _glBlock2.size += _glUniform.size;
                }
              }

              var glActiveSamplers = [];
              var glActiveSamplerLocations = [];
              var bindingMappings = device.bindingMappings;
              var texUnitCacheMap = device.stateCache.texUnitCacheMap;

              if (!(legacyCC.rendering && legacyCC.rendering.enableEffectImport)) {
                var flexibleSetBaseOffset = 0;

                for (var _i12 = 0; _i12 < gpuShader.blocks.length; ++_i12) {
                  if (gpuShader.blocks[_i12].set === bindingMappings.flexibleSet) {
                    flexibleSetBaseOffset++;
                  }
                }

                var arrayOffset = 0;

                for (var _i13 = 0; _i13 < gpuShader.samplerTextures.length; ++_i13) {
                  var _sampler = gpuShader.samplerTextures[_i13];

                  var _glLoc2 = gl.getUniformLocation(gpuShader.glProgram, _sampler.name);

                  if (device.extensions.isLocationActive(_glLoc2)) {
                    glActiveSamplers.push(gpuShader.glSamplerTextures[_i13]);
                    glActiveSamplerLocations.push(_glLoc2);
                  }

                  if (texUnitCacheMap[_sampler.name] === undefined) {
                    var binding = _sampler.binding + bindingMappings.samplerTextureOffsets[_sampler.set] + arrayOffset;

                    if (_sampler.set === bindingMappings.flexibleSet) {
                      binding -= flexibleSetBaseOffset;
                    }

                    texUnitCacheMap[_sampler.name] = binding % device.capabilities.maxTextureUnits;
                    arrayOffset += _sampler.count - 1;
                  }
                }
              } else {
                for (var _i14 = 0; _i14 < gpuShader.samplerTextures.length; ++_i14) {
                  var _sampler2 = gpuShader.samplerTextures[_i14];

                  var _glLoc3 = gl.getUniformLocation(gpuShader.glProgram, _sampler2.name);

                  if (device.extensions.isLocationActive(_glLoc3)) {
                    glActiveSamplers.push(gpuShader.glSamplerTextures[_i14]);
                    glActiveSamplerLocations.push(_glLoc3);
                  }

                  if (texUnitCacheMap[_sampler2.name] === undefined) {
                    texUnitCacheMap[_sampler2.name] = _sampler2.flattened;
                  }
                }
              }

              if (glActiveSamplers.length) {
                var usedTexUnits = [];

                for (var _i15 = 0; _i15 < glActiveSamplers.length; ++_i15) {
                  var glSampler = glActiveSamplers[_i15];
                  var cachedUnit = texUnitCacheMap[glSampler.name];

                  if (cachedUnit !== undefined) {
                    glSampler.glLoc = glActiveSamplerLocations[_i15];

                    for (var t = 0; t < glSampler.count; ++t) {
                      while (usedTexUnits[cachedUnit]) {
                        cachedUnit = (cachedUnit + 1) % device.capabilities.maxTextureUnits;
                      }

                      glSampler.units.push(cachedUnit);
                      usedTexUnits[cachedUnit] = true;
                    }
                  }
                }

                var unitIdx = 0;

                for (var _i16 = 0; _i16 < glActiveSamplers.length; ++_i16) {
                  var _glSampler = glActiveSamplers[_i16];

                  if (!device.extensions.isLocationActive(_glSampler.glLoc)) {
                    _glSampler.glLoc = glActiveSamplerLocations[_i16];

                    for (var _t = 0; _t < _glSampler.count; ++_t) {
                      while (usedTexUnits[unitIdx]) {
                        unitIdx = (unitIdx + 1) % device.capabilities.maxTextureUnits;
                      }

                      if (texUnitCacheMap[_glSampler.name] === undefined) {
                        texUnitCacheMap[_glSampler.name] = unitIdx;
                      }

                      _glSampler.units.push(unitIdx);

                      usedTexUnits[unitIdx] = true;
                    }
                  }
                }

                if (device.stateCache.glProgram !== gpuShader.glProgram) {
                  gl.useProgram(gpuShader.glProgram);
                }

                for (var _i17 = 0; _i17 < glActiveSamplers.length; _i17++) {
                  var _glSampler2 = glActiveSamplers[_i17];
                  _glSampler2.glUnits = new Int32Array(_glSampler2.units);
                  gl.uniform1iv(_glSampler2.glLoc, _glSampler2.glUnits);
                }

                if (device.stateCache.glProgram !== gpuShader.glProgram) {
                  gl.useProgram(device.stateCache.glProgram);
                }
              }

              for (var _i18 = 0; _i18 < gpuShader.glBlocks.length;) {
                if (gpuShader.glBlocks[_i18].glActiveUniforms.length) {
                  _i18++;
                } else {
                  gpuShader.glBlocks[_i18] = gpuShader.glBlocks[gpuShader.glBlocks.length - 1];
                  gpuShader.glBlocks.length--;
                }
              }

              gpuShader.glSamplerTextures = glActiveSamplers;
            }
            function WebGLCmdFuncDestroyShader(device, gpuShader) {
              if (gpuShader.glProgram) {
                var gl = device.gl;

                if (!device.extensions.destroyShadersImmediately) {
                  for (var k = 0; k < gpuShader.gpuStages.length; k++) {
                    var gpuStage = gpuShader.gpuStages[k];

                    if (gpuStage.glShader) {
                      gl.detachShader(gpuShader.glProgram, gpuStage.glShader);
                      gl.deleteShader(gpuStage.glShader);
                      gpuStage.glShader = null;
                    }
                  }
                }

                gl.deleteProgram(gpuShader.glProgram);

                if (device.stateCache.glProgram === gpuShader.glProgram) {
                  device.gl.useProgram(null);
                  device.stateCache.glProgram = null;
                }

                gpuShader.glProgram = null;
              }
            }
            function WebGLCmdFuncCreateInputAssember(device, gpuInputAssembler) {
              var gl = device.gl;
              gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
              var offsets = [0, 0, 0, 0, 0, 0, 0, 0];

              for (var i = 0; i < gpuInputAssembler.attributes.length; ++i) {
                var attrib = gpuInputAssembler.attributes[i];
                var stream = attrib.stream !== undefined ? attrib.stream : 0;
                var gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream];
                var glType = GFXFormatToWebGLType(attrib.format, gl);
                var size = FormatInfos[attrib.format].size;
                gpuInputAssembler.glAttribs[i] = {
                  name: attrib.name,
                  glBuffer: gpuBuffer.glBuffer,
                  glType: glType,
                  size: size,
                  count: FormatInfos[attrib.format].count,
                  stride: gpuBuffer.stride,
                  componentCount: WebGLGetComponentCount(glType, gl),
                  isNormalized: attrib.isNormalized !== undefined ? attrib.isNormalized : false,
                  isInstanced: attrib.isInstanced !== undefined ? attrib.isInstanced : false,
                  offset: offsets[stream]
                };
                offsets[stream] += size;
              }
            }
            function WebGLCmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
              var it = gpuInputAssembler.glVAOs.values();
              var res = it.next();
              var OES_vertex_array_object = device.extensions.OES_vertex_array_object;
              var glVAO = device.stateCache.glVAO;

              while (!res.done) {
                OES_vertex_array_object.deleteVertexArrayOES(res.value);

                if (glVAO === res.value) {
                  OES_vertex_array_object.bindVertexArrayOES(null);
                  glVAO = null;
                }

                res = it.next();
              }

              device.stateCache.glVAO = glVAO;
              gpuInputAssembler.glVAOs.clear();
            }
            var gfxStateCache = {
              gpuPipelineState: null,
              gpuInputAssembler: null,
              glPrimitive: 0
            };
            var realRenderArea = new Rect();
            function WebGLCmdFuncBeginRenderPass(device, gpuRenderPass, gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil) {
              var gl = device.gl;
              var cache = device.stateCache;
              var clears = 0;

              if (gpuFramebuffer) {
                realRenderArea.x = renderArea.x << gpuFramebuffer.lodLevel;
                realRenderArea.y = renderArea.y << gpuFramebuffer.lodLevel;
                realRenderArea.width = renderArea.width << gpuFramebuffer.lodLevel;
                realRenderArea.height = renderArea.height << gpuFramebuffer.lodLevel;
              }

              if (gpuFramebuffer && gpuRenderPass) {
                if (cache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
                  cache.glFramebuffer = gpuFramebuffer.glFramebuffer;
                }

                if (cache.viewport.left !== realRenderArea.x || cache.viewport.top !== realRenderArea.y || cache.viewport.width !== realRenderArea.width || cache.viewport.height !== realRenderArea.height) {
                  gl.viewport(realRenderArea.x, realRenderArea.y, realRenderArea.width, realRenderArea.height);
                  cache.viewport.left = realRenderArea.x;
                  cache.viewport.top = realRenderArea.y;
                  cache.viewport.width = realRenderArea.width;
                  cache.viewport.height = realRenderArea.height;
                }

                if (cache.scissorRect.x !== realRenderArea.x || cache.scissorRect.y !== realRenderArea.y || cache.scissorRect.width !== realRenderArea.width || cache.scissorRect.height !== realRenderArea.height) {
                  gl.scissor(realRenderArea.x, realRenderArea.y, realRenderArea.width, realRenderArea.height);
                  cache.scissorRect.x = realRenderArea.x;
                  cache.scissorRect.y = realRenderArea.y;
                  cache.scissorRect.width = realRenderArea.width;
                  cache.scissorRect.height = realRenderArea.height;
                }

                var clearCount = clearColors.length;

                if (!device.extensions.WEBGL_draw_buffers) {
                  clearCount = 1;
                }

                for (var j = 0; j < clearCount; ++j) {
                  var colorAttachment = gpuRenderPass.colorAttachments[j];

                  if (colorAttachment.format !== Format.UNKNOWN) {
                    switch (colorAttachment.loadOp) {
                      case LoadOp.LOAD:
                        break;

                      case LoadOp.CLEAR:
                        {
                          if (cache.bs.targets[0].blendColorMask !== ColorMask.ALL) {
                            gl.colorMask(true, true, true, true);
                          }

                          var clearColor = clearColors[0];
                          gl.clearColor(clearColor.x, clearColor.y, clearColor.z, clearColor.w);
                          clears |= gl.COLOR_BUFFER_BIT;
                          break;
                        }

                      case LoadOp.DISCARD:
                        {
                          break;
                        }
                    }
                  }
                }

                if (gpuRenderPass.depthStencilAttachment) {
                  if (gpuRenderPass.depthStencilAttachment.format !== Format.UNKNOWN) {
                    switch (gpuRenderPass.depthStencilAttachment.depthLoadOp) {
                      case LoadOp.LOAD:
                        break;

                      case LoadOp.CLEAR:
                        {
                          if (!cache.dss.depthWrite) {
                            gl.depthMask(true);
                          }

                          gl.clearDepth(clearDepth);
                          clears |= gl.DEPTH_BUFFER_BIT;
                          break;
                        }

                      case LoadOp.DISCARD:
                        {
                          break;
                        }
                    }

                    if (FormatInfos[gpuRenderPass.depthStencilAttachment.format].hasStencil) {
                      switch (gpuRenderPass.depthStencilAttachment.stencilLoadOp) {
                        case LoadOp.LOAD:
                          break;

                        case LoadOp.CLEAR:
                          {
                            if (!cache.dss.stencilWriteMaskFront) {
                              gl.stencilMaskSeparate(gl.FRONT, 0xffff);
                            }

                            if (!cache.dss.stencilWriteMaskBack) {
                              gl.stencilMaskSeparate(gl.BACK, 0xffff);
                            }

                            gl.clearStencil(clearStencil);
                            clears |= gl.STENCIL_BUFFER_BIT;
                            break;
                          }

                        case LoadOp.DISCARD:
                          {
                            break;
                          }
                      }
                    }
                  }
                }

                if (clears) {
                  gl.clear(clears);
                }

                if (clears & gl.COLOR_BUFFER_BIT) {
                  var colorMask = cache.bs.targets[0].blendColorMask;

                  if (colorMask !== ColorMask.ALL) {
                    var r = (colorMask & ColorMask.R) !== ColorMask.NONE;
                    var g = (colorMask & ColorMask.G) !== ColorMask.NONE;
                    var b = (colorMask & ColorMask.B) !== ColorMask.NONE;
                    var a = (colorMask & ColorMask.A) !== ColorMask.NONE;
                    gl.colorMask(r, g, b, a);
                  }
                }

                if (clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite) {
                  gl.depthMask(false);
                }

                if (clears & gl.STENCIL_BUFFER_BIT) {
                  if (!cache.dss.stencilWriteMaskFront) {
                    gl.stencilMaskSeparate(gl.FRONT, 0);
                  }

                  if (!cache.dss.stencilWriteMaskBack) {
                    gl.stencilMaskSeparate(gl.BACK, 0);
                  }
                }
              }
            }
            function WebGLCmdFuncBindStates(device, gpuPipelineState, gpuInputAssembler, gpuDescriptorSets, dynamicOffsets, dynamicStates) {
              var gl = device.gl;
              var cache = device.stateCache;
              var gpuShader = gpuPipelineState && gpuPipelineState.gpuShader;
              var isShaderChanged = false;
              var glWrapS;
              var glWrapT;
              var glMinFilter;

              if (gpuPipelineState && gfxStateCache.gpuPipelineState !== gpuPipelineState) {
                gfxStateCache.gpuPipelineState = gpuPipelineState;
                gfxStateCache.glPrimitive = gpuPipelineState.glPrimitive;

                if (gpuPipelineState.gpuShader) {
                  var glProgram = gpuPipelineState.gpuShader.glProgram;

                  if (cache.glProgram !== glProgram) {
                    gl.useProgram(glProgram);
                    cache.glProgram = glProgram;
                    isShaderChanged = true;
                  }
                }

                var rs = gpuPipelineState.rs;

                if (rs) {
                  if (cache.rs.cullMode !== rs.cullMode) {
                    switch (rs.cullMode) {
                      case CullMode.NONE:
                        {
                          gl.disable(gl.CULL_FACE);
                          break;
                        }

                      case CullMode.FRONT:
                        {
                          gl.enable(gl.CULL_FACE);
                          gl.cullFace(gl.FRONT);
                          break;
                        }

                      case CullMode.BACK:
                        {
                          gl.enable(gl.CULL_FACE);
                          gl.cullFace(gl.BACK);
                          break;
                        }
                    }

                    cache.rs.cullMode = rs.cullMode;
                  }

                  var isFrontFaceCCW = rs.isFrontFaceCCW;

                  if (cache.rs.isFrontFaceCCW !== isFrontFaceCCW) {
                    gl.frontFace(isFrontFaceCCW ? gl.CCW : gl.CW);
                    cache.rs.isFrontFaceCCW = isFrontFaceCCW;
                  }

                  if (cache.rs.depthBias !== rs.depthBias || cache.rs.depthBiasSlop !== rs.depthBiasSlop) {
                    gl.polygonOffset(rs.depthBias, rs.depthBiasSlop);
                    cache.rs.depthBias = rs.depthBias;
                    cache.rs.depthBiasSlop = rs.depthBiasSlop;
                  }

                  if (cache.rs.lineWidth !== rs.lineWidth) {
                    gl.lineWidth(rs.lineWidth);
                    cache.rs.lineWidth = rs.lineWidth;
                  }
                }

                var dss = gpuPipelineState.dss;

                if (dss) {
                  if (cache.dss.depthTest !== dss.depthTest) {
                    if (dss.depthTest) {
                      gl.enable(gl.DEPTH_TEST);
                    } else {
                      gl.disable(gl.DEPTH_TEST);
                    }

                    cache.dss.depthTest = dss.depthTest;
                  }

                  if (cache.dss.depthWrite !== dss.depthWrite) {
                    gl.depthMask(dss.depthWrite);
                    cache.dss.depthWrite = dss.depthWrite;
                  }

                  if (cache.dss.depthFunc !== dss.depthFunc) {
                    gl.depthFunc(WebGLCmpFuncs[dss.depthFunc]);
                    cache.dss.depthFunc = dss.depthFunc;
                  }

                  if (cache.dss.stencilTestFront !== dss.stencilTestFront || cache.dss.stencilTestBack !== dss.stencilTestBack) {
                    if (dss.stencilTestFront || dss.stencilTestBack) {
                      gl.enable(gl.STENCIL_TEST);
                    } else {
                      gl.disable(gl.STENCIL_TEST);
                    }

                    cache.dss.stencilTestFront = dss.stencilTestFront;
                    cache.dss.stencilTestBack = dss.stencilTestBack;
                  }

                  if (cache.dss.stencilFuncFront !== dss.stencilFuncFront || cache.dss.stencilRefFront !== dss.stencilRefFront || cache.dss.stencilReadMaskFront !== dss.stencilReadMaskFront) {
                    gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront);
                    cache.dss.stencilFuncFront = dss.stencilFuncFront;
                    cache.dss.stencilRefFront = dss.stencilRefFront;
                    cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront;
                  }

                  if (cache.dss.stencilFailOpFront !== dss.stencilFailOpFront || cache.dss.stencilZFailOpFront !== dss.stencilZFailOpFront || cache.dss.stencilPassOpFront !== dss.stencilPassOpFront) {
                    gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps[dss.stencilFailOpFront], WebGLStencilOps[dss.stencilZFailOpFront], WebGLStencilOps[dss.stencilPassOpFront]);
                    cache.dss.stencilFailOpFront = dss.stencilFailOpFront;
                    cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront;
                    cache.dss.stencilPassOpFront = dss.stencilPassOpFront;
                  }

                  if (cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront) {
                    gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront);
                    cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront;
                  }

                  if (cache.dss.stencilFuncBack !== dss.stencilFuncBack || cache.dss.stencilRefBack !== dss.stencilRefBack || cache.dss.stencilReadMaskBack !== dss.stencilReadMaskBack) {
                    gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack);
                    cache.dss.stencilFuncBack = dss.stencilFuncBack;
                    cache.dss.stencilRefBack = dss.stencilRefBack;
                    cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack;
                  }

                  if (cache.dss.stencilFailOpBack !== dss.stencilFailOpBack || cache.dss.stencilZFailOpBack !== dss.stencilZFailOpBack || cache.dss.stencilPassOpBack !== dss.stencilPassOpBack) {
                    gl.stencilOpSeparate(gl.BACK, WebGLStencilOps[dss.stencilFailOpBack], WebGLStencilOps[dss.stencilZFailOpBack], WebGLStencilOps[dss.stencilPassOpBack]);
                    cache.dss.stencilFailOpBack = dss.stencilFailOpBack;
                    cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack;
                    cache.dss.stencilPassOpBack = dss.stencilPassOpBack;
                  }

                  if (cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack) {
                    gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack);
                    cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack;
                  }
                }

                var bs = gpuPipelineState.bs;

                if (bs) {
                  if (cache.bs.isA2C !== bs.isA2C) {
                    if (bs.isA2C) {
                      gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    } else {
                      gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    }

                    cache.bs.isA2C = bs.isA2C;
                  }

                  if (cache.bs.blendColor.x !== bs.blendColor.x || cache.bs.blendColor.y !== bs.blendColor.y || cache.bs.blendColor.z !== bs.blendColor.z || cache.bs.blendColor.w !== bs.blendColor.w) {
                    gl.blendColor(bs.blendColor.x, bs.blendColor.y, bs.blendColor.z, bs.blendColor.w);
                    cache.bs.blendColor.x = bs.blendColor.x;
                    cache.bs.blendColor.y = bs.blendColor.y;
                    cache.bs.blendColor.z = bs.blendColor.z;
                    cache.bs.blendColor.w = bs.blendColor.w;
                  }

                  var target0 = bs.targets[0];
                  var target0Cache = cache.bs.targets[0];

                  if (target0Cache.blend !== target0.blend) {
                    if (target0.blend) {
                      gl.enable(gl.BLEND);
                    } else {
                      gl.disable(gl.BLEND);
                    }

                    target0Cache.blend = target0.blend;
                  }

                  if (target0Cache.blendEq !== target0.blendEq || target0Cache.blendAlphaEq !== target0.blendAlphaEq) {
                    gl.blendEquationSeparate(WebGLBlendOps[target0.blendEq], WebGLBlendOps[target0.blendAlphaEq]);
                    target0Cache.blendEq = target0.blendEq;
                    target0Cache.blendAlphaEq = target0.blendAlphaEq;
                  }

                  if (target0Cache.blendSrc !== target0.blendSrc || target0Cache.blendDst !== target0.blendDst || target0Cache.blendSrcAlpha !== target0.blendSrcAlpha || target0Cache.blendDstAlpha !== target0.blendDstAlpha) {
                    gl.blendFuncSeparate(WebGLBlendFactors[target0.blendSrc], WebGLBlendFactors[target0.blendDst], WebGLBlendFactors[target0.blendSrcAlpha], WebGLBlendFactors[target0.blendDstAlpha]);
                    target0Cache.blendSrc = target0.blendSrc;
                    target0Cache.blendDst = target0.blendDst;
                    target0Cache.blendSrcAlpha = target0.blendSrcAlpha;
                    target0Cache.blendDstAlpha = target0.blendDstAlpha;
                  }

                  if (target0Cache.blendColorMask !== target0.blendColorMask) {
                    gl.colorMask((target0.blendColorMask & ColorMask.R) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.G) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.B) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.A) !== ColorMask.NONE);
                    target0Cache.blendColorMask = target0.blendColorMask;
                  }
                }
              }

              if (gpuPipelineState && gpuPipelineState.gpuPipelineLayout && gpuShader) {
                var blockLen = gpuShader.glBlocks.length;
                var dynamicOffsetIndices = gpuPipelineState.gpuPipelineLayout.dynamicOffsetIndices;

                for (var j = 0; j < blockLen; j++) {
                  var glBlock = gpuShader.glBlocks[j];
                  var gpuDescriptorSet = gpuDescriptorSets[glBlock.set];
                  var descriptorIdx = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glBlock.binding];
                  var gpuDescriptor = descriptorIdx >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIdx];
                  var vf32 = null;
                  var offset = 0;

                  if (gpuDescriptor && gpuDescriptor.gpuBuffer) {
                    var gpuBuffer = gpuDescriptor.gpuBuffer;
                    var dynamicOffsetIndexSet = dynamicOffsetIndices[glBlock.set];
                    var dynamicOffsetIndex = dynamicOffsetIndexSet && dynamicOffsetIndexSet[glBlock.binding];

                    if (dynamicOffsetIndex >= 0) {
                      offset = dynamicOffsets[dynamicOffsetIndex];
                    }

                    if ('vf32' in gpuBuffer) {
                      vf32 = gpuBuffer.vf32;
                    } else {
                      offset += gpuBuffer.offset;
                      vf32 = gpuBuffer.gpuBuffer.vf32;
                    }

                    offset >>= 2;
                  }

                  if (!vf32) {
                    continue;
                  }

                  var uniformLen = glBlock.glActiveUniforms.length;

                  for (var l = 0; l < uniformLen; l++) {
                    var glUniform = glBlock.glActiveUniforms[l];

                    switch (glUniform.glType) {
                      case gl.BOOL:
                      case gl.INT:
                        {
                          for (var u = 0; u < glUniform.array.length; ++u) {
                            var idx = glUniform.offset + offset + u;

                            if (vf32[idx] !== glUniform.array[u]) {
                              for (var n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                                glUniform.array[n] = vf32[m];
                              }

                              gl.uniform1iv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.BOOL_VEC2:
                      case gl.INT_VEC2:
                        {
                          for (var _u = 0; _u < glUniform.array.length; ++_u) {
                            var _idx = glUniform.offset + offset + _u;

                            if (vf32[_idx] !== glUniform.array[_u]) {
                              for (var _n = _u, _m = _idx; _n < glUniform.array.length; ++_n, ++_m) {
                                glUniform.array[_n] = vf32[_m];
                              }

                              gl.uniform2iv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.BOOL_VEC3:
                      case gl.INT_VEC3:
                        {
                          for (var _u2 = 0; _u2 < glUniform.array.length; ++_u2) {
                            var _idx2 = glUniform.offset + offset + _u2;

                            if (vf32[_idx2] !== glUniform.array[_u2]) {
                              for (var _n2 = _u2, _m2 = _idx2; _n2 < glUniform.array.length; ++_n2, ++_m2) {
                                glUniform.array[_n2] = vf32[_m2];
                              }

                              gl.uniform3iv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.BOOL_VEC4:
                      case gl.INT_VEC4:
                        {
                          for (var _u3 = 0; _u3 < glUniform.array.length; ++_u3) {
                            var _idx3 = glUniform.offset + offset + _u3;

                            if (vf32[_idx3] !== glUniform.array[_u3]) {
                              for (var _n3 = _u3, _m3 = _idx3; _n3 < glUniform.array.length; ++_n3, ++_m3) {
                                glUniform.array[_n3] = vf32[_m3];
                              }

                              gl.uniform4iv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT:
                        {
                          for (var _u4 = 0; _u4 < glUniform.array.length; ++_u4) {
                            var _idx4 = glUniform.offset + offset + _u4;

                            if (vf32[_idx4] !== glUniform.array[_u4]) {
                              for (var _n4 = _u4, _m4 = _idx4; _n4 < glUniform.array.length; ++_n4, ++_m4) {
                                glUniform.array[_n4] = vf32[_m4];
                              }

                              gl.uniform1fv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_VEC2:
                        {
                          for (var _u5 = 0; _u5 < glUniform.array.length; ++_u5) {
                            var _idx5 = glUniform.offset + offset + _u5;

                            if (vf32[_idx5] !== glUniform.array[_u5]) {
                              for (var _n5 = _u5, _m5 = _idx5; _n5 < glUniform.array.length; ++_n5, ++_m5) {
                                glUniform.array[_n5] = vf32[_m5];
                              }

                              gl.uniform2fv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_VEC3:
                        {
                          for (var _u6 = 0; _u6 < glUniform.array.length; ++_u6) {
                            var _idx6 = glUniform.offset + offset + _u6;

                            if (vf32[_idx6] !== glUniform.array[_u6]) {
                              for (var _n6 = _u6, _m6 = _idx6; _n6 < glUniform.array.length; ++_n6, ++_m6) {
                                glUniform.array[_n6] = vf32[_m6];
                              }

                              gl.uniform3fv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_VEC4:
                        {
                          for (var _u7 = 0; _u7 < glUniform.array.length; ++_u7) {
                            var _idx7 = glUniform.offset + offset + _u7;

                            if (vf32[_idx7] !== glUniform.array[_u7]) {
                              for (var _n7 = _u7, _m7 = _idx7; _n7 < glUniform.array.length; ++_n7, ++_m7) {
                                glUniform.array[_n7] = vf32[_m7];
                              }

                              gl.uniform4fv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_MAT2:
                        {
                          for (var _u8 = 0; _u8 < glUniform.array.length; ++_u8) {
                            var _idx8 = glUniform.offset + offset + _u8;

                            if (vf32[_idx8] !== glUniform.array[_u8]) {
                              for (var _n8 = _u8, _m8 = _idx8; _n8 < glUniform.array.length; ++_n8, ++_m8) {
                                glUniform.array[_n8] = vf32[_m8];
                              }

                              gl.uniformMatrix2fv(glUniform.glLoc, false, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_MAT3:
                        {
                          for (var _u9 = 0; _u9 < glUniform.array.length; ++_u9) {
                            var _idx9 = glUniform.offset + offset + _u9;

                            if (vf32[_idx9] !== glUniform.array[_u9]) {
                              for (var _n9 = _u9, _m9 = _idx9; _n9 < glUniform.array.length; ++_n9, ++_m9) {
                                glUniform.array[_n9] = vf32[_m9];
                              }

                              gl.uniformMatrix3fv(glUniform.glLoc, false, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_MAT4:
                        {
                          for (var _u10 = 0; _u10 < glUniform.array.length; ++_u10) {
                            var _idx10 = glUniform.offset + offset + _u10;

                            if (vf32[_idx10] !== glUniform.array[_u10]) {
                              for (var _n10 = _u10, _m10 = _idx10; _n10 < glUniform.array.length; ++_n10, ++_m10) {
                                glUniform.array[_n10] = vf32[_m10];
                              }

                              gl.uniformMatrix4fv(glUniform.glLoc, false, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }
                    }
                  }

                  continue;
                }

                var samplerLen = gpuShader.glSamplerTextures.length;

                for (var i = 0; i < samplerLen; i++) {
                  var glSampler = gpuShader.glSamplerTextures[i];
                  var _gpuDescriptorSet = gpuDescriptorSets[glSampler.set];
                  var descriptorIndex = _gpuDescriptorSet && _gpuDescriptorSet.descriptorIndices[glSampler.binding];

                  var _gpuDescriptor = descriptorIndex >= 0 && _gpuDescriptorSet.gpuDescriptors[descriptorIndex];

                  var texUnitLen = glSampler.units.length;

                  for (var _l = 0; _l < texUnitLen; _l++) {
                    var texUnit = glSampler.units[_l];

                    if (!_gpuDescriptor || !_gpuDescriptor.gpuSampler) {
                      continue;
                    }

                    if (_gpuDescriptor.gpuTexture && _gpuDescriptor.gpuTexture.size > 0) {
                      var _gpuDescriptor2 = _gpuDescriptor,
                          gpuTexture = _gpuDescriptor2.gpuTexture;
                      var glTexUnit = cache.glTexUnits[texUnit];

                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        if (gpuTexture.glTexture) {
                          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                        } else {
                          gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture);
                        }

                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      var _gpuDescriptor3 = _gpuDescriptor,
                          gpuSampler = _gpuDescriptor3.gpuSampler;

                      if (gpuTexture.isPowerOf2) {
                        glWrapS = gpuSampler.glWrapS;
                        glWrapT = gpuSampler.glWrapT;
                      } else {
                        glWrapS = gl.CLAMP_TO_EDGE;
                        glWrapT = gl.CLAMP_TO_EDGE;
                      }

                      if (gpuTexture.isPowerOf2) {
                        if (gpuTexture.mipLevel <= 1 && (gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR)) {
                          glMinFilter = gl.LINEAR;
                        } else {
                          glMinFilter = gpuSampler.glMinFilter;
                        }
                      } else if (gpuSampler.glMinFilter === gl.LINEAR || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR) {
                        glMinFilter = gl.LINEAR;
                      } else {
                        glMinFilter = gl.NEAREST;
                      }

                      if (gpuTexture.glWrapS !== glWrapS) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, glWrapS);
                        gpuTexture.glWrapS = glWrapS;
                      }

                      if (gpuTexture.glWrapT !== glWrapT) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, glWrapT);
                        gpuTexture.glWrapT = glWrapT;
                      }

                      if (gpuTexture.glMinFilter !== glMinFilter) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, glMinFilter);
                        gpuTexture.glMinFilter = glMinFilter;
                      }

                      if (gpuTexture.glMagFilter !== gpuSampler.glMagFilter) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuSampler.glMagFilter);
                        gpuTexture.glMagFilter = gpuSampler.glMagFilter;
                      }
                    }

                    _gpuDescriptor = _gpuDescriptorSet.gpuDescriptors[++descriptorIndex];
                  }
                }
              }

              if (gpuInputAssembler && gpuShader && (isShaderChanged || gfxStateCache.gpuInputAssembler !== gpuInputAssembler)) {
                gfxStateCache.gpuInputAssembler = gpuInputAssembler;
                var ia = device.extensions.ANGLE_instanced_arrays;

                if (device.extensions.useVAO) {
                  var vao = device.extensions.OES_vertex_array_object;
                  var glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);

                  if (!glVAO) {
                    glVAO = vao.createVertexArrayOES();
                    gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO);
                    vao.bindVertexArrayOES(glVAO);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    cache.glArrayBuffer = null;
                    cache.glElementArrayBuffer = null;
                    var glAttrib;
                    var inputLen = gpuShader.glInputs.length;

                    for (var _j2 = 0; _j2 < inputLen; _j2++) {
                      var glInput = gpuShader.glInputs[_j2];
                      glAttrib = null;
                      var attribLen = gpuInputAssembler.glAttribs.length;

                      for (var k = 0; k < attribLen; k++) {
                        var attrib = gpuInputAssembler.glAttribs[k];

                        if (attrib.name === glInput.name) {
                          glAttrib = attrib;
                          break;
                        }
                      }

                      if (glAttrib) {
                        if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                          gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                          cache.glArrayBuffer = glAttrib.glBuffer;
                        }

                        for (var c = 0; c < glAttrib.componentCount; ++c) {
                          var glLoc = glInput.glLoc + c;
                          var attribOffset = glAttrib.offset + glAttrib.size * c;
                          gl.enableVertexAttribArray(glLoc);
                          cache.glCurrentAttribLocs[glLoc] = true;
                          gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);

                          if (ia) {
                            ia.vertexAttribDivisorANGLE(glLoc, glAttrib.isInstanced ? 1 : 0);
                          }
                        }
                      }
                    }

                    var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;

                    if (_gpuBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer.glBuffer);
                    }

                    vao.bindVertexArrayOES(null);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    cache.glArrayBuffer = null;
                    cache.glElementArrayBuffer = null;
                  }

                  if (cache.glVAO !== glVAO) {
                    vao.bindVertexArrayOES(glVAO);
                    cache.glVAO = glVAO;
                  }
                } else {
                  for (var a = 0; a < device.capabilities.maxVertexAttributes; ++a) {
                    cache.glCurrentAttribLocs[a] = false;
                  }

                  var _inputLen = gpuShader.glInputs.length;

                  for (var _j3 = 0; _j3 < _inputLen; _j3++) {
                    var _glInput = gpuShader.glInputs[_j3];
                    var _glAttrib = null;
                    var _attribLen = gpuInputAssembler.glAttribs.length;

                    for (var _k5 = 0; _k5 < _attribLen; _k5++) {
                      var _attrib = gpuInputAssembler.glAttribs[_k5];

                      if (_attrib.name === _glInput.name) {
                        _glAttrib = _attrib;
                        break;
                      }
                    }

                    if (_glAttrib) {
                      if (cache.glArrayBuffer !== _glAttrib.glBuffer) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, _glAttrib.glBuffer);
                        cache.glArrayBuffer = _glAttrib.glBuffer;
                      }

                      for (var _c = 0; _c < _glAttrib.componentCount; ++_c) {
                        var _glLoc4 = _glInput.glLoc + _c;

                        var _attribOffset = _glAttrib.offset + _glAttrib.size * _c;

                        if (!cache.glEnabledAttribLocs[_glLoc4] && _glLoc4 >= 0) {
                          gl.enableVertexAttribArray(_glLoc4);
                          cache.glEnabledAttribLocs[_glLoc4] = true;
                        }

                        cache.glCurrentAttribLocs[_glLoc4] = true;
                        gl.vertexAttribPointer(_glLoc4, _glAttrib.count, _glAttrib.glType, _glAttrib.isNormalized, _glAttrib.stride, _attribOffset);

                        if (ia) {
                          ia.vertexAttribDivisorANGLE(_glLoc4, _glAttrib.isInstanced ? 1 : 0);
                        }
                      }
                    }
                  }

                  var _gpuBuffer2 = gpuInputAssembler.gpuIndexBuffer;

                  if (_gpuBuffer2) {
                    if (cache.glElementArrayBuffer !== _gpuBuffer2.glBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer2.glBuffer);
                      cache.glElementArrayBuffer = _gpuBuffer2.glBuffer;
                    }
                  }

                  for (var _a = 0; _a < device.capabilities.maxVertexAttributes; ++_a) {
                    if (cache.glEnabledAttribLocs[_a] !== cache.glCurrentAttribLocs[_a]) {
                      gl.disableVertexAttribArray(_a);
                      cache.glEnabledAttribLocs[_a] = false;
                    }
                  }
                }
              }

              if (gpuPipelineState && gpuPipelineState.dynamicStates.length) {
                var dsLen = gpuPipelineState.dynamicStates.length;

                for (var _j4 = 0; _j4 < dsLen; _j4++) {
                  var dynamicState = gpuPipelineState.dynamicStates[_j4];

                  switch (dynamicState) {
                    case DynamicStateFlagBit.LINE_WIDTH:
                      {
                        if (cache.rs.lineWidth !== dynamicStates.lineWidth) {
                          gl.lineWidth(dynamicStates.lineWidth);
                          cache.rs.lineWidth = dynamicStates.lineWidth;
                        }

                        break;
                      }

                    case DynamicStateFlagBit.DEPTH_BIAS:
                      {
                        if (cache.rs.depthBias !== dynamicStates.depthBiasConstant || cache.rs.depthBiasSlop !== dynamicStates.depthBiasSlope) {
                          gl.polygonOffset(dynamicStates.depthBiasConstant, dynamicStates.depthBiasSlope);
                          cache.rs.depthBias = dynamicStates.depthBiasConstant;
                          cache.rs.depthBiasSlop = dynamicStates.depthBiasSlope;
                        }

                        break;
                      }

                    case DynamicStateFlagBit.BLEND_CONSTANTS:
                      {
                        var blendConstant = dynamicStates.blendConstant;

                        if (cache.bs.blendColor.x !== blendConstant.x || cache.bs.blendColor.y !== blendConstant.y || cache.bs.blendColor.z !== blendConstant.z || cache.bs.blendColor.w !== blendConstant.w) {
                          gl.blendColor(blendConstant.x, blendConstant.y, blendConstant.z, blendConstant.w);
                          cache.bs.blendColor.copy(blendConstant);
                        }

                        break;
                      }

                    case DynamicStateFlagBit.STENCIL_WRITE_MASK:
                      {
                        var front = dynamicStates.stencilStatesFront;
                        var back = dynamicStates.stencilStatesBack;

                        if (cache.dss.stencilWriteMaskFront !== front.writeMask) {
                          gl.stencilMaskSeparate(gl.FRONT, front.writeMask);
                          cache.dss.stencilWriteMaskFront = front.writeMask;
                        }

                        if (cache.dss.stencilWriteMaskBack !== back.writeMask) {
                          gl.stencilMaskSeparate(gl.BACK, back.writeMask);
                          cache.dss.stencilWriteMaskBack = back.writeMask;
                        }

                        break;
                      }

                    case DynamicStateFlagBit.STENCIL_COMPARE_MASK:
                      {
                        var _front = dynamicStates.stencilStatesFront;
                        var _back = dynamicStates.stencilStatesBack;

                        if (cache.dss.stencilRefFront !== _front.reference || cache.dss.stencilReadMaskFront !== _front.compareMask) {
                          gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[cache.dss.stencilFuncFront], _front.reference, _front.compareMask);
                          cache.dss.stencilRefFront = _front.reference;
                          cache.dss.stencilReadMaskFront = _front.compareMask;
                        }

                        if (cache.dss.stencilRefBack !== _back.reference || cache.dss.stencilReadMaskBack !== _back.compareMask) {
                          gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[cache.dss.stencilFuncBack], _back.reference, _back.compareMask);
                          cache.dss.stencilRefBack = _back.reference;
                          cache.dss.stencilReadMaskBack = _back.compareMask;
                        }

                        break;
                      }
                  }
                }
              }
            }
            function WebGLCmdFuncDraw(device, drawInfo) {
              var gl = device.gl;
              var _device$extensions = device.extensions,
                  ia = _device$extensions.ANGLE_instanced_arrays,
                  md = _device$extensions.WEBGL_multi_draw;
              var gpuInputAssembler = gfxStateCache.gpuInputAssembler,
                  glPrimitive = gfxStateCache.glPrimitive;

              if (gpuInputAssembler) {
                var indexBuffer = gpuInputAssembler.gpuIndexBuffer;

                if (gpuInputAssembler.gpuIndirectBuffer) {
                  var indirects = gpuInputAssembler.gpuIndirectBuffer.indirects;

                  if (indirects.drawByIndex) {
                    for (var j = 0; j < indirects.drawCount; j++) {
                      indirects.byteOffsets[j] = indirects.offsets[j] * indexBuffer.stride;
                    }

                    if (md) {
                      if (indirects.instancedDraw) {
                        md.multiDrawElementsInstancedWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.instances, 0, indirects.drawCount);
                      } else {
                        md.multiDrawElementsWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.drawCount);
                      }
                    } else {
                      for (var _j5 = 0; _j5 < indirects.drawCount; _j5++) {
                        if (indirects.instances[_j5] && ia) {
                          ia.drawElementsInstancedANGLE(glPrimitive, indirects.counts[_j5], gpuInputAssembler.glIndexType, indirects.byteOffsets[_j5], indirects.instances[_j5]);
                        } else {
                          gl.drawElements(glPrimitive, indirects.counts[_j5], gpuInputAssembler.glIndexType, indirects.byteOffsets[_j5]);
                        }
                      }
                    }
                  } else if (md) {
                    if (indirects.instancedDraw) {
                      md.multiDrawArraysInstancedWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.instances, 0, indirects.drawCount);
                    } else {
                      md.multiDrawArraysWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.drawCount);
                    }
                  } else {
                    for (var _j6 = 0; _j6 < indirects.drawCount; _j6++) {
                      if (indirects.instances[_j6] && ia) {
                        ia.drawArraysInstancedANGLE(glPrimitive, indirects.offsets[_j6], indirects.counts[_j6], indirects.instances[_j6]);
                      } else {
                        gl.drawArrays(glPrimitive, indirects.offsets[_j6], indirects.counts[_j6]);
                      }
                    }
                  }
                } else if (drawInfo.instanceCount && ia) {
                  if (indexBuffer) {
                    if (drawInfo.indexCount > 0) {
                      var offset = drawInfo.firstIndex * indexBuffer.stride;
                      ia.drawElementsInstancedANGLE(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset, drawInfo.instanceCount);
                    }
                  } else if (drawInfo.vertexCount > 0) {
                    ia.drawArraysInstancedANGLE(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount, drawInfo.instanceCount);
                  }
                } else if (indexBuffer) {
                  if (drawInfo.indexCount > 0) {
                    var _offset = drawInfo.firstIndex * indexBuffer.stride;

                    gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
                  }
                } else if (drawInfo.vertexCount > 0) {
                  gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
                }
              }
            }
            var cmdIds = new Array(WebGLCmd.COUNT);
            function WebGLCmdFuncExecuteCmds(device, cmdPackage) {
              cmdIds.fill(0);

              for (var i = 0; i < cmdPackage.cmds.length; ++i) {
                var cmd = cmdPackage.cmds.array[i];
                var cmdId = cmdIds[cmd]++;

                switch (cmd) {
                  case WebGLCmd.BEGIN_RENDER_PASS:
                    {
                      var cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId];
                      WebGLCmdFuncBeginRenderPass(device, cmd0.gpuRenderPass, cmd0.gpuFramebuffer, cmd0.renderArea, cmd0.clearColors, cmd0.clearDepth, cmd0.clearStencil);
                      break;
                    }

                  case WebGLCmd.BIND_STATES:
                    {
                      var cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
                      WebGLCmdFuncBindStates(device, cmd2.gpuPipelineState, cmd2.gpuInputAssembler, cmd2.gpuDescriptorSets, cmd2.dynamicOffsets, cmd2.dynamicStates);
                      break;
                    }

                  case WebGLCmd.DRAW:
                    {
                      var cmd3 = cmdPackage.drawCmds.array[cmdId];
                      WebGLCmdFuncDraw(device, cmd3.drawInfo);
                      break;
                    }

                  case WebGLCmd.UPDATE_BUFFER:
                    {
                      var cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
                      WebGLCmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
                      break;
                    }

                  case WebGLCmd.COPY_BUFFER_TO_TEXTURE:
                    {
                      var cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
                      WebGLCmdFuncCopyBuffersToTexture(device, cmd5.buffers, cmd5.gpuTexture, cmd5.regions);
                      break;
                    }

                  case WebGLCmd.BLIT_TEXTURE:
                    {
                      var cmd6 = cmdPackage.blitTextureCmds.array[cmdId];
                      WebGLCmdFuncBlitTexture(device, cmd6.srcTexture, cmd6.dstTexture, cmd6.regions, cmd6.filter);
                      break;
                    }
                }
              }
            }
            function WebGLCmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
              var gl = device.gl;
              var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }

              var n = 0;
              var f = 0;

              switch (gpuTexture.glTarget) {
                case gl.TEXTURE_2D:
                  {
                    for (var i = 0; i < regions.length; i++) {
                      var region = regions[i];
                      gl.texSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                    }

                    break;
                  }

                case gl.TEXTURE_CUBE_MAP:
                  {
                    for (var _i19 = 0; _i19 < regions.length; _i19++) {
                      var _region = regions[_i19];
                      var fcount = _region.texSubres.baseArrayLayer + _region.texSubres.layerCount;

                      for (f = _region.texSubres.baseArrayLayer; f < fcount; ++f) {
                        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _region.texSubres.mipLevel, _region.texOffset.x, _region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported GL texture type, copy buffer to texture failed.');
                  }
              }

              if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP && gpuTexture.isPowerOf2) {
                gl.generateMipmap(gpuTexture.glTarget);
              }
            }
            var stagingBuffer = new Uint8Array(1);

            function pixelBufferPick(buffer, format, offset, stride, extent) {
              var blockHeight = formatAlignment(format).height;
              var bufferSize = FormatSize(format, extent.width, extent.height, extent.depth);
              var rowStride = FormatSize(format, stride.width, 1, 1);
              var sliceStride = FormatSize(format, stride.width, stride.height, 1);
              var chunkSize = FormatSize(format, extent.width, 1, 1);
              var ArrayBufferCtor = getTypedArrayConstructor(FormatInfos[format]);

              if (stagingBuffer.byteLength < bufferSize) {
                stagingBuffer = new Uint8Array(bufferSize);
              }

              var destOffset = 0;
              var bufferOffset = offset;

              for (var i = 0; i < extent.depth; i++) {
                bufferOffset = offset + sliceStride * i;

                for (var j = 0; j < extent.height; j += blockHeight) {
                  stagingBuffer.subarray(destOffset, destOffset + chunkSize).set(new Uint8Array(buffer.buffer, buffer.byteOffset + bufferOffset, chunkSize));
                  destOffset += chunkSize;
                  bufferOffset += rowStride;
                }
              }

              return new ArrayBufferCtor(stagingBuffer.buffer);
            }

            function WebGLCmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
              var gl = device.gl;
              var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }

              var n = 0;
              var f = 0;
              var fmtInfo = FormatInfos[gpuTexture.format];
              var ArrayBufferCtor = getTypedArrayConstructor(fmtInfo);
              var isCompressed = fmtInfo.isCompressed;
              var blockSize = formatAlignment(gpuTexture.format);
              var extent = new Extent();
              var offset = new Offset();
              var stride = new Extent();

              switch (gpuTexture.glTarget) {
                case gl.TEXTURE_2D:
                  {
                    for (var i = 0; i < regions.length; i++) {
                      var region = regions[i];
                      var mipLevel = region.texSubres.mipLevel;
                      offset.x = region.texOffset.x === 0 ? 0 : alignTo(region.texOffset.x, blockSize.width);
                      offset.y = region.texOffset.y === 0 ? 0 : alignTo(region.texOffset.y, blockSize.height);
                      extent.width = region.texExtent.width < blockSize.width ? region.texExtent.width : alignTo(region.texExtent.width, blockSize.width);
                      extent.height = region.texExtent.height < blockSize.height ? region.texExtent.width : alignTo(region.texExtent.height, blockSize.height);
                      stride.width = region.buffStride > 0 ? region.buffStride : extent.width;
                      stride.height = region.buffTexHeight > 0 ? region.buffTexHeight : extent.height;
                      var destWidth = region.texExtent.width + offset.x === gpuTexture.width >> mipLevel ? region.texExtent.width : extent.width;
                      var destHeight = region.texExtent.height + offset.y === gpuTexture.height >> mipLevel ? region.texExtent.height : extent.height;
                      var pixels = void 0;
                      var buffer = buffers[n++];

                      if (stride.width === extent.width && stride.height === extent.height) {
                        pixels = new ArrayBufferCtor(buffer.buffer, buffer.byteOffset + region.buffOffset);
                      } else {
                        pixels = pixelBufferPick(buffer, gpuTexture.format, region.buffOffset, stride, extent);
                      }

                      if (!isCompressed) {
                        gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, gpuTexture.glType, pixels);
                      } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL && !device.extensions.noCompressedTexSubImage2D) {
                        gl.compressedTexSubImage2D(gl.TEXTURE_2D, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, pixels);
                      } else {
                        gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, gpuTexture.glInternalFmt, destWidth, destHeight, 0, pixels);
                      }
                    }

                    break;
                  }

                case gl.TEXTURE_CUBE_MAP:
                  {
                    for (var _i20 = 0; _i20 < regions.length; _i20++) {
                      var _region2 = regions[_i20];
                      var _mipLevel = _region2.texSubres.mipLevel;
                      offset.x = _region2.texOffset.x === 0 ? 0 : alignTo(_region2.texOffset.x, blockSize.width);
                      offset.y = _region2.texOffset.y === 0 ? 0 : alignTo(_region2.texOffset.y, blockSize.height);
                      extent.width = _region2.texExtent.width < blockSize.width ? _region2.texExtent.width : alignTo(_region2.texExtent.width, blockSize.width);
                      extent.height = _region2.texExtent.height < blockSize.height ? _region2.texExtent.width : alignTo(_region2.texExtent.height, blockSize.height);
                      stride.width = _region2.buffStride > 0 ? _region2.buffStride : extent.width;
                      stride.height = _region2.buffTexHeight > 0 ? _region2.buffTexHeight : extent.height;

                      var _destWidth = _region2.texExtent.width + offset.x === gpuTexture.width >> _mipLevel ? _region2.texExtent.width : extent.width;

                      var _destHeight = _region2.texExtent.height + offset.y === gpuTexture.height >> _mipLevel ? _region2.texExtent.height : extent.height;

                      var fcount = _region2.texSubres.baseArrayLayer + _region2.texSubres.layerCount;

                      for (f = _region2.texSubres.baseArrayLayer; f < fcount; ++f) {
                        var _pixels = void 0;

                        var _buffer = buffers[n++];

                        if (stride.width === extent.width && stride.height === extent.height) {
                          _pixels = new ArrayBufferCtor(_buffer.buffer, _buffer.byteOffset + _region2.buffOffset);
                        } else {
                          _pixels = pixelBufferPick(_buffer, gpuTexture.format, _region2.buffOffset, stride, extent);
                        }

                        if (!isCompressed) {
                          gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _mipLevel, offset.x, offset.y, _destWidth, _destHeight, gpuTexture.glFormat, gpuTexture.glType, _pixels);
                        } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL && !device.extensions.noCompressedTexSubImage2D) {
                          gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _mipLevel, offset.x, offset.y, _destWidth, _destHeight, gpuTexture.glFormat, _pixels);
                        } else {
                          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _mipLevel, gpuTexture.glInternalFmt, _destWidth, _destHeight, 0, _pixels);
                        }
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported GL texture type, copy buffer to texture failed.');
                  }
              }

              if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP) {
                gl.generateMipmap(gpuTexture.glTarget);
              }
            }
            function WebGLCmdFuncCopyTextureToBuffers(device, gpuTexture, buffers, regions) {
              var gl = device.gl;
              var cache = device.stateCache;
              var framebuffer = gl.createFramebuffer();
              gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
              var x = 0;
              var y = 0;
              var w = 1;
              var h = 1;

              switch (gpuTexture.glTarget) {
                case gl.TEXTURE_2D:
                  {
                    for (var k = 0; k < regions.length; k++) {
                      var region = regions[k];
                      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gpuTexture.glTarget, gpuTexture.glTexture, region.texSubres.mipLevel);
                      x = region.texOffset.x;
                      y = region.texOffset.y;
                      w = region.texExtent.width;
                      h = region.texExtent.height;
                      gl.readPixels(x, y, w, h, gpuTexture.glFormat, gpuTexture.glType, buffers[k]);
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported GL texture type, copy texture to buffers failed.');
                  }
              }

              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              cache.glFramebuffer = null;
              gl.deleteFramebuffer(framebuffer);
            }
            function WebGLCmdFuncBlitTexture(device, srcTexture, dstTexture, regions, filter) {
              device.blitManager.draw(srcTexture, dstTexture, regions, filter);
            }

            var WebGLIndirectDrawInfos = function () {
              function WebGLIndirectDrawInfos() {
                this.counts = void 0;
                this.offsets = void 0;
                this.instances = void 0;
                this.drawCount = 0;
                this.drawByIndex = false;
                this.instancedDraw = false;
                this.byteOffsets = void 0;
                this._capacity = 4;
                this.counts = new Int32Array(this._capacity);
                this.offsets = new Int32Array(this._capacity);
                this.instances = new Int32Array(this._capacity);
                this.byteOffsets = new Int32Array(this._capacity);
              }

              var _proto = WebGLIndirectDrawInfos.prototype;

              _proto.clearDraws = function clearDraws() {
                this.drawCount = 0;
                this.drawByIndex = false;
                this.instancedDraw = false;
              };

              _proto.setDrawInfo = function setDrawInfo(idx, info) {
                this._ensureCapacity(idx);

                this.drawByIndex = info.indexCount > 0;
                this.instancedDraw = !!info.instanceCount;
                this.drawCount = Math.max(idx + 1, this.drawCount);

                if (this.drawByIndex) {
                  this.counts[idx] = info.indexCount;
                  this.offsets[idx] = info.firstIndex;
                } else {
                  this.counts[idx] = info.vertexCount;
                  this.offsets[idx] = info.firstVertex;
                }

                this.instances[idx] = Math.max(1, info.instanceCount);
              };

              _proto._ensureCapacity = function _ensureCapacity(target) {
                if (this._capacity > target) return;
                this._capacity = nextPow2(target);
                var counts = new Int32Array(this._capacity);
                var offsets = new Int32Array(this._capacity);
                var instances = new Int32Array(this._capacity);
                this.byteOffsets = new Int32Array(this._capacity);
                counts.set(this.counts);
                offsets.set(this.offsets);
                instances.set(this.instances);
                this.counts = counts;
                this.offsets = offsets;
                this.instances = instances;
              };

              return WebGLIndirectDrawInfos;
            }();
            var IWebGLBlitManager = function () {
              function IWebGLBlitManager() {
                this._gpuShader = null;
                this._gpuDescriptorSetLayout = null;
                this._gpuPipelineLayout = null;
                this._gpuPipelineState = null;
                this._gpuVertexBuffer = null;
                this._gpuInputAssembler = null;
                this._gpuPointSampler = null;
                this._gpuLinearSampler = null;
                this._gpuDescriptorSet = null;
                this._gpuUniformBuffer = null;
                this._drawInfo = null;
                this._glFramebuffer = null;
                this._uniformBuffer = null;
                var gl = WebGLDeviceManager.instance.gl;
                var device = WebGLDeviceManager.instance;
                var samplerOffset = device.bindingMappingInfo.maxBlockCounts[0];
                this._gpuShader = {
                  name: 'Blit Pass',
                  blocks: [new UniformBlock(0, 0, "BlitParams", [new Uniform("tilingOffsetSrc", Type$1.FLOAT4, 1), new Uniform("tilingOffsetDst", Type$1.FLOAT4, 1)], 1)],
                  samplerTextures: [new UniformSamplerTexture(0, samplerOffset, 'textureSrc', Type$1.SAMPLER2D, 1)],
                  subpassInputs: [],
                  gpuStages: [{
                    type: ShaderStageFlagBit.VERTEX,
                    source: "\n                    precision mediump float;\n\n                    attribute vec2 a_position;\n                    attribute vec2 a_texCoord;\n            \n                    uniform vec4 tilingOffsetSrc;\n                    uniform vec4 tilingOffsetDst;\n            \n                    varying vec2 v_texCoord;\n            \n                    void main() {\n                        v_texCoord = a_texCoord * tilingOffsetSrc.xy + tilingOffsetSrc.zw;\n                        gl_Position = vec4((a_position + 1.0) * tilingOffsetDst.xy - 1.0 + tilingOffsetDst.zw * 2.0, 0, 1);\n                    }",
                    glShader: null
                  }, {
                    type: ShaderStageFlagBit.FRAGMENT,
                    source: "\n                    precision mediump float;\n                    uniform sampler2D textureSrc;\n\n                    varying vec2 v_texCoord;\n                    \n                    void main() {\n                        gl_FragColor = texture2D(textureSrc, v_texCoord);\n                    }",
                    glShader: null
                  }],
                  glProgram: null,
                  glInputs: [],
                  glUniforms: [],
                  glBlocks: [],
                  glSamplerTextures: []
                };
                WebGLCmdFuncCreateShader(WebGLDeviceManager.instance, this._gpuShader);
                this._gpuDescriptorSetLayout = {
                  bindings: [new DescriptorSetLayoutBinding(0, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX), new DescriptorSetLayoutBinding(samplerOffset, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT)],
                  dynamicBindings: [],
                  descriptorIndices: [],
                  descriptorCount: samplerOffset + 1
                };

                for (var i = 0; i < samplerOffset; i++) {
                  this._gpuDescriptorSetLayout.descriptorIndices[i] = 0;
                }

                this._gpuDescriptorSetLayout.descriptorIndices.push(1);

                this._gpuPipelineLayout = {
                  gpuSetLayouts: [this._gpuDescriptorSetLayout],
                  dynamicOffsetCount: 0,
                  dynamicOffsetOffsets: [0],
                  dynamicOffsetIndices: [[]]
                };
                this._gpuPipelineState = {
                  glPrimitive: gl.TRIANGLE_STRIP,
                  gpuShader: this._gpuShader,
                  gpuPipelineLayout: this._gpuPipelineLayout,
                  rs: null,
                  dss: new DepthStencilState(false, false),
                  bs: null,
                  dynamicStates: [],
                  gpuRenderPass: null
                };
                this._gpuVertexBuffer = {
                  usage: BufferUsageBit.VERTEX,
                  memUsage: MemoryUsageBit.DEVICE,
                  size: 16 * Float32Array.BYTES_PER_ELEMENT,
                  stride: 4 * Float32Array.BYTES_PER_ELEMENT,
                  buffer: null,
                  vf32: null,
                  indirects: new WebGLIndirectDrawInfos(),
                  glTarget: 0,
                  glBuffer: null
                };
                WebGLCmdFuncCreateBuffer(WebGLDeviceManager.instance, this._gpuVertexBuffer);
                WebGLDeviceManager.instance.memoryStatus.bufferSize += this._gpuVertexBuffer.size;
                var data = new Float32Array([-1.0, -1.0, 0.0, 0.0, 1.0, -1.0, 1.0, 0.0, -1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0]);
                WebGLCmdFuncUpdateBuffer(WebGLDeviceManager.instance, this._gpuVertexBuffer, data, 0, data.length);
                this._gpuInputAssembler = {
                  attributes: [new Attribute("a_position", Format.RG32F), new Attribute("a_texCoord", Format.RG32F)],
                  gpuVertexBuffers: [this._gpuVertexBuffer],
                  gpuIndexBuffer: null,
                  gpuIndirectBuffer: null,
                  glAttribs: [],
                  glIndexType: 0,
                  glVAOs: new Map()
                };
                WebGLCmdFuncCreateInputAssember(WebGLDeviceManager.instance, this._gpuInputAssembler);
                this._gpuPointSampler = {
                  glMinFilter: 0x2600,
                  glMagFilter: 0x2600,
                  glWrapS: 0x2901,
                  glWrapT: 0x2901,
                  glWrapR: 0x2901
                };
                this._gpuLinearSampler = {
                  glMinFilter: 0x2601,
                  glMagFilter: 0x2601,
                  glWrapS: 0x2901,
                  glWrapT: 0x2901,
                  glWrapR: 0x2901
                };
                this._uniformBuffer = new Float32Array(8);
                this._gpuUniformBuffer = {
                  usage: BufferUsageBit.UNIFORM,
                  memUsage: MemoryUsageBit.DEVICE,
                  size: 8 * Float32Array.BYTES_PER_ELEMENT,
                  stride: 8 * Float32Array.BYTES_PER_ELEMENT,
                  buffer: this._uniformBuffer,
                  vf32: null,
                  indirects: new WebGLIndirectDrawInfos(),
                  glTarget: 0,
                  glBuffer: null
                };
                WebGLCmdFuncCreateBuffer(WebGLDeviceManager.instance, this._gpuUniformBuffer);
                WebGLDeviceManager.instance.memoryStatus.bufferSize += this._gpuUniformBuffer.size;
                this._gpuDescriptorSet = {
                  gpuDescriptors: [{
                    type: DescriptorType.UNIFORM_BUFFER,
                    gpuBuffer: this._gpuUniformBuffer,
                    gpuTexture: null,
                    gpuSampler: null
                  }, {
                    type: DescriptorType.SAMPLER_TEXTURE,
                    gpuBuffer: null,
                    gpuTexture: null,
                    gpuSampler: null
                  }],
                  descriptorIndices: this._gpuDescriptorSetLayout.descriptorIndices
                };
                this._drawInfo = new DrawInfo(4, 0, 0, 0, 0, 0, 0);
                this._glFramebuffer = WebGLDeviceManager.instance.gl.createFramebuffer();
              }

              var _proto2 = IWebGLBlitManager.prototype;

              _proto2.destroy = function destroy() {
                if (this._glFramebuffer) {
                  WebGLDeviceManager.instance.gl.deleteFramebuffer(this._glFramebuffer);
                  this._glFramebuffer = null;
                }

                if (this._gpuVertexBuffer) {
                  WebGLDeviceManager.instance.memoryStatus.bufferSize -= this._gpuVertexBuffer.size;
                  WebGLCmdFuncDestroyBuffer(WebGLDeviceManager.instance, this._gpuVertexBuffer);
                }

                if (this._gpuUniformBuffer) {
                  WebGLDeviceManager.instance.memoryStatus.bufferSize -= this._gpuUniformBuffer.size;
                  WebGLCmdFuncDestroyBuffer(WebGLDeviceManager.instance, this._gpuUniformBuffer);
                }

                if (this._gpuShader) {
                  WebGLCmdFuncDestroyShader(WebGLDeviceManager.instance, this._gpuShader);
                }

                if (this._gpuInputAssembler) {
                  WebGLCmdFuncDestroyInputAssembler(WebGLDeviceManager.instance, this._gpuInputAssembler);
                }
              };

              _proto2.draw = function draw(gpuTextureSrc, gpuTextureDst, regions, filter) {
                var device = WebGLDeviceManager.instance;
                var gl = device.gl;
                var stateCache = device.stateCache;
                var origFramebuffer = stateCache.glFramebuffer;
                gl.viewport(0, 0, gpuTextureDst.width, gpuTextureDst.height);
                gl.scissor(0, 0, gpuTextureDst.width, gpuTextureDst.height);

                if (!this._uniformBuffer || !this._gpuUniformBuffer || !this._gpuPipelineState || !this._gpuInputAssembler || !this._gpuDescriptorSet || !this._drawInfo) {
                  return;
                }

                var descriptor = this._gpuDescriptorSet.gpuDescriptors[1];
                descriptor.gpuTexture = gpuTextureSrc;
                descriptor.gpuSampler = filter === Filter.POINT ? this._gpuPointSampler : this._gpuLinearSampler;
                var formatInfo = FormatInfos[gpuTextureDst.format];
                var attachment = gl.COLOR_ATTACHMENT0;

                if (formatInfo.hasStencil) {
                  attachment = gl.DEPTH_STENCIL_ATTACHMENT;
                } else if (formatInfo.hasDepth) {
                  attachment = gl.DEPTH_ATTACHMENT;
                }

                var regionIndices = regions.map(function (_, i) {
                  return i;
                });
                regionIndices.sort(function (a, b) {
                  return regions[a].srcSubres.mipLevel - regions[b].srcSubres.mipLevel;
                });

                if (stateCache.glFramebuffer !== this._glFramebuffer) {
                  device.gl.bindFramebuffer(device.gl.FRAMEBUFFER, this._glFramebuffer);
                  stateCache.glFramebuffer = this._glFramebuffer;
                }

                var mipLevel = regions[0].dstSubres.mipLevel;

                if (gpuTextureDst.glTexture) {
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gpuTextureDst.glTarget, gpuTextureDst.glTexture, mipLevel);
                } else {
                  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, gpuTextureDst.glRenderbuffer);
                }

                for (var i = 0; i < regionIndices.length; ++i) {
                  var region = regions[regionIndices[i]];

                  if (gpuTextureSrc.glTexture && mipLevel !== region.srcSubres.mipLevel) {
                    mipLevel = region.srcSubres.mipLevel;
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gpuTextureDst.glTarget, gpuTextureDst.glTexture, mipLevel);
                  }

                  var srcWidth = gpuTextureSrc.width;
                  var srcHeight = gpuTextureSrc.height;
                  var dstWidth = gpuTextureDst.width;
                  var dstHeight = gpuTextureDst.height;
                  this._uniformBuffer[0] = region.srcExtent.width / srcWidth;
                  this._uniformBuffer[1] = region.srcExtent.height / srcHeight;
                  this._uniformBuffer[2] = region.srcOffset.x / srcWidth;
                  this._uniformBuffer[3] = region.srcOffset.y / srcHeight;
                  this._uniformBuffer[4] = region.dstExtent.width / dstWidth;
                  this._uniformBuffer[5] = region.dstExtent.height / dstHeight;
                  this._uniformBuffer[6] = region.dstOffset.x / dstWidth;
                  this._uniformBuffer[7] = region.dstOffset.y / dstHeight;
                  WebGLCmdFuncUpdateBuffer(device, this._gpuUniformBuffer, this._uniformBuffer, 0, this._uniformBuffer.length * Float32Array.BYTES_PER_ELEMENT);
                  WebGLCmdFuncBindStates(device, this._gpuPipelineState, this._gpuInputAssembler, [this._gpuDescriptorSet], [], null);
                  WebGLCmdFuncDraw(device, this._drawInfo);
                }

                if (stateCache.glFramebuffer !== origFramebuffer) {
                  device.gl.bindFramebuffer(device.gl.FRAMEBUFFER, origFramebuffer);
                  stateCache.glFramebuffer = origFramebuffer;
                }

                var origViewport = stateCache.viewport;
                gl.viewport(origViewport.left, origViewport.top, origViewport.width, origViewport.height);
                var origScissor = stateCache.scissorRect;
                gl.scissor(origScissor.x, origScissor.y, origScissor.width, origScissor.height);
              };

              return IWebGLBlitManager;
            }();

            var WebGLBuffer = function (_Buffer) {
              _inheritsLoose(WebGLBuffer, _Buffer);

              function WebGLBuffer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Buffer.call.apply(_Buffer, [this].concat(args)) || this;
                _this._gpuBuffer = null;
                _this._gpuBufferView = null;
                _this._uniformBuffer = null;
                return _this;
              }

              var _proto = WebGLBuffer.prototype;

              _proto.initialize = function initialize(info) {
                if ('buffer' in info) {
                  this._isBufferView = true;
                  var buffer = info.buffer;
                  this._usage = buffer.usage;
                  this._memUsage = buffer.memUsage;
                  this._size = this._stride = info.range;
                  this._count = 1;
                  this._flags = buffer.flags;
                  this._gpuBufferView = {
                    gpuBuffer: buffer.gpuBuffer,
                    offset: info.offset,
                    range: info.range
                  };
                } else {
                  this._usage = info.usage;
                  this._memUsage = info.memUsage;
                  this._size = info.size;
                  this._stride = Math.max(info.stride || this._size, 1);
                  this._count = this._size / this._stride;
                  this._flags = info.flags;

                  if (this._usage & BufferUsageBit.UNIFORM && this._size > 0) {
                    this._uniformBuffer = new Uint8Array(this._size);
                  }

                  this._gpuBuffer = {
                    usage: this._usage,
                    memUsage: this._memUsage,
                    size: this._size,
                    stride: this._stride,
                    buffer: null,
                    vf32: null,
                    indirects: new WebGLIndirectDrawInfos(),
                    glTarget: 0,
                    glBuffer: null
                  };

                  if (this._usage & BufferUsageBit.UNIFORM) {
                    this._gpuBuffer.buffer = this._uniformBuffer;
                  }

                  WebGLCmdFuncCreateBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
                  WebGLDeviceManager.instance.memoryStatus.bufferSize += this._size;
                }
              };

              _proto.destroy = function destroy() {
                if (this._gpuBuffer) {
                  WebGLCmdFuncDestroyBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
                  WebGLDeviceManager.instance.memoryStatus.bufferSize -= this._size;
                  this._gpuBuffer = null;
                }

                if (this._gpuBufferView) {
                  this._gpuBufferView = null;
                }
              };

              _proto.resize = function resize(size) {
                if (this._isBufferView) {
                  console.warn('cannot resize buffer views!');
                  return;
                }

                var oldSize = this._size;

                if (oldSize === size) {
                  return;
                }

                this._size = size;
                this._count = this._size / this._stride;

                if (this._uniformBuffer) {
                  this._uniformBuffer = new Uint8Array(size);
                }

                if (this._gpuBuffer) {
                  if (this._uniformBuffer) {
                    this._gpuBuffer.buffer = this._uniformBuffer;
                  }

                  this._gpuBuffer.size = size;

                  if (size > 0) {
                    WebGLCmdFuncResizeBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
                    WebGLDeviceManager.instance.memoryStatus.bufferSize -= oldSize;
                    WebGLDeviceManager.instance.memoryStatus.bufferSize += size;
                  }
                }
              };

              _proto.update = function update(buffer, size) {
                if (this._isBufferView) {
                  console.warn('cannot update through buffer views!');
                  return;
                }

                var buffSize;

                if (size !== undefined) {
                  buffSize = size;
                } else if (this._usage & BufferUsageBit.INDIRECT) {
                  buffSize = 0;
                } else {
                  buffSize = buffer.byteLength;
                }

                WebGLCmdFuncUpdateBuffer(WebGLDeviceManager.instance, this._gpuBuffer, buffer, 0, buffSize);
              };

              _createClass(WebGLBuffer, [{
                key: "gpuBuffer",
                get: function get() {
                  return this._gpuBuffer;
                }
              }, {
                key: "gpuBufferView",
                get: function get() {
                  return this._gpuBufferView;
                }
              }]);

              return WebGLBuffer;
            }(Buffer);

            var WebGLCommandPool = function () {
              function WebGLCommandPool(Clazz, count) {
                this._frees = void 0;
                this._freeIdx = 0;
                this._freeCmds = void 0;
                this._frees = new Array(count);
                this._freeCmds = new CachedArray(count);

                for (var i = 0; i < count; ++i) {
                  this._frees[i] = new Clazz();
                }

                this._freeIdx = count - 1;
              }

              var _proto = WebGLCommandPool.prototype;

              _proto.alloc = function alloc(Clazz) {
                if (this._freeIdx < 0) {
                  var size = this._frees.length * 2;
                  var temp = this._frees;
                  this._frees = new Array(size);
                  var increase = size - temp.length;

                  for (var i = 0; i < increase; ++i) {
                    this._frees[i] = new Clazz();
                  }

                  for (var _i = increase, j = 0; _i < size; ++_i, ++j) {
                    this._frees[_i] = temp[j];
                  }

                  this._freeIdx += increase;
                }

                var cmd = this._frees[this._freeIdx];
                this._frees[this._freeIdx--] = null;
                ++cmd.refCount;
                return cmd;
              };

              _proto.free = function free(cmd) {
                if (--cmd.refCount === 0) {
                  this._freeCmds.push(cmd);
                }
              };

              _proto.freeCmds = function freeCmds(cmds) {
                for (var i = 0; i < cmds.length; ++i) {
                  if (--cmds.array[i].refCount === 0) {
                    this._freeCmds.push(cmds.array[i]);
                  }
                }
              };

              _proto.release = function release() {
                for (var i = 0; i < this._freeCmds.length; ++i) {
                  var cmd = this._freeCmds.array[i];
                  cmd.clear();
                  this._frees[++this._freeIdx] = cmd;
                }

                this._freeCmds.clear();
              };

              return WebGLCommandPool;
            }();
            var WebGLCommandAllocator = function () {
              function WebGLCommandAllocator() {
                this.beginRenderPassCmdPool = void 0;
                this.bindStatesCmdPool = void 0;
                this.drawCmdPool = void 0;
                this.updateBufferCmdPool = void 0;
                this.copyBufferToTextureCmdPool = void 0;
                this.blitTextureCmdPool = void 0;
                this.beginRenderPassCmdPool = new WebGLCommandPool(WebGLCmdBeginRenderPass, 1);
                this.bindStatesCmdPool = new WebGLCommandPool(WebGLCmdBindStates, 1);
                this.drawCmdPool = new WebGLCommandPool(WebGLCmdDraw, 1);
                this.updateBufferCmdPool = new WebGLCommandPool(WebGLCmdUpdateBuffer, 1);
                this.copyBufferToTextureCmdPool = new WebGLCommandPool(WebGLCmdCopyBufferToTexture, 1);
                this.blitTextureCmdPool = new WebGLCommandPool(WebGLCmdBlitTexture, 1);
              }

              var _proto2 = WebGLCommandAllocator.prototype;

              _proto2.clearCmds = function clearCmds(cmdPackage) {
                if (cmdPackage.beginRenderPassCmds.length) {
                  this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds);
                  cmdPackage.beginRenderPassCmds.clear();
                }

                if (cmdPackage.bindStatesCmds.length) {
                  this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds);
                  cmdPackage.bindStatesCmds.clear();
                }

                if (cmdPackage.drawCmds.length) {
                  this.drawCmdPool.freeCmds(cmdPackage.drawCmds);
                  cmdPackage.drawCmds.clear();
                }

                if (cmdPackage.updateBufferCmds.length) {
                  this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds);
                  cmdPackage.updateBufferCmds.clear();
                }

                if (cmdPackage.copyBufferToTextureCmds.length) {
                  this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds);
                  cmdPackage.copyBufferToTextureCmds.clear();
                }

                if (cmdPackage.blitTextureCmds.length) {
                  this.blitTextureCmdPool.freeCmds(cmdPackage.blitTextureCmds);
                  cmdPackage.blitTextureCmds.clear();
                }

                cmdPackage.cmds.clear();
              };

              _proto2.releaseCmds = function releaseCmds() {
                this.beginRenderPassCmdPool.release();
                this.bindStatesCmdPool.release();
                this.drawCmdPool.release();
                this.updateBufferCmdPool.release();
                this.copyBufferToTextureCmdPool.release();
                this.blitTextureCmdPool.release();
              };

              return WebGLCommandAllocator;
            }();

            var WebGLCommandBuffer = function (_CommandBuffer) {
              _inheritsLoose(WebGLCommandBuffer, _CommandBuffer);

              function WebGLCommandBuffer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _CommandBuffer.call.apply(_CommandBuffer, [this].concat(args)) || this;
                _this.cmdPackage = new WebGLCmdPackage();
                _this._cmdAllocator = new WebGLCommandAllocator();
                _this._isInRenderPass = false;
                _this._curGPUPipelineState = null;
                _this._curGPUInputAssembler = null;
                _this._curGPUDescriptorSets = [];
                _this._curDynamicOffsets = Array(8).fill(0);
                _this._curDynamicStates = new DynamicStates();
                _this._isStateInvalied = false;
                return _this;
              }

              var _proto = WebGLCommandBuffer.prototype;

              _proto.initialize = function initialize(info) {
                this._type = info.type;
                this._queue = info.queue;
                var setCount = WebGLDeviceManager.instance.bindingMappings.blockOffsets.length;

                for (var i = 0; i < setCount; i++) {
                  this._curGPUDescriptorSets.push(null);
                }
              };

              _proto.destroy = function destroy() {
                this._cmdAllocator.clearCmds(this.cmdPackage);
              };

              _proto.begin = function begin(renderPass, subpass, frameBuffer) {

                this._cmdAllocator.clearCmds(this.cmdPackage);

                this._curGPUPipelineState = null;
                this._curGPUInputAssembler = null;
                this._curGPUDescriptorSets.length = 0;
                this._numDrawCalls = 0;
                this._numInstances = 0;
                this._numTris = 0;
              };

              _proto.end = function end() {
                if (this._isStateInvalied) {
                  this.bindStates();
                }

                this._isInRenderPass = false;
              };

              _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
                var cmd = this._cmdAllocator.beginRenderPassCmdPool.alloc(WebGLCmdBeginRenderPass);

                cmd.gpuRenderPass = renderPass.gpuRenderPass;
                cmd.gpuFramebuffer = framebuffer.gpuFramebuffer;
                cmd.renderArea.copy(renderArea);
                cmd.clearColors.length = clearColors.length;

                for (var i = 0; i < clearColors.length; ++i) {
                  cmd.clearColors[i] = clearColors[i];
                }

                cmd.clearDepth = clearDepth;
                cmd.clearStencil = clearStencil;
                this.cmdPackage.beginRenderPassCmds.push(cmd);
                this.cmdPackage.cmds.push(WebGLCmd.BEGIN_RENDER_PASS);
                this._isInRenderPass = true;
              };

              _proto.endRenderPass = function endRenderPass() {
                this._isInRenderPass = false;
              };

              _proto.bindPipelineState = function bindPipelineState(pipelineState) {
                var gpuPipelineState = pipelineState.gpuPipelineState;

                if (gpuPipelineState !== this._curGPUPipelineState) {
                  this._curGPUPipelineState = gpuPipelineState;
                  this._isStateInvalied = true;
                }
              };

              _proto.bindDescriptorSet = function bindDescriptorSet(set, descriptorSet, dynamicOffsets) {
                var gpuDescriptorSet = descriptorSet.gpuDescriptorSet;

                if (gpuDescriptorSet !== this._curGPUDescriptorSets[set]) {
                  this._curGPUDescriptorSets[set] = gpuDescriptorSet;
                  this._isStateInvalied = true;
                }

                if (dynamicOffsets) {
                  var _this$_curGPUPipeline;

                  var gpuPipelineLayout = (_this$_curGPUPipeline = this._curGPUPipelineState) === null || _this$_curGPUPipeline === void 0 ? void 0 : _this$_curGPUPipeline.gpuPipelineLayout;

                  if (gpuPipelineLayout) {
                    var offsets = this._curDynamicOffsets;
                    var idx = gpuPipelineLayout.dynamicOffsetOffsets[set];

                    for (var i = 0; i < dynamicOffsets.length; i++) {
                      offsets[idx + i] = dynamicOffsets[i];
                    }

                    this._isStateInvalied = true;
                  }
                }
              };

              _proto.bindInputAssembler = function bindInputAssembler(inputAssembler) {
                var gpuInputAssembler = inputAssembler.gpuInputAssembler;
                this._curGPUInputAssembler = gpuInputAssembler;
                this._isStateInvalied = true;
              };

              _proto.setViewport = function setViewport(viewport) {
                var cache = this._curDynamicStates.viewport;

                if (cache.left !== viewport.left || cache.top !== viewport.top || cache.width !== viewport.width || cache.height !== viewport.height || cache.minDepth !== viewport.minDepth || cache.maxDepth !== viewport.maxDepth) {
                  cache.left = viewport.left;
                  cache.top = viewport.top;
                  cache.width = viewport.width;
                  cache.height = viewport.height;
                  cache.minDepth = viewport.minDepth;
                  cache.maxDepth = viewport.maxDepth;
                  this._isStateInvalied = true;
                }
              };

              _proto.setScissor = function setScissor(scissor) {
                var cache = this._curDynamicStates.scissor;

                if (cache.x !== scissor.x || cache.y !== scissor.y || cache.width !== scissor.width || cache.height !== scissor.height) {
                  cache.x = scissor.x;
                  cache.y = scissor.y;
                  cache.width = scissor.width;
                  cache.height = scissor.height;
                  this._isStateInvalied = true;
                }
              };

              _proto.setLineWidth = function setLineWidth(lineWidth) {
                if (this._curDynamicStates.lineWidth !== lineWidth) {
                  this._curDynamicStates.lineWidth = lineWidth;
                  this._isStateInvalied = true;
                }
              };

              _proto.setDepthBias = function setDepthBias(depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor) {
                var cache = this._curDynamicStates;

                if (cache.depthBiasConstant !== depthBiasConstantFactor || cache.depthBiasClamp !== depthBiasClamp || cache.depthBiasSlope !== depthBiasSlopeFactor) {
                  cache.depthBiasConstant = depthBiasConstantFactor;
                  cache.depthBiasClamp = depthBiasClamp;
                  cache.depthBiasSlope = depthBiasSlopeFactor;
                  this._isStateInvalied = true;
                }
              };

              _proto.setBlendConstants = function setBlendConstants(blendConstants) {
                var cache = this._curDynamicStates.blendConstant;

                if (cache.x !== blendConstants.x || cache.y !== blendConstants.y || cache.z !== blendConstants.z || cache.w !== blendConstants.w) {
                  cache.copy(blendConstants);
                  this._isStateInvalied = true;
                }
              };

              _proto.setDepthBound = function setDepthBound(minDepthBounds, maxDepthBounds) {
                var cache = this._curDynamicStates;

                if (cache.depthMinBounds !== minDepthBounds || cache.depthMaxBounds !== maxDepthBounds) {
                  cache.depthMinBounds = minDepthBounds;
                  cache.depthMaxBounds = maxDepthBounds;
                  this._isStateInvalied = true;
                }
              };

              _proto.setStencilWriteMask = function setStencilWriteMask(face, writeMask) {
                var front = this._curDynamicStates.stencilStatesFront;
                var back = this._curDynamicStates.stencilStatesBack;

                if (face & StencilFace.FRONT) {
                  if (front.writeMask !== writeMask) {
                    front.writeMask = writeMask;
                    this._isStateInvalied = true;
                  }
                }

                if (face & StencilFace.BACK) {
                  if (back.writeMask !== writeMask) {
                    back.writeMask = writeMask;
                    this._isStateInvalied = true;
                  }
                }
              };

              _proto.setStencilCompareMask = function setStencilCompareMask(face, reference, compareMask) {
                var front = this._curDynamicStates.stencilStatesFront;
                var back = this._curDynamicStates.stencilStatesBack;

                if (face & StencilFace.FRONT) {
                  if (front.compareMask !== compareMask || front.reference !== reference) {
                    front.reference = reference;
                    front.compareMask = compareMask;
                    this._isStateInvalied = true;
                  }
                }

                if (face & StencilFace.BACK) {
                  if (back.compareMask !== compareMask || back.reference !== reference) {
                    back.reference = reference;
                    back.compareMask = compareMask;
                    this._isStateInvalied = true;
                  }
                }
              };

              _proto.draw = function draw(infoOrAssembler) {
                if (this._type === CommandBufferType.PRIMARY && this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  if (this._isStateInvalied) {
                    this.bindStates();
                  }

                  var info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;

                  var cmd = this._cmdAllocator.drawCmdPool.alloc(WebGLCmdDraw);

                  cmd.drawInfo.copy(info);
                  this.cmdPackage.drawCmds.push(cmd);
                  this.cmdPackage.cmds.push(WebGLCmd.DRAW);
                  ++this._numDrawCalls;
                  this._numInstances += info.instanceCount;
                  var indexCount = info.indexCount || info.vertexCount;

                  if (this._curGPUPipelineState) {
                    var glPrimitive = this._curGPUPipelineState.glPrimitive;

                    switch (glPrimitive) {
                      case 0x0004:
                        {
                          this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                          break;
                        }

                      case 0x0005:
                      case 0x0006:
                        {
                          this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                          break;
                        }
                    }
                  }
                } else {
                  console.error('Command \'draw\' must be recorded inside a render pass.');
                }
              };

              _proto.updateBuffer = function updateBuffer(buffer, data, size) {
                if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  var gpuBuffer = buffer.gpuBuffer;

                  if (gpuBuffer) {
                    var cmd = this._cmdAllocator.updateBufferCmdPool.alloc(WebGLCmdUpdateBuffer);

                    var buffSize = 0;
                    var buff = null;

                    if (buffer.usage & BufferUsageBit.INDIRECT) {
                      buff = data;
                    } else {
                      if (size !== undefined) {
                        buffSize = size;
                      } else {
                        buffSize = data.byteLength;
                      }

                      buff = data;
                    }

                    cmd.gpuBuffer = gpuBuffer;
                    cmd.buffer = buff;
                    cmd.offset = 0;
                    cmd.size = buffSize;
                    this.cmdPackage.updateBufferCmds.push(cmd);
                    this.cmdPackage.cmds.push(WebGLCmd.UPDATE_BUFFER);
                  }
                } else {
                  console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
                }
              };

              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  var gpuTexture = texture.gpuTexture;

                  if (gpuTexture) {
                    var cmd = this._cmdAllocator.copyBufferToTextureCmdPool.alloc(WebGLCmdCopyBufferToTexture);

                    if (cmd) {
                      cmd.gpuTexture = gpuTexture;
                      cmd.regions = regions;
                      cmd.buffers = buffers;
                      this.cmdPackage.copyBufferToTextureCmds.push(cmd);
                      this.cmdPackage.cmds.push(WebGLCmd.COPY_BUFFER_TO_TEXTURE);
                    }
                  }
                } else {
                  console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
                }
              };

              _proto.execute = function execute(cmdBuffs, count) {
                for (var i = 0; i < count; ++i) {
                  var webGLCmdBuff = cmdBuffs[i];

                  for (var c = 0; c < webGLCmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
                    var cmd = webGLCmdBuff.cmdPackage.beginRenderPassCmds.array[c];
                    ++cmd.refCount;
                    this.cmdPackage.beginRenderPassCmds.push(cmd);
                  }

                  for (var _c = 0; _c < webGLCmdBuff.cmdPackage.bindStatesCmds.length; ++_c) {
                    var _cmd = webGLCmdBuff.cmdPackage.bindStatesCmds.array[_c];
                    ++_cmd.refCount;
                    this.cmdPackage.bindStatesCmds.push(_cmd);
                  }

                  for (var _c2 = 0; _c2 < webGLCmdBuff.cmdPackage.drawCmds.length; ++_c2) {
                    var _cmd2 = webGLCmdBuff.cmdPackage.drawCmds.array[_c2];
                    ++_cmd2.refCount;
                    this.cmdPackage.drawCmds.push(_cmd2);
                  }

                  for (var _c3 = 0; _c3 < webGLCmdBuff.cmdPackage.updateBufferCmds.length; ++_c3) {
                    var _cmd3 = webGLCmdBuff.cmdPackage.updateBufferCmds.array[_c3];
                    ++_cmd3.refCount;
                    this.cmdPackage.updateBufferCmds.push(_cmd3);
                  }

                  for (var _c4 = 0; _c4 < webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++_c4) {
                    var _cmd4 = webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.array[_c4];
                    ++_cmd4.refCount;
                    this.cmdPackage.copyBufferToTextureCmds.push(_cmd4);
                  }

                  for (var _c5 = 0; _c5 < webGLCmdBuff.cmdPackage.blitTextureCmds.length; ++_c5) {
                    var _cmd5 = webGLCmdBuff.cmdPackage.blitTextureCmds.array[_c5];
                    ++_cmd5.refCount;
                    this.cmdPackage.blitTextureCmds.push(_cmd5);
                  }

                  this.cmdPackage.cmds.concat(webGLCmdBuff.cmdPackage.cmds.array);
                  this._numDrawCalls += webGLCmdBuff._numDrawCalls;
                  this._numInstances += webGLCmdBuff._numInstances;
                  this._numTris += webGLCmdBuff._numTris;
                }
              };

              _proto.pipelineBarrier = function pipelineBarrier(GeneralBarrier, bufferBarriers, buffers, textureBarriers, textures) {};

              _proto.bindStates = function bindStates() {
                var bindStatesCmd = this._cmdAllocator.bindStatesCmdPool.alloc(WebGLCmdBindStates);

                if (bindStatesCmd) {
                  bindStatesCmd.gpuPipelineState = this._curGPUPipelineState;
                  Array.prototype.push.apply(bindStatesCmd.gpuDescriptorSets, this._curGPUDescriptorSets);
                  Array.prototype.push.apply(bindStatesCmd.dynamicOffsets, this._curDynamicOffsets);
                  bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler;
                  bindStatesCmd.dynamicStates.copy(this._curDynamicStates);
                  this.cmdPackage.bindStatesCmds.push(bindStatesCmd);
                  this.cmdPackage.cmds.push(WebGLCmd.BIND_STATES);
                  this._isStateInvalied = false;
                }
              };

              _proto.blitTexture = function blitTexture(srcTexture, dstTexture, regions, filter) {
                var blitTextureCmd = this._cmdAllocator.blitTextureCmdPool.alloc(WebGLCmdBlitTexture);

                blitTextureCmd.srcTexture = srcTexture.gpuTexture;
                blitTextureCmd.dstTexture = dstTexture.gpuTexture;
                blitTextureCmd.regions = regions;
                blitTextureCmd.filter = filter;
                ++this._numDrawCalls;
                this.cmdPackage.blitTextureCmds.push(blitTextureCmd);
                this.cmdPackage.cmds.push(WebGLCmd.BLIT_TEXTURE);
              };

              return WebGLCommandBuffer;
            }(CommandBuffer);

            var WebGLFramebuffer = function (_Framebuffer) {
              _inheritsLoose(WebGLFramebuffer, _Framebuffer);

              function WebGLFramebuffer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Framebuffer.call.apply(_Framebuffer, [this].concat(args)) || this;
                _this._gpuFramebuffer = null;
                return _this;
              }

              var _proto = WebGLFramebuffer.prototype;

              _proto.initialize = function initialize(info) {
                this._renderPass = info.renderPass;
                this._colorTextures = info.colorTextures || [];
                this._depthStencilTexture = info.depthStencilTexture || null;
                var lodLevel = 0;
                var gpuColorTextures = [];

                for (var i = 0; i < info.colorTextures.length; ++i) {
                  var colorTexture = info.colorTextures[i];

                  if (colorTexture) {
                    gpuColorTextures.push(colorTexture.gpuTexture);
                    lodLevel = colorTexture.lodLevel;
                  }
                }

                var gpuDepthStencilTexture = null;

                if (info.depthStencilTexture) {
                  gpuDepthStencilTexture = info.depthStencilTexture.gpuTexture;
                  lodLevel = info.depthStencilTexture.lodLevel;
                }

                var width = Number.MAX_SAFE_INTEGER;
                var height = Number.MAX_SAFE_INTEGER;
                this._gpuFramebuffer = {
                  gpuRenderPass: info.renderPass.gpuRenderPass,
                  gpuColorTextures: gpuColorTextures,
                  gpuDepthStencilTexture: gpuDepthStencilTexture,
                  glFramebuffer: null,
                  isOffscreen: true,

                  get width() {
                    return this.isOffscreen ? width : this.gpuColorTextures[0].width;
                  },

                  set width(val) {
                    width = val;
                  },

                  get height() {
                    return this.isOffscreen ? height : this.gpuColorTextures[0].height;
                  },

                  set height(val) {
                    height = val;
                  },

                  lodLevel: lodLevel
                };
                WebGLCmdFuncCreateFramebuffer(WebGLDeviceManager.instance, this._gpuFramebuffer);
              };

              _proto.destroy = function destroy() {
                if (this._gpuFramebuffer) {
                  WebGLCmdFuncDestroyFramebuffer(WebGLDeviceManager.instance, this._gpuFramebuffer);
                  this._gpuFramebuffer = null;
                }
              };

              _createClass(WebGLFramebuffer, [{
                key: "gpuFramebuffer",
                get: function get() {
                  return this._gpuFramebuffer;
                }
              }]);

              return WebGLFramebuffer;
            }(Framebuffer);

            var WebGLInputAssembler = function (_InputAssembler) {
              _inheritsLoose(WebGLInputAssembler, _InputAssembler);

              function WebGLInputAssembler() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _InputAssembler.call.apply(_InputAssembler, [this].concat(args)) || this;
                _this._gpuInputAssembler = null;
                return _this;
              }

              var _proto = WebGLInputAssembler.prototype;

              _proto.initialize = function initialize(info) {
                if (info.vertexBuffers.length === 0) {
                  console.error('InputAssemblerInfo.vertexBuffers is null.');
                  return;
                }

                this._attributes = info.attributes;
                this._attributesHash = this.computeAttributesHash();
                this._vertexBuffers = info.vertexBuffers;

                if (info.indexBuffer) {
                  this._indexBuffer = info.indexBuffer;
                  this._drawInfo.indexCount = this._indexBuffer.size / this._indexBuffer.stride;
                  this._drawInfo.firstIndex = 0;
                } else {
                  var vertBuff = this._vertexBuffers[0];
                  this._drawInfo.vertexCount = vertBuff.size / vertBuff.stride;
                  this._drawInfo.firstVertex = 0;
                  this._drawInfo.vertexOffset = 0;
                }

                this._drawInfo.instanceCount = 0;
                this._drawInfo.firstInstance = 0;
                this._indirectBuffer = info.indirectBuffer || null;
                var gpuVertexBuffers = new Array(info.vertexBuffers.length);

                for (var i = 0; i < info.vertexBuffers.length; ++i) {
                  var vb = info.vertexBuffers[i];

                  if (vb.gpuBuffer) {
                    gpuVertexBuffers[i] = vb.gpuBuffer;
                  }
                }

                var gpuIndexBuffer = null;
                var glIndexType = 0;

                if (info.indexBuffer) {
                  gpuIndexBuffer = info.indexBuffer.gpuBuffer;

                  if (gpuIndexBuffer) {
                    switch (gpuIndexBuffer.stride) {
                      case 1:
                        glIndexType = 0x1401;
                        break;

                      case 2:
                        glIndexType = 0x1403;
                        break;

                      case 4:
                        glIndexType = 0x1405;
                        break;

                      default:
                        {
                          console.error('Error index buffer stride.');
                        }
                    }
                  }
                }

                var gpuIndirectBuffer = null;

                if (info.indirectBuffer) {
                  gpuIndirectBuffer = info.indirectBuffer.gpuBuffer;
                }

                this._gpuInputAssembler = {
                  attributes: info.attributes,
                  gpuVertexBuffers: gpuVertexBuffers,
                  gpuIndexBuffer: gpuIndexBuffer,
                  gpuIndirectBuffer: gpuIndirectBuffer,
                  glAttribs: [],
                  glIndexType: glIndexType,
                  glVAOs: new Map()
                };
                WebGLCmdFuncCreateInputAssember(WebGLDeviceManager.instance, this._gpuInputAssembler);
              };

              _proto.destroy = function destroy() {
                var device = WebGLDeviceManager.instance;

                if (this._gpuInputAssembler && device.extensions.useVAO) {
                  WebGLCmdFuncDestroyInputAssembler(device, this._gpuInputAssembler);
                }

                this._gpuInputAssembler = null;
              };

              _createClass(WebGLInputAssembler, [{
                key: "gpuInputAssembler",
                get: function get() {
                  return this._gpuInputAssembler;
                }
              }]);

              return WebGLInputAssembler;
            }(InputAssembler);

            var WebGLDescriptorSetLayout = function (_DescriptorSetLayout) {
              _inheritsLoose(WebGLDescriptorSetLayout, _DescriptorSetLayout);

              function WebGLDescriptorSetLayout() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _DescriptorSetLayout.call.apply(_DescriptorSetLayout, [this].concat(args)) || this;
                _this._gpuDescriptorSetLayout = null;
                return _this;
              }

              var _proto = WebGLDescriptorSetLayout.prototype;

              _proto.initialize = function initialize(info) {
                Array.prototype.push.apply(this._bindings, info.bindings);
                var descriptorCount = 0;
                var maxBinding = -1;
                var flattenedIndices = [];

                for (var i = 0; i < this._bindings.length; i++) {
                  var binding = this._bindings[i];
                  flattenedIndices.push(descriptorCount);
                  descriptorCount += binding.count;
                  if (binding.binding > maxBinding) maxBinding = binding.binding;
                }

                this._bindingIndices = Array(maxBinding + 1).fill(-1);
                var descriptorIndices = this._descriptorIndices = Array(maxBinding + 1).fill(-1);

                for (var _i = 0; _i < this._bindings.length; _i++) {
                  var _binding = this._bindings[_i];
                  this._bindingIndices[_binding.binding] = _i;
                  descriptorIndices[_binding.binding] = flattenedIndices[_i];
                }

                var dynamicBindings = [];

                for (var _i2 = 0; _i2 < this._bindings.length; _i2++) {
                  var _binding2 = this._bindings[_i2];

                  if (_binding2.descriptorType & DESCRIPTOR_DYNAMIC_TYPE) {
                    for (var j = 0; j < _binding2.count; j++) {
                      dynamicBindings.push(_binding2.binding);
                    }
                  }
                }

                this._gpuDescriptorSetLayout = {
                  bindings: this._bindings,
                  dynamicBindings: dynamicBindings,
                  descriptorIndices: descriptorIndices,
                  descriptorCount: descriptorCount
                };
              };

              _proto.destroy = function destroy() {
                this._bindings.length = 0;
              };

              _createClass(WebGLDescriptorSetLayout, [{
                key: "gpuDescriptorSetLayout",
                get: function get() {
                  return this._gpuDescriptorSetLayout;
                }
              }]);

              return WebGLDescriptorSetLayout;
            }(DescriptorSetLayout);

            var WebGLPipelineLayout = function (_PipelineLayout) {
              _inheritsLoose(WebGLPipelineLayout, _PipelineLayout);

              function WebGLPipelineLayout() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _PipelineLayout.call.apply(_PipelineLayout, [this].concat(args)) || this;
                _this._gpuPipelineLayout = null;
                return _this;
              }

              var _proto = WebGLPipelineLayout.prototype;

              _proto.initialize = function initialize(info) {
                Array.prototype.push.apply(this._setLayouts, info.setLayouts);
                var dynamicOffsetIndices = [];
                var gpuSetLayouts = [];
                var dynamicOffsetCount = 0;
                var dynamicOffsetOffsets = [];

                for (var i = 0; i < this._setLayouts.length; i++) {
                  var setLayout = this._setLayouts[i];
                  var dynamicBindings = setLayout.gpuDescriptorSetLayout.dynamicBindings;
                  var indices = Array(setLayout.bindingIndices.length).fill(-1);

                  for (var j = 0; j < dynamicBindings.length; j++) {
                    var binding = dynamicBindings[j];
                    if (indices[binding] < 0) indices[binding] = dynamicOffsetCount + j;
                  }

                  gpuSetLayouts.push(setLayout.gpuDescriptorSetLayout);
                  dynamicOffsetIndices.push(indices);
                  dynamicOffsetOffsets.push(dynamicOffsetCount);
                  dynamicOffsetCount += dynamicBindings.length;
                }

                this._gpuPipelineLayout = {
                  gpuSetLayouts: gpuSetLayouts,
                  dynamicOffsetIndices: dynamicOffsetIndices,
                  dynamicOffsetCount: dynamicOffsetCount,
                  dynamicOffsetOffsets: dynamicOffsetOffsets
                };
              };

              _proto.destroy = function destroy() {
                this._setLayouts.length = 0;
              };

              _createClass(WebGLPipelineLayout, [{
                key: "gpuPipelineLayout",
                get: function get() {
                  return this._gpuPipelineLayout;
                }
              }]);

              return WebGLPipelineLayout;
            }(PipelineLayout);

            var WebGLPrimitives = [0x0000, 0x0001, 0x0003, 0x0002, 0x0000, 0x0000, 0x0000, 0x0004, 0x0005, 0x0006, 0x0000, 0x0000, 0x0000, 0x0000];
            var WebGLPipelineState = function (_PipelineState) {
              _inheritsLoose(WebGLPipelineState, _PipelineState);

              function WebGLPipelineState() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _PipelineState.call.apply(_PipelineState, [this].concat(args)) || this;
                _this._gpuPipelineState = null;
                return _this;
              }

              var _proto = WebGLPipelineState.prototype;

              _proto.initialize = function initialize(info) {
                this._primitive = info.primitive;
                this._shader = info.shader;
                this._pipelineLayout = info.pipelineLayout;
                var bs = this._bs;

                if (info.blendState) {
                  var bsInfo = info.blendState;
                  var targets = bsInfo.targets;

                  if (targets) {
                    targets.forEach(function (t, i) {
                      bs.setTarget(i, t);
                    });
                  }

                  if (bsInfo.isA2C !== undefined) {
                    bs.isA2C = bsInfo.isA2C;
                  }

                  if (bsInfo.isIndepend !== undefined) {
                    bs.isIndepend = bsInfo.isIndepend;
                  }

                  if (bsInfo.blendColor !== undefined) {
                    bs.blendColor = bsInfo.blendColor;
                  }
                }

                Object.assign(this._rs, info.rasterizerState);
                Object.assign(this._dss, info.depthStencilState);
                this._is = info.inputState;
                this._renderPass = info.renderPass;
                this._dynamicStates = info.dynamicStates;
                var dynamicStates = [];

                for (var i = 0; i < 31; i++) {
                  if (this._dynamicStates & 1 << i) {
                    dynamicStates.push(1 << i);
                  }
                }

                this._gpuPipelineState = {
                  glPrimitive: WebGLPrimitives[info.primitive],
                  gpuShader: info.shader.gpuShader,
                  gpuPipelineLayout: info.pipelineLayout.gpuPipelineLayout,
                  rs: info.rasterizerState,
                  dss: info.depthStencilState,
                  bs: info.blendState,
                  gpuRenderPass: info.renderPass.gpuRenderPass,
                  dynamicStates: dynamicStates
                };
              };

              _proto.destroy = function destroy() {
                this._gpuPipelineState = null;
              };

              _createClass(WebGLPipelineState, [{
                key: "gpuPipelineState",
                get: function get() {
                  return this._gpuPipelineState;
                }
              }]);

              return WebGLPipelineState;
            }(PipelineState);

            var WebGLPrimaryCommandBuffer = function (_WebGLCommandBuffer) {
              _inheritsLoose(WebGLPrimaryCommandBuffer, _WebGLCommandBuffer);

              function WebGLPrimaryCommandBuffer() {
                return _WebGLCommandBuffer.apply(this, arguments) || this;
              }

              var _proto = WebGLPrimaryCommandBuffer.prototype;

              _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
                WebGLCmdFuncBeginRenderPass(WebGLDeviceManager.instance, renderPass.gpuRenderPass, framebuffer.gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil);
                this._isInRenderPass = true;
              };

              _proto.draw = function draw(infoOrAssembler) {
                if (this._isInRenderPass) {
                  if (this._isStateInvalied) {
                    this.bindStates();
                  }

                  var info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;
                  WebGLCmdFuncDraw(WebGLDeviceManager.instance, info);
                  ++this._numDrawCalls;
                  this._numInstances += info.instanceCount;
                  var indexCount = info.indexCount || info.vertexCount;

                  if (this._curGPUPipelineState) {
                    var glPrimitive = this._curGPUPipelineState.glPrimitive;

                    switch (glPrimitive) {
                      case 0x0004:
                        {
                          this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                          break;
                        }

                      case 0x0005:
                      case 0x0006:
                        {
                          this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                          break;
                        }
                    }
                  }
                } else {
                  console.error('Command \'draw\' must be recorded inside a render pass.');
                }
              };

              _proto.setViewport = function setViewport(viewport) {
                var _WebGLDeviceManager$i = WebGLDeviceManager.instance,
                    cache = _WebGLDeviceManager$i.stateCache,
                    gl = _WebGLDeviceManager$i.gl;

                if (cache.viewport.left !== viewport.left || cache.viewport.top !== viewport.top || cache.viewport.width !== viewport.width || cache.viewport.height !== viewport.height) {
                  gl.viewport(viewport.left, viewport.top, viewport.width, viewport.height);
                  cache.viewport.left = viewport.left;
                  cache.viewport.top = viewport.top;
                  cache.viewport.width = viewport.width;
                  cache.viewport.height = viewport.height;
                }
              };

              _proto.setScissor = function setScissor(scissor) {
                var _WebGLDeviceManager$i2 = WebGLDeviceManager.instance,
                    cache = _WebGLDeviceManager$i2.stateCache,
                    gl = _WebGLDeviceManager$i2.gl;

                if (cache.scissorRect.x !== scissor.x || cache.scissorRect.y !== scissor.y || cache.scissorRect.width !== scissor.width || cache.scissorRect.height !== scissor.height) {
                  gl.scissor(scissor.x, scissor.y, scissor.width, scissor.height);
                  cache.scissorRect.x = scissor.x;
                  cache.scissorRect.y = scissor.y;
                  cache.scissorRect.width = scissor.width;
                  cache.scissorRect.height = scissor.height;
                }
              };

              _proto.updateBuffer = function updateBuffer(buffer, data, size) {
                if (!this._isInRenderPass) {
                  var gpuBuffer = buffer.gpuBuffer;

                  if (gpuBuffer) {
                    var buffSize;

                    if (size !== undefined) {
                      buffSize = size;
                    } else if (buffer.usage & BufferUsageBit.INDIRECT) {
                      buffSize = 0;
                    } else {
                      buffSize = data.byteLength;
                    }

                    WebGLCmdFuncUpdateBuffer(WebGLDeviceManager.instance, gpuBuffer, data, 0, buffSize);
                  }
                } else {
                  console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
                }
              };

              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                if (!this._isInRenderPass) {
                  var gpuTexture = texture.gpuTexture;

                  if (gpuTexture) {
                    WebGLCmdFuncCopyBuffersToTexture(WebGLDeviceManager.instance, buffers, gpuTexture, regions);
                  }
                } else {
                  console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
                }
              };

              _proto.execute = function execute(cmdBuffs, count) {
                for (var i = 0; i < count; ++i) {
                  var webGLCmdBuff = cmdBuffs[i];
                  WebGLCmdFuncExecuteCmds(WebGLDeviceManager.instance, webGLCmdBuff.cmdPackage);
                  this._numDrawCalls += webGLCmdBuff._numDrawCalls;
                  this._numInstances += webGLCmdBuff._numInstances;
                  this._numTris += webGLCmdBuff._numTris;
                }
              };

              _proto.bindStates = function bindStates() {
                WebGLCmdFuncBindStates(WebGLDeviceManager.instance, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, this._curDynamicOffsets, this._curDynamicStates);
                this._isStateInvalied = false;
              };

              _proto.blitTexture = function blitTexture(srcTexture, dstTexture, regions, filter) {
                var gpuTextureSrc = srcTexture.gpuTexture;
                var gpuTextureDst = dstTexture.gpuTexture;
                WebGLCmdFuncBlitTexture(WebGLDeviceManager.instance, gpuTextureSrc, gpuTextureDst, regions, filter);
              };

              return WebGLPrimaryCommandBuffer;
            }(WebGLCommandBuffer);

            var WebGLQueue = function (_Queue) {
              _inheritsLoose(WebGLQueue, _Queue);

              function WebGLQueue() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Queue.call.apply(_Queue, [this].concat(args)) || this;
                _this.numDrawCalls = 0;
                _this.numInstances = 0;
                _this.numTris = 0;
                return _this;
              }

              var _proto = WebGLQueue.prototype;

              _proto.initialize = function initialize(info) {
                this._type = info.type;
              };

              _proto.destroy = function destroy() {};

              _proto.submit = function submit(cmdBuffs) {
                var len = cmdBuffs.length;

                for (var i = 0; i < len; i++) {
                  var cmdBuff = cmdBuffs[i];
                  this.numDrawCalls += cmdBuff.numDrawCalls;
                  this.numInstances += cmdBuff.numInstances;
                  this.numTris += cmdBuff.numTris;
                }
              };

              _proto.clear = function clear() {
                this.numDrawCalls = 0;
                this.numInstances = 0;
                this.numTris = 0;
              };

              return WebGLQueue;
            }(Queue);

            var WebGLRenderPass = function (_RenderPass) {
              _inheritsLoose(WebGLRenderPass, _RenderPass);

              function WebGLRenderPass() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _RenderPass.call.apply(_RenderPass, [this].concat(args)) || this;
                _this._gpuRenderPass = null;
                return _this;
              }

              var _proto = WebGLRenderPass.prototype;

              _proto.initialize = function initialize(info) {
                this._colorInfos = info.colorAttachments;
                this._depthStencilInfo = info.depthStencilAttachment;
                this._subpasses = info.subpasses;
                this._gpuRenderPass = {
                  colorAttachments: this._colorInfos,
                  depthStencilAttachment: this._depthStencilInfo
                };
                this._hash = this.computeHash();
              };

              _proto.destroy = function destroy() {
                this._gpuRenderPass = null;
              };

              _createClass(WebGLRenderPass, [{
                key: "gpuRenderPass",
                get: function get() {
                  return this._gpuRenderPass;
                }
              }]);

              return WebGLRenderPass;
            }(RenderPass);

            var WebGLWraps = [0x2901, 0x8370, 0x812F, 0x812F];
            var WebGLSampler = function (_Sampler) {
              _inheritsLoose(WebGLSampler, _Sampler);

              function WebGLSampler(info, hash) {
                var _this;

                _this = _Sampler.call(this, info, hash) || this;
                _this._gpuSampler = null;
                var glMinFilter = 0;
                var glMagFilter = 0;
                var minFilter = _this._info.minFilter;
                var magFilter = _this._info.magFilter;
                var mipFilter = _this._info.mipFilter;

                if (minFilter === Filter.LINEAR || minFilter === Filter.ANISOTROPIC) {
                  if (mipFilter === Filter.LINEAR || mipFilter === Filter.ANISOTROPIC) {
                    glMinFilter = 0x2703;
                  } else if (mipFilter === Filter.POINT) {
                    glMinFilter = 0x2701;
                  } else {
                    glMinFilter = 0x2601;
                  }
                } else if (mipFilter === Filter.LINEAR || mipFilter === Filter.ANISOTROPIC) {
                  glMinFilter = 0x2702;
                } else if (mipFilter === Filter.POINT) {
                  glMinFilter = 0x2700;
                } else {
                  glMinFilter = 0x2600;
                }

                if (magFilter === Filter.LINEAR || magFilter === Filter.ANISOTROPIC) {
                  glMagFilter = 0x2601;
                } else {
                  glMagFilter = 0x2600;
                }

                var glWrapS = WebGLWraps[_this._info.addressU];
                var glWrapT = WebGLWraps[_this._info.addressV];
                var glWrapR = WebGLWraps[_this._info.addressW];
                _this._gpuSampler = {
                  glMinFilter: glMinFilter,
                  glMagFilter: glMagFilter,
                  glWrapS: glWrapS,
                  glWrapT: glWrapT,
                  glWrapR: glWrapR
                };
                return _this;
              }

              _createClass(WebGLSampler, [{
                key: "gpuSampler",
                get: function get() {
                  return this._gpuSampler;
                }
              }]);

              return WebGLSampler;
            }(Sampler);

            var WebGLShader = function (_Shader) {
              _inheritsLoose(WebGLShader, _Shader);

              function WebGLShader() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Shader.call.apply(_Shader, [this].concat(args)) || this;
                _this._gpuShader = null;
                return _this;
              }

              var _proto = WebGLShader.prototype;

              _proto.initialize = function initialize(info) {
                this._name = info.name;
                this._stages = info.stages;
                this._attributes = info.attributes;
                this._blocks = info.blocks;
                this._samplers = info.samplers;
                this._gpuShader = {
                  name: info.name,
                  blocks: info.blocks.slice(),
                  samplerTextures: info.samplerTextures.slice(),
                  subpassInputs: info.subpassInputs.slice(),
                  gpuStages: new Array(info.stages.length),
                  glProgram: null,
                  glInputs: [],
                  glUniforms: [],
                  glBlocks: [],
                  glSamplerTextures: []
                };

                for (var i = 0; i < info.stages.length; ++i) {
                  var stage = info.stages[i];
                  this._gpuShader.gpuStages[i] = {
                    type: stage.stage,
                    source: stage.source,
                    glShader: null
                  };
                }
              };

              _proto.destroy = function destroy() {
                if (this._gpuShader) {
                  WebGLCmdFuncDestroyShader(WebGLDeviceManager.instance, this._gpuShader);
                  this._gpuShader = null;
                }
              };

              _createClass(WebGLShader, [{
                key: "gpuShader",
                get: function get() {
                  if (this._gpuShader.glProgram === null) {
                    WebGLCmdFuncCreateShader(WebGLDeviceManager.instance, this._gpuShader);
                  }

                  return this._gpuShader;
                }
              }]);

              return WebGLShader;
            }(Shader);

            var WebGLStateCache = function () {
              function WebGLStateCache() {
                this.glArrayBuffer = null;
                this.glElementArrayBuffer = null;
                this.glVAO = null;
                this.texUnit = 0;
                this.glTexUnits = [];
                this.glRenderbuffer = null;
                this.glFramebuffer = null;
                this.viewport = new Viewport();
                this.scissorRect = new Rect(0, 0, 0, 0);
                this.rs = new RasterizerState();
                this.dss = new DepthStencilState();
                this.bs = new BlendState$1();
                this.glProgram = null;
                this.glEnabledAttribLocs = [];
                this.glCurrentAttribLocs = [];
                this.texUnitCacheMap = {};
              }

              var _proto = WebGLStateCache.prototype;

              _proto.initialize = function initialize(texUnit, vertexAttributes) {
                for (var i = 0; i < texUnit; ++i) {
                  this.glTexUnits.push({
                    glTexture: null
                  });
                }

                this.glEnabledAttribLocs.length = vertexAttributes;
                this.glEnabledAttribLocs.fill(false);
                this.glCurrentAttribLocs.length = vertexAttributes;
                this.glCurrentAttribLocs.fill(false);
              };

              return WebGLStateCache;
            }();

            var WebGLTexture = function (_Texture) {
              _inheritsLoose(WebGLTexture, _Texture);

              function WebGLTexture() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Texture.call.apply(_Texture, [this].concat(args)) || this;
                _this._gpuTexture = null;
                _this._lodLevel = 0;
                return _this;
              }

              var _proto = WebGLTexture.prototype;

              _proto.initialize = function initialize(info, isSwapchainTexture) {
                var texInfo = info;
                var viewInfo = info;

                if ('texture' in info) {
                  texInfo = viewInfo.texture.info;
                  this._isTextureView = true;
                }

                this._info.copy(texInfo);

                this._isPowerOf2 = IsPowerOf2(this._info.width) && IsPowerOf2(this._info.height);
                this._size = FormatSurfaceSize(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount;

                if (!this._isTextureView) {
                  this._gpuTexture = {
                    type: texInfo.type,
                    format: texInfo.format,
                    usage: texInfo.usage,
                    width: texInfo.width,
                    height: texInfo.height,
                    depth: texInfo.depth,
                    size: this._size,
                    arrayLayer: texInfo.layerCount,
                    mipLevel: texInfo.levelCount,
                    samples: texInfo.samples,
                    flags: texInfo.flags,
                    isPowerOf2: this._isPowerOf2,
                    glTarget: 0,
                    glInternalFmt: 0,
                    glFormat: 0,
                    glType: 0,
                    glUsage: 0,
                    glTexture: null,
                    glRenderbuffer: null,
                    glWrapS: 0,
                    glWrapT: 0,
                    glMinFilter: 0,
                    glMagFilter: 0,
                    isSwapchainTexture: isSwapchainTexture || false
                  };

                  if (!this._gpuTexture.isSwapchainTexture) {
                    WebGLCmdFuncCreateTexture(WebGLDeviceManager.instance, this._gpuTexture);
                    WebGLDeviceManager.instance.memoryStatus.textureSize += this._size;
                  }

                  this._viewInfo.texture = this;
                  this._viewInfo.type = info.type;
                  this._viewInfo.format = info.format;
                  this._viewInfo.baseLevel = 0;
                  this._viewInfo.levelCount = info.levelCount;
                  this._viewInfo.baseLayer = 0;
                  this._viewInfo.layerCount = info.layerCount;
                } else {
                  this._viewInfo.copy(viewInfo);

                  this._lodLevel = viewInfo.baseLevel;
                  this._gpuTexture = viewInfo.texture._gpuTexture;
                }
              };

              _proto.destroy = function destroy() {
                if (!this._isTextureView && this._gpuTexture) {
                  WebGLCmdFuncDestroyTexture(WebGLDeviceManager.instance, this._gpuTexture);
                  WebGLDeviceManager.instance.memoryStatus.textureSize -= this._size;
                  this._gpuTexture = null;
                }
              };

              _proto.getGLTextureHandle = function getGLTextureHandle() {
                var gpuTexture = this._gpuTexture;

                if (!gpuTexture) {
                  return 0;
                }

                if (gpuTexture.glTexture) {
                  return gpuTexture.glTexture;
                } else if (gpuTexture.glRenderbuffer) {
                  return gpuTexture.glRenderbuffer;
                }

                return 0;
              };

              _proto.resize = function resize(width, height) {
                if (this._info.width === width && this._info.height === height) {
                  return;
                }

                if (this._info.levelCount === WebGLTexture.getLevelCount(this._info.width, this._info.height)) {
                  this._info.levelCount = WebGLTexture.getLevelCount(width, height);
                } else if (this._info.levelCount > 1) {
                  this._info.levelCount = Math.min(this._info.levelCount, WebGLTexture.getLevelCount(width, height));
                }

                var oldSize = this._size;
                this._info.width = width;
                this._info.height = height;
                this._size = FormatSurfaceSize(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount;

                if (!this._isTextureView && this._gpuTexture) {
                  this._gpuTexture.width = width;
                  this._gpuTexture.height = height;
                  this._gpuTexture.size = this._size;

                  if (!this._gpuTexture.isSwapchainTexture) {
                    WebGLCmdFuncResizeTexture(WebGLDeviceManager.instance, this._gpuTexture);
                    WebGLDeviceManager.instance.memoryStatus.textureSize -= oldSize;
                    WebGLDeviceManager.instance.memoryStatus.textureSize += this._size;
                  }
                }
              };

              _proto.initAsSwapchainTexture = function initAsSwapchainTexture(info) {
                var texInfo = new TextureInfo();
                texInfo.format = info.format;
                texInfo.usage = FormatInfos[info.format].hasDepth ? TextureUsageBit.DEPTH_STENCIL_ATTACHMENT : TextureUsageBit.COLOR_ATTACHMENT;
                texInfo.width = info.width;
                texInfo.height = info.height;
                this.initialize(texInfo, true);
              };

              _createClass(WebGLTexture, [{
                key: "gpuTexture",
                get: function get() {
                  return this._gpuTexture;
                }
              }, {
                key: "lodLevel",
                get: function get() {
                  return this._lodLevel;
                }
              }]);

              return WebGLTexture;
            }(Texture);

            var eventWebGLContextLost = 'webglcontextlost';

            function initStates(gl) {
              gl.activeTexture(gl.TEXTURE0);
              gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
              gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
              gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.enable(gl.SCISSOR_TEST);
              gl.enable(gl.CULL_FACE);
              gl.cullFace(gl.BACK);
              gl.frontFace(gl.CCW);
              gl.disable(gl.POLYGON_OFFSET_FILL);
              gl.polygonOffset(0.0, 0.0);
              gl.enable(gl.DEPTH_TEST);
              gl.depthMask(true);
              gl.depthFunc(gl.LESS);
              gl.depthRange(0.0, 1.0);
              gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 0xffff);
              gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
              gl.stencilMaskSeparate(gl.FRONT, 0xffff);
              gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 0xffff);
              gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
              gl.stencilMaskSeparate(gl.BACK, 0xffff);
              gl.disable(gl.STENCIL_TEST);
              gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
              gl.disable(gl.BLEND);
              gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
              gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
              gl.colorMask(true, true, true, true);
              gl.blendColor(0.0, 0.0, 0.0, 0.0);
            }

            function getExtension(gl, ext) {
              var prefixes = ['', 'WEBKIT_', 'MOZ_'];

              for (var i = 0; i < prefixes.length; ++i) {
                var _ext = gl.getExtension(prefixes[i] + ext);

                if (_ext) {
                  return _ext;
                }
              }

              return null;
            }

            function getExtensions(gl) {
              var res = {
                EXT_texture_filter_anisotropic: getExtension(gl, 'EXT_texture_filter_anisotropic'),
                EXT_blend_minmax: getExtension(gl, 'EXT_blend_minmax'),
                EXT_frag_depth: getExtension(gl, 'EXT_frag_depth'),
                EXT_shader_texture_lod: getExtension(gl, 'EXT_shader_texture_lod'),
                EXT_sRGB: getExtension(gl, 'EXT_sRGB'),
                OES_vertex_array_object: getExtension(gl, 'OES_vertex_array_object'),
                EXT_color_buffer_half_float: getExtension(gl, 'EXT_color_buffer_half_float'),
                WEBGL_color_buffer_float: getExtension(gl, 'WEBGL_color_buffer_float'),
                WEBGL_compressed_texture_etc1: getExtension(gl, 'WEBGL_compressed_texture_etc1'),
                WEBGL_compressed_texture_etc: getExtension(gl, 'WEBGL_compressed_texture_etc'),
                WEBGL_compressed_texture_pvrtc: getExtension(gl, 'WEBGL_compressed_texture_pvrtc'),
                WEBGL_compressed_texture_s3tc: getExtension(gl, 'WEBGL_compressed_texture_s3tc'),
                WEBGL_compressed_texture_s3tc_srgb: getExtension(gl, 'WEBGL_compressed_texture_s3tc_srgb'),
                WEBGL_debug_shaders: getExtension(gl, 'WEBGL_debug_shaders'),
                WEBGL_draw_buffers: getExtension(gl, 'WEBGL_draw_buffers'),
                WEBGL_lose_context: getExtension(gl, 'WEBGL_lose_context'),
                WEBGL_depth_texture: getExtension(gl, 'WEBGL_depth_texture'),
                OES_texture_half_float: getExtension(gl, 'OES_texture_half_float'),
                OES_texture_half_float_linear: getExtension(gl, 'OES_texture_half_float_linear'),
                OES_texture_float: getExtension(gl, 'OES_texture_float'),
                OES_texture_float_linear: getExtension(gl, 'OES_texture_float_linear'),
                OES_standard_derivatives: getExtension(gl, 'OES_standard_derivatives'),
                OES_element_index_uint: getExtension(gl, 'OES_element_index_uint'),
                ANGLE_instanced_arrays: getExtension(gl, 'ANGLE_instanced_arrays'),
                WEBGL_debug_renderer_info: getExtension(gl, 'WEBGL_debug_renderer_info'),
                WEBGL_multi_draw: null,
                WEBGL_compressed_texture_astc: null,
                destroyShadersImmediately: true,
                noCompressedTexSubImage2D: false,
                isLocationActive: function isLocationActive(glLoc) {
                  return !!glLoc;
                },
                useVAO: false
              };
              {
                if (systemInfo.os !== OS.IOS || systemInfo.osMainVersion !== 14 || !systemInfo.isBrowser) {
                  res.WEBGL_compressed_texture_astc = getExtension(gl, 'WEBGL_compressed_texture_astc');
                }

                if (systemInfo.os !== OS.ANDROID && systemInfo.os !== OS.IOS) {
                  res.WEBGL_multi_draw = getExtension(gl, 'WEBGL_multi_draw');
                }

                if (systemInfo.browserType === BrowserType.UC) {
                  res.ANGLE_instanced_arrays = null;
                }

                if (systemInfo.os === OS.IOS && systemInfo.osMainVersion <= 10 || ( WECHAT_MINI_PROGRAM) ) {
                  res.destroyShadersImmediately = false;
                }
              }

              if (res.OES_vertex_array_object) {
                res.useVAO = true;
              }

              return res;
            }
            function getContext(canvas) {
              var context = null;

              try {
                var webGLCtxAttribs = {
                  alpha: macro.ENABLE_TRANSPARENT_CANVAS,
                  antialias: EDITOR || macro.ENABLE_WEBGL_ANTIALIAS,
                  depth: true,
                  stencil: true,
                  premultipliedAlpha: false,
                  preserveDrawingBuffer: false,
                  powerPreference: 'default',
                  failIfMajorPerformanceCaveat: false
                };
                context = canvas.getContext('webgl', webGLCtxAttribs);
              } catch (err) {
                return null;
              }

              return context;
            }
            var WebGLSwapchain = function (_Swapchain) {
              _inheritsLoose(WebGLSwapchain, _Swapchain);

              function WebGLSwapchain() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Swapchain.call.apply(_Swapchain, [this].concat(args)) || this;
                _this.stateCache = new WebGLStateCache();
                _this.cmdAllocator = new WebGLCommandAllocator();
                _this.nullTex2D = null;
                _this.nullTexCube = null;
                _this._canvas = null;
                _this._webGLContextLostHandler = null;
                _this._extensions = null;
                _this._blitManager = null;
                return _this;
              }

              var _proto = WebGLSwapchain.prototype;

              _proto.initialize = function initialize(info) {
                this._canvas = info.windowHandle;
                this._webGLContextLostHandler = this._onWebGLContextLost.bind(this);

                this._canvas.addEventListener(eventWebGLContextLost, this._onWebGLContextLost);

                var gl = WebGLDeviceManager.instance.gl;
                this.stateCache.initialize(WebGLDeviceManager.instance.capabilities.maxTextureUnits, WebGLDeviceManager.instance.capabilities.maxVertexAttributes);
                this._extensions = getExtensions(gl);
                initStates(gl);
                var colorFmt = Format.RGBA8;
                var depthStencilFmt = Format.DEPTH_STENCIL;
                var depthBits = gl.getParameter(gl.DEPTH_BITS);
                var stencilBits = gl.getParameter(gl.STENCIL_BITS);

                if (depthBits && stencilBits) depthStencilFmt = Format.DEPTH_STENCIL;else if (depthBits) depthStencilFmt = Format.DEPTH;
                this._colorTexture = new WebGLTexture();

                this._colorTexture.initAsSwapchainTexture({
                  swapchain: this,
                  format: colorFmt,
                  width: info.width,
                  height: info.height
                });

                this._depthStencilTexture = new WebGLTexture();

                this._depthStencilTexture.initAsSwapchainTexture({
                  swapchain: this,
                  format: depthStencilFmt,
                  width: info.width,
                  height: info.height
                });

                this.nullTex2D = WebGLDeviceManager.instance.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.GEN_MIPMAP));
                this.nullTexCube = WebGLDeviceManager.instance.createTexture(new TextureInfo(TextureType.CUBE, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.GEN_MIPMAP, 6));
                var nullTexRegion = new BufferTextureCopy();
                nullTexRegion.texExtent.width = 2;
                nullTexRegion.texExtent.height = 2;
                var nullTexBuff = new Uint8Array(this.nullTex2D.size);
                nullTexBuff.fill(0);
                WebGLDeviceManager.instance.copyBuffersToTexture([nullTexBuff], this.nullTex2D, [nullTexRegion]);
                nullTexRegion.texSubres.layerCount = 6;
                WebGLDeviceManager.instance.copyBuffersToTexture([nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff], this.nullTexCube, [nullTexRegion]);
                this._blitManager = new IWebGLBlitManager();
              };

              _proto.destroy = function destroy() {
                if (this._canvas && this._webGLContextLostHandler) {
                  this._canvas.removeEventListener(eventWebGLContextLost, this._webGLContextLostHandler);

                  this._webGLContextLostHandler = null;
                }

                if (this.nullTex2D) {
                  this.nullTex2D.destroy();
                  this.nullTex2D = null;
                }

                if (this.nullTexCube) {
                  this.nullTexCube.destroy();
                  this.nullTexCube = null;
                }

                if (this._blitManager) {
                  this._blitManager.destroy();

                  this._blitManager = null;
                }

                this._extensions = null;
                this._canvas = null;
              };

              _proto.resize = function resize(width, height, surfaceTransform) {
                if (this._colorTexture.width !== width || this._colorTexture.height !== height) {
                  debug("Resizing swapchain: " + width + "x" + height);
                  this._canvas.width = width;
                  this._canvas.height = height;

                  this._colorTexture.resize(width, height);

                  this._depthStencilTexture.resize(width, height);
                }
              };

              _proto._onWebGLContextLost = function _onWebGLContextLost(event) {
                warnID(11000);
                warn(event);
              };

              _createClass(WebGLSwapchain, [{
                key: "extensions",
                get: function get() {
                  return this._extensions;
                }
              }, {
                key: "blitManager",
                get: function get() {
                  return this._blitManager;
                }
              }]);

              return WebGLSwapchain;
            }(Swapchain);

            var WebGLDevice = exports('WebGLDevice', function (_Device) {
              _inheritsLoose(WebGLDevice, _Device);

              function WebGLDevice() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Device.call.apply(_Device, [this].concat(args)) || this;
                _this._swapchain = null;
                _this._context = null;
                _this._bindingMappings = null;
                _this._textureExclusive = new Array(Format.COUNT);
                return _this;
              }

              var _proto = WebGLDevice.prototype;

              _proto.initialize = function initialize(info) {
                WebGLDeviceManager.setInstance(this);
                this._gfxAPI = API.WEBGL;
                var mapping = this._bindingMappingInfo = info.bindingMappingInfo;
                var blockOffsets = [];
                var samplerTextureOffsets = [];
                var firstSet = mapping.setIndices[0];
                blockOffsets[firstSet] = 0;
                samplerTextureOffsets[firstSet] = 0;

                for (var i = 1; i < mapping.setIndices.length; ++i) {
                  var curSet = mapping.setIndices[i];
                  var prevSet = mapping.setIndices[i - 1];
                  blockOffsets[curSet] = mapping.maxBlockCounts[prevSet] + blockOffsets[prevSet];
                  samplerTextureOffsets[curSet] = mapping.maxSamplerTextureCounts[prevSet] + samplerTextureOffsets[prevSet];
                }

                for (var _i = 0; _i < mapping.setIndices.length; ++_i) {
                  var _curSet = mapping.setIndices[_i];
                  samplerTextureOffsets[_curSet] -= mapping.maxBlockCounts[_curSet];
                }

                this._bindingMappings = {
                  blockOffsets: blockOffsets,
                  samplerTextureOffsets: samplerTextureOffsets,
                  flexibleSet: mapping.setIndices[mapping.setIndices.length - 1]
                };
                var gl = this._context = getContext(Device.canvas);

                if (!gl) {
                  console.error('This device does not support WebGL.');
                  return false;
                }

                this._queue = this.createQueue(new QueueInfo(QueueType.GRAPHICS));
                this._cmdBuff = this.createCommandBuffer(new CommandBufferInfo(this._queue));
                this._caps.maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
                this._caps.maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
                this._caps.maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
                this._caps.maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
                this._caps.maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
                this._caps.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                this._caps.maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                this._caps.maxArrayTextureLayers = 0;
                this._caps.max3DTextureSize = 0;
                this._caps.maxUniformBufferBindings = 16;
                var extensions = gl.getSupportedExtensions();
                var extStr = '';

                if (extensions) {
                  for (var _iterator = _createForOfIteratorHelperLoose(extensions), _step; !(_step = _iterator()).done;) {
                    var ext = _step.value;
                    extStr += ext + " ";
                  }
                }

                var exts = getExtensions(gl);

                if (exts.WEBGL_debug_renderer_info) {
                  this._renderer = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL);
                  this._vendor = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL);
                } else {
                  this._renderer = gl.getParameter(gl.RENDERER);
                  this._vendor = gl.getParameter(gl.VENDOR);
                }

                var version = gl.getParameter(gl.VERSION);

                this._features.fill(false);

                this.initFormatFeatures(exts);

                if (exts.EXT_blend_minmax) {
                  this._features[Feature.BLEND_MINMAX] = true;
                }

                if (exts.OES_element_index_uint) {
                  this._features[Feature.ELEMENT_INDEX_UINT] = true;
                }

                if (exts.ANGLE_instanced_arrays) {
                  this._features[Feature.INSTANCED_ARRAYS] = true;
                }

                if (exts.WEBGL_draw_buffers) {
                  this._features[Feature.MULTIPLE_RENDER_TARGETS] = true;
                }

                var compressedFormat = '';

                if (this.getFormatFeatures(Format.ETC_RGB8)) {
                  compressedFormat += 'etc1 ';
                }

                if (this.getFormatFeatures(Format.ETC2_RGB8)) {
                  compressedFormat += 'etc2 ';
                }

                if (this.getFormatFeatures(Format.BC1)) {
                  compressedFormat += 'dxt ';
                }

                if (this.getFormatFeatures(Format.PVRTC_RGB2)) {
                  compressedFormat += 'pvrtc ';
                }

                if (this.getFormatFeatures(Format.ASTC_RGBA_4X4)) {
                  compressedFormat += 'astc ';
                }

                debug('WebGL device initialized.');
                debug("RENDERER: " + this._renderer);
                debug("VENDOR: " + this._vendor);
                debug("VERSION: " + version);
                debug("COMPRESSED_FORMAT: " + compressedFormat);
                debug("EXTENSIONS: " + extStr);
                return true;
              };

              _proto.destroy = function destroy() {
                if (this._queue) {
                  this._queue.destroy();

                  this._queue = null;
                }

                if (this._cmdBuff) {
                  this._cmdBuff.destroy();

                  this._cmdBuff = null;
                }

                this._swapchain = null;
              };

              _proto.flushCommands = function flushCommands(cmdBuffs) {};

              _proto.acquire = function acquire(swapchains) {};

              _proto.present = function present() {
                var queue = this._queue;
                this._numDrawCalls = queue.numDrawCalls;
                this._numInstances = queue.numInstances;
                this._numTris = queue.numTris;
                queue.clear();
              };

              _proto.initFormatFeatures = function initFormatFeatures(exts) {
                this._formatFeatures.fill(FormatFeatureBit.NONE);

                this._textureExclusive.fill(true);

                var tempFeature = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;
                this._formatFeatures[Format.RGB8] = tempFeature;
                this._formatFeatures[Format.R5G6B5] = tempFeature;
                this._textureExclusive[Format.R5G6B5] = false;
                this._formatFeatures[Format.RGBA8] = tempFeature;
                this._formatFeatures[Format.RGBA4] = tempFeature;
                this._textureExclusive[Format.RGBA4] = false;
                this._formatFeatures[Format.RGB5A1] = tempFeature;
                this._textureExclusive[Format.RGB5A1] = false;
                this._formatFeatures[Format.DEPTH] = FormatFeatureBit.RENDER_TARGET;
                this._textureExclusive[Format.DEPTH] = false;
                this._formatFeatures[Format.DEPTH_STENCIL] = FormatFeatureBit.RENDER_TARGET;
                this._textureExclusive[Format.DEPTH_STENCIL] = false;
                this._formatFeatures[Format.R8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.RG8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.RGB8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.RGBA8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.R8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.RG8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.RGB8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.RGBA8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.R8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.RG8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.RGB8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.RGBA8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.R8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.RG8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.RGB8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.RGBA8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.R32F] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.RG32F] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.VERTEX_ATTRIBUTE;

                if (exts.EXT_sRGB) {
                  this._formatFeatures[Format.SRGB8] = tempFeature;
                  this._formatFeatures[Format.SRGB8_A8] = tempFeature;
                  this._textureExclusive[Format.SRGB8_A8] = false;
                }

                if (exts.WEBGL_depth_texture) {
                  this._formatFeatures[Format.DEPTH] |= tempFeature;
                  this._formatFeatures[Format.DEPTH_STENCIL] |= tempFeature;
                }

                if (exts.WEBGL_color_buffer_float) {
                  this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.RENDER_TARGET;
                  this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.RENDER_TARGET;
                  this._textureExclusive[Format.RGB32F] = false;
                  this._textureExclusive[Format.RGBA32F] = false;
                }

                if (exts.EXT_color_buffer_half_float) {
                  this._formatFeatures[Format.RGB16F] |= FormatFeatureBit.RENDER_TARGET;
                  this._formatFeatures[Format.RGBA16F] |= FormatFeatureBit.RENDER_TARGET;
                  this._textureExclusive[Format.RGB16F] = false;
                  this._textureExclusive[Format.RGBA16F] = false;
                }

                if (exts.OES_texture_float) {
                  this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE;
                  this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE;
                }

                if (exts.OES_texture_half_float) {
                  this._formatFeatures[Format.RGB16F] |= FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE;
                  this._formatFeatures[Format.RGBA16F] |= FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE;
                }

                if (exts.OES_texture_float_linear) {
                  this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.LINEAR_FILTER;
                  this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.LINEAR_FILTER;
                }

                if (exts.OES_texture_half_float_linear) {
                  this._formatFeatures[Format.RGB16F] |= FormatFeatureBit.LINEAR_FILTER;
                  this._formatFeatures[Format.RGBA16F] |= FormatFeatureBit.LINEAR_FILTER;
                }

                var compressedFeature = FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;

                if (exts.WEBGL_compressed_texture_etc1) {
                  this._formatFeatures[Format.ETC_RGB8] = compressedFeature;
                }

                if (exts.WEBGL_compressed_texture_etc) {
                  this._formatFeatures[Format.ETC2_RGB8] = compressedFeature;
                  this._formatFeatures[Format.ETC2_RGBA8] = compressedFeature;
                  this._formatFeatures[Format.ETC2_SRGB8] = compressedFeature;
                  this._formatFeatures[Format.ETC2_SRGB8_A8] = compressedFeature;
                  this._formatFeatures[Format.ETC2_RGB8_A1] = compressedFeature;
                  this._formatFeatures[Format.ETC2_SRGB8_A1] = compressedFeature;
                }

                if (exts.WEBGL_compressed_texture_s3tc) {
                  this._formatFeatures[Format.BC1] = compressedFeature;
                  this._formatFeatures[Format.BC1_ALPHA] = compressedFeature;
                  this._formatFeatures[Format.BC1_SRGB] = compressedFeature;
                  this._formatFeatures[Format.BC1_SRGB_ALPHA] = compressedFeature;
                  this._formatFeatures[Format.BC2] = compressedFeature;
                  this._formatFeatures[Format.BC2_SRGB] = compressedFeature;
                  this._formatFeatures[Format.BC3] = compressedFeature;
                  this._formatFeatures[Format.BC3_SRGB] = compressedFeature;
                }

                if (exts.WEBGL_compressed_texture_pvrtc) {
                  this._formatFeatures[Format.PVRTC_RGB2] |= compressedFeature;
                  this._formatFeatures[Format.PVRTC_RGBA2] |= compressedFeature;
                  this._formatFeatures[Format.PVRTC_RGB4] |= compressedFeature;
                  this._formatFeatures[Format.PVRTC_RGBA4] |= compressedFeature;
                }

                if (exts.WEBGL_compressed_texture_astc) {
                  this._formatFeatures[Format.ASTC_RGBA_4X4] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_5X4] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_5X5] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_6X5] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_6X6] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_8X5] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_8X6] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_8X8] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_10X5] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_10X6] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_10X8] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_10X10] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_12X10] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_12X12] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_4X4] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_5X4] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_5X5] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_6X5] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_6X6] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_8X5] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_8X6] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_8X8] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_10X5] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_10X6] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_10X8] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_10X10] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_12X10] |= compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_12X12] |= compressedFeature;
                }
              };

              _proto.createCommandBuffer = function createCommandBuffer(info) {
                var Ctor = info.type === CommandBufferType.PRIMARY ? WebGLPrimaryCommandBuffer : WebGLCommandBuffer;
                var cmdBuff = new Ctor();
                cmdBuff.initialize(info);
                return cmdBuff;
              };

              _proto.createSwapchain = function createSwapchain(info) {
                var swapchain = new WebGLSwapchain();
                this._swapchain = swapchain;
                swapchain.initialize(info);
                return swapchain;
              };

              _proto.createBuffer = function createBuffer(info) {
                var buffer = new WebGLBuffer();
                buffer.initialize(info);
                return buffer;
              };

              _proto.createTexture = function createTexture(info) {
                var texture = new WebGLTexture();
                texture.initialize(info);
                return texture;
              };

              _proto.createDescriptorSet = function createDescriptorSet(info) {
                var descriptorSet = new WebGLDescriptorSet();
                descriptorSet.initialize(info);
                return descriptorSet;
              };

              _proto.createShader = function createShader(info) {
                var shader = new WebGLShader();
                shader.initialize(info);
                return shader;
              };

              _proto.createInputAssembler = function createInputAssembler(info) {
                var inputAssembler = new WebGLInputAssembler();
                inputAssembler.initialize(info);
                return inputAssembler;
              };

              _proto.createRenderPass = function createRenderPass(info) {
                var renderPass = new WebGLRenderPass();
                renderPass.initialize(info);
                return renderPass;
              };

              _proto.createFramebuffer = function createFramebuffer(info) {
                var framebuffer = new WebGLFramebuffer();
                framebuffer.initialize(info);
                return framebuffer;
              };

              _proto.createDescriptorSetLayout = function createDescriptorSetLayout(info) {
                var descriptorSetLayout = new WebGLDescriptorSetLayout();
                descriptorSetLayout.initialize(info);
                return descriptorSetLayout;
              };

              _proto.createPipelineLayout = function createPipelineLayout(info) {
                var pipelineLayout = new WebGLPipelineLayout();
                pipelineLayout.initialize(info);
                return pipelineLayout;
              };

              _proto.createPipelineState = function createPipelineState(info) {
                var pipelineState = new WebGLPipelineState();
                pipelineState.initialize(info);
                return pipelineState;
              };

              _proto.createQueue = function createQueue(info) {
                var queue = new WebGLQueue();
                queue.initialize(info);
                return queue;
              };

              _proto.getSampler = function getSampler(info) {
                var hash = Sampler.computeHash(info);

                if (!this._samplers.has(hash)) {
                  this._samplers.set(hash, new WebGLSampler(info, hash));
                }

                return this._samplers.get(hash);
              };

              _proto.getSwapchains = function getSwapchains() {
                return [this._swapchain];
              };

              _proto.getGeneralBarrier = function getGeneralBarrier(info) {
                var hash = GeneralBarrier.computeHash(info);

                if (!this._generalBarrierss.has(hash)) {
                  this._generalBarrierss.set(hash, new GeneralBarrier(info, hash));
                }

                return this._generalBarrierss.get(hash);
              };

              _proto.getTextureBarrier = function getTextureBarrier(info) {
                var hash = TextureBarrier.computeHash(info);

                if (!this._textureBarriers.has(hash)) {
                  this._textureBarriers.set(hash, new TextureBarrier(info, hash));
                }

                return this._textureBarriers.get(hash);
              };

              _proto.getBufferBarrier = function getBufferBarrier(info) {
                var hash = BufferBarrier.computeHash(info);

                if (!this._bufferBarriers.has(hash)) {
                  this._bufferBarriers.set(hash, new BufferBarrier(info, hash));
                }

                return this._bufferBarriers.get(hash);
              };

              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                WebGLCmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
              };

              _proto.copyTextureToBuffers = function copyTextureToBuffers(texture, buffers, regions) {
                WebGLCmdFuncCopyTextureToBuffers(this, texture.gpuTexture, buffers, regions);
              };

              _proto.copyTexImagesToTexture = function copyTexImagesToTexture(texImages, texture, regions) {
                WebGLCmdFuncCopyTexImagesToTexture(this, texImages, texture.gpuTexture, regions);
              };

              _createClass(WebGLDevice, [{
                key: "gl",
                get: function get() {
                  return this._context;
                }
              }, {
                key: "extensions",
                get: function get() {
                  return this._swapchain.extensions;
                }
              }, {
                key: "stateCache",
                get: function get() {
                  return this._swapchain.stateCache;
                }
              }, {
                key: "nullTex2D",
                get: function get() {
                  return this._swapchain.nullTex2D;
                }
              }, {
                key: "nullTexCube",
                get: function get() {
                  return this._swapchain.nullTexCube;
                }
              }, {
                key: "textureExclusive",
                get: function get() {
                  return this._textureExclusive;
                }
              }, {
                key: "bindingMappings",
                get: function get() {
                  return this._bindingMappings;
                }
              }, {
                key: "blitManager",
                get: function get() {
                  return this._swapchain.blitManager;
                }
              }]);

              return WebGLDevice;
            }(Device));

            legacyCC.WebGLDevice = WebGLDevice;

            var WebGL2DescriptorSet = function (_DescriptorSet) {
              _inheritsLoose(WebGL2DescriptorSet, _DescriptorSet);

              function WebGL2DescriptorSet() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _DescriptorSet.call.apply(_DescriptorSet, [this].concat(args)) || this;
                _this._gpuDescriptorSet = null;
                return _this;
              }

              var _proto = WebGL2DescriptorSet.prototype;

              _proto.initialize = function initialize(info) {
                this._layout = info.layout;
                var _gpuDescriptorSetLayo = info.layout.gpuDescriptorSetLayout,
                    bindings = _gpuDescriptorSetLayo.bindings,
                    descriptorIndices = _gpuDescriptorSetLayo.descriptorIndices,
                    descriptorCount = _gpuDescriptorSetLayo.descriptorCount;
                this._buffers = Array(descriptorCount).fill(null);
                this._textures = Array(descriptorCount).fill(null);
                this._samplers = Array(descriptorCount).fill(null);
                var gpuDescriptors = [];
                this._gpuDescriptorSet = {
                  gpuDescriptors: gpuDescriptors,
                  descriptorIndices: descriptorIndices
                };

                for (var i = 0; i < bindings.length; ++i) {
                  var binding = bindings[i];

                  for (var j = 0; j < binding.count; j++) {
                    gpuDescriptors.push({
                      type: binding.descriptorType,
                      gpuBuffer: null,
                      gpuTextureView: null,
                      gpuSampler: null
                    });
                  }
                }
              };

              _proto.destroy = function destroy() {
                this._layout = null;
                this._gpuDescriptorSet = null;
              };

              _proto.update = function update() {
                if (this._isDirty && this._gpuDescriptorSet) {
                  var descriptors = this._gpuDescriptorSet.gpuDescriptors;

                  for (var i = 0; i < descriptors.length; ++i) {
                    if (descriptors[i].type & DESCRIPTOR_BUFFER_TYPE) {
                      if (this._buffers[i]) {
                        descriptors[i].gpuBuffer = this._buffers[i].gpuBuffer;
                      }
                    } else if (descriptors[i].type & DESCRIPTOR_SAMPLER_TYPE) {
                      if (this._textures[i]) {
                        descriptors[i].gpuTextureView = this._textures[i].gpuTextureView;
                      }

                      if (this._samplers[i]) {
                        descriptors[i].gpuSampler = this._samplers[i].gpuSampler;
                      }
                    }
                  }

                  this._isDirty = false;
                }
              };

              _createClass(WebGL2DescriptorSet, [{
                key: "gpuDescriptorSet",
                get: function get() {
                  return this._gpuDescriptorSet;
                }
              }]);

              return WebGL2DescriptorSet;
            }(DescriptorSet);

            var WebGL2EXT;

            (function (WebGL2EXT) {
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
              WebGL2EXT[WebGL2EXT["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
            })(WebGL2EXT || (WebGL2EXT = {}));

            var WebGL2DeviceManager = function () {
              function WebGL2DeviceManager() {}

              WebGL2DeviceManager.setInstance = function setInstance(instance) {
                WebGL2DeviceManager._instance = instance;
              };

              _createClass(WebGL2DeviceManager, null, [{
                key: "instance",
                get: function get() {
                  return WebGL2DeviceManager._instance;
                }
              }]);

              return WebGL2DeviceManager;
            }();
            WebGL2DeviceManager._instance = null;

            var WebGLWraps$1 = [0x2901, 0x8370, 0x812F, 0x812F];

            var _f32v4 = new Float32Array(4);

            function GFXFormatToWebGLType$1(format, gl) {
              switch (format) {
                case Format.R8:
                  return gl.UNSIGNED_BYTE;

                case Format.R8SN:
                  return gl.BYTE;

                case Format.R8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.R8I:
                  return gl.BYTE;

                case Format.R16F:
                  return gl.HALF_FLOAT;

                case Format.R16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.R16I:
                  return gl.SHORT;

                case Format.R32F:
                  return gl.FLOAT;

                case Format.R32UI:
                  return gl.UNSIGNED_INT;

                case Format.R32I:
                  return gl.INT;

                case Format.RG8:
                  return gl.UNSIGNED_BYTE;

                case Format.RG8SN:
                  return gl.BYTE;

                case Format.RG8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RG8I:
                  return gl.BYTE;

                case Format.RG16F:
                  return gl.HALF_FLOAT;

                case Format.RG16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RG16I:
                  return gl.SHORT;

                case Format.RG32F:
                  return gl.FLOAT;

                case Format.RG32UI:
                  return gl.UNSIGNED_INT;

                case Format.RG32I:
                  return gl.INT;

                case Format.RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.SRGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGB8SN:
                  return gl.BYTE;

                case Format.RGB8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RGB8I:
                  return gl.BYTE;

                case Format.RGB16F:
                  return gl.HALF_FLOAT;

                case Format.RGB16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RGB16I:
                  return gl.SHORT;

                case Format.RGB32F:
                  return gl.FLOAT;

                case Format.RGB32UI:
                  return gl.UNSIGNED_INT;

                case Format.RGB32I:
                  return gl.INT;

                case Format.BGRA8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8:
                  return gl.UNSIGNED_BYTE;

                case Format.SRGB8_A8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8SN:
                  return gl.BYTE;

                case Format.RGBA8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8I:
                  return gl.BYTE;

                case Format.RGBA16F:
                  return gl.HALF_FLOAT;

                case Format.RGBA16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RGBA16I:
                  return gl.SHORT;

                case Format.RGBA32F:
                  return gl.FLOAT;

                case Format.RGBA32UI:
                  return gl.UNSIGNED_INT;

                case Format.RGBA32I:
                  return gl.INT;

                case Format.R5G6B5:
                  return gl.UNSIGNED_SHORT_5_6_5;

                case Format.R11G11B10F:
                  return gl.UNSIGNED_INT_10F_11F_11F_REV;

                case Format.RGB5A1:
                  return gl.UNSIGNED_SHORT_5_5_5_1;

                case Format.RGBA4:
                  return gl.UNSIGNED_SHORT_4_4_4_4;

                case Format.RGB10A2:
                  return gl.UNSIGNED_INT_2_10_10_10_REV;

                case Format.RGB10A2UI:
                  return gl.UNSIGNED_INT_2_10_10_10_REV;

                case Format.RGB9E5:
                  return gl.FLOAT;

                case Format.DEPTH:
                  return gl.FLOAT;

                case Format.DEPTH_STENCIL:
                  return gl.UNSIGNED_INT_24_8;

                case Format.BC1:
                  return gl.UNSIGNED_BYTE;

                case Format.BC1_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC2:
                  return gl.UNSIGNED_BYTE;

                case Format.BC2_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC3:
                  return gl.UNSIGNED_BYTE;

                case Format.BC3_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC4:
                  return gl.UNSIGNED_BYTE;

                case Format.BC4_SNORM:
                  return gl.BYTE;

                case Format.BC5:
                  return gl.UNSIGNED_BYTE;

                case Format.BC5_SNORM:
                  return gl.BYTE;

                case Format.BC6H_SF16:
                  return gl.FLOAT;

                case Format.BC6H_UF16:
                  return gl.FLOAT;

                case Format.BC7:
                  return gl.UNSIGNED_BYTE;

                case Format.BC7_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC_RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_SRGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_RGB8_A1:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_SRGB8_A1:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_R11:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_R11SN:
                  return gl.BYTE;

                case Format.EAC_RG11:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_RG11SN:
                  return gl.BYTE;

                case Format.PVRTC_RGB2:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGBA2:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGB4:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGBA4:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC2_2BPP:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC2_4BPP:
                  return gl.UNSIGNED_BYTE;

                case Format.ASTC_RGBA_4X4:
                case Format.ASTC_RGBA_5X4:
                case Format.ASTC_RGBA_5X5:
                case Format.ASTC_RGBA_6X5:
                case Format.ASTC_RGBA_6X6:
                case Format.ASTC_RGBA_8X5:
                case Format.ASTC_RGBA_8X6:
                case Format.ASTC_RGBA_8X8:
                case Format.ASTC_RGBA_10X5:
                case Format.ASTC_RGBA_10X6:
                case Format.ASTC_RGBA_10X8:
                case Format.ASTC_RGBA_10X10:
                case Format.ASTC_RGBA_12X10:
                case Format.ASTC_RGBA_12X12:
                case Format.ASTC_SRGBA_4X4:
                case Format.ASTC_SRGBA_5X4:
                case Format.ASTC_SRGBA_5X5:
                case Format.ASTC_SRGBA_6X5:
                case Format.ASTC_SRGBA_6X6:
                case Format.ASTC_SRGBA_8X5:
                case Format.ASTC_SRGBA_8X6:
                case Format.ASTC_SRGBA_8X8:
                case Format.ASTC_SRGBA_10X5:
                case Format.ASTC_SRGBA_10X6:
                case Format.ASTC_SRGBA_10X8:
                case Format.ASTC_SRGBA_10X10:
                case Format.ASTC_SRGBA_12X10:
                case Format.ASTC_SRGBA_12X12:
                  return gl.UNSIGNED_BYTE;

                default:
                  {
                    return gl.UNSIGNED_BYTE;
                  }
              }
            }
            function GFXFormatToWebGLInternalFormat$1(format, gl) {
              switch (format) {
                case Format.A8:
                  return gl.ALPHA;

                case Format.L8:
                  return gl.LUMINANCE;

                case Format.LA8:
                  return gl.LUMINANCE_ALPHA;

                case Format.R8:
                  return gl.R8;

                case Format.R8SN:
                  return gl.R8_SNORM;

                case Format.R8UI:
                  return gl.R8UI;

                case Format.R8I:
                  return gl.R8I;

                case Format.RG8:
                  return gl.RG8;

                case Format.RG8SN:
                  return gl.RG8_SNORM;

                case Format.RG8UI:
                  return gl.RG8UI;

                case Format.RG8I:
                  return gl.RG8I;

                case Format.RGB8:
                  return gl.RGB8;

                case Format.RGB8SN:
                  return gl.RGB8_SNORM;

                case Format.RGB8UI:
                  return gl.RGB8UI;

                case Format.RGB8I:
                  return gl.RGB8I;

                case Format.BGRA8:
                  return gl.RGBA8;

                case Format.RGBA8:
                  return gl.RGBA8;

                case Format.RGBA8SN:
                  return gl.RGBA8_SNORM;

                case Format.RGBA8UI:
                  return gl.RGBA8UI;

                case Format.RGBA8I:
                  return gl.RGBA8I;

                case Format.R16I:
                  return gl.R16I;

                case Format.R16UI:
                  return gl.R16UI;

                case Format.R16F:
                  return gl.R16F;

                case Format.RG16I:
                  return gl.RG16I;

                case Format.RG16UI:
                  return gl.RG16UI;

                case Format.RG16F:
                  return gl.RG16F;

                case Format.RGB16I:
                  return gl.RGB16I;

                case Format.RGB16UI:
                  return gl.RGB16UI;

                case Format.RGB16F:
                  return gl.RGB16F;

                case Format.RGBA16I:
                  return gl.RGBA16I;

                case Format.RGBA16UI:
                  return gl.RGBA16UI;

                case Format.RGBA16F:
                  return gl.RGBA16F;

                case Format.R32I:
                  return gl.R32I;

                case Format.R32UI:
                  return gl.R32UI;

                case Format.R32F:
                  return gl.R32F;

                case Format.RG32I:
                  return gl.RG32I;

                case Format.RG32UI:
                  return gl.RG32UI;

                case Format.RG32F:
                  return gl.RG32F;

                case Format.RGB32I:
                  return gl.RGB32I;

                case Format.RGB32UI:
                  return gl.RGB32UI;

                case Format.RGB32F:
                  return gl.RGB32F;

                case Format.RGBA32I:
                  return gl.RGBA32I;

                case Format.RGBA32UI:
                  return gl.RGBA32UI;

                case Format.RGBA32F:
                  return gl.RGBA32F;

                case Format.R5G6B5:
                  return gl.RGB565;

                case Format.RGB5A1:
                  return gl.RGB5_A1;

                case Format.RGBA4:
                  return gl.RGBA4;

                case Format.SRGB8:
                  return gl.SRGB8;

                case Format.SRGB8_A8:
                  return gl.SRGB8_ALPHA8;

                case Format.RGB10A2:
                  return gl.RGB10_A2;

                case Format.RGB10A2UI:
                  return gl.RGB10_A2UI;

                case Format.R11G11B10F:
                  return gl.R11F_G11F_B10F;

                case Format.DEPTH:
                  return gl.DEPTH_COMPONENT32F;

                case Format.DEPTH_STENCIL:
                  return gl.DEPTH24_STENCIL8;

                case Format.BC1:
                  return WebGL2EXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

                case Format.BC1_ALPHA:
                  return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

                case Format.BC1_SRGB:
                  return WebGL2EXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

                case Format.BC1_SRGB_ALPHA:
                  return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

                case Format.BC2:
                  return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

                case Format.BC2_SRGB:
                  return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

                case Format.BC3:
                  return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                case Format.BC3_SRGB:
                  return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

                case Format.ETC_RGB8:
                  return WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL;

                case Format.ETC2_RGB8:
                  return WebGL2EXT.COMPRESSED_RGB8_ETC2;

                case Format.ETC2_SRGB8:
                  return WebGL2EXT.COMPRESSED_SRGB8_ETC2;

                case Format.ETC2_RGB8_A1:
                  return WebGL2EXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_SRGB8_A1:
                  return WebGL2EXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_RGBA8:
                  return WebGL2EXT.COMPRESSED_RGBA8_ETC2_EAC;

                case Format.ETC2_SRGB8_A8:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

                case Format.EAC_R11:
                  return WebGL2EXT.COMPRESSED_R11_EAC;

                case Format.EAC_R11SN:
                  return WebGL2EXT.COMPRESSED_SIGNED_R11_EAC;

                case Format.EAC_RG11:
                  return WebGL2EXT.COMPRESSED_RG11_EAC;

                case Format.EAC_RG11SN:
                  return WebGL2EXT.COMPRESSED_SIGNED_RG11_EAC;

                case Format.PVRTC_RGB2:
                  return WebGL2EXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGBA2:
                  return WebGL2EXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGB4:
                  return WebGL2EXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

                case Format.PVRTC_RGBA4:
                  return WebGL2EXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                case Format.ASTC_RGBA_4X4:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_4x4_KHR;

                case Format.ASTC_RGBA_5X4:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_5x4_KHR;

                case Format.ASTC_RGBA_5X5:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_5x5_KHR;

                case Format.ASTC_RGBA_6X5:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_6x5_KHR;

                case Format.ASTC_RGBA_6X6:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_6x6_KHR;

                case Format.ASTC_RGBA_8X5:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x5_KHR;

                case Format.ASTC_RGBA_8X6:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x6_KHR;

                case Format.ASTC_RGBA_8X8:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x8_KHR;

                case Format.ASTC_RGBA_10X5:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x5_KHR;

                case Format.ASTC_RGBA_10X6:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x6_KHR;

                case Format.ASTC_RGBA_10X8:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x8_KHR;

                case Format.ASTC_RGBA_10X10:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x10_KHR;

                case Format.ASTC_RGBA_12X10:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_12x10_KHR;

                case Format.ASTC_RGBA_12X12:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_12x12_KHR;

                case Format.ASTC_SRGBA_4X4:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

                case Format.ASTC_SRGBA_5X4:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

                case Format.ASTC_SRGBA_5X5:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

                case Format.ASTC_SRGBA_6X5:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

                case Format.ASTC_SRGBA_6X6:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

                case Format.ASTC_SRGBA_8X5:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

                case Format.ASTC_SRGBA_8X6:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

                case Format.ASTC_SRGBA_8X8:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

                case Format.ASTC_SRGBA_10X5:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

                case Format.ASTC_SRGBA_10X6:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

                case Format.ASTC_SRGBA_10X8:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

                case Format.ASTC_SRGBA_10X10:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

                case Format.ASTC_SRGBA_12X10:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

                case Format.ASTC_SRGBA_12X12:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

                default:
                  {
                    console.error('Unsupported Format, convert to WebGL internal format failed.');
                    return gl.RGBA;
                  }
              }
            }
            function GFXFormatToWebGLFormat$1(format, gl) {
              switch (format) {
                case Format.A8:
                  return gl.ALPHA;

                case Format.L8:
                  return gl.LUMINANCE;

                case Format.LA8:
                  return gl.LUMINANCE_ALPHA;

                case Format.R8:
                case Format.R8SN:
                  return gl.RED;

                case Format.R8UI:
                case Format.R8I:
                  return gl.RED;

                case Format.RG8:
                case Format.RG8SN:
                case Format.RG8UI:
                case Format.RG8I:
                  return gl.RG;

                case Format.RGB8:
                case Format.RGB8SN:
                case Format.RGB8UI:
                case Format.RGB8I:
                  return gl.RGB;

                case Format.BGRA8:
                case Format.RGBA8:
                case Format.RGBA8SN:
                case Format.RGBA8UI:
                case Format.RGBA8I:
                  return gl.RGBA;

                case Format.R16UI:
                case Format.R16I:
                case Format.R16F:
                  return gl.RED;

                case Format.RG16UI:
                case Format.RG16I:
                case Format.RG16F:
                  return gl.RG;

                case Format.RGB16UI:
                case Format.RGB16I:
                case Format.RGB16F:
                  return gl.RGB;

                case Format.RGBA16UI:
                case Format.RGBA16I:
                case Format.RGBA16F:
                  return gl.RGBA;

                case Format.R32UI:
                case Format.R32I:
                case Format.R32F:
                  return gl.RED;

                case Format.RG32UI:
                case Format.RG32I:
                case Format.RG32F:
                  return gl.RG;

                case Format.RGB32UI:
                case Format.RGB32I:
                case Format.RGB32F:
                  return gl.RGB;

                case Format.RGBA32UI:
                case Format.RGBA32I:
                case Format.RGBA32F:
                  return gl.RGBA;

                case Format.RGB10A2:
                  return gl.RGBA;

                case Format.R11G11B10F:
                  return gl.RGB;

                case Format.R5G6B5:
                  return gl.RGB;

                case Format.RGB5A1:
                  return gl.RGBA;

                case Format.RGBA4:
                  return gl.RGBA;

                case Format.SRGB8:
                  return gl.RGB;

                case Format.SRGB8_A8:
                  return gl.RGBA;

                case Format.DEPTH:
                  return gl.DEPTH_COMPONENT;

                case Format.DEPTH_STENCIL:
                  return gl.DEPTH_STENCIL;

                case Format.BC1:
                  return WebGL2EXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

                case Format.BC1_ALPHA:
                  return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

                case Format.BC1_SRGB:
                  return WebGL2EXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

                case Format.BC1_SRGB_ALPHA:
                  return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

                case Format.BC2:
                  return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

                case Format.BC2_SRGB:
                  return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

                case Format.BC3:
                  return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                case Format.BC3_SRGB:
                  return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

                case Format.ETC_RGB8:
                  return WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL;

                case Format.ETC2_RGB8:
                  return WebGL2EXT.COMPRESSED_RGB8_ETC2;

                case Format.ETC2_SRGB8:
                  return WebGL2EXT.COMPRESSED_SRGB8_ETC2;

                case Format.ETC2_RGB8_A1:
                  return WebGL2EXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_SRGB8_A1:
                  return WebGL2EXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_RGBA8:
                  return WebGL2EXT.COMPRESSED_RGBA8_ETC2_EAC;

                case Format.ETC2_SRGB8_A8:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

                case Format.EAC_R11:
                  return WebGL2EXT.COMPRESSED_R11_EAC;

                case Format.EAC_R11SN:
                  return WebGL2EXT.COMPRESSED_SIGNED_R11_EAC;

                case Format.EAC_RG11:
                  return WebGL2EXT.COMPRESSED_RG11_EAC;

                case Format.EAC_RG11SN:
                  return WebGL2EXT.COMPRESSED_SIGNED_RG11_EAC;

                case Format.PVRTC_RGB2:
                  return WebGL2EXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGBA2:
                  return WebGL2EXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGB4:
                  return WebGL2EXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

                case Format.PVRTC_RGBA4:
                  return WebGL2EXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                case Format.ASTC_RGBA_4X4:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_4x4_KHR;

                case Format.ASTC_RGBA_5X4:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_5x4_KHR;

                case Format.ASTC_RGBA_5X5:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_5x5_KHR;

                case Format.ASTC_RGBA_6X5:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_6x5_KHR;

                case Format.ASTC_RGBA_6X6:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_6x6_KHR;

                case Format.ASTC_RGBA_8X5:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x5_KHR;

                case Format.ASTC_RGBA_8X6:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x6_KHR;

                case Format.ASTC_RGBA_8X8:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x8_KHR;

                case Format.ASTC_RGBA_10X5:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x5_KHR;

                case Format.ASTC_RGBA_10X6:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x6_KHR;

                case Format.ASTC_RGBA_10X8:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x8_KHR;

                case Format.ASTC_RGBA_10X10:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x10_KHR;

                case Format.ASTC_RGBA_12X10:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_12x10_KHR;

                case Format.ASTC_RGBA_12X12:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_12x12_KHR;

                case Format.ASTC_SRGBA_4X4:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

                case Format.ASTC_SRGBA_5X4:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

                case Format.ASTC_SRGBA_5X5:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

                case Format.ASTC_SRGBA_6X5:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

                case Format.ASTC_SRGBA_6X6:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

                case Format.ASTC_SRGBA_8X5:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

                case Format.ASTC_SRGBA_8X6:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

                case Format.ASTC_SRGBA_8X8:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

                case Format.ASTC_SRGBA_10X5:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

                case Format.ASTC_SRGBA_10X6:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

                case Format.ASTC_SRGBA_10X8:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

                case Format.ASTC_SRGBA_10X10:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

                case Format.ASTC_SRGBA_12X10:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

                case Format.ASTC_SRGBA_12X12:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

                default:
                  {
                    console.error('Unsupported Format, convert to WebGL format failed.');
                    return gl.RGBA;
                  }
              }
            }

            function GFXTypeToWebGLType$1(type, gl) {
              switch (type) {
                case Type$1.BOOL:
                  return gl.BOOL;

                case Type$1.BOOL2:
                  return gl.BOOL_VEC2;

                case Type$1.BOOL3:
                  return gl.BOOL_VEC3;

                case Type$1.BOOL4:
                  return gl.BOOL_VEC4;

                case Type$1.INT:
                  return gl.INT;

                case Type$1.INT2:
                  return gl.INT_VEC2;

                case Type$1.INT3:
                  return gl.INT_VEC3;

                case Type$1.INT4:
                  return gl.INT_VEC4;

                case Type$1.UINT:
                  return gl.UNSIGNED_INT;

                case Type$1.FLOAT:
                  return gl.FLOAT;

                case Type$1.FLOAT2:
                  return gl.FLOAT_VEC2;

                case Type$1.FLOAT3:
                  return gl.FLOAT_VEC3;

                case Type$1.FLOAT4:
                  return gl.FLOAT_VEC4;

                case Type$1.MAT2:
                  return gl.FLOAT_MAT2;

                case Type$1.MAT2X3:
                  return gl.FLOAT_MAT2x3;

                case Type$1.MAT2X4:
                  return gl.FLOAT_MAT2x4;

                case Type$1.MAT3X2:
                  return gl.FLOAT_MAT3x2;

                case Type$1.MAT3:
                  return gl.FLOAT_MAT3;

                case Type$1.MAT3X4:
                  return gl.FLOAT_MAT3x4;

                case Type$1.MAT4X2:
                  return gl.FLOAT_MAT4x2;

                case Type$1.MAT4X3:
                  return gl.FLOAT_MAT4x3;

                case Type$1.MAT4:
                  return gl.FLOAT_MAT4;

                case Type$1.SAMPLER2D:
                  return gl.SAMPLER_2D;

                case Type$1.SAMPLER2D_ARRAY:
                  return gl.SAMPLER_2D_ARRAY;

                case Type$1.SAMPLER3D:
                  return gl.SAMPLER_3D;

                case Type$1.SAMPLER_CUBE:
                  return gl.SAMPLER_CUBE;

                default:
                  {
                    console.error('Unsupported GLType, convert to GL type failed.');
                    return Type$1.UNKNOWN;
                  }
              }
            }

            function WebGLTypeToGFXType$1(glType, gl) {
              switch (glType) {
                case gl.BOOL:
                  return Type$1.BOOL;

                case gl.BOOL_VEC2:
                  return Type$1.BOOL2;

                case gl.BOOL_VEC3:
                  return Type$1.BOOL3;

                case gl.BOOL_VEC4:
                  return Type$1.BOOL4;

                case gl.INT:
                  return Type$1.INT;

                case gl.INT_VEC2:
                  return Type$1.INT2;

                case gl.INT_VEC3:
                  return Type$1.INT3;

                case gl.INT_VEC4:
                  return Type$1.INT4;

                case gl.UNSIGNED_INT:
                  return Type$1.UINT;

                case gl.UNSIGNED_INT_VEC2:
                  return Type$1.UINT2;

                case gl.UNSIGNED_INT_VEC3:
                  return Type$1.UINT3;

                case gl.UNSIGNED_INT_VEC4:
                  return Type$1.UINT4;

                case gl.FLOAT:
                  return Type$1.FLOAT;

                case gl.FLOAT_VEC2:
                  return Type$1.FLOAT2;

                case gl.FLOAT_VEC3:
                  return Type$1.FLOAT3;

                case gl.FLOAT_VEC4:
                  return Type$1.FLOAT4;

                case gl.FLOAT_MAT2:
                  return Type$1.MAT2;

                case gl.FLOAT_MAT2x3:
                  return Type$1.MAT2X3;

                case gl.FLOAT_MAT2x4:
                  return Type$1.MAT2X4;

                case gl.FLOAT_MAT3x2:
                  return Type$1.MAT3X2;

                case gl.FLOAT_MAT3:
                  return Type$1.MAT3;

                case gl.FLOAT_MAT3x4:
                  return Type$1.MAT3X4;

                case gl.FLOAT_MAT4x2:
                  return Type$1.MAT4X2;

                case gl.FLOAT_MAT4x3:
                  return Type$1.MAT4X3;

                case gl.FLOAT_MAT4:
                  return Type$1.MAT4;

                case gl.SAMPLER_2D:
                  return Type$1.SAMPLER2D;

                case gl.SAMPLER_2D_ARRAY:
                  return Type$1.SAMPLER2D_ARRAY;

                case gl.SAMPLER_3D:
                  return Type$1.SAMPLER3D;

                case gl.SAMPLER_CUBE:
                  return Type$1.SAMPLER_CUBE;

                default:
                  {
                    console.error('Unsupported GLType, convert to Type failed.');
                    return Type$1.UNKNOWN;
                  }
              }
            }

            function WebGLGetTypeSize$1(glType, gl) {
              switch (glType) {
                case gl.BOOL:
                  return 4;

                case gl.BOOL_VEC2:
                  return 8;

                case gl.BOOL_VEC3:
                  return 12;

                case gl.BOOL_VEC4:
                  return 16;

                case gl.INT:
                  return 4;

                case gl.INT_VEC2:
                  return 8;

                case gl.INT_VEC3:
                  return 12;

                case gl.INT_VEC4:
                  return 16;

                case gl.UNSIGNED_INT:
                  return 4;

                case gl.UNSIGNED_INT_VEC2:
                  return 8;

                case gl.UNSIGNED_INT_VEC3:
                  return 12;

                case gl.UNSIGNED_INT_VEC4:
                  return 16;

                case gl.FLOAT:
                  return 4;

                case gl.FLOAT_VEC2:
                  return 8;

                case gl.FLOAT_VEC3:
                  return 12;

                case gl.FLOAT_VEC4:
                  return 16;

                case gl.FLOAT_MAT2:
                  return 16;

                case gl.FLOAT_MAT2x3:
                  return 24;

                case gl.FLOAT_MAT2x4:
                  return 32;

                case gl.FLOAT_MAT3x2:
                  return 24;

                case gl.FLOAT_MAT3:
                  return 36;

                case gl.FLOAT_MAT3x4:
                  return 48;

                case gl.FLOAT_MAT4x2:
                  return 32;

                case gl.FLOAT_MAT4x3:
                  return 48;

                case gl.FLOAT_MAT4:
                  return 64;

                case gl.SAMPLER_2D:
                  return 4;

                case gl.SAMPLER_2D_ARRAY:
                  return 4;

                case gl.SAMPLER_2D_ARRAY_SHADOW:
                  return 4;

                case gl.SAMPLER_3D:
                  return 4;

                case gl.SAMPLER_CUBE:
                  return 4;

                case gl.INT_SAMPLER_2D:
                  return 4;

                case gl.INT_SAMPLER_2D_ARRAY:
                  return 4;

                case gl.INT_SAMPLER_3D:
                  return 4;

                case gl.INT_SAMPLER_CUBE:
                  return 4;

                case gl.UNSIGNED_INT_SAMPLER_2D:
                  return 4;

                case gl.UNSIGNED_INT_SAMPLER_2D_ARRAY:
                  return 4;

                case gl.UNSIGNED_INT_SAMPLER_3D:
                  return 4;

                case gl.UNSIGNED_INT_SAMPLER_CUBE:
                  return 4;

                default:
                  {
                    console.error('Unsupported GLType, get type failed.');
                    return 0;
                  }
              }
            }

            function WebGLGetComponentCount$1(glType, gl) {
              switch (glType) {
                case gl.FLOAT_MAT2:
                  return 2;

                case gl.FLOAT_MAT2x3:
                  return 2;

                case gl.FLOAT_MAT2x4:
                  return 2;

                case gl.FLOAT_MAT3x2:
                  return 3;

                case gl.FLOAT_MAT3:
                  return 3;

                case gl.FLOAT_MAT3x4:
                  return 3;

                case gl.FLOAT_MAT4x2:
                  return 4;

                case gl.FLOAT_MAT4x3:
                  return 4;

                case gl.FLOAT_MAT4:
                  return 4;

                default:
                  {
                    return 1;
                  }
              }
            }

            var WebGLCmpFuncs$1 = [0x0200, 0x0201, 0x0202, 0x0203, 0x0204, 0x0205, 0x0206, 0x0207];
            var WebGLStencilOps$1 = [0x0000, 0x1E00, 0x1E01, 0x1E02, 0x1E03, 0x150A, 0x8507, 0x8508];
            var WebGLBlendOps$1 = [0x8006, 0x800A, 0x800B, 0x8007, 0x8008];
            var WebGLBlendFactors$1 = [0x0000, 0x0001, 0x0302, 0x0304, 0x0303, 0x0305, 0x0300, 0x0306, 0x0301, 0x0307, 0x0308, 0x8001, 0x8002, 0x8003, 0x8004];
            var WebGL2Cmd;

            (function (WebGL2Cmd) {
              WebGL2Cmd[WebGL2Cmd["BEGIN_RENDER_PASS"] = 0] = "BEGIN_RENDER_PASS";
              WebGL2Cmd[WebGL2Cmd["END_RENDER_PASS"] = 1] = "END_RENDER_PASS";
              WebGL2Cmd[WebGL2Cmd["BIND_STATES"] = 2] = "BIND_STATES";
              WebGL2Cmd[WebGL2Cmd["DRAW"] = 3] = "DRAW";
              WebGL2Cmd[WebGL2Cmd["UPDATE_BUFFER"] = 4] = "UPDATE_BUFFER";
              WebGL2Cmd[WebGL2Cmd["COPY_BUFFER_TO_TEXTURE"] = 5] = "COPY_BUFFER_TO_TEXTURE";
              WebGL2Cmd[WebGL2Cmd["BLIT_TEXTURE"] = 6] = "BLIT_TEXTURE";
              WebGL2Cmd[WebGL2Cmd["COUNT"] = 7] = "COUNT";
            })(WebGL2Cmd || (WebGL2Cmd = {}));

            var WebGL2CmdObject = function WebGL2CmdObject(type) {
              this.cmdType = void 0;
              this.refCount = 0;
              this.cmdType = type;
            };
            var WebGL2CmdBeginRenderPass = function (_WebGL2CmdObject) {
              _inheritsLoose(WebGL2CmdBeginRenderPass, _WebGL2CmdObject);

              function WebGL2CmdBeginRenderPass() {
                var _this;

                _this = _WebGL2CmdObject.call(this, WebGL2Cmd.BEGIN_RENDER_PASS) || this;
                _this.gpuRenderPass = null;
                _this.gpuFramebuffer = null;
                _this.renderArea = new Rect();
                _this.clearColors = [];
                _this.clearDepth = 1.0;
                _this.clearStencil = 0;
                return _this;
              }

              var _proto = WebGL2CmdBeginRenderPass.prototype;

              _proto.clear = function clear() {
                this.gpuFramebuffer = null;
                this.clearColors.length = 0;
              };

              return WebGL2CmdBeginRenderPass;
            }(WebGL2CmdObject);
            var WebGL2CmdBindStates = function (_WebGL2CmdObject2) {
              _inheritsLoose(WebGL2CmdBindStates, _WebGL2CmdObject2);

              function WebGL2CmdBindStates() {
                var _this2;

                _this2 = _WebGL2CmdObject2.call(this, WebGL2Cmd.BIND_STATES) || this;
                _this2.gpuPipelineState = null;
                _this2.gpuInputAssembler = null;
                _this2.gpuDescriptorSets = [];
                _this2.dynamicOffsets = [];
                _this2.dynamicStates = new DynamicStates();
                return _this2;
              }

              var _proto2 = WebGL2CmdBindStates.prototype;

              _proto2.clear = function clear() {
                this.gpuPipelineState = null;
                this.gpuInputAssembler = null;
                this.gpuDescriptorSets.length = 0;
                this.dynamicOffsets.length = 0;
              };

              return WebGL2CmdBindStates;
            }(WebGL2CmdObject);
            var WebGL2CmdDraw = function (_WebGL2CmdObject3) {
              _inheritsLoose(WebGL2CmdDraw, _WebGL2CmdObject3);

              function WebGL2CmdDraw() {
                var _this3;

                _this3 = _WebGL2CmdObject3.call(this, WebGL2Cmd.DRAW) || this;
                _this3.drawInfo = new DrawInfo();
                return _this3;
              }

              var _proto3 = WebGL2CmdDraw.prototype;

              _proto3.clear = function clear() {};

              return WebGL2CmdDraw;
            }(WebGL2CmdObject);
            var WebGL2CmdUpdateBuffer = function (_WebGL2CmdObject4) {
              _inheritsLoose(WebGL2CmdUpdateBuffer, _WebGL2CmdObject4);

              function WebGL2CmdUpdateBuffer() {
                var _this4;

                _this4 = _WebGL2CmdObject4.call(this, WebGL2Cmd.UPDATE_BUFFER) || this;
                _this4.gpuBuffer = null;
                _this4.buffer = null;
                _this4.offset = 0;
                _this4.size = 0;
                return _this4;
              }

              var _proto4 = WebGL2CmdUpdateBuffer.prototype;

              _proto4.clear = function clear() {
                this.gpuBuffer = null;
                this.buffer = null;
              };

              return WebGL2CmdUpdateBuffer;
            }(WebGL2CmdObject);
            var WebGL2CmdCopyBufferToTexture = function (_WebGL2CmdObject5) {
              _inheritsLoose(WebGL2CmdCopyBufferToTexture, _WebGL2CmdObject5);

              function WebGL2CmdCopyBufferToTexture() {
                var _this5;

                _this5 = _WebGL2CmdObject5.call(this, WebGL2Cmd.COPY_BUFFER_TO_TEXTURE) || this;
                _this5.gpuTexture = null;
                _this5.buffers = [];
                _this5.regions = [];
                return _this5;
              }

              var _proto5 = WebGL2CmdCopyBufferToTexture.prototype;

              _proto5.clear = function clear() {
                this.gpuTexture = null;
                this.buffers.length = 0;
                this.regions.length = 0;
              };

              return WebGL2CmdCopyBufferToTexture;
            }(WebGL2CmdObject);
            var WebGL2CmdBlitTexture = function (_WebGL2CmdObject6) {
              _inheritsLoose(WebGL2CmdBlitTexture, _WebGL2CmdObject6);

              function WebGL2CmdBlitTexture() {
                var _this6;

                _this6 = _WebGL2CmdObject6.call(this, WebGL2Cmd.BLIT_TEXTURE) || this;
                _this6.srcTexture = null;
                _this6.dstTexture = null;
                _this6.regions = [];
                _this6.filter = Filter.LINEAR;
                return _this6;
              }

              var _proto6 = WebGL2CmdBlitTexture.prototype;

              _proto6.clear = function clear() {
                this.srcTexture = null;
                this.dstTexture = null;
                this.regions.length = 0;
              };

              return WebGL2CmdBlitTexture;
            }(WebGL2CmdObject);
            var WebGL2CmdPackage = function () {
              function WebGL2CmdPackage() {
                this.cmds = new CachedArray(1);
                this.beginRenderPassCmds = new CachedArray(1);
                this.bindStatesCmds = new CachedArray(1);
                this.drawCmds = new CachedArray(1);
                this.updateBufferCmds = new CachedArray(1);
                this.copyBufferToTextureCmds = new CachedArray(1);
                this.blitTextureCmds = new CachedArray(1);
              }

              var _proto7 = WebGL2CmdPackage.prototype;

              _proto7.clearCmds = function clearCmds(allocator) {
                if (this.beginRenderPassCmds.length) {
                  allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds);
                  this.beginRenderPassCmds.clear();
                }

                if (this.bindStatesCmds.length) {
                  allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds);
                  this.bindStatesCmds.clear();
                }

                if (this.drawCmds.length) {
                  allocator.drawCmdPool.freeCmds(this.drawCmds);
                  this.drawCmds.clear();
                }

                if (this.updateBufferCmds.length) {
                  allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds);
                  this.updateBufferCmds.clear();
                }

                if (this.copyBufferToTextureCmds.length) {
                  allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds);
                  this.copyBufferToTextureCmds.clear();
                }

                if (this.blitTextureCmds.length) {
                  allocator.blitTextureCmdPool.freeCmds(this.blitTextureCmds);
                  this.blitTextureCmds.clear();
                }

                this.cmds.clear();
              };

              return WebGL2CmdPackage;
            }();
            function WebGL2CmdFuncCreateBuffer(device, gpuBuffer) {
              var gl = device.gl;
              var cache = device.stateCache;
              var glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

              if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
                gpuBuffer.glTarget = gl.ARRAY_BUFFER;
                var glBuffer = gl.createBuffer();

                if (glBuffer) {
                  gpuBuffer.glBuffer = glBuffer;

                  if (gpuBuffer.size > 0) {
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        gl.bindVertexArray(null);
                        cache.glVAO = null;
                      }
                    }

                    gfxStateCache$1.gpuInputAssembler = null;

                    if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                      device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
                    }

                    gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    device.stateCache.glArrayBuffer = null;
                  }
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
                gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;

                var _glBuffer = gl.createBuffer();

                if (_glBuffer) {
                  gpuBuffer.glBuffer = _glBuffer;

                  if (gpuBuffer.size > 0) {
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        gl.bindVertexArray(null);
                        cache.glVAO = null;
                      }
                    }

                    gfxStateCache$1.gpuInputAssembler = null;

                    if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                      device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
                    }

                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    device.stateCache.glElementArrayBuffer = null;
                  }
                }
              } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
                gpuBuffer.glTarget = gl.UNIFORM_BUFFER;

                var _glBuffer2 = gl.createBuffer();

                if (_glBuffer2 && gpuBuffer.size > 0) {
                  gpuBuffer.glBuffer = _glBuffer2;

                  if (device.stateCache.glUniformBuffer !== gpuBuffer.glBuffer) {
                    gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer);
                    device.stateCache.glUniformBuffer = gpuBuffer.glBuffer;
                  }

                  gl.bufferData(gl.UNIFORM_BUFFER, gpuBuffer.size, glUsage);
                  gl.bindBuffer(gl.UNIFORM_BUFFER, null);
                  device.stateCache.glUniformBuffer = null;
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
                gpuBuffer.glTarget = gl.NONE;
              } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_DST) {
                gpuBuffer.glTarget = gl.NONE;
              } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
                gpuBuffer.glTarget = gl.NONE;
              } else {
                console.error('Unsupported BufferType, create buffer failed.');
                gpuBuffer.glTarget = gl.NONE;
              }
            }
            function WebGL2CmdFuncDestroyBuffer(device, gpuBuffer) {
              var gl = device.gl;
              var cache = device.stateCache;

              if (gpuBuffer.glBuffer) {
                switch (gpuBuffer.glTarget) {
                  case gl.ARRAY_BUFFER:
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        gl.bindVertexArray(null);
                        device.stateCache.glVAO = null;
                      }
                    }

                    gfxStateCache$1.gpuInputAssembler = null;
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    device.stateCache.glArrayBuffer = null;
                    break;

                  case gl.ELEMENT_ARRAY_BUFFER:
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        gl.bindVertexArray(null);
                        device.stateCache.glVAO = null;
                      }
                    }

                    gfxStateCache$1.gpuInputAssembler = null;
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    device.stateCache.glElementArrayBuffer = null;
                    break;

                  case gl.UNIFORM_BUFFER:
                    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
                    device.stateCache.glUniformBuffer = null;
                    break;
                }

                gl.deleteBuffer(gpuBuffer.glBuffer);
                gpuBuffer.glBuffer = null;
              }
            }
            function WebGL2CmdFuncResizeBuffer(device, gpuBuffer) {
              var gl = device.gl;
              var cache = device.stateCache;
              var glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

              if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    gl.bindVertexArray(null);
                    cache.glVAO = null;
                  }
                }

                gfxStateCache$1.gpuInputAssembler = null;

                if (cache.glArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                }

                if (gpuBuffer.buffer) {
                  gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
                } else {
                  gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                cache.glArrayBuffer = null;
              } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    gl.bindVertexArray(null);
                    cache.glVAO = null;
                  }
                }

                gfxStateCache$1.gpuInputAssembler = null;

                if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                }

                if (gpuBuffer.buffer) {
                  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
                } else {
                  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
                }

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                device.stateCache.glElementArrayBuffer = null;
              } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
                if (device.stateCache.glUniformBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer);
                }

                gl.bufferData(gl.UNIFORM_BUFFER, gpuBuffer.size, glUsage);
                gl.bindBuffer(gl.UNIFORM_BUFFER, null);
                device.stateCache.glUniformBuffer = null;
              } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT || gpuBuffer.usage & BufferUsageBit.TRANSFER_DST || gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
                gpuBuffer.glTarget = gl.NONE;
              } else {
                console.error('Unsupported BufferType, create buffer failed.');
                gpuBuffer.glTarget = gl.NONE;
              }
            }
            function WebGL2CmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
              if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
                gpuBuffer.indirects.clearDraws();
                var drawInfos = buffer.drawInfos;

                for (var i = 0; i < drawInfos.length; ++i) {
                  gpuBuffer.indirects.setDrawInfo(offset + i, drawInfos[i]);
                }
              } else {
                var buff = buffer;
                var gl = device.gl;
                var cache = device.stateCache;

                switch (gpuBuffer.glTarget) {
                  case gl.ARRAY_BUFFER:
                    {
                      if (device.extensions.useVAO) {
                        if (cache.glVAO) {
                          gl.bindVertexArray(null);
                          cache.glVAO = null;
                        }
                      }

                      gfxStateCache$1.gpuInputAssembler = null;

                      if (cache.glArrayBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                        cache.glArrayBuffer = gpuBuffer.glBuffer;
                      }

                      if (size === buff.byteLength) {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                      } else {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                      }

                      break;
                    }

                  case gl.ELEMENT_ARRAY_BUFFER:
                    {
                      if (device.extensions.useVAO) {
                        if (cache.glVAO) {
                          gl.bindVertexArray(null);
                          cache.glVAO = null;
                        }
                      }

                      gfxStateCache$1.gpuInputAssembler = null;

                      if (cache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                        cache.glElementArrayBuffer = gpuBuffer.glBuffer;
                      }

                      if (size === buff.byteLength) {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                      } else {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                      }

                      break;
                    }

                  case gl.UNIFORM_BUFFER:
                    {
                      if (cache.glUniformBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer);
                        cache.glUniformBuffer = gpuBuffer.glBuffer;
                      }

                      if (size === buff.byteLength) {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                      } else {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, new Float32Array(buff, 0, size / 4));
                      }

                      break;
                    }

                  default:
                    {
                      console.error('Unsupported BufferType, update buffer failed.');
                    }
                }
              }
            }
            function WebGL2CmdFuncCreateTexture(device, gpuTexture) {
              var gl = device.gl;
              gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat$1(gpuTexture.format, gl);
              gpuTexture.glFormat = GFXFormatToWebGLFormat$1(gpuTexture.format, gl);
              gpuTexture.glType = GFXFormatToWebGLType$1(gpuTexture.format, gl);
              var w = gpuTexture.width;
              var h = gpuTexture.height;
              var d = gpuTexture.depth;
              var l = gpuTexture.arrayLayer;

              switch (gpuTexture.type) {
                case TextureType.TEX2D:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                    var maxSize = Math.max(w, h);

                    if (maxSize > device.capabilities.maxTextureSize) {
                      errorID(9100, maxSize, device.capabilities.maxTextureSize);
                    }

                    if (gpuTexture.samples === SampleCount.ONE) {
                      gpuTexture.glTexture = gl.createTexture();

                      if (gpuTexture.size > 0) {
                        var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                          gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                          glTexUnit.glTexture = gpuTexture.glTexture;
                        }

                        if (FormatInfos[gpuTexture.format].isCompressed) {
                          for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                            var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                            var view = new Uint8Array(imgSize);
                            gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                            w = Math.max(1, w >> 1);
                            h = Math.max(1, h >> 1);
                          }
                        } else {
                          gl.texStorage2D(gl.TEXTURE_2D, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h);
                        }
                      }
                    } else {
                      gpuTexture.glRenderbuffer = gl.createRenderbuffer();

                      if (gpuTexture.size > 0) {
                        if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                          gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                          device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                        }

                        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, gpuTexture.samples, gpuTexture.glInternalFmt, gpuTexture.width, gpuTexture.height);
                      }
                    }

                    break;
                  }

                case TextureType.TEX2D_ARRAY:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_2D_ARRAY;

                    var _maxSize = Math.max(w, h);

                    if (_maxSize > device.capabilities.maxTextureSize) {
                      errorID(9100, _maxSize, device.capabilities.maxTextureSize);
                    }

                    if (l > device.capabilities.maxArrayTextureLayers) {
                      errorID(9100, l, device.capabilities.maxArrayTextureLayers);
                    }

                    gpuTexture.glTexture = gl.createTexture();

                    if (gpuTexture.size > 0) {
                      var _glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                      if (_glTexUnit.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(gl.TEXTURE_2D_ARRAY, gpuTexture.glTexture);
                        _glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                          var _imgSize = FormatSize(gpuTexture.format, w, h, l);

                          var _view = new Uint8Array(_imgSize);

                          gl.compressedTexImage3D(gl.TEXTURE_2D_ARRAY, _i, gpuTexture.glInternalFmt, w, h, l, 0, _view);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      } else {
                        gl.texStorage3D(gl.TEXTURE_2D_ARRAY, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h, l);
                      }
                    }

                    break;
                  }

                case TextureType.TEX3D:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_3D;

                    var _maxSize2 = Math.max(Math.max(w, h), d);

                    if (_maxSize2 > device.capabilities.max3DTextureSize) {
                      errorID(9100, _maxSize2, device.capabilities.max3DTextureSize);
                    }

                    gpuTexture.glTexture = gl.createTexture();

                    if (gpuTexture.size > 0) {
                      var _glTexUnit2 = device.stateCache.glTexUnits[device.stateCache.texUnit];

                      if (_glTexUnit2.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(gl.TEXTURE_3D, gpuTexture.glTexture);
                        _glTexUnit2.glTexture = gpuTexture.glTexture;
                      }

                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (var _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) {
                          var _imgSize2 = FormatSize(gpuTexture.format, w, h, d);

                          var _view2 = new Uint8Array(_imgSize2);

                          gl.compressedTexImage3D(gl.TEXTURE_3D, _i2, gpuTexture.glInternalFmt, w, h, d, 0, _view2);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      } else {
                        gl.texStorage3D(gl.TEXTURE_3D, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h, d);
                      }
                    }

                    break;
                  }

                case TextureType.CUBE:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;

                    var _maxSize3 = Math.max(w, h);

                    if (_maxSize3 > device.capabilities.maxCubeMapTextureSize) {
                      errorID(9100, _maxSize3, device.capabilities.maxTextureSize);
                    }

                    gpuTexture.glTexture = gl.createTexture();

                    if (gpuTexture.size > 0) {
                      var _glTexUnit3 = device.stateCache.glTexUnits[device.stateCache.texUnit];

                      if (_glTexUnit3.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                        _glTexUnit3.glTexture = gpuTexture.glTexture;
                      }

                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (var _i3 = 0; _i3 < gpuTexture.mipLevel; ++_i3) {
                          var _imgSize3 = FormatSize(gpuTexture.format, w, h, 1);

                          var _view3 = new Uint8Array(_imgSize3);

                          for (var f = 0; f < 6; ++f) {
                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i3, gpuTexture.glInternalFmt, w, h, 0, _view3);
                          }

                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      } else {
                        gl.texStorage2D(gl.TEXTURE_CUBE_MAP, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h);
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported TextureType, create texture failed.');
                    gpuTexture.type = TextureType.TEX2D;
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                  }
              }
            }
            function WebGL2CmdFuncDestroyTexture(device, gpuTexture) {
              var gl = device.gl;

              if (gpuTexture.glTexture) {
                var glTexUnits = device.stateCache.glTexUnits;
                var texUnit = device.stateCache.texUnit;
                gl.deleteTexture(gpuTexture.glTexture);

                for (var i = 0; i < glTexUnits.length; ++i) {
                  if (glTexUnits[i].glTexture === gpuTexture.glTexture) {
                    gl.activeTexture(gl.TEXTURE0 + i);
                    texUnit = i;
                    gl.bindTexture(gpuTexture.glTarget, null);
                    glTexUnits[i].glTexture = null;
                  }
                }

                device.stateCache.texUnit = texUnit;
                gpuTexture.glTexture = null;
              }

              if (gpuTexture.glRenderbuffer) {
                var glRenderbuffer = device.stateCache.glRenderbuffer;
                gl.deleteRenderbuffer(gpuTexture.glRenderbuffer);

                if (glRenderbuffer === gpuTexture.glRenderbuffer) {
                  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                  glRenderbuffer = null;
                }

                gpuTexture.glRenderbuffer = null;
              }
            }
            function WebGL2CmdFuncResizeTexture(device, gpuTexture) {
              if (!gpuTexture.size) return;
              var gl = device.gl;
              var w = gpuTexture.width;
              var h = gpuTexture.height;
              var d = gpuTexture.depth;
              var l = gpuTexture.arrayLayer;

              switch (gpuTexture.type) {
                case TextureType.TEX2D:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                    var maxSize = Math.max(w, h);

                    if (maxSize > device.capabilities.maxTextureSize) {
                      errorID(9100, maxSize, device.capabilities.maxTextureSize);
                    }

                    if (gpuTexture.samples === SampleCount.ONE) {
                      var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                          var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                          var view = new Uint8Array(imgSize);
                          gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      } else {
                        WebGL2CmdFuncDestroyTexture(device, gpuTexture);
                        WebGL2CmdFuncCreateTexture(device, gpuTexture);
                      }
                    } else if (gpuTexture.glRenderbuffer) {
                      if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                        gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                        device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                      }

                      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, gpuTexture.samples, gpuTexture.glInternalFmt, gpuTexture.width, gpuTexture.height);
                    }

                    break;
                  }

                case TextureType.TEX2D_ARRAY:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_2D_ARRAY;

                    var _maxSize4 = Math.max(w, h);

                    if (_maxSize4 > device.capabilities.maxTextureSize) {
                      errorID(9100, _maxSize4, device.capabilities.maxTextureSize);
                    }

                    if (l > device.capabilities.maxArrayTextureLayers) {
                      errorID(9100, l, device.capabilities.maxArrayTextureLayers);
                    }

                    gpuTexture.glTexture = gl.createTexture();

                    if (gpuTexture.size > 0) {
                      var _glTexUnit4 = device.stateCache.glTexUnits[device.stateCache.texUnit];

                      if (_glTexUnit4.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(gl.TEXTURE_2D_ARRAY, gpuTexture.glTexture);
                        _glTexUnit4.glTexture = gpuTexture.glTexture;
                      }

                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (var _i4 = 0; _i4 < gpuTexture.mipLevel; ++_i4) {
                          var _imgSize4 = FormatSize(gpuTexture.format, w, h, l);

                          var _view4 = new Uint8Array(_imgSize4);

                          gl.compressedTexImage3D(gl.TEXTURE_2D_ARRAY, _i4, gpuTexture.glInternalFmt, w, h, l, 0, _view4);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      } else {
                        gl.texStorage3D(gl.TEXTURE_2D_ARRAY, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h, l);
                      }
                    }

                    break;
                  }

                case TextureType.TEX3D:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_3D;

                    var _maxSize5 = Math.max(Math.max(w, h), d);

                    if (_maxSize5 > device.capabilities.max3DTextureSize) {
                      errorID(9100, _maxSize5, device.capabilities.max3DTextureSize);
                    }

                    gpuTexture.glTexture = gl.createTexture();

                    if (gpuTexture.size > 0) {
                      var _glTexUnit5 = device.stateCache.glTexUnits[device.stateCache.texUnit];

                      if (_glTexUnit5.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(gl.TEXTURE_3D, gpuTexture.glTexture);
                        _glTexUnit5.glTexture = gpuTexture.glTexture;
                      }

                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (var _i5 = 0; _i5 < gpuTexture.mipLevel; ++_i5) {
                          var _imgSize5 = FormatSize(gpuTexture.format, w, h, d);

                          var _view5 = new Uint8Array(_imgSize5);

                          gl.compressedTexImage3D(gl.TEXTURE_3D, _i5, gpuTexture.glInternalFmt, w, h, d, 0, _view5);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      } else {
                        gl.texStorage3D(gl.TEXTURE_3D, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h, d);
                      }
                    }

                    break;
                  }

                case TextureType.CUBE:
                  {
                    gpuTexture.type = TextureType.CUBE;
                    gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;

                    var _maxSize6 = Math.max(w, h);

                    if (_maxSize6 > device.capabilities.maxCubeMapTextureSize) {
                      errorID(9100, _maxSize6, device.capabilities.maxTextureSize);
                    }

                    var _glTexUnit6 = device.stateCache.glTexUnits[device.stateCache.texUnit];

                    if (_glTexUnit6.glTexture !== gpuTexture.glTexture) {
                      gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                      _glTexUnit6.glTexture = gpuTexture.glTexture;
                    }

                    if (FormatInfos[gpuTexture.format].isCompressed) {
                      for (var f = 0; f < 6; ++f) {
                        w = gpuTexture.width;
                        h = gpuTexture.height;

                        for (var _i6 = 0; _i6 < gpuTexture.mipLevel; ++_i6) {
                          var _imgSize6 = FormatSize(gpuTexture.format, w, h, 1);

                          var _view6 = new Uint8Array(_imgSize6);

                          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i6, gpuTexture.glInternalFmt, w, h, 0, _view6);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      }
                    } else {
                      WebGL2CmdFuncDestroyTexture(device, gpuTexture);
                      WebGL2CmdFuncCreateTexture(device, gpuTexture);
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported TextureType, create texture failed.');
                    gpuTexture.type = TextureType.TEX2D;
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                  }
              }
            }
            function WebGL2CmdFuncPrepareSamplerInfo(device, gpuSampler) {
              var gl = device.gl;

              if (gpuSampler.minFilter === Filter.LINEAR || gpuSampler.minFilter === Filter.ANISOTROPIC) {
                if (gpuSampler.mipFilter === Filter.LINEAR || gpuSampler.mipFilter === Filter.ANISOTROPIC) {
                  gpuSampler.glMinFilter = gl.LINEAR_MIPMAP_LINEAR;
                } else if (gpuSampler.mipFilter === Filter.POINT) {
                  gpuSampler.glMinFilter = gl.LINEAR_MIPMAP_NEAREST;
                } else {
                  gpuSampler.glMinFilter = gl.LINEAR;
                }
              } else if (gpuSampler.mipFilter === Filter.LINEAR || gpuSampler.mipFilter === Filter.ANISOTROPIC) {
                gpuSampler.glMinFilter = gl.NEAREST_MIPMAP_LINEAR;
              } else if (gpuSampler.mipFilter === Filter.POINT) {
                gpuSampler.glMinFilter = gl.NEAREST_MIPMAP_NEAREST;
              } else {
                gpuSampler.glMinFilter = gl.NEAREST;
              }

              if (gpuSampler.magFilter === Filter.LINEAR || gpuSampler.magFilter === Filter.ANISOTROPIC) {
                gpuSampler.glMagFilter = gl.LINEAR;
              } else {
                gpuSampler.glMagFilter = gl.NEAREST;
              }

              gpuSampler.glWrapS = WebGLWraps$1[gpuSampler.addressU];
              gpuSampler.glWrapT = WebGLWraps$1[gpuSampler.addressV];
              gpuSampler.glWrapR = WebGLWraps$1[gpuSampler.addressW];
            }
            function WebGL2CmdFuncDestroySampler(device, gpuSampler) {
              var gl = device.gl;
              var it = gpuSampler.glSamplers.values();
              var res = it.next();

              while (!res.done) {
                gl.deleteSampler(res.value);
                var glSamplerUnits = device.stateCache.glSamplerUnits;

                for (var i = 0; i < glSamplerUnits.length; ++i) {
                  if (glSamplerUnits[i] === res.value) {
                    gl.bindSampler(i, null);
                    glSamplerUnits[i] = null;
                  }
                }
              }

              gpuSampler.glSamplers.clear();
            }
            function WebGL2CmdFuncCreateFramebuffer(device, gpuFramebuffer) {
              for (var i = 0; i < gpuFramebuffer.gpuColorViews.length; ++i) {
                var tex = gpuFramebuffer.gpuColorViews[i].gpuTexture;

                if (tex.isSwapchainTexture) {
                  gpuFramebuffer.isOffscreen = false;
                  return;
                }
              }

              var gl = device.gl;
              var attachments = [];
              var glFramebuffer = gl.createFramebuffer();

              if (glFramebuffer) {
                gpuFramebuffer.glFramebuffer = glFramebuffer;

                if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
                }

                for (var _i7 = 0; _i7 < gpuFramebuffer.gpuColorViews.length; ++_i7) {
                  var colorTextureView = gpuFramebuffer.gpuColorViews[_i7];
                  var colorTexture = colorTextureView.gpuTexture;

                  if (colorTexture) {
                    if (colorTexture.glTexture) {
                      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i7, colorTexture.glTarget, colorTexture.glTexture, colorTextureView.baseLevel);
                    } else {
                      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i7, gl.RENDERBUFFER, colorTexture.glRenderbuffer);
                    }

                    attachments.push(gl.COLOR_ATTACHMENT0 + _i7);
                    gpuFramebuffer.width = Math.min(gpuFramebuffer.width, colorTexture.width >> colorTextureView.baseLevel);
                    gpuFramebuffer.height = Math.min(gpuFramebuffer.height, colorTexture.height >> colorTextureView.baseLevel);
                  }
                }

                var dstView = gpuFramebuffer.gpuDepthStencilView;

                if (dstView) {
                  var dst = dstView.gpuTexture;
                  var glAttachment = FormatInfos[dst.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;

                  if (dst.glTexture) {
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dst.glTarget, dst.glTexture, gpuFramebuffer.gpuDepthStencilView.baseLevel);
                  } else {
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dst.glRenderbuffer);
                  }

                  gpuFramebuffer.width = Math.min(gpuFramebuffer.width, dst.width >> dstView.baseLevel);
                  gpuFramebuffer.height = Math.min(gpuFramebuffer.height, dst.height >> dstView.baseLevel);
                }

                gl.drawBuffers(attachments);
                var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

                if (status !== gl.FRAMEBUFFER_COMPLETE) {
                  switch (status) {
                    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT');
                        break;
                      }

                    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT');
                        break;
                      }

                    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS');
                        break;
                      }

                    case gl.FRAMEBUFFER_UNSUPPORTED:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED');
                        break;
                      }
                  }
                }

                if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, device.stateCache.glFramebuffer);
                }
              }
            }
            function WebGL2CmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
              if (gpuFramebuffer.glFramebuffer) {
                device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer);

                if (device.stateCache.glFramebuffer === gpuFramebuffer.glFramebuffer) {
                  device.gl.bindFramebuffer(device.gl.FRAMEBUFFER, null);
                  device.stateCache.glFramebuffer = null;
                }

                gpuFramebuffer.glFramebuffer = null;
              }
            }
            function WebGL2CmdFuncCreateShader(device, gpuShader) {
              var gl = device.gl;

              var _loop = function _loop(k) {
                var gpuStage = gpuShader.gpuStages[k];
                var glShaderType = 0;
                var shaderTypeStr = '';
                var lineNumber = 1;

                switch (gpuStage.type) {
                  case ShaderStageFlagBit.VERTEX:
                    {
                      shaderTypeStr = 'VertexShader';
                      glShaderType = gl.VERTEX_SHADER;
                      break;
                    }

                  case ShaderStageFlagBit.FRAGMENT:
                    {
                      shaderTypeStr = 'FragmentShader';
                      glShaderType = gl.FRAGMENT_SHADER;
                      break;
                    }

                  default:
                    {
                      console.error('Unsupported ShaderType.');
                      return {
                        v: void 0
                      };
                    }
                }

                var glShader = gl.createShader(glShaderType);

                if (glShader) {
                  gpuStage.glShader = glShader;
                  gl.shaderSource(gpuStage.glShader, "#version 300 es\n" + gpuStage.source);
                  gl.compileShader(gpuStage.glShader);

                  if (!gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS)) {
                    console.error(shaderTypeStr + " in '" + gpuShader.name + "' compilation failed.");
                    console.error('Shader source dump:', gpuStage.source.replace(/^|\n/g, function () {
                      return "\n" + lineNumber++ + " ";
                    }));
                    console.error(gl.getShaderInfoLog(gpuStage.glShader));

                    for (var l = 0; l < gpuShader.gpuStages.length; l++) {
                      var stage = gpuShader.gpuStages[k];

                      if (stage.glShader) {
                        gl.deleteShader(stage.glShader);
                        stage.glShader = null;
                      }
                    }

                    return {
                      v: void 0
                    };
                  }
                }
              };

              for (var k = 0; k < gpuShader.gpuStages.length; k++) {
                var _ret = _loop(k);

                if (typeof _ret === "object") return _ret.v;
              }

              var glProgram = gl.createProgram();

              if (!glProgram) {
                return;
              }

              gpuShader.glProgram = glProgram;
              var enableEffectImport = !!(legacyCC.rendering && legacyCC.rendering.enableEffectImport);

              for (var _k = 0; _k < gpuShader.gpuStages.length; _k++) {
                var gpuStage = gpuShader.gpuStages[_k];
                gl.attachShader(gpuShader.glProgram, gpuStage.glShader);
              }

              gl.linkProgram(gpuShader.glProgram);

              for (var _k2 = 0; _k2 < gpuShader.gpuStages.length; _k2++) {
                var _gpuStage = gpuShader.gpuStages[_k2];

                if (_gpuStage.glShader) {
                  gl.detachShader(gpuShader.glProgram, _gpuStage.glShader);
                  gl.deleteShader(_gpuStage.glShader);
                  _gpuStage.glShader = null;
                }
              }

              if (gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) {
                debug("Shader '" + gpuShader.name + "' compilation succeeded.");
              } else {
                console.error("Failed to link shader '" + gpuShader.name + "'.");
                console.error(gl.getProgramInfoLog(gpuShader.glProgram));
                return;
              }

              var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
              gpuShader.glInputs = new Array(activeAttribCount);

              for (var i = 0; i < activeAttribCount; ++i) {
                var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);

                if (attribInfo) {
                  var varName = void 0;
                  var nameOffset = attribInfo.name.indexOf('[');

                  if (nameOffset !== -1) {
                    varName = attribInfo.name.substr(0, nameOffset);
                  } else {
                    varName = attribInfo.name;
                  }

                  var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName);
                  var type = WebGLTypeToGFXType$1(attribInfo.type, gl);
                  var stride = WebGLGetTypeSize$1(attribInfo.type, gl);
                  gpuShader.glInputs[i] = {
                    name: varName,
                    type: type,
                    stride: stride,
                    count: attribInfo.size,
                    size: stride * attribInfo.size,
                    glType: attribInfo.type,
                    glLoc: glLoc
                  };
                }
              }

              var activeBlockCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORM_BLOCKS);
              var blockName;
              var blockIdx;
              var blockSize;
              var block;

              if (activeBlockCount) {
                gpuShader.glBlocks = new Array(activeBlockCount);

                for (var b = 0; b < activeBlockCount; ++b) {
                  blockName = gl.getActiveUniformBlockName(gpuShader.glProgram, b);

                  var _nameOffset = blockName.indexOf('[');

                  if (_nameOffset !== -1) {
                    blockName = blockName.substr(0, _nameOffset);
                  }

                  block = null;

                  for (var _k3 = 0; _k3 < gpuShader.blocks.length; _k3++) {
                    if (gpuShader.blocks[_k3].name === blockName) {
                      block = gpuShader.blocks[_k3];
                      break;
                    }
                  }

                  if (!block) {
                    error("Block '" + blockName + "' does not bound");
                  } else {
                    blockIdx = b;
                    blockSize = gl.getActiveUniformBlockParameter(gpuShader.glProgram, blockIdx, gl.UNIFORM_BLOCK_DATA_SIZE);
                    var glBinding = enableEffectImport ? block.flattened : block.binding + (device.bindingMappings.blockOffsets[block.set] || 0);
                    gl.uniformBlockBinding(gpuShader.glProgram, blockIdx, glBinding);
                    gpuShader.glBlocks[b] = {
                      set: block.set,
                      binding: block.binding,
                      idx: blockIdx,
                      name: blockName,
                      size: blockSize,
                      glBinding: glBinding
                    };
                  }
                }
              }

              for (var _i8 = 0; _i8 < gpuShader.subpassInputs.length; ++_i8) {
                var subpassInput = gpuShader.subpassInputs[_i8];
                gpuShader.samplerTextures.push(new UniformSamplerTexture(subpassInput.set, subpassInput.binding, subpassInput.name, Type$1.SAMPLER2D, subpassInput.count));
              }

              if (gpuShader.samplerTextures.length > 0) {
                gpuShader.glSamplerTextures = new Array(gpuShader.samplerTextures.length);

                for (var _i9 = 0; _i9 < gpuShader.samplerTextures.length; ++_i9) {
                  var sampler = gpuShader.samplerTextures[_i9];
                  gpuShader.glSamplerTextures[_i9] = {
                    set: sampler.set,
                    binding: sampler.binding,
                    name: sampler.name,
                    type: sampler.type,
                    count: sampler.count,
                    units: [],
                    glUnits: null,
                    glType: GFXTypeToWebGLType$1(sampler.type, gl),
                    glLoc: null
                  };
                }
              }

              var glActiveSamplers = [];
              var glActiveSamplerLocations = [];
              var texUnitCacheMap = device.stateCache.texUnitCacheMap;

              if (!enableEffectImport) {
                var flexibleSetBaseOffset = 0;

                for (var _i10 = 0; _i10 < gpuShader.blocks.length; ++_i10) {
                  if (gpuShader.blocks[_i10].set === device.bindingMappings.flexibleSet) {
                    flexibleSetBaseOffset++;
                  }
                }

                var arrayOffset = 0;

                for (var _i11 = 0; _i11 < gpuShader.samplerTextures.length; ++_i11) {
                  var _sampler = gpuShader.samplerTextures[_i11];

                  var _glLoc = gl.getUniformLocation(gpuShader.glProgram, _sampler.name);

                  if (_glLoc && _glLoc.id !== -1) {
                    glActiveSamplers.push(gpuShader.glSamplerTextures[_i11]);
                    glActiveSamplerLocations.push(_glLoc);
                  }

                  if (texUnitCacheMap[_sampler.name] === undefined) {
                    var binding = _sampler.binding + device.bindingMappings.samplerTextureOffsets[_sampler.set] + arrayOffset;

                    if (_sampler.set === device.bindingMappings.flexibleSet) {
                      binding -= flexibleSetBaseOffset;
                    }

                    texUnitCacheMap[_sampler.name] = binding % device.capabilities.maxTextureUnits;
                    arrayOffset += _sampler.count - 1;
                  }
                }
              } else {
                for (var _i12 = 0; _i12 < gpuShader.samplerTextures.length; ++_i12) {
                  var _sampler2 = gpuShader.samplerTextures[_i12];

                  var _glLoc2 = gl.getUniformLocation(gpuShader.glProgram, _sampler2.name);

                  if (_glLoc2 && _glLoc2.id !== -1) {
                    glActiveSamplers.push(gpuShader.glSamplerTextures[_i12]);
                    glActiveSamplerLocations.push(_glLoc2);
                  }

                  if (texUnitCacheMap[_sampler2.name] === undefined) {
                    texUnitCacheMap[_sampler2.name] = _sampler2.flattened % device.capabilities.maxTextureUnits;
                  }
                }
              }

              if (glActiveSamplers.length) {
                var usedTexUnits = [];

                for (var _i13 = 0; _i13 < glActiveSamplers.length; ++_i13) {
                  var glSampler = glActiveSamplers[_i13];
                  var cachedUnit = texUnitCacheMap[glSampler.name];

                  if (cachedUnit !== undefined) {
                    glSampler.glLoc = glActiveSamplerLocations[_i13];

                    for (var t = 0; t < glSampler.count; ++t) {
                      while (usedTexUnits[cachedUnit]) {
                        cachedUnit = (cachedUnit + 1) % device.capabilities.maxTextureUnits;
                      }

                      glSampler.units.push(cachedUnit);
                      usedTexUnits[cachedUnit] = true;
                    }
                  }
                }

                var unitIdx = 0;

                for (var _i14 = 0; _i14 < glActiveSamplers.length; ++_i14) {
                  var _glSampler = glActiveSamplers[_i14];

                  if (!_glSampler.glLoc) {
                    _glSampler.glLoc = glActiveSamplerLocations[_i14];

                    while (usedTexUnits[unitIdx]) {
                      unitIdx++;
                    }

                    for (var _t = 0; _t < _glSampler.count; ++_t) {
                      while (usedTexUnits[unitIdx]) {
                        unitIdx = (unitIdx + 1) % device.capabilities.maxTextureUnits;
                      }

                      if (texUnitCacheMap[_glSampler.name] === undefined) {
                        texUnitCacheMap[_glSampler.name] = unitIdx;
                      }

                      _glSampler.units.push(unitIdx);

                      usedTexUnits[unitIdx] = true;
                    }
                  }
                }

                if (device.stateCache.glProgram !== gpuShader.glProgram) {
                  gl.useProgram(gpuShader.glProgram);
                }

                for (var _k4 = 0; _k4 < glActiveSamplers.length; _k4++) {
                  var _glSampler2 = glActiveSamplers[_k4];
                  _glSampler2.glUnits = new Int32Array(_glSampler2.units);
                  gl.uniform1iv(_glSampler2.glLoc, _glSampler2.glUnits);
                }

                if (device.stateCache.glProgram !== gpuShader.glProgram) {
                  gl.useProgram(device.stateCache.glProgram);
                }
              }

              gpuShader.glSamplerTextures = glActiveSamplers;
            }
            function WebGL2CmdFuncDestroyShader(device, gpuShader) {
              if (gpuShader.glProgram) {
                device.gl.deleteProgram(gpuShader.glProgram);

                if (device.stateCache.glProgram === gpuShader.glProgram) {
                  device.gl.useProgram(null);
                  device.stateCache.glProgram = null;
                }

                gpuShader.glProgram = null;
              }
            }
            function WebGL2CmdFuncCreateInputAssember(device, gpuInputAssembler) {
              var gl = device.gl;
              gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
              var offsets = [0, 0, 0, 0, 0, 0, 0, 0];

              for (var i = 0; i < gpuInputAssembler.attributes.length; ++i) {
                var attrib = gpuInputAssembler.attributes[i];
                var stream = attrib.stream !== undefined ? attrib.stream : 0;
                var gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream];
                var glType = GFXFormatToWebGLType$1(attrib.format, gl);
                var size = FormatInfos[attrib.format].size;
                gpuInputAssembler.glAttribs[i] = {
                  name: attrib.name,
                  glBuffer: gpuBuffer.glBuffer,
                  glType: glType,
                  size: size,
                  count: FormatInfos[attrib.format].count,
                  stride: gpuBuffer.stride,
                  componentCount: WebGLGetComponentCount$1(glType, gl),
                  isNormalized: attrib.isNormalized !== undefined ? attrib.isNormalized : false,
                  isInstanced: attrib.isInstanced !== undefined ? attrib.isInstanced : false,
                  offset: offsets[stream]
                };
                offsets[stream] += size;
              }
            }
            function WebGL2CmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
              var it = gpuInputAssembler.glVAOs.values();
              var res = it.next();
              var gl = device.gl;
              var glVAO = device.stateCache.glVAO;

              while (!res.done) {
                gl.deleteVertexArray(res.value);

                if (glVAO === res.value) {
                  gl.bindVertexArray(null);
                  glVAO = null;
                }

                res = it.next();
              }

              device.stateCache.glVAO = glVAO;
              gpuInputAssembler.glVAOs.clear();
            }
            var gfxStateCache$1 = {
              gpuPipelineState: null,
              gpuInputAssembler: null,
              glPrimitive: 0,
              invalidateAttachments: []
            };
            function WebGL2CmdFuncBeginRenderPass(device, gpuRenderPass, gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil) {
              var gl = device.gl;
              var cache = device.stateCache;
              var clears = 0;

              if (gpuFramebuffer && gpuRenderPass) {
                if (cache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
                  cache.glFramebuffer = gpuFramebuffer.glFramebuffer;
                }

                if (cache.viewport.left !== renderArea.x || cache.viewport.top !== renderArea.y || cache.viewport.width !== renderArea.width || cache.viewport.height !== renderArea.height) {
                  gl.viewport(renderArea.x, renderArea.y, renderArea.width, renderArea.height);
                  cache.viewport.left = renderArea.x;
                  cache.viewport.top = renderArea.y;
                  cache.viewport.width = renderArea.width;
                  cache.viewport.height = renderArea.height;
                }

                if (cache.scissorRect.x !== renderArea.x || cache.scissorRect.y !== renderArea.y || cache.scissorRect.width !== renderArea.width || cache.scissorRect.height !== renderArea.height) {
                  gl.scissor(renderArea.x, renderArea.y, renderArea.width, renderArea.height);
                  cache.scissorRect.x = renderArea.x;
                  cache.scissorRect.y = renderArea.y;
                  cache.scissorRect.width = renderArea.width;
                  cache.scissorRect.height = renderArea.height;
                }

                gfxStateCache$1.invalidateAttachments.length = 0;

                for (var j = 0; j < clearColors.length; ++j) {
                  var colorAttachment = gpuRenderPass.colorAttachments[j];

                  if (colorAttachment.format !== Format.UNKNOWN) {
                    switch (colorAttachment.loadOp) {
                      case LoadOp.LOAD:
                        break;

                      case LoadOp.CLEAR:
                        {
                          if (cache.bs.targets[0].blendColorMask !== ColorMask.ALL) {
                            gl.colorMask(true, true, true, true);
                          }

                          if (gpuRenderPass.colorAttachments.length === 1) {
                            var clearColor = clearColors[0];
                            gl.clearColor(clearColor.x, clearColor.y, clearColor.z, clearColor.w);
                            clears |= gl.COLOR_BUFFER_BIT;
                          } else {
                            _f32v4[0] = clearColors[j].x;
                            _f32v4[1] = clearColors[j].y;
                            _f32v4[2] = clearColors[j].z;
                            _f32v4[3] = clearColors[j].w;
                            gl.clearBufferfv(gl.COLOR, j, _f32v4);
                          }

                          break;
                        }

                      case LoadOp.DISCARD:
                        {
                          gfxStateCache$1.invalidateAttachments.push(gl.COLOR_ATTACHMENT0 + j);
                          break;
                        }
                    }
                  }
                }

                if (gpuRenderPass.depthStencilAttachment) {
                  if (gpuRenderPass.depthStencilAttachment.format !== Format.UNKNOWN) {
                    switch (gpuRenderPass.depthStencilAttachment.depthLoadOp) {
                      case LoadOp.LOAD:
                        break;

                      case LoadOp.CLEAR:
                        {
                          if (!cache.dss.depthWrite) {
                            gl.depthMask(true);
                          }

                          gl.clearDepth(clearDepth);
                          clears |= gl.DEPTH_BUFFER_BIT;
                          break;
                        }

                      case LoadOp.DISCARD:
                        {
                          gfxStateCache$1.invalidateAttachments.push(gl.DEPTH_ATTACHMENT);
                          break;
                        }
                    }

                    if (FormatInfos[gpuRenderPass.depthStencilAttachment.format].hasStencil) {
                      switch (gpuRenderPass.depthStencilAttachment.stencilLoadOp) {
                        case LoadOp.LOAD:
                          break;

                        case LoadOp.CLEAR:
                          {
                            if (!cache.dss.stencilWriteMaskFront) {
                              gl.stencilMaskSeparate(gl.FRONT, 0xffff);
                            }

                            if (!cache.dss.stencilWriteMaskBack) {
                              gl.stencilMaskSeparate(gl.BACK, 0xffff);
                            }

                            gl.clearStencil(clearStencil);
                            clears |= gl.STENCIL_BUFFER_BIT;
                            break;
                          }

                        case LoadOp.DISCARD:
                          {
                            gfxStateCache$1.invalidateAttachments.push(gl.STENCIL_ATTACHMENT);
                            break;
                          }
                      }
                    }
                  }
                }

                if (gpuFramebuffer.glFramebuffer && gfxStateCache$1.invalidateAttachments.length) {
                  gl.invalidateFramebuffer(gl.FRAMEBUFFER, gfxStateCache$1.invalidateAttachments);
                }

                if (clears) {
                  gl.clear(clears);
                }

                if (clears & gl.COLOR_BUFFER_BIT) {
                  var colorMask = cache.bs.targets[0].blendColorMask;

                  if (colorMask !== ColorMask.ALL) {
                    var r = (colorMask & ColorMask.R) !== ColorMask.NONE;
                    var g = (colorMask & ColorMask.G) !== ColorMask.NONE;
                    var b = (colorMask & ColorMask.B) !== ColorMask.NONE;
                    var a = (colorMask & ColorMask.A) !== ColorMask.NONE;
                    gl.colorMask(r, g, b, a);
                  }
                }

                if (clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite) {
                  gl.depthMask(false);
                }

                if (clears & gl.STENCIL_BUFFER_BIT) {
                  if (!cache.dss.stencilWriteMaskFront) {
                    gl.stencilMaskSeparate(gl.FRONT, 0);
                  }

                  if (!cache.dss.stencilWriteMaskBack) {
                    gl.stencilMaskSeparate(gl.BACK, 0);
                  }
                }
              }
            }
            function WebGL2CmdFuncBindStates(device, gpuPipelineState, gpuInputAssembler, gpuDescriptorSets, dynamicOffsets, dynamicStates) {
              var gl = device.gl;
              var cache = device.stateCache;
              var gpuShader = gpuPipelineState && gpuPipelineState.gpuShader;
              var isShaderChanged = false;

              if (gpuPipelineState && gfxStateCache$1.gpuPipelineState !== gpuPipelineState) {
                gfxStateCache$1.gpuPipelineState = gpuPipelineState;
                gfxStateCache$1.glPrimitive = gpuPipelineState.glPrimitive;

                if (gpuShader) {
                  var glProgram = gpuShader.glProgram;

                  if (cache.glProgram !== glProgram) {
                    gl.useProgram(glProgram);
                    cache.glProgram = glProgram;
                    isShaderChanged = true;
                  }
                }

                var rs = gpuPipelineState.rs;

                if (rs) {
                  if (cache.rs.cullMode !== rs.cullMode) {
                    switch (rs.cullMode) {
                      case CullMode.NONE:
                        {
                          gl.disable(gl.CULL_FACE);
                          break;
                        }

                      case CullMode.FRONT:
                        {
                          gl.enable(gl.CULL_FACE);
                          gl.cullFace(gl.FRONT);
                          break;
                        }

                      case CullMode.BACK:
                        {
                          gl.enable(gl.CULL_FACE);
                          gl.cullFace(gl.BACK);
                          break;
                        }
                    }

                    device.stateCache.rs.cullMode = rs.cullMode;
                  }

                  var isFrontFaceCCW = rs.isFrontFaceCCW;

                  if (device.stateCache.rs.isFrontFaceCCW !== isFrontFaceCCW) {
                    gl.frontFace(isFrontFaceCCW ? gl.CCW : gl.CW);
                    device.stateCache.rs.isFrontFaceCCW = isFrontFaceCCW;
                  }

                  if (device.stateCache.rs.depthBias !== rs.depthBias || device.stateCache.rs.depthBiasSlop !== rs.depthBiasSlop) {
                    gl.polygonOffset(rs.depthBias, rs.depthBiasSlop);
                    device.stateCache.rs.depthBias = rs.depthBias;
                    device.stateCache.rs.depthBiasSlop = rs.depthBiasSlop;
                  }

                  if (device.stateCache.rs.lineWidth !== rs.lineWidth) {
                    gl.lineWidth(rs.lineWidth);
                    device.stateCache.rs.lineWidth = rs.lineWidth;
                  }
                }

                var dss = gpuPipelineState.dss;

                if (dss) {
                  if (cache.dss.depthTest !== dss.depthTest) {
                    if (dss.depthTest) {
                      gl.enable(gl.DEPTH_TEST);
                    } else {
                      gl.disable(gl.DEPTH_TEST);
                    }

                    cache.dss.depthTest = dss.depthTest;
                  }

                  if (cache.dss.depthWrite !== dss.depthWrite) {
                    gl.depthMask(dss.depthWrite);
                    cache.dss.depthWrite = dss.depthWrite;
                  }

                  if (cache.dss.depthFunc !== dss.depthFunc) {
                    gl.depthFunc(WebGLCmpFuncs$1[dss.depthFunc]);
                    cache.dss.depthFunc = dss.depthFunc;
                  }

                  if (cache.dss.stencilTestFront !== dss.stencilTestFront || cache.dss.stencilTestBack !== dss.stencilTestBack) {
                    if (dss.stencilTestFront || dss.stencilTestBack) {
                      gl.enable(gl.STENCIL_TEST);
                    } else {
                      gl.disable(gl.STENCIL_TEST);
                    }

                    cache.dss.stencilTestFront = dss.stencilTestFront;
                    cache.dss.stencilTestBack = dss.stencilTestBack;
                  }

                  if (cache.dss.stencilFuncFront !== dss.stencilFuncFront || cache.dss.stencilRefFront !== dss.stencilRefFront || cache.dss.stencilReadMaskFront !== dss.stencilReadMaskFront) {
                    gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs$1[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront);
                    cache.dss.stencilFuncFront = dss.stencilFuncFront;
                    cache.dss.stencilRefFront = dss.stencilRefFront;
                    cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront;
                  }

                  if (cache.dss.stencilFailOpFront !== dss.stencilFailOpFront || cache.dss.stencilZFailOpFront !== dss.stencilZFailOpFront || cache.dss.stencilPassOpFront !== dss.stencilPassOpFront) {
                    gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps$1[dss.stencilFailOpFront], WebGLStencilOps$1[dss.stencilZFailOpFront], WebGLStencilOps$1[dss.stencilPassOpFront]);
                    cache.dss.stencilFailOpFront = dss.stencilFailOpFront;
                    cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront;
                    cache.dss.stencilPassOpFront = dss.stencilPassOpFront;
                  }

                  if (cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront) {
                    gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront);
                    cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront;
                  }

                  if (cache.dss.stencilFuncBack !== dss.stencilFuncBack || cache.dss.stencilRefBack !== dss.stencilRefBack || cache.dss.stencilReadMaskBack !== dss.stencilReadMaskBack) {
                    gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs$1[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack);
                    cache.dss.stencilFuncBack = dss.stencilFuncBack;
                    cache.dss.stencilRefBack = dss.stencilRefBack;
                    cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack;
                  }

                  if (cache.dss.stencilFailOpBack !== dss.stencilFailOpBack || cache.dss.stencilZFailOpBack !== dss.stencilZFailOpBack || cache.dss.stencilPassOpBack !== dss.stencilPassOpBack) {
                    gl.stencilOpSeparate(gl.BACK, WebGLStencilOps$1[dss.stencilFailOpBack], WebGLStencilOps$1[dss.stencilZFailOpBack], WebGLStencilOps$1[dss.stencilPassOpBack]);
                    cache.dss.stencilFailOpBack = dss.stencilFailOpBack;
                    cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack;
                    cache.dss.stencilPassOpBack = dss.stencilPassOpBack;
                  }

                  if (cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack) {
                    gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack);
                    cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack;
                  }
                }

                var bs = gpuPipelineState.bs;

                if (bs) {
                  if (cache.bs.isA2C !== bs.isA2C) {
                    if (bs.isA2C) {
                      gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    } else {
                      gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    }

                    cache.bs.isA2C = bs.isA2C;
                  }

                  if (cache.bs.blendColor.x !== bs.blendColor.x || cache.bs.blendColor.y !== bs.blendColor.y || cache.bs.blendColor.z !== bs.blendColor.z || cache.bs.blendColor.w !== bs.blendColor.w) {
                    gl.blendColor(bs.blendColor.x, bs.blendColor.y, bs.blendColor.z, bs.blendColor.w);
                    cache.bs.blendColor.x = bs.blendColor.x;
                    cache.bs.blendColor.y = bs.blendColor.y;
                    cache.bs.blendColor.z = bs.blendColor.z;
                    cache.bs.blendColor.w = bs.blendColor.w;
                  }

                  var target0 = bs.targets[0];
                  var target0Cache = cache.bs.targets[0];

                  if (target0Cache.blend !== target0.blend) {
                    if (target0.blend) {
                      gl.enable(gl.BLEND);
                    } else {
                      gl.disable(gl.BLEND);
                    }

                    target0Cache.blend = target0.blend;
                  }

                  if (target0Cache.blendEq !== target0.blendEq || target0Cache.blendAlphaEq !== target0.blendAlphaEq) {
                    gl.blendEquationSeparate(WebGLBlendOps$1[target0.blendEq], WebGLBlendOps$1[target0.blendAlphaEq]);
                    target0Cache.blendEq = target0.blendEq;
                    target0Cache.blendAlphaEq = target0.blendAlphaEq;
                  }

                  if (target0Cache.blendSrc !== target0.blendSrc || target0Cache.blendDst !== target0.blendDst || target0Cache.blendSrcAlpha !== target0.blendSrcAlpha || target0Cache.blendDstAlpha !== target0.blendDstAlpha) {
                    gl.blendFuncSeparate(WebGLBlendFactors$1[target0.blendSrc], WebGLBlendFactors$1[target0.blendDst], WebGLBlendFactors$1[target0.blendSrcAlpha], WebGLBlendFactors$1[target0.blendDstAlpha]);
                    target0Cache.blendSrc = target0.blendSrc;
                    target0Cache.blendDst = target0.blendDst;
                    target0Cache.blendSrcAlpha = target0.blendSrcAlpha;
                    target0Cache.blendDstAlpha = target0.blendDstAlpha;
                  }

                  if (target0Cache.blendColorMask !== target0.blendColorMask) {
                    gl.colorMask((target0.blendColorMask & ColorMask.R) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.G) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.B) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.A) !== ColorMask.NONE);
                    target0Cache.blendColorMask = target0.blendColorMask;
                  }
                }
              }

              if (gpuPipelineState && gpuPipelineState.gpuPipelineLayout && gpuShader) {
                var blockLen = gpuShader.glBlocks.length;
                var dynamicOffsetIndices = gpuPipelineState.gpuPipelineLayout.dynamicOffsetIndices;

                for (var j = 0; j < blockLen; j++) {
                  var glBlock = gpuShader.glBlocks[j];
                  var gpuDescriptorSet = gpuDescriptorSets[glBlock.set];
                  var descriptorIndex = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glBlock.binding];
                  var gpuDescriptor = descriptorIndex >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIndex];

                  if (!gpuDescriptor || !gpuDescriptor.gpuBuffer) {
                    continue;
                  }

                  var dynamicOffsetIndexSet = dynamicOffsetIndices[glBlock.set];
                  var dynamicOffsetIndex = dynamicOffsetIndexSet && dynamicOffsetIndexSet[glBlock.binding];
                  var offset = gpuDescriptor.gpuBuffer.glOffset;

                  if (dynamicOffsetIndex >= 0) {
                    offset += dynamicOffsets[dynamicOffsetIndex];
                  }

                  if (cache.glBindUBOs[glBlock.glBinding] !== gpuDescriptor.gpuBuffer.glBuffer || cache.glBindUBOOffsets[glBlock.glBinding] !== offset) {
                    if (offset) {
                      gl.bindBufferRange(gl.UNIFORM_BUFFER, glBlock.glBinding, gpuDescriptor.gpuBuffer.glBuffer, offset, gpuDescriptor.gpuBuffer.size);
                    } else {
                      gl.bindBufferBase(gl.UNIFORM_BUFFER, glBlock.glBinding, gpuDescriptor.gpuBuffer.glBuffer);
                    }

                    cache.glUniformBuffer = cache.glBindUBOs[glBlock.glBinding] = gpuDescriptor.gpuBuffer.glBuffer;
                    cache.glBindUBOOffsets[glBlock.glBinding] = offset;
                  }
                }

                var samplerLen = gpuShader.glSamplerTextures.length;

                for (var i = 0; i < samplerLen; i++) {
                  var glSampler = gpuShader.glSamplerTextures[i];
                  var _gpuDescriptorSet = gpuDescriptorSets[glSampler.set];

                  var _descriptorIndex = _gpuDescriptorSet && _gpuDescriptorSet.descriptorIndices[glSampler.binding];

                  var _gpuDescriptor = _descriptorIndex >= 0 && _gpuDescriptorSet.gpuDescriptors[_descriptorIndex];

                  for (var l = 0; l < glSampler.units.length; l++) {
                    var texUnit = glSampler.units[l];
                    var glTexUnit = cache.glTexUnits[texUnit];

                    if (!_gpuDescriptor || !_gpuDescriptor.gpuTextureView || !_gpuDescriptor.gpuTextureView.gpuTexture || !_gpuDescriptor.gpuSampler) {
                      continue;
                    }

                    var gpuTextureView = _gpuDescriptor.gpuTextureView;
                    var gpuTexture = gpuTextureView.gpuTexture;
                    var minLod = gpuTextureView.baseLevel;
                    var maxLod = minLod + gpuTextureView.levelCount;

                    if (gpuTexture.size > 0) {
                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        if (gpuTexture.glTexture) {
                          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                        } else {
                          gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture);
                        }

                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      var _gpuDescriptor2 = _gpuDescriptor,
                          gpuSampler = _gpuDescriptor2.gpuSampler;

                      var _glSampler3 = gpuSampler.getGLSampler(device, minLod, maxLod);

                      if (cache.glSamplerUnits[texUnit] !== _glSampler3) {
                        gl.bindSampler(texUnit, _glSampler3);
                        cache.glSamplerUnits[texUnit] = _glSampler3;
                      }
                    }

                    _gpuDescriptor = _gpuDescriptorSet.gpuDescriptors[++_descriptorIndex];
                  }
                }
              }

              if (gpuInputAssembler && gpuShader && (isShaderChanged || gfxStateCache$1.gpuInputAssembler !== gpuInputAssembler)) {
                gfxStateCache$1.gpuInputAssembler = gpuInputAssembler;

                if (device.extensions.useVAO) {
                  var glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);

                  if (!glVAO) {
                    glVAO = gl.createVertexArray();
                    gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO);
                    gl.bindVertexArray(glVAO);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    cache.glArrayBuffer = null;
                    cache.glElementArrayBuffer = null;
                    var glAttrib;

                    for (var _j = 0; _j < gpuShader.glInputs.length; _j++) {
                      var glInput = gpuShader.glInputs[_j];
                      glAttrib = null;

                      for (var k = 0; k < gpuInputAssembler.glAttribs.length; k++) {
                        var attrib = gpuInputAssembler.glAttribs[k];

                        if (attrib.name === glInput.name) {
                          glAttrib = attrib;
                          break;
                        }
                      }

                      if (glAttrib) {
                        if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                          gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                          cache.glArrayBuffer = glAttrib.glBuffer;
                        }

                        for (var c = 0; c < glAttrib.componentCount; ++c) {
                          var glLoc = glInput.glLoc + c;
                          var attribOffset = glAttrib.offset + glAttrib.size * c;
                          gl.enableVertexAttribArray(glLoc);
                          cache.glCurrentAttribLocs[glLoc] = true;
                          gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);
                          gl.vertexAttribDivisor(glLoc, glAttrib.isInstanced ? 1 : 0);
                        }
                      }
                    }

                    var gpuBuffer = gpuInputAssembler.gpuIndexBuffer;

                    if (gpuBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                    }

                    gl.bindVertexArray(null);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    cache.glArrayBuffer = null;
                    cache.glElementArrayBuffer = null;
                  }

                  if (cache.glVAO !== glVAO) {
                    gl.bindVertexArray(glVAO);
                    cache.glVAO = glVAO;
                  }
                } else {
                  for (var a = 0; a < device.capabilities.maxVertexAttributes; ++a) {
                    cache.glCurrentAttribLocs[a] = false;
                  }

                  for (var _j2 = 0; _j2 < gpuShader.glInputs.length; _j2++) {
                    var _glInput = gpuShader.glInputs[_j2];
                    var _glAttrib = null;

                    for (var _k5 = 0; _k5 < gpuInputAssembler.glAttribs.length; _k5++) {
                      var _attrib = gpuInputAssembler.glAttribs[_k5];

                      if (_attrib.name === _glInput.name) {
                        _glAttrib = _attrib;
                        break;
                      }
                    }

                    if (_glAttrib) {
                      if (cache.glArrayBuffer !== _glAttrib.glBuffer) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, _glAttrib.glBuffer);
                        cache.glArrayBuffer = _glAttrib.glBuffer;
                      }

                      for (var _c = 0; _c < _glAttrib.componentCount; ++_c) {
                        var _glLoc3 = _glInput.glLoc + _c;

                        var _attribOffset = _glAttrib.offset + _glAttrib.size * _c;

                        if (!cache.glEnabledAttribLocs[_glLoc3] && _glLoc3 >= 0) {
                          gl.enableVertexAttribArray(_glLoc3);
                          cache.glEnabledAttribLocs[_glLoc3] = true;
                        }

                        cache.glCurrentAttribLocs[_glLoc3] = true;
                        gl.vertexAttribPointer(_glLoc3, _glAttrib.count, _glAttrib.glType, _glAttrib.isNormalized, _glAttrib.stride, _attribOffset);
                        gl.vertexAttribDivisor(_glLoc3, _glAttrib.isInstanced ? 1 : 0);
                      }
                    }
                  }

                  var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;

                  if (_gpuBuffer) {
                    if (cache.glElementArrayBuffer !== _gpuBuffer.glBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer.glBuffer);
                      cache.glElementArrayBuffer = _gpuBuffer.glBuffer;
                    }
                  }

                  for (var _a = 0; _a < device.capabilities.maxVertexAttributes; ++_a) {
                    if (cache.glEnabledAttribLocs[_a] !== cache.glCurrentAttribLocs[_a]) {
                      gl.disableVertexAttribArray(_a);
                      cache.glEnabledAttribLocs[_a] = false;
                    }
                  }
                }
              }

              if (gpuPipelineState && gpuPipelineState.dynamicStates.length) {
                var dsLen = gpuPipelineState.dynamicStates.length;

                for (var _k6 = 0; _k6 < dsLen; _k6++) {
                  var dynamicState = gpuPipelineState.dynamicStates[_k6];

                  switch (dynamicState) {
                    case DynamicStateFlagBit.LINE_WIDTH:
                      {
                        if (cache.rs.lineWidth !== dynamicStates.lineWidth) {
                          gl.lineWidth(dynamicStates.lineWidth);
                          cache.rs.lineWidth = dynamicStates.lineWidth;
                        }

                        break;
                      }

                    case DynamicStateFlagBit.DEPTH_BIAS:
                      {
                        if (cache.rs.depthBias !== dynamicStates.depthBiasConstant || cache.rs.depthBiasSlop !== dynamicStates.depthBiasSlope) {
                          gl.polygonOffset(dynamicStates.depthBiasConstant, dynamicStates.depthBiasSlope);
                          cache.rs.depthBias = dynamicStates.depthBiasConstant;
                          cache.rs.depthBiasSlop = dynamicStates.depthBiasSlope;
                        }

                        break;
                      }

                    case DynamicStateFlagBit.BLEND_CONSTANTS:
                      {
                        var blendConstant = dynamicStates.blendConstant;

                        if (cache.bs.blendColor.x !== blendConstant.x || cache.bs.blendColor.y !== blendConstant.y || cache.bs.blendColor.z !== blendConstant.z || cache.bs.blendColor.w !== blendConstant.w) {
                          gl.blendColor(blendConstant.x, blendConstant.y, blendConstant.z, blendConstant.w);
                          cache.bs.blendColor.copy(blendConstant);
                        }

                        break;
                      }

                    case DynamicStateFlagBit.STENCIL_WRITE_MASK:
                      {
                        var front = dynamicStates.stencilStatesFront;
                        var back = dynamicStates.stencilStatesBack;

                        if (cache.dss.stencilWriteMaskFront !== front.writeMask) {
                          gl.stencilMaskSeparate(gl.FRONT, front.writeMask);
                          cache.dss.stencilWriteMaskFront = front.writeMask;
                        }

                        if (cache.dss.stencilWriteMaskBack !== back.writeMask) {
                          gl.stencilMaskSeparate(gl.BACK, back.writeMask);
                          cache.dss.stencilWriteMaskBack = back.writeMask;
                        }

                        break;
                      }

                    case DynamicStateFlagBit.STENCIL_COMPARE_MASK:
                      {
                        var _front = dynamicStates.stencilStatesFront;
                        var _back = dynamicStates.stencilStatesBack;

                        if (cache.dss.stencilRefFront !== _front.reference || cache.dss.stencilReadMaskFront !== _front.compareMask) {
                          gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs$1[cache.dss.stencilFuncFront], _front.reference, _front.compareMask);
                          cache.dss.stencilRefFront = _front.reference;
                          cache.dss.stencilReadMaskFront = _front.compareMask;
                        }

                        if (cache.dss.stencilRefBack !== _back.reference || cache.dss.stencilReadMaskBack !== _back.compareMask) {
                          gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs$1[cache.dss.stencilFuncBack], _back.reference, _back.compareMask);
                          cache.dss.stencilRefBack = _back.reference;
                          cache.dss.stencilReadMaskBack = _back.compareMask;
                        }

                        break;
                      }
                  }
                }
              }
            }
            function WebGL2CmdFuncDraw(device, drawInfo) {
              var gl = device.gl;
              var gpuInputAssembler = gfxStateCache$1.gpuInputAssembler,
                  glPrimitive = gfxStateCache$1.glPrimitive;
              var md = device.extensions.WEBGL_multi_draw;

              if (gpuInputAssembler) {
                var indexBuffer = gpuInputAssembler.gpuIndexBuffer;

                if (gpuInputAssembler.gpuIndirectBuffer) {
                  var indirects = gpuInputAssembler.gpuIndirectBuffer.indirects;

                  if (indirects.drawByIndex) {
                    for (var j = 0; j < indirects.drawCount; j++) {
                      indirects.byteOffsets[j] = indirects.offsets[j] * indexBuffer.stride;
                    }

                    if (md) {
                      if (indirects.instancedDraw) {
                        md.multiDrawElementsInstancedWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.instances, 0, indirects.drawCount);
                      } else {
                        md.multiDrawElementsWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.drawCount);
                      }
                    } else {
                      for (var _j3 = 0; _j3 < indirects.drawCount; _j3++) {
                        if (indirects.instances[_j3]) {
                          gl.drawElementsInstanced(glPrimitive, indirects.counts[_j3], gpuInputAssembler.glIndexType, indirects.byteOffsets[_j3], indirects.instances[_j3]);
                        } else {
                          gl.drawElements(glPrimitive, indirects.counts[_j3], gpuInputAssembler.glIndexType, indirects.byteOffsets[_j3]);
                        }
                      }
                    }
                  } else if (md) {
                    if (indirects.instancedDraw) {
                      md.multiDrawArraysInstancedWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.instances, 0, indirects.drawCount);
                    } else {
                      md.multiDrawArraysWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.drawCount);
                    }
                  } else {
                    for (var _j4 = 0; _j4 < indirects.drawCount; _j4++) {
                      if (indirects.instances[_j4]) {
                        gl.drawArraysInstanced(glPrimitive, indirects.offsets[_j4], indirects.counts[_j4], indirects.instances[_j4]);
                      } else {
                        gl.drawArrays(glPrimitive, indirects.offsets[_j4], indirects.counts[_j4]);
                      }
                    }
                  }
                } else if (drawInfo.instanceCount) {
                  if (indexBuffer) {
                    if (drawInfo.indexCount > 0) {
                      var offset = drawInfo.firstIndex * indexBuffer.stride;
                      gl.drawElementsInstanced(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset, drawInfo.instanceCount);
                    }
                  } else if (drawInfo.vertexCount > 0) {
                    gl.drawArraysInstanced(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount, drawInfo.instanceCount);
                  }
                } else if (indexBuffer) {
                  if (drawInfo.indexCount > 0) {
                    var _offset = drawInfo.firstIndex * indexBuffer.stride;

                    gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
                  }
                } else if (drawInfo.vertexCount > 0) {
                  gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
                }
              }
            }
            var cmdIds$1 = new Array(WebGL2Cmd.COUNT);
            function WebGL2CmdFuncExecuteCmds(device, cmdPackage) {
              cmdIds$1.fill(0);

              for (var i = 0; i < cmdPackage.cmds.length; ++i) {
                var cmd = cmdPackage.cmds.array[i];
                var cmdId = cmdIds$1[cmd]++;

                switch (cmd) {
                  case WebGL2Cmd.BEGIN_RENDER_PASS:
                    {
                      var cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId];
                      WebGL2CmdFuncBeginRenderPass(device, cmd0.gpuRenderPass, cmd0.gpuFramebuffer, cmd0.renderArea, cmd0.clearColors, cmd0.clearDepth, cmd0.clearStencil);
                      break;
                    }

                  case WebGL2Cmd.BIND_STATES:
                    {
                      var cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
                      WebGL2CmdFuncBindStates(device, cmd2.gpuPipelineState, cmd2.gpuInputAssembler, cmd2.gpuDescriptorSets, cmd2.dynamicOffsets, cmd2.dynamicStates);
                      break;
                    }

                  case WebGL2Cmd.DRAW:
                    {
                      var cmd3 = cmdPackage.drawCmds.array[cmdId];
                      WebGL2CmdFuncDraw(device, cmd3.drawInfo);
                      break;
                    }

                  case WebGL2Cmd.UPDATE_BUFFER:
                    {
                      var cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
                      WebGL2CmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
                      break;
                    }

                  case WebGL2Cmd.COPY_BUFFER_TO_TEXTURE:
                    {
                      var cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
                      WebGL2CmdFuncCopyBuffersToTexture(device, cmd5.buffers, cmd5.gpuTexture, cmd5.regions);
                      break;
                    }

                  case WebGL2Cmd.BLIT_TEXTURE:
                    {
                      var cmd6 = cmdPackage.blitTextureCmds.array[cmdId];
                      WebGL2CmdFuncBlitTexture(device, cmd6.srcTexture, cmd6.dstTexture, cmd6.regions, cmd6.filter);
                      break;
                    }
                }
              }
            }

            function toUseTexImage2D(texImages, regions) {
              if (texImages.length > 1 || regions.length > 1) return false;
              var isVideoElement = texImages[0] instanceof HTMLVideoElement;

              if (isVideoElement) {
                var videoElement = texImages[0];
                var isSameSize = regions[0].texOffset.x === 0 && regions[0].texOffset.y === 0 && regions[0].texExtent.width === videoElement.videoWidth && regions[0].texExtent.height === videoElement.videoHeight;
                return isSameSize;
              }

              return false;
            }

            function WebGL2CmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
              var gl = device.gl;
              var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }

              var n = 0;
              var f = 0;

              switch (gpuTexture.glTarget) {
                case gl.TEXTURE_2D:
                  {
                    if (toUseTexImage2D(texImages, regions)) {
                      gl.texImage2D(gl.TEXTURE_2D, regions[0].texSubres.mipLevel, gpuTexture.glInternalFmt, regions[0].texExtent.width, regions[0].texExtent.height, 0, gpuTexture.glFormat, gpuTexture.glType, texImages[0]);
                    } else {
                      for (var k = 0; k < regions.length; k++) {
                        var region = regions[k];
                        gl.texSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                      }
                    }

                    break;
                  }

                case gl.TEXTURE_CUBE_MAP:
                  {
                    for (var _k7 = 0; _k7 < regions.length; _k7++) {
                      var _region = regions[_k7];
                      var fcount = _region.texSubres.baseArrayLayer + _region.texSubres.layerCount;

                      for (f = _region.texSubres.baseArrayLayer; f < fcount; ++f) {
                        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _region.texSubres.mipLevel, _region.texOffset.x, _region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported GL texture type, copy buffer to texture failed.');
                  }
              }

              if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP) {
                gl.generateMipmap(gpuTexture.glTarget);
              }
            }
            var stagingBuffer$1 = new Uint8Array(1);

            function pixelBufferPick$1(buffer, format, offset, stride, extent) {
              var blockHeight = formatAlignment(format).height;
              var bufferSize = FormatSize(format, extent.width, extent.height, extent.depth);
              var rowStrideSize = FormatSize(format, stride.width, 1, 1);
              var sliceStrideSize = FormatSize(format, stride.width, stride.height, 1);
              var destRowSize = FormatSize(format, extent.width, 1, 1);
              var ArrayBufferCtor = getTypedArrayConstructor(FormatInfos[format]);

              if (stagingBuffer$1.byteLength < bufferSize) {
                stagingBuffer$1 = new Uint8Array(bufferSize);
              }

              var destOffset = 0;
              var bufferOffset = offset;

              for (var i = 0; i < extent.depth; i++) {
                bufferOffset = offset + sliceStrideSize * i;

                for (var j = 0; j < extent.height; j += blockHeight) {
                  stagingBuffer$1.subarray(destOffset, destOffset + destRowSize).set(new Uint8Array(buffer.buffer, buffer.byteOffset + bufferOffset, destRowSize));
                  destOffset += destRowSize;
                  bufferOffset += rowStrideSize;
                }
              }

              return new ArrayBufferCtor(stagingBuffer$1.buffer);
            }

            function WebGL2CmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
              var gl = device.gl;
              var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }

              var n = 0;
              var f = 0;
              var fmtInfo = FormatInfos[gpuTexture.format];
              var ArrayBufferCtor = getTypedArrayConstructor(fmtInfo);
              var isCompressed = fmtInfo.isCompressed;
              var blockSize = formatAlignment(gpuTexture.format);
              var extent = new Extent();
              var offset = new Offset();
              var stride = new Extent();

              switch (gpuTexture.glTarget) {
                case gl.TEXTURE_2D:
                  {
                    for (var k = 0; k < regions.length; k++) {
                      var region = regions[k];
                      var mipLevel = region.texSubres.mipLevel;
                      offset.x = region.texOffset.x === 0 ? 0 : alignTo(region.texOffset.x, blockSize.width);
                      offset.y = region.texOffset.y === 0 ? 0 : alignTo(region.texOffset.y, blockSize.height);
                      extent.width = region.texExtent.width < blockSize.width ? region.texExtent.width : alignTo(region.texExtent.width, blockSize.width);
                      extent.height = region.texExtent.height < blockSize.height ? region.texExtent.width : alignTo(region.texExtent.height, blockSize.height);
                      stride.width = region.buffStride > 0 ? region.buffStride : extent.width;
                      stride.height = region.buffTexHeight > 0 ? region.buffTexHeight : extent.height;
                      var destWidth = region.texExtent.width + offset.x === gpuTexture.width >> mipLevel ? region.texExtent.width : extent.width;
                      var destHeight = region.texExtent.height + offset.y === gpuTexture.height >> mipLevel ? region.texExtent.height : extent.height;
                      var pixels = void 0;
                      var buffer = buffers[n++];

                      if (stride.width === extent.width && stride.height === extent.height) {
                        pixels = new ArrayBufferCtor(buffer.buffer, buffer.byteOffset + region.buffOffset);
                      } else {
                        pixels = pixelBufferPick$1(buffer, gpuTexture.format, region.buffOffset, stride, extent);
                      }

                      if (!isCompressed) {
                        gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, gpuTexture.glType, pixels);
                      } else if (gpuTexture.glInternalFmt !== WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL) {
                        gl.compressedTexSubImage2D(gl.TEXTURE_2D, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, pixels);
                      } else {
                        gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, gpuTexture.glInternalFmt, destWidth, destHeight, 0, pixels);
                      }
                    }

                    break;
                  }

                case gl.TEXTURE_2D_ARRAY:
                  {
                    for (var _k8 = 0; _k8 < regions.length; _k8++) {
                      var _region2 = regions[_k8];
                      var _mipLevel = _region2.texSubres.mipLevel;
                      offset.x = _region2.texOffset.x === 0 ? 0 : alignTo(_region2.texOffset.x, blockSize.width);
                      offset.y = _region2.texOffset.y === 0 ? 0 : alignTo(_region2.texOffset.y, blockSize.height);
                      extent.width = _region2.texExtent.width < blockSize.width ? _region2.texExtent.width : alignTo(_region2.texExtent.width, blockSize.width);
                      extent.height = _region2.texExtent.height < blockSize.height ? _region2.texExtent.width : alignTo(_region2.texExtent.height, blockSize.height);
                      extent.depth = 1;
                      stride.width = _region2.buffStride > 0 ? _region2.buffStride : extent.width;
                      stride.height = _region2.buffTexHeight > 0 ? _region2.buffTexHeight : extent.height;

                      var _destWidth = _region2.texExtent.width + offset.x === gpuTexture.width >> _mipLevel ? _region2.texExtent.width : extent.width;

                      var _destHeight = _region2.texExtent.height + offset.y === gpuTexture.height >> _mipLevel ? _region2.texExtent.height : extent.height;

                      var fcount = _region2.texSubres.baseArrayLayer + _region2.texSubres.layerCount;

                      for (f = _region2.texSubres.baseArrayLayer; f < fcount; ++f) {
                        offset.z = f;

                        var _pixels = void 0;

                        var _buffer = buffers[n++];

                        if (stride.width === extent.width && stride.height === extent.height) {
                          _pixels = new ArrayBufferCtor(_buffer.buffer, _buffer.byteOffset + _region2.buffOffset);
                        } else {
                          _pixels = pixelBufferPick$1(_buffer, gpuTexture.format, _region2.buffOffset, stride, extent);
                        }

                        if (!isCompressed) {
                          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel, offset.x, offset.y, offset.z, _destWidth, _destHeight, extent.depth, gpuTexture.glFormat, gpuTexture.glType, _pixels);
                        } else if (gpuTexture.glInternalFmt !== WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL) {
                          gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel, offset.x, offset.y, offset.z, _destWidth, _destHeight, extent.depth, gpuTexture.glFormat, _pixels);
                        } else {
                          gl.compressedTexImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel, gpuTexture.glInternalFmt, _destWidth, _destHeight, extent.depth, 0, _pixels);
                        }
                      }
                    }

                    break;
                  }

                case gl.TEXTURE_3D:
                  {
                    for (var _k9 = 0; _k9 < regions.length; _k9++) {
                      var _region3 = regions[_k9];
                      var _mipLevel2 = _region3.texSubres.mipLevel;
                      offset.x = _region3.texOffset.x === 0 ? 0 : alignTo(_region3.texOffset.x, blockSize.width);
                      offset.y = _region3.texOffset.y === 0 ? 0 : alignTo(_region3.texOffset.y, blockSize.height);
                      offset.z = _region3.texOffset.z;
                      extent.width = _region3.texExtent.width < blockSize.width ? _region3.texExtent.width : alignTo(_region3.texExtent.width, blockSize.width);
                      extent.height = _region3.texExtent.height < blockSize.height ? _region3.texExtent.width : alignTo(_region3.texExtent.height, blockSize.height);
                      extent.depth = _region3.texExtent.depth;
                      stride.width = _region3.buffStride > 0 ? _region3.buffStride : extent.width;
                      stride.height = _region3.buffTexHeight > 0 ? _region3.buffTexHeight : extent.height;

                      var _destWidth2 = _region3.texExtent.width + offset.x === gpuTexture.width >> _mipLevel2 ? _region3.texExtent.width : extent.width;

                      var _destHeight2 = _region3.texExtent.height + offset.y === gpuTexture.height >> _mipLevel2 ? _region3.texExtent.height : extent.height;

                      var _pixels2 = void 0;

                      var _buffer2 = buffers[n++];

                      if (stride.width === extent.width && stride.height === extent.height) {
                        _pixels2 = new ArrayBufferCtor(_buffer2.buffer, _buffer2.byteOffset + _region3.buffOffset);
                      } else {
                        _pixels2 = pixelBufferPick$1(_buffer2, gpuTexture.format, _region3.buffOffset, stride, extent);
                      }

                      if (!isCompressed) {
                        gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel2, offset.x, offset.y, offset.z, _destWidth2, _destHeight2, extent.depth, gpuTexture.glFormat, gpuTexture.glType, _pixels2);
                      } else if (gpuTexture.glInternalFmt !== WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL) {
                        gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel2, offset.x, offset.y, offset.z, _destWidth2, _destHeight2, extent.depth, gpuTexture.glFormat, _pixels2);
                      } else {
                        gl.compressedTexImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel2, gpuTexture.glInternalFmt, _destWidth2, _destHeight2, extent.depth, 0, _pixels2);
                      }
                    }

                    break;
                  }

                case gl.TEXTURE_CUBE_MAP:
                  {
                    for (var _k10 = 0; _k10 < regions.length; _k10++) {
                      var _region4 = regions[_k10];
                      var _mipLevel3 = _region4.texSubres.mipLevel;
                      offset.x = _region4.texOffset.x === 0 ? 0 : alignTo(_region4.texOffset.x, blockSize.width);
                      offset.y = _region4.texOffset.y === 0 ? 0 : alignTo(_region4.texOffset.y, blockSize.height);
                      extent.width = _region4.texExtent.width < blockSize.width ? _region4.texExtent.width : alignTo(_region4.texExtent.width, blockSize.width);
                      extent.height = _region4.texExtent.height < blockSize.height ? _region4.texExtent.width : alignTo(_region4.texExtent.height, blockSize.height);
                      stride.width = _region4.buffStride > 0 ? _region4.buffStride : extent.width;
                      stride.height = _region4.buffTexHeight > 0 ? _region4.buffTexHeight : extent.height;

                      var _destWidth3 = _region4.texExtent.width + offset.x === gpuTexture.width >> _mipLevel3 ? _region4.texExtent.width : extent.width;

                      var _destHeight3 = _region4.texExtent.height + offset.y === gpuTexture.height >> _mipLevel3 ? _region4.texExtent.height : extent.height;

                      var _fcount = _region4.texSubres.baseArrayLayer + _region4.texSubres.layerCount;

                      for (f = _region4.texSubres.baseArrayLayer; f < _fcount; ++f) {
                        var _pixels3 = void 0;

                        var _buffer3 = buffers[n++];

                        if (stride.width === extent.width && stride.height === extent.height) {
                          _pixels3 = new ArrayBufferCtor(_buffer3.buffer, _buffer3.byteOffset + _region4.buffOffset);
                        } else {
                          _pixels3 = pixelBufferPick$1(_buffer3, gpuTexture.format, _region4.buffOffset, stride, extent);
                        }

                        if (!isCompressed) {
                          gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _mipLevel3, offset.x, offset.y, _destWidth3, _destHeight3, gpuTexture.glFormat, gpuTexture.glType, _pixels3);
                        } else if (gpuTexture.glInternalFmt !== WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL) {
                          gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _mipLevel3, offset.x, offset.y, _destWidth3, _destHeight3, gpuTexture.glFormat, _pixels3);
                        } else {
                          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _mipLevel3, gpuTexture.glInternalFmt, _destWidth3, _destHeight3, 0, _pixels3);
                        }
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported GL texture type, copy buffer to texture failed.');
                  }
              }

              if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP) {
                gl.generateMipmap(gpuTexture.glTarget);
              }
            }
            function WebGL2CmdFuncCopyTextureToBuffers(device, gpuTexture, buffers, regions) {
              var gl = device.gl;
              var cache = device.stateCache;
              var framebuffer = gl.createFramebuffer();
              gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
              var x = 0;
              var y = 0;
              var w = 1;
              var h = 1;

              switch (gpuTexture.glTarget) {
                case gl.TEXTURE_2D:
                  {
                    for (var k = 0; k < regions.length; k++) {
                      var region = regions[k];
                      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gpuTexture.glTarget, gpuTexture.glTexture, region.texSubres.mipLevel);
                      x = region.texOffset.x;
                      y = region.texOffset.y;
                      w = region.texExtent.width;
                      h = region.texExtent.height;
                      gl.readPixels(x, y, w, h, gpuTexture.glFormat, gpuTexture.glType, buffers[k]);
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported GL texture type, copy texture to buffers failed.');
                  }
              }

              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              cache.glFramebuffer = null;
              gl.deleteFramebuffer(framebuffer);
            }
            function WebGL2CmdFuncBlitTexture(device, src, dst, regions, filter) {
              var gl = device.gl;
              var cache = device.stateCache;
              var blitManager = device.blitManager;

              if (!blitManager) {
                return;
              }

              var glFilter = filter === Filter.LINEAR || filter === Filter.ANISOTROPIC ? gl.LINEAR : gl.NEAREST;
              var srcFramebuffer = blitManager.srcFramebuffer;
              var dstFramebuffer = blitManager.dstFramebuffer;
              var origReadFBO = cache.glReadFramebuffer;
              var origDrawFBO = cache.glFramebuffer;
              var srcMip = regions[0].srcSubres.mipLevel;
              var dstMip = regions[0].dstSubres.mipLevel;

              var blitInfo = function blitInfo(formatInfo) {
                var mask = 0;
                var attachment = gl.COLOR_ATTACHMENT0;

                if (formatInfo.hasStencil) {
                  attachment = gl.DEPTH_STENCIL_ATTACHMENT;
                } else if (formatInfo.hasDepth) {
                  attachment = gl.DEPTH_ATTACHMENT;
                }

                if (formatInfo.hasDepth || formatInfo.hasStencil) {
                  if (formatInfo.hasDepth) {
                    mask |= gl.DEPTH_BUFFER_BIT;
                  }

                  if (formatInfo.hasStencil) {
                    mask |= gl.STENCIL_BUFFER_BIT;
                  }
                } else {
                  mask |= gl.COLOR_BUFFER_BIT;
                }

                return {
                  mask: mask,
                  attachment: attachment
                };
              };

              var regionIndices = regions.map(function (_, i) {
                return i;
              });
              regionIndices.sort(function (a, b) {
                return regions[a].srcSubres.mipLevel - regions[b].srcSubres.mipLevel;
              });

              var _blitInfo = blitInfo(FormatInfos[src.format]),
                  srcMask = _blitInfo.mask,
                  srcAttachment = _blitInfo.attachment;

              var _blitInfo2 = blitInfo(FormatInfos[dst.format]),
                  dstAttachment = _blitInfo2.attachment;

              if (cache.glReadFramebuffer !== srcFramebuffer) {
                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, srcFramebuffer);
                cache.glReadFramebuffer = srcFramebuffer;
              }

              if (cache.glFramebuffer !== dstFramebuffer) {
                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dstFramebuffer);
                cache.glFramebuffer = dstFramebuffer;
              }

              if (src.glTexture) {
                gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, srcAttachment, src.glTarget, src.glTexture, srcMip);
              } else {
                gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER, srcAttachment, gl.RENDERBUFFER, src.glRenderbuffer);
              }

              if (dst.glTexture) {
                gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, dstAttachment, dst.glTarget, dst.glTexture, dstMip);
              } else {
                gl.framebufferRenderbuffer(gl.DRAW_FRAMEBUFFER, dstAttachment, gl.RENDERBUFFER, dst.glRenderbuffer);
              }

              for (var i = 0; i < regionIndices.length; i++) {
                var region = regions[regionIndices[i]];

                if (src.glTexture && srcMip !== region.srcSubres.mipLevel) {
                  srcMip = region.srcSubres.mipLevel;
                  gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, srcAttachment, src.glTarget, src.glTexture, srcMip);
                }

                if (dst.glTexture && dstMip !== region.dstSubres.mipLevel) {
                  dstMip = region.dstSubres.mipLevel;
                  gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, dstAttachment, dst.glTarget, dst.glTexture, dstMip);
                }

                gl.blitFramebuffer(region.srcOffset.x, region.srcOffset.y, region.srcOffset.x + region.srcExtent.width, region.srcOffset.y + region.srcExtent.height, region.dstOffset.x, region.dstOffset.y, region.dstOffset.x + region.dstExtent.width, region.dstOffset.y + region.dstExtent.height, srcMask, glFilter);
              }

              if (cache.glReadFramebuffer !== origReadFBO) {
                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, origReadFBO);
                cache.glReadFramebuffer = origReadFBO;
              }

              if (cache.glFramebuffer !== origDrawFBO) {
                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, origDrawFBO);
                cache.glFramebuffer = origDrawFBO;
              }
            }

            var WebGL2IndirectDrawInfos = function () {
              function WebGL2IndirectDrawInfos() {
                this.counts = void 0;
                this.offsets = void 0;
                this.instances = void 0;
                this.drawCount = 0;
                this.drawByIndex = false;
                this.instancedDraw = false;
                this.byteOffsets = void 0;
                this._capacity = 4;
                this.counts = new Int32Array(this._capacity);
                this.offsets = new Int32Array(this._capacity);
                this.instances = new Int32Array(this._capacity);
                this.byteOffsets = new Int32Array(this._capacity);
              }

              var _proto = WebGL2IndirectDrawInfos.prototype;

              _proto.clearDraws = function clearDraws() {
                this.drawCount = 0;
                this.drawByIndex = false;
                this.instancedDraw = false;
              };

              _proto.setDrawInfo = function setDrawInfo(idx, info) {
                this._ensureCapacity(idx);

                this.drawByIndex = info.indexCount > 0;
                this.instancedDraw = !!info.instanceCount;
                this.drawCount = Math.max(idx + 1, this.drawCount);

                if (this.drawByIndex) {
                  this.counts[idx] = info.indexCount;
                  this.offsets[idx] = info.firstIndex;
                } else {
                  this.counts[idx] = info.vertexCount;
                  this.offsets[idx] = info.firstVertex;
                }

                this.instances[idx] = Math.max(1, info.instanceCount);
              };

              _proto._ensureCapacity = function _ensureCapacity(target) {
                if (this._capacity > target) return;
                this._capacity = nextPow2(target);
                var counts = new Int32Array(this._capacity);
                var offsets = new Int32Array(this._capacity);
                var instances = new Int32Array(this._capacity);
                this.byteOffsets = new Int32Array(this._capacity);
                counts.set(this.counts);
                offsets.set(this.offsets);
                instances.set(this.instances);
                this.counts = counts;
                this.offsets = offsets;
                this.instances = instances;
              };

              return WebGL2IndirectDrawInfos;
            }();
            var IWebGL2BlitManager = function () {
              function IWebGL2BlitManager() {
                this._srcFramebuffer = void 0;
                this._dstFramebuffer = void 0;
                var gl = WebGL2DeviceManager.instance.gl;
                this._srcFramebuffer = gl.createFramebuffer();
                this._dstFramebuffer = gl.createFramebuffer();
              }

              var _proto2 = IWebGL2BlitManager.prototype;

              _proto2.destroy = function destroy() {
                var gl = WebGL2DeviceManager.instance.gl;
                gl.deleteFramebuffer(this._srcFramebuffer);
                gl.deleteFramebuffer(this._dstFramebuffer);
              };

              _createClass(IWebGL2BlitManager, [{
                key: "srcFramebuffer",
                get: function get() {
                  return this._srcFramebuffer;
                }
              }, {
                key: "dstFramebuffer",
                get: function get() {
                  return this._dstFramebuffer;
                }
              }]);

              return IWebGL2BlitManager;
            }();

            var WebGL2Buffer = function (_Buffer) {
              _inheritsLoose(WebGL2Buffer, _Buffer);

              function WebGL2Buffer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Buffer.call.apply(_Buffer, [this].concat(args)) || this;
                _this._gpuBuffer = null;
                return _this;
              }

              var _proto = WebGL2Buffer.prototype;

              _proto.initialize = function initialize(info) {
                if ('buffer' in info) {
                  this._isBufferView = true;
                  var buffer = info.buffer;
                  this._usage = buffer.usage;
                  this._memUsage = buffer.memUsage;
                  this._size = this._stride = info.range;
                  this._count = 1;
                  this._flags = buffer.flags;
                  this._gpuBuffer = {
                    usage: this._usage,
                    memUsage: this._memUsage,
                    size: this._size,
                    stride: this._stride,
                    buffer: null,
                    indirects: buffer.gpuBuffer.indirects,
                    glTarget: buffer.gpuBuffer.glTarget,
                    glBuffer: buffer.gpuBuffer.glBuffer,
                    glOffset: info.offset
                  };
                } else {
                  this._usage = info.usage;
                  this._memUsage = info.memUsage;
                  this._size = info.size;
                  this._stride = Math.max(info.stride || this._size, 1);
                  this._count = this._size / this._stride;
                  this._flags = info.flags;
                  this._gpuBuffer = {
                    usage: this._usage,
                    memUsage: this._memUsage,
                    size: this._size,
                    stride: this._stride,
                    buffer: null,
                    indirects: new WebGL2IndirectDrawInfos(),
                    glTarget: 0,
                    glBuffer: null,
                    glOffset: 0
                  };
                  WebGL2CmdFuncCreateBuffer(WebGL2DeviceManager.instance, this._gpuBuffer);
                  WebGL2DeviceManager.instance.memoryStatus.bufferSize += this._size;
                }
              };

              _proto.destroy = function destroy() {
                if (this._gpuBuffer) {
                  if (!this._isBufferView) {
                    WebGL2CmdFuncDestroyBuffer(WebGL2DeviceManager.instance, this._gpuBuffer);
                    WebGL2DeviceManager.instance.memoryStatus.bufferSize -= this._size;
                  }

                  this._gpuBuffer = null;
                }
              };

              _proto.resize = function resize(size) {
                if (this._isBufferView) {
                  console.warn('cannot resize buffer views!');
                  return;
                }

                var oldSize = this._size;

                if (oldSize === size) {
                  return;
                }

                this._size = size;
                this._count = this._size / this._stride;

                if (this._gpuBuffer) {
                  this._gpuBuffer.size = size;

                  if (size > 0) {
                    WebGL2CmdFuncResizeBuffer(WebGL2DeviceManager.instance, this._gpuBuffer);
                    WebGL2DeviceManager.instance.memoryStatus.bufferSize -= oldSize;
                    WebGL2DeviceManager.instance.memoryStatus.bufferSize += size;
                  }
                }
              };

              _proto.update = function update(buffer, size) {
                if (this._isBufferView) {
                  console.warn('cannot update through buffer views!');
                  return;
                }

                var buffSize;

                if (size !== undefined) {
                  buffSize = size;
                } else if (this._usage & BufferUsageBit.INDIRECT) {
                  buffSize = 0;
                } else {
                  buffSize = buffer.byteLength;
                }

                WebGL2CmdFuncUpdateBuffer(WebGL2DeviceManager.instance, this._gpuBuffer, buffer, 0, buffSize);
              };

              _createClass(WebGL2Buffer, [{
                key: "gpuBuffer",
                get: function get() {
                  return this._gpuBuffer;
                }
              }]);

              return WebGL2Buffer;
            }(Buffer);

            var WebGL2CommandPool = function () {
              function WebGL2CommandPool(Clazz, count) {
                this._frees = void 0;
                this._freeIdx = 0;
                this._freeCmds = void 0;
                this._frees = new Array(count);
                this._freeCmds = new CachedArray(count);

                for (var i = 0; i < count; ++i) {
                  this._frees[i] = new Clazz();
                }

                this._freeIdx = count - 1;
              }

              var _proto = WebGL2CommandPool.prototype;

              _proto.alloc = function alloc(Clazz) {
                if (this._freeIdx < 0) {
                  var size = this._frees.length * 2;
                  var temp = this._frees;
                  this._frees = new Array(size);
                  var increase = size - temp.length;

                  for (var i = 0; i < increase; ++i) {
                    this._frees[i] = new Clazz();
                  }

                  for (var _i = increase, j = 0; _i < size; ++_i, ++j) {
                    this._frees[_i] = temp[j];
                  }

                  this._freeIdx += increase;
                }

                var cmd = this._frees[this._freeIdx];
                this._frees[this._freeIdx--] = null;
                ++cmd.refCount;
                return cmd;
              };

              _proto.free = function free(cmd) {
                if (--cmd.refCount === 0) {
                  this._freeCmds.push(cmd);
                }
              };

              _proto.freeCmds = function freeCmds(cmds) {
                for (var i = 0; i < cmds.length; ++i) {
                  if (--cmds.array[i].refCount === 0) {
                    this._freeCmds.push(cmds.array[i]);
                  }
                }
              };

              _proto.release = function release() {
                for (var i = 0; i < this._freeCmds.length; ++i) {
                  var cmd = this._freeCmds.array[i];
                  cmd.clear();
                  this._frees[++this._freeIdx] = cmd;
                }

                this._freeCmds.clear();
              };

              return WebGL2CommandPool;
            }();
            var WebGL2CommandAllocator = function () {
              function WebGL2CommandAllocator() {
                this.beginRenderPassCmdPool = void 0;
                this.bindStatesCmdPool = void 0;
                this.drawCmdPool = void 0;
                this.updateBufferCmdPool = void 0;
                this.copyBufferToTextureCmdPool = void 0;
                this.blitTextureCmdPool = void 0;
                this.beginRenderPassCmdPool = new WebGL2CommandPool(WebGL2CmdBeginRenderPass, 1);
                this.bindStatesCmdPool = new WebGL2CommandPool(WebGL2CmdBindStates, 1);
                this.drawCmdPool = new WebGL2CommandPool(WebGL2CmdDraw, 1);
                this.updateBufferCmdPool = new WebGL2CommandPool(WebGL2CmdUpdateBuffer, 1);
                this.copyBufferToTextureCmdPool = new WebGL2CommandPool(WebGL2CmdCopyBufferToTexture, 1);
                this.blitTextureCmdPool = new WebGL2CommandPool(WebGL2CmdBlitTexture, 1);
              }

              var _proto2 = WebGL2CommandAllocator.prototype;

              _proto2.clearCmds = function clearCmds(cmdPackage) {
                if (cmdPackage.beginRenderPassCmds.length) {
                  this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds);
                  cmdPackage.beginRenderPassCmds.clear();
                }

                if (cmdPackage.bindStatesCmds.length) {
                  this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds);
                  cmdPackage.bindStatesCmds.clear();
                }

                if (cmdPackage.drawCmds.length) {
                  this.drawCmdPool.freeCmds(cmdPackage.drawCmds);
                  cmdPackage.drawCmds.clear();
                }

                if (cmdPackage.updateBufferCmds.length) {
                  this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds);
                  cmdPackage.updateBufferCmds.clear();
                }

                if (cmdPackage.copyBufferToTextureCmds.length) {
                  this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds);
                  cmdPackage.copyBufferToTextureCmds.clear();
                }

                if (cmdPackage.blitTextureCmds.length) {
                  this.blitTextureCmdPool.freeCmds(cmdPackage.blitTextureCmds);
                  cmdPackage.blitTextureCmds.clear();
                }

                cmdPackage.cmds.clear();
              };

              _proto2.releaseCmds = function releaseCmds() {
                this.beginRenderPassCmdPool.release();
                this.bindStatesCmdPool.release();
                this.drawCmdPool.release();
                this.updateBufferCmdPool.release();
                this.copyBufferToTextureCmdPool.release();
                this.blitTextureCmdPool.release();
              };

              return WebGL2CommandAllocator;
            }();

            var WebGL2CommandBuffer = function (_CommandBuffer) {
              _inheritsLoose(WebGL2CommandBuffer, _CommandBuffer);

              function WebGL2CommandBuffer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _CommandBuffer.call.apply(_CommandBuffer, [this].concat(args)) || this;
                _this.cmdPackage = new WebGL2CmdPackage();
                _this._cmdAllocator = new WebGL2CommandAllocator();
                _this._isInRenderPass = false;
                _this._curGPUPipelineState = null;
                _this._curGPUDescriptorSets = [];
                _this._curGPUInputAssembler = null;
                _this._curDynamicOffsets = Array(8).fill(0);
                _this._curDynamicStates = new DynamicStates();
                _this._isStateInvalied = false;
                return _this;
              }

              var _proto = WebGL2CommandBuffer.prototype;

              _proto.initialize = function initialize(info) {
                this._type = info.type;
                this._queue = info.queue;
                var setCount = WebGL2DeviceManager.instance.bindingMappings.blockOffsets.length;

                for (var i = 0; i < setCount; i++) {
                  this._curGPUDescriptorSets.push(null);
                }
              };

              _proto.destroy = function destroy() {
                this._cmdAllocator.clearCmds(this.cmdPackage);
              };

              _proto.begin = function begin(renderPass, subpass, frameBuffer) {

                this._cmdAllocator.clearCmds(this.cmdPackage);

                this._curGPUPipelineState = null;
                this._curGPUInputAssembler = null;
                this._curGPUDescriptorSets.length = 0;
                this._numDrawCalls = 0;
                this._numInstances = 0;
                this._numTris = 0;
              };

              _proto.end = function end() {
                if (this._isStateInvalied) {
                  this.bindStates();
                }

                this._isInRenderPass = false;
              };

              _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
                var cmd = this._cmdAllocator.beginRenderPassCmdPool.alloc(WebGL2CmdBeginRenderPass);

                cmd.gpuRenderPass = renderPass.gpuRenderPass;
                cmd.gpuFramebuffer = framebuffer.gpuFramebuffer;
                cmd.renderArea.copy(renderArea);

                for (var i = 0; i < clearColors.length; ++i) {
                  cmd.clearColors[i] = clearColors[i];
                }

                cmd.clearDepth = clearDepth;
                cmd.clearStencil = clearStencil;
                this.cmdPackage.beginRenderPassCmds.push(cmd);
                this.cmdPackage.cmds.push(WebGL2Cmd.BEGIN_RENDER_PASS);
                this._isInRenderPass = true;
              };

              _proto.endRenderPass = function endRenderPass() {
                this._isInRenderPass = false;
              };

              _proto.bindPipelineState = function bindPipelineState(pipelineState) {
                var gpuPipelineState = pipelineState.gpuPipelineState;

                if (gpuPipelineState !== this._curGPUPipelineState) {
                  this._curGPUPipelineState = gpuPipelineState;
                  this._isStateInvalied = true;
                }
              };

              _proto.bindDescriptorSet = function bindDescriptorSet(set, descriptorSet, dynamicOffsets) {
                var gpuDescriptorSets = descriptorSet.gpuDescriptorSet;

                if (gpuDescriptorSets !== this._curGPUDescriptorSets[set]) {
                  this._curGPUDescriptorSets[set] = gpuDescriptorSets;
                  this._isStateInvalied = true;
                }

                if (dynamicOffsets) {
                  var _this$_curGPUPipeline;

                  var gpuPipelineLayout = (_this$_curGPUPipeline = this._curGPUPipelineState) === null || _this$_curGPUPipeline === void 0 ? void 0 : _this$_curGPUPipeline.gpuPipelineLayout;

                  if (gpuPipelineLayout) {
                    var offsets = this._curDynamicOffsets;
                    var idx = gpuPipelineLayout.dynamicOffsetOffsets[set];

                    for (var i = 0; i < dynamicOffsets.length; i++) {
                      offsets[idx + i] = dynamicOffsets[i];
                    }

                    this._isStateInvalied = true;
                  }
                }
              };

              _proto.bindInputAssembler = function bindInputAssembler(inputAssembler) {
                var gpuInputAssembler = inputAssembler.gpuInputAssembler;
                this._curGPUInputAssembler = gpuInputAssembler;
                this._isStateInvalied = true;
              };

              _proto.setViewport = function setViewport(viewport) {
                var cache = this._curDynamicStates.viewport;

                if (cache.left !== viewport.left || cache.top !== viewport.top || cache.width !== viewport.width || cache.height !== viewport.height || cache.minDepth !== viewport.minDepth || cache.maxDepth !== viewport.maxDepth) {
                  cache.left = viewport.left;
                  cache.top = viewport.top;
                  cache.width = viewport.width;
                  cache.height = viewport.height;
                  cache.minDepth = viewport.minDepth;
                  cache.maxDepth = viewport.maxDepth;
                  this._isStateInvalied = true;
                }
              };

              _proto.setScissor = function setScissor(scissor) {
                var cache = this._curDynamicStates.scissor;

                if (cache.x !== scissor.x || cache.y !== scissor.y || cache.width !== scissor.width || cache.height !== scissor.height) {
                  cache.x = scissor.x;
                  cache.y = scissor.y;
                  cache.width = scissor.width;
                  cache.height = scissor.height;
                  this._isStateInvalied = true;
                }
              };

              _proto.setLineWidth = function setLineWidth(lineWidth) {
                if (this._curDynamicStates.lineWidth !== lineWidth) {
                  this._curDynamicStates.lineWidth = lineWidth;
                  this._isStateInvalied = true;
                }
              };

              _proto.setDepthBias = function setDepthBias(depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor) {
                var cache = this._curDynamicStates;

                if (cache.depthBiasConstant !== depthBiasConstantFactor || cache.depthBiasClamp !== depthBiasClamp || cache.depthBiasSlope !== depthBiasSlopeFactor) {
                  cache.depthBiasConstant = depthBiasConstantFactor;
                  cache.depthBiasClamp = depthBiasClamp;
                  cache.depthBiasSlope = depthBiasSlopeFactor;
                  this._isStateInvalied = true;
                }
              };

              _proto.setBlendConstants = function setBlendConstants(blendConstants) {
                var cache = this._curDynamicStates.blendConstant;

                if (cache.x !== blendConstants.x || cache.y !== blendConstants.y || cache.z !== blendConstants.z || cache.w !== blendConstants.w) {
                  cache.copy(blendConstants);
                  this._isStateInvalied = true;
                }
              };

              _proto.setDepthBound = function setDepthBound(minDepthBounds, maxDepthBounds) {
                var cache = this._curDynamicStates;

                if (cache.depthMinBounds !== minDepthBounds || cache.depthMaxBounds !== maxDepthBounds) {
                  cache.depthMinBounds = minDepthBounds;
                  cache.depthMaxBounds = maxDepthBounds;
                  this._isStateInvalied = true;
                }
              };

              _proto.setStencilWriteMask = function setStencilWriteMask(face, writeMask) {
                var front = this._curDynamicStates.stencilStatesFront;
                var back = this._curDynamicStates.stencilStatesBack;

                if (face & StencilFace.FRONT) {
                  if (front.writeMask !== writeMask) {
                    front.writeMask = writeMask;
                    this._isStateInvalied = true;
                  }
                }

                if (face & StencilFace.BACK) {
                  if (back.writeMask !== writeMask) {
                    back.writeMask = writeMask;
                    this._isStateInvalied = true;
                  }
                }
              };

              _proto.setStencilCompareMask = function setStencilCompareMask(face, reference, compareMask) {
                var front = this._curDynamicStates.stencilStatesFront;
                var back = this._curDynamicStates.stencilStatesBack;

                if (face & StencilFace.FRONT) {
                  if (front.compareMask !== compareMask || front.reference !== reference) {
                    front.reference = reference;
                    front.compareMask = compareMask;
                    this._isStateInvalied = true;
                  }
                }

                if (face & StencilFace.BACK) {
                  if (back.compareMask !== compareMask || back.reference !== reference) {
                    back.reference = reference;
                    back.compareMask = compareMask;
                    this._isStateInvalied = true;
                  }
                }
              };

              _proto.draw = function draw(infoOrAssembler) {
                if (this._type === CommandBufferType.PRIMARY && this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  if (this._isStateInvalied) {
                    this.bindStates();
                  }

                  var info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;

                  var cmd = this._cmdAllocator.drawCmdPool.alloc(WebGL2CmdDraw);

                  cmd.drawInfo.copy(info);
                  this.cmdPackage.drawCmds.push(cmd);
                  this.cmdPackage.cmds.push(WebGL2Cmd.DRAW);
                  ++this._numDrawCalls;
                  this._numInstances += info.instanceCount;
                  var indexCount = info.indexCount || info.vertexCount;

                  if (this._curGPUPipelineState) {
                    var glPrimitive = this._curGPUPipelineState.glPrimitive;

                    switch (glPrimitive) {
                      case 0x0004:
                        {
                          this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                          break;
                        }

                      case 0x0005:
                      case 0x0006:
                        {
                          this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                          break;
                        }
                    }
                  }
                } else {
                  console.error('Command \'draw\' must be recorded inside a render pass.');
                }
              };

              _proto.updateBuffer = function updateBuffer(buffer, data, size) {
                if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  var gpuBuffer = buffer.gpuBuffer;

                  if (gpuBuffer) {
                    var cmd = this._cmdAllocator.updateBufferCmdPool.alloc(WebGL2CmdUpdateBuffer);

                    var buffSize = 0;
                    var buff = null;

                    if (buffer.usage & BufferUsageBit.INDIRECT) {
                      buff = data;
                    } else {
                      if (size !== undefined) {
                        buffSize = size;
                      } else {
                        buffSize = data.byteLength;
                      }

                      buff = data;
                    }

                    cmd.gpuBuffer = gpuBuffer;
                    cmd.buffer = buff;
                    cmd.offset = 0;
                    cmd.size = buffSize;
                    this.cmdPackage.updateBufferCmds.push(cmd);
                    this.cmdPackage.cmds.push(WebGL2Cmd.UPDATE_BUFFER);
                  }
                } else {
                  console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
                }
              };

              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  var gpuTexture = texture.gpuTexture;

                  if (gpuTexture) {
                    var cmd = this._cmdAllocator.copyBufferToTextureCmdPool.alloc(WebGL2CmdCopyBufferToTexture);

                    cmd.gpuTexture = gpuTexture;
                    cmd.regions = regions;
                    cmd.buffers = buffers;
                    this.cmdPackage.copyBufferToTextureCmds.push(cmd);
                    this.cmdPackage.cmds.push(WebGL2Cmd.COPY_BUFFER_TO_TEXTURE);
                  }
                } else {
                  console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
                }
              };

              _proto.execute = function execute(cmdBuffs, count) {
                for (var i = 0; i < count; ++i) {
                  var webGL2CmdBuff = cmdBuffs[i];

                  for (var c = 0; c < webGL2CmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
                    var cmd = webGL2CmdBuff.cmdPackage.beginRenderPassCmds.array[c];
                    ++cmd.refCount;
                    this.cmdPackage.beginRenderPassCmds.push(cmd);
                  }

                  for (var _c = 0; _c < webGL2CmdBuff.cmdPackage.bindStatesCmds.length; ++_c) {
                    var _cmd = webGL2CmdBuff.cmdPackage.bindStatesCmds.array[_c];
                    ++_cmd.refCount;
                    this.cmdPackage.bindStatesCmds.push(_cmd);
                  }

                  for (var _c2 = 0; _c2 < webGL2CmdBuff.cmdPackage.drawCmds.length; ++_c2) {
                    var _cmd2 = webGL2CmdBuff.cmdPackage.drawCmds.array[_c2];
                    ++_cmd2.refCount;
                    this.cmdPackage.drawCmds.push(_cmd2);
                  }

                  for (var _c3 = 0; _c3 < webGL2CmdBuff.cmdPackage.updateBufferCmds.length; ++_c3) {
                    var _cmd3 = webGL2CmdBuff.cmdPackage.updateBufferCmds.array[_c3];
                    ++_cmd3.refCount;
                    this.cmdPackage.updateBufferCmds.push(_cmd3);
                  }

                  for (var _c4 = 0; _c4 < webGL2CmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++_c4) {
                    var _cmd4 = webGL2CmdBuff.cmdPackage.copyBufferToTextureCmds.array[_c4];
                    ++_cmd4.refCount;
                    this.cmdPackage.copyBufferToTextureCmds.push(_cmd4);
                  }

                  for (var _c5 = 0; _c5 < webGL2CmdBuff.cmdPackage.blitTextureCmds.length; ++_c5) {
                    var _cmd5 = webGL2CmdBuff.cmdPackage.blitTextureCmds.array[_c5];
                    ++_cmd5.refCount;
                    this.cmdPackage.blitTextureCmds.push(_cmd5);
                  }

                  this.cmdPackage.cmds.concat(webGL2CmdBuff.cmdPackage.cmds.array);
                  this._numDrawCalls += webGL2CmdBuff._numDrawCalls;
                  this._numInstances += webGL2CmdBuff._numInstances;
                  this._numTris += webGL2CmdBuff._numTris;
                }
              };

              _proto.pipelineBarrier = function pipelineBarrier(GeneralBarrier, bufferBarriers, buffers, textureBarriers, textures) {};

              _proto.bindStates = function bindStates() {
                var bindStatesCmd = this._cmdAllocator.bindStatesCmdPool.alloc(WebGL2CmdBindStates);

                bindStatesCmd.gpuPipelineState = this._curGPUPipelineState;
                Array.prototype.push.apply(bindStatesCmd.gpuDescriptorSets, this._curGPUDescriptorSets);
                Array.prototype.push.apply(bindStatesCmd.dynamicOffsets, this._curDynamicOffsets);
                bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler;
                bindStatesCmd.dynamicStates = this._curDynamicStates;
                this.cmdPackage.bindStatesCmds.push(bindStatesCmd);
                this.cmdPackage.cmds.push(WebGL2Cmd.BIND_STATES);
                this._isStateInvalied = false;
              };

              _proto.blitTexture = function blitTexture(srcTexture, dstTexture, regions, filter) {
                var blitTextureCmd = this._cmdAllocator.blitTextureCmdPool.alloc(WebGL2CmdBlitTexture);

                blitTextureCmd.srcTexture = srcTexture.gpuTexture;
                blitTextureCmd.dstTexture = dstTexture.gpuTexture;
                blitTextureCmd.regions = regions;
                blitTextureCmd.filter = filter;
                ++this._numDrawCalls;
                this.cmdPackage.blitTextureCmds.push(blitTextureCmd);
                this.cmdPackage.cmds.push(WebGL2Cmd.BLIT_TEXTURE);
              };

              return WebGL2CommandBuffer;
            }(CommandBuffer);

            var WebGL2Framebuffer = function (_Framebuffer) {
              _inheritsLoose(WebGL2Framebuffer, _Framebuffer);

              function WebGL2Framebuffer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Framebuffer.call.apply(_Framebuffer, [this].concat(args)) || this;
                _this._gpuFramebuffer = null;
                return _this;
              }

              var _proto = WebGL2Framebuffer.prototype;

              _proto.initialize = function initialize(info) {
                this._renderPass = info.renderPass;
                this._colorTextures = info.colorTextures || [];
                this._depthStencilTexture = info.depthStencilTexture || null;
                var gpuColorViews = [];

                for (var i = 0; i < info.colorTextures.length; i++) {
                  var colorTexture = info.colorTextures[i];

                  if (colorTexture) {
                    gpuColorViews.push(colorTexture.gpuTextureView);
                  }
                }

                var gpuDepthStencilView = null;

                if (info.depthStencilTexture) {
                  gpuDepthStencilView = info.depthStencilTexture.gpuTextureView;
                }

                var width = Number.MAX_SAFE_INTEGER;
                this._gpuFramebuffer = {
                  gpuRenderPass: info.renderPass.gpuRenderPass,
                  gpuColorViews: gpuColorViews,
                  gpuDepthStencilView: gpuDepthStencilView,
                  glFramebuffer: null,
                  isOffscreen: true,

                  get width() {
                    if (this.isOffscreen) {
                      return width;
                    } else if (this.gpuColorViews.length > 0) {
                      return this.gpuColorViews[0].gpuTexture.width;
                    } else {
                      return this.gpuDepthStencilView.gpuTexture.width;
                    }
                  },

                  set width(val) {
                    width = val;
                  },

                  get height() {
                    if (this.isOffscreen) {
                      return width;
                    } else if (this.gpuColorViews.length > 0) {
                      return this.gpuColorViews[0].gpuTexture.height;
                    } else {
                      return this.gpuDepthStencilView.gpuTexture.height;
                    }
                  },

                  set height(val) {
                  }

                };
                WebGL2CmdFuncCreateFramebuffer(WebGL2DeviceManager.instance, this._gpuFramebuffer);
              };

              _proto.destroy = function destroy() {
                if (this._gpuFramebuffer) {
                  WebGL2CmdFuncDestroyFramebuffer(WebGL2DeviceManager.instance, this._gpuFramebuffer);
                  this._gpuFramebuffer = null;
                }
              };

              _createClass(WebGL2Framebuffer, [{
                key: "gpuFramebuffer",
                get: function get() {
                  return this._gpuFramebuffer;
                }
              }]);

              return WebGL2Framebuffer;
            }(Framebuffer);

            var WebGL2InputAssembler = function (_InputAssembler) {
              _inheritsLoose(WebGL2InputAssembler, _InputAssembler);

              function WebGL2InputAssembler() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _InputAssembler.call.apply(_InputAssembler, [this].concat(args)) || this;
                _this._gpuInputAssembler = null;
                return _this;
              }

              var _proto = WebGL2InputAssembler.prototype;

              _proto.initialize = function initialize(info) {
                if (info.vertexBuffers.length === 0) {
                  console.error('InputAssemblerInfo.vertexBuffers is null.');
                  return;
                }

                this._attributes = info.attributes;
                this._attributesHash = this.computeAttributesHash();
                this._vertexBuffers = info.vertexBuffers;

                if (info.indexBuffer) {
                  this._indexBuffer = info.indexBuffer;
                  this._drawInfo.indexCount = this._indexBuffer.size / this._indexBuffer.stride;
                  this._drawInfo.firstIndex = 0;
                } else {
                  var vertBuff = this._vertexBuffers[0];
                  this._drawInfo.vertexCount = vertBuff.size / vertBuff.stride;
                  this._drawInfo.firstVertex = 0;
                  this._drawInfo.vertexOffset = 0;
                }

                this._drawInfo.instanceCount = 0;
                this._drawInfo.firstInstance = 0;
                this._indirectBuffer = info.indirectBuffer || null;
                var gpuVertexBuffers = new Array(info.vertexBuffers.length);

                for (var i = 0; i < info.vertexBuffers.length; ++i) {
                  var vb = info.vertexBuffers[i];

                  if (vb.gpuBuffer) {
                    gpuVertexBuffers[i] = vb.gpuBuffer;
                  }
                }

                var gpuIndexBuffer = null;
                var glIndexType = 0;

                if (info.indexBuffer) {
                  gpuIndexBuffer = info.indexBuffer.gpuBuffer;

                  if (gpuIndexBuffer) {
                    switch (gpuIndexBuffer.stride) {
                      case 1:
                        glIndexType = 0x1401;
                        break;

                      case 2:
                        glIndexType = 0x1403;
                        break;

                      case 4:
                        glIndexType = 0x1405;
                        break;

                      default:
                        {
                          console.error('Illegal index buffer stride.');
                        }
                    }
                  }
                }

                var gpuIndirectBuffer = null;

                if (info.indirectBuffer) {
                  gpuIndirectBuffer = info.indirectBuffer.gpuBuffer;
                }

                this._gpuInputAssembler = {
                  attributes: info.attributes,
                  gpuVertexBuffers: gpuVertexBuffers,
                  gpuIndexBuffer: gpuIndexBuffer,
                  gpuIndirectBuffer: gpuIndirectBuffer,
                  glAttribs: [],
                  glIndexType: glIndexType,
                  glVAOs: new Map()
                };
                WebGL2CmdFuncCreateInputAssember(WebGL2DeviceManager.instance, this._gpuInputAssembler);
              };

              _proto.destroy = function destroy() {
                var device = WebGL2DeviceManager.instance;

                if (this._gpuInputAssembler && device.extensions.useVAO) {
                  WebGL2CmdFuncDestroyInputAssembler(device, this._gpuInputAssembler);
                }

                this._gpuInputAssembler = null;
              };

              _createClass(WebGL2InputAssembler, [{
                key: "gpuInputAssembler",
                get: function get() {
                  return this._gpuInputAssembler;
                }
              }]);

              return WebGL2InputAssembler;
            }(InputAssembler);

            var WebGL2DescriptorSetLayout = function (_DescriptorSetLayout) {
              _inheritsLoose(WebGL2DescriptorSetLayout, _DescriptorSetLayout);

              function WebGL2DescriptorSetLayout() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _DescriptorSetLayout.call.apply(_DescriptorSetLayout, [this].concat(args)) || this;
                _this._gpuDescriptorSetLayout = null;
                return _this;
              }

              var _proto = WebGL2DescriptorSetLayout.prototype;

              _proto.initialize = function initialize(info) {
                Array.prototype.push.apply(this._bindings, info.bindings);
                var descriptorCount = 0;
                var maxBinding = -1;
                var flattenedIndices = [];

                for (var i = 0; i < this._bindings.length; i++) {
                  var binding = this._bindings[i];
                  flattenedIndices.push(descriptorCount);
                  descriptorCount += binding.count;
                  if (binding.binding > maxBinding) maxBinding = binding.binding;
                }

                this._bindingIndices = Array(maxBinding + 1).fill(-1);
                var descriptorIndices = this._descriptorIndices = Array(maxBinding + 1).fill(-1);

                for (var _i = 0; _i < this._bindings.length; _i++) {
                  var _binding = this._bindings[_i];
                  this._bindingIndices[_binding.binding] = _i;
                  descriptorIndices[_binding.binding] = flattenedIndices[_i];
                }

                var dynamicBindings = [];

                for (var _i2 = 0; _i2 < this._bindings.length; _i2++) {
                  var _binding2 = this._bindings[_i2];

                  if (_binding2.descriptorType & DESCRIPTOR_DYNAMIC_TYPE) {
                    for (var j = 0; j < _binding2.count; j++) {
                      dynamicBindings.push(_binding2.binding);
                    }
                  }
                }

                this._gpuDescriptorSetLayout = {
                  bindings: this._bindings,
                  dynamicBindings: dynamicBindings,
                  descriptorIndices: descriptorIndices,
                  descriptorCount: descriptorCount
                };
              };

              _proto.destroy = function destroy() {
                this._bindings.length = 0;
              };

              _createClass(WebGL2DescriptorSetLayout, [{
                key: "gpuDescriptorSetLayout",
                get: function get() {
                  return this._gpuDescriptorSetLayout;
                }
              }]);

              return WebGL2DescriptorSetLayout;
            }(DescriptorSetLayout);

            var WebGL2PipelineLayout = function (_PipelineLayout) {
              _inheritsLoose(WebGL2PipelineLayout, _PipelineLayout);

              function WebGL2PipelineLayout() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _PipelineLayout.call.apply(_PipelineLayout, [this].concat(args)) || this;
                _this._gpuPipelineLayout = null;
                return _this;
              }

              var _proto = WebGL2PipelineLayout.prototype;

              _proto.initialize = function initialize(info) {
                Array.prototype.push.apply(this._setLayouts, info.setLayouts);
                var dynamicOffsetIndices = [];
                var gpuSetLayouts = [];
                var dynamicOffsetCount = 0;
                var dynamicOffsetOffsets = [];

                for (var i = 0; i < this._setLayouts.length; i++) {
                  var setLayout = this._setLayouts[i];
                  var dynamicBindings = setLayout.gpuDescriptorSetLayout.dynamicBindings;
                  var indices = Array(setLayout.bindingIndices.length).fill(-1);

                  for (var j = 0; j < dynamicBindings.length; j++) {
                    var binding = dynamicBindings[j];
                    if (indices[binding] < 0) indices[binding] = dynamicOffsetCount + j;
                  }

                  gpuSetLayouts.push(setLayout.gpuDescriptorSetLayout);
                  dynamicOffsetIndices.push(indices);
                  dynamicOffsetOffsets.push(dynamicOffsetCount);
                  dynamicOffsetCount += dynamicBindings.length;
                }

                this._gpuPipelineLayout = {
                  gpuSetLayouts: gpuSetLayouts,
                  dynamicOffsetIndices: dynamicOffsetIndices,
                  dynamicOffsetCount: dynamicOffsetCount,
                  dynamicOffsetOffsets: dynamicOffsetOffsets
                };
              };

              _proto.destroy = function destroy() {
                this._setLayouts.length = 0;
              };

              _createClass(WebGL2PipelineLayout, [{
                key: "gpuPipelineLayout",
                get: function get() {
                  return this._gpuPipelineLayout;
                }
              }]);

              return WebGL2PipelineLayout;
            }(PipelineLayout);

            var WebGLPrimitives$1 = [0x0000, 0x0001, 0x0003, 0x0002, 0x0000, 0x0000, 0x0000, 0x0004, 0x0005, 0x0006, 0x0000, 0x0000, 0x0000, 0x0000];
            var WebGL2PipelineState = function (_PipelineState) {
              _inheritsLoose(WebGL2PipelineState, _PipelineState);

              function WebGL2PipelineState() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _PipelineState.call.apply(_PipelineState, [this].concat(args)) || this;
                _this._gpuPipelineState = null;
                return _this;
              }

              var _proto = WebGL2PipelineState.prototype;

              _proto.initialize = function initialize(info) {
                this._primitive = info.primitive;
                this._shader = info.shader;
                this._pipelineLayout = info.pipelineLayout;
                var bs = this._bs;

                if (info.blendState) {
                  var bsInfo = info.blendState;
                  var targets = bsInfo.targets;

                  if (targets) {
                    targets.forEach(function (t, i) {
                      bs.setTarget(i, t);
                    });
                  }

                  if (bsInfo.isA2C !== undefined) {
                    bs.isA2C = bsInfo.isA2C;
                  }

                  if (bsInfo.isIndepend !== undefined) {
                    bs.isIndepend = bsInfo.isIndepend;
                  }

                  if (bsInfo.blendColor !== undefined) {
                    bs.blendColor = bsInfo.blendColor;
                  }
                }

                Object.assign(this._rs, info.rasterizerState);
                Object.assign(this._dss, info.depthStencilState);
                this._is = info.inputState;
                this._renderPass = info.renderPass;
                this._dynamicStates = info.dynamicStates;
                var dynamicStates = [];

                for (var i = 0; i < 31; i++) {
                  if (this._dynamicStates & 1 << i) {
                    dynamicStates.push(1 << i);
                  }
                }

                this._gpuPipelineState = {
                  glPrimitive: WebGLPrimitives$1[info.primitive],
                  gpuShader: info.shader.gpuShader,
                  gpuPipelineLayout: info.pipelineLayout.gpuPipelineLayout,
                  rs: info.rasterizerState,
                  dss: info.depthStencilState,
                  bs: info.blendState,
                  gpuRenderPass: info.renderPass.gpuRenderPass,
                  dynamicStates: dynamicStates
                };
              };

              _proto.destroy = function destroy() {
                this._gpuPipelineState = null;
              };

              _createClass(WebGL2PipelineState, [{
                key: "gpuPipelineState",
                get: function get() {
                  return this._gpuPipelineState;
                }
              }]);

              return WebGL2PipelineState;
            }(PipelineState);

            var WebGL2PrimaryCommandBuffer = function (_WebGL2CommandBuffer) {
              _inheritsLoose(WebGL2PrimaryCommandBuffer, _WebGL2CommandBuffer);

              function WebGL2PrimaryCommandBuffer() {
                return _WebGL2CommandBuffer.apply(this, arguments) || this;
              }

              var _proto = WebGL2PrimaryCommandBuffer.prototype;

              _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
                WebGL2CmdFuncBeginRenderPass(WebGL2DeviceManager.instance, renderPass.gpuRenderPass, framebuffer.gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil);
                this._isInRenderPass = true;
              };

              _proto.draw = function draw(infoOrAssembler) {
                if (this._isInRenderPass) {
                  if (this._isStateInvalied) {
                    this.bindStates();
                  }

                  var info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;
                  WebGL2CmdFuncDraw(WebGL2DeviceManager.instance, info);
                  ++this._numDrawCalls;
                  this._numInstances += info.instanceCount;
                  var indexCount = info.indexCount || info.vertexCount;

                  if (this._curGPUPipelineState) {
                    var glPrimitive = this._curGPUPipelineState.glPrimitive;

                    switch (glPrimitive) {
                      case 0x0004:
                        {
                          this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                          break;
                        }

                      case 0x0005:
                      case 0x0006:
                        {
                          this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                          break;
                        }
                    }
                  }
                } else {
                  console.error('Command \'draw\' must be recorded inside a render pass.');
                }
              };

              _proto.setViewport = function setViewport(viewport) {
                var _WebGL2DeviceManager$ = WebGL2DeviceManager.instance,
                    cache = _WebGL2DeviceManager$.stateCache,
                    gl = _WebGL2DeviceManager$.gl;

                if (cache.viewport.left !== viewport.left || cache.viewport.top !== viewport.top || cache.viewport.width !== viewport.width || cache.viewport.height !== viewport.height) {
                  gl.viewport(viewport.left, viewport.top, viewport.width, viewport.height);
                  cache.viewport.left = viewport.left;
                  cache.viewport.top = viewport.top;
                  cache.viewport.width = viewport.width;
                  cache.viewport.height = viewport.height;
                }
              };

              _proto.setScissor = function setScissor(scissor) {
                var _WebGL2DeviceManager$2 = WebGL2DeviceManager.instance,
                    cache = _WebGL2DeviceManager$2.stateCache,
                    gl = _WebGL2DeviceManager$2.gl;

                if (cache.scissorRect.x !== scissor.x || cache.scissorRect.y !== scissor.y || cache.scissorRect.width !== scissor.width || cache.scissorRect.height !== scissor.height) {
                  gl.scissor(scissor.x, scissor.y, scissor.width, scissor.height);
                  cache.scissorRect.x = scissor.x;
                  cache.scissorRect.y = scissor.y;
                  cache.scissorRect.width = scissor.width;
                  cache.scissorRect.height = scissor.height;
                }
              };

              _proto.updateBuffer = function updateBuffer(buffer, data, size) {
                if (!this._isInRenderPass) {
                  var gpuBuffer = buffer.gpuBuffer;

                  if (gpuBuffer) {
                    var buffSize;

                    if (size !== undefined) {
                      buffSize = size;
                    } else if (buffer.usage & BufferUsageBit.INDIRECT) {
                      buffSize = 0;
                    } else {
                      buffSize = data.byteLength;
                    }

                    WebGL2CmdFuncUpdateBuffer(WebGL2DeviceManager.instance, gpuBuffer, data, 0, buffSize);
                  }
                } else {
                  console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
                }
              };

              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                if (!this._isInRenderPass) {
                  var gpuTexture = texture.gpuTexture;

                  if (gpuTexture) {
                    WebGL2CmdFuncCopyBuffersToTexture(WebGL2DeviceManager.instance, buffers, gpuTexture, regions);
                  }
                } else {
                  console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
                }
              };

              _proto.execute = function execute(cmdBuffs, count) {
                for (var i = 0; i < count; ++i) {
                  var webGL2CmdBuff = cmdBuffs[i];
                  WebGL2CmdFuncExecuteCmds(WebGL2DeviceManager.instance, webGL2CmdBuff.cmdPackage);
                  this._numDrawCalls += webGL2CmdBuff._numDrawCalls;
                  this._numInstances += webGL2CmdBuff._numInstances;
                  this._numTris += webGL2CmdBuff._numTris;
                }
              };

              _proto.bindStates = function bindStates() {
                WebGL2CmdFuncBindStates(WebGL2DeviceManager.instance, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, this._curDynamicOffsets, this._curDynamicStates);
                this._isStateInvalied = false;
              };

              _proto.blitTexture = function blitTexture(srcTexture, dstTexture, regions, filter) {
                var gpuTextureSrc = srcTexture.gpuTexture;
                var gpuTextureDst = dstTexture.gpuTexture;
                WebGL2CmdFuncBlitTexture(WebGL2DeviceManager.instance, gpuTextureSrc, gpuTextureDst, regions, filter);
              };

              return WebGL2PrimaryCommandBuffer;
            }(WebGL2CommandBuffer);

            var WebGL2Queue = function (_Queue) {
              _inheritsLoose(WebGL2Queue, _Queue);

              function WebGL2Queue() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Queue.call.apply(_Queue, [this].concat(args)) || this;
                _this.numDrawCalls = 0;
                _this.numInstances = 0;
                _this.numTris = 0;
                return _this;
              }

              var _proto = WebGL2Queue.prototype;

              _proto.initialize = function initialize(info) {
                this._type = info.type;
              };

              _proto.destroy = function destroy() {};

              _proto.submit = function submit(cmdBuffs) {
                for (var i = 0; i < cmdBuffs.length; i++) {
                  var cmdBuff = cmdBuffs[i];
                  this.numDrawCalls += cmdBuff.numDrawCalls;
                  this.numInstances += cmdBuff.numInstances;
                  this.numTris += cmdBuff.numTris;
                }
              };

              _proto.clear = function clear() {
                this.numDrawCalls = 0;
                this.numInstances = 0;
                this.numTris = 0;
              };

              return WebGL2Queue;
            }(Queue);

            var WebGL2RenderPass = function (_RenderPass) {
              _inheritsLoose(WebGL2RenderPass, _RenderPass);

              function WebGL2RenderPass() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _RenderPass.call.apply(_RenderPass, [this].concat(args)) || this;
                _this._gpuRenderPass = null;
                return _this;
              }

              var _proto = WebGL2RenderPass.prototype;

              _proto.initialize = function initialize(info) {
                this._colorInfos = info.colorAttachments;
                this._depthStencilInfo = info.depthStencilAttachment;
                this._subpasses = info.subpasses;
                this._gpuRenderPass = {
                  colorAttachments: this._colorInfos,
                  depthStencilAttachment: this._depthStencilInfo
                };
                this._hash = this.computeHash();
              };

              _proto.destroy = function destroy() {
                this._gpuRenderPass = null;
              };

              _createClass(WebGL2RenderPass, [{
                key: "gpuRenderPass",
                get: function get() {
                  return this._gpuRenderPass;
                }
              }]);

              return WebGL2RenderPass;
            }(RenderPass);

            var WebGL2Sampler = function (_Sampler) {
              _inheritsLoose(WebGL2Sampler, _Sampler);

              function WebGL2Sampler(info, hash) {
                var _this;

                _this = _Sampler.call(this, info, hash) || this;
                _this._gpuSampler = null;
                _this._gpuSampler = {
                  glSamplers: new Map(),
                  minFilter: _this._info.minFilter,
                  magFilter: _this._info.magFilter,
                  mipFilter: _this._info.mipFilter,
                  addressU: _this._info.addressU,
                  addressV: _this._info.addressV,
                  addressW: _this._info.addressW,
                  glMinFilter: 0,
                  glMagFilter: 0,
                  glWrapS: 0,
                  glWrapT: 0,
                  glWrapR: 0,
                  getGLSampler: function getGLSampler(device, minLod, maxLod) {
                    var gl = device.gl;
                    var samplerHash = minLod << 16 | maxLod;

                    if (!this.glSamplers.has(samplerHash)) {
                      var glSampler = gl.createSampler();

                      if (glSampler) {
                        this.glSamplers.set(samplerHash, glSampler);
                        gl.samplerParameteri(glSampler, gl.TEXTURE_MIN_FILTER, this.glMinFilter);
                        gl.samplerParameteri(glSampler, gl.TEXTURE_MAG_FILTER, this.glMagFilter);
                        gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_S, this.glWrapS);
                        gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_T, this.glWrapT);
                        gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_R, this.glWrapR);
                        gl.samplerParameterf(glSampler, gl.TEXTURE_MIN_LOD, minLod);
                        gl.samplerParameterf(glSampler, gl.TEXTURE_MAX_LOD, maxLod);
                      }
                    }

                    var sampler = this.glSamplers.get(samplerHash);
                    return sampler;
                  }
                };
                WebGL2CmdFuncPrepareSamplerInfo(WebGL2DeviceManager.instance, _this._gpuSampler);
                return _this;
              }

              var _proto = WebGL2Sampler.prototype;

              _proto.destroy = function destroy() {
                if (this._gpuSampler) {
                  WebGL2CmdFuncDestroySampler(WebGL2DeviceManager.instance, this._gpuSampler);
                  this._gpuSampler = null;
                }
              };

              _createClass(WebGL2Sampler, [{
                key: "gpuSampler",
                get: function get() {
                  return this._gpuSampler;
                }
              }]);

              return WebGL2Sampler;
            }(Sampler);

            var WebGL2Shader = function (_Shader) {
              _inheritsLoose(WebGL2Shader, _Shader);

              function WebGL2Shader() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Shader.call.apply(_Shader, [this].concat(args)) || this;
                _this._gpuShader = null;
                return _this;
              }

              var _proto = WebGL2Shader.prototype;

              _proto.initialize = function initialize(info) {
                this._name = info.name;
                this._stages = info.stages;
                this._attributes = info.attributes;
                this._blocks = info.blocks;
                this._samplers = info.samplers;
                this._gpuShader = {
                  name: info.name,
                  blocks: info.blocks.slice(),
                  samplerTextures: info.samplerTextures.slice(),
                  subpassInputs: info.subpassInputs.slice(),
                  gpuStages: new Array(info.stages.length),
                  glProgram: null,
                  glInputs: [],
                  glUniforms: [],
                  glBlocks: [],
                  glSamplerTextures: []
                };

                for (var i = 0; i < info.stages.length; ++i) {
                  var stage = info.stages[i];
                  this._gpuShader.gpuStages[i] = {
                    type: stage.stage,
                    source: stage.source,
                    glShader: null
                  };
                }
              };

              _proto.destroy = function destroy() {
                if (this._gpuShader) {
                  WebGL2CmdFuncDestroyShader(WebGL2DeviceManager.instance, this._gpuShader);
                  this._gpuShader = null;
                }
              };

              _createClass(WebGL2Shader, [{
                key: "gpuShader",
                get: function get() {
                  if (this._gpuShader.glProgram === null) {
                    WebGL2CmdFuncCreateShader(WebGL2DeviceManager.instance, this._gpuShader);
                  }

                  return this._gpuShader;
                }
              }]);

              return WebGL2Shader;
            }(Shader);

            var WebGL2StateCache = function () {
              function WebGL2StateCache() {
                this.glArrayBuffer = null;
                this.glElementArrayBuffer = null;
                this.glUniformBuffer = null;
                this.glBindUBOs = [];
                this.glBindUBOOffsets = [];
                this.glVAO = null;
                this.texUnit = 0;
                this.glTexUnits = [];
                this.glSamplerUnits = [];
                this.glRenderbuffer = null;
                this.glFramebuffer = null;
                this.glReadFramebuffer = null;
                this.viewport = new Viewport();
                this.scissorRect = new Rect(0, 0, 0, 0);
                this.rs = new RasterizerState();
                this.dss = new DepthStencilState();
                this.bs = new BlendState$1();
                this.glProgram = null;
                this.glEnabledAttribLocs = [];
                this.glCurrentAttribLocs = [];
                this.texUnitCacheMap = {};
              }

              var _proto = WebGL2StateCache.prototype;

              _proto.initialize = function initialize(texUnit, bufferBindings, vertexAttributes) {
                for (var i = 0; i < texUnit; ++i) {
                  this.glTexUnits.push({
                    glTexture: null
                  });
                }

                this.glSamplerUnits.length = texUnit;
                this.glSamplerUnits.fill(null);
                this.glBindUBOs.length = bufferBindings;
                this.glBindUBOs.fill(null);
                this.glBindUBOOffsets.length = bufferBindings;
                this.glBindUBOOffsets.fill(0);
                this.glEnabledAttribLocs.length = vertexAttributes;
                this.glEnabledAttribLocs.fill(false);
                this.glCurrentAttribLocs.length = vertexAttributes;
                this.glCurrentAttribLocs.fill(false);
              };

              return WebGL2StateCache;
            }();

            var WebGL2Texture = function (_Texture) {
              _inheritsLoose(WebGL2Texture, _Texture);

              function WebGL2Texture() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Texture.call.apply(_Texture, [this].concat(args)) || this;
                _this._gpuTexture = null;
                _this._gpuTextureView = null;
                return _this;
              }

              var _proto = WebGL2Texture.prototype;

              _proto.initialize = function initialize(info, isSwapchainTexture) {
                var texInfo = info;
                var viewInfo = info;

                if ('texture' in info) {
                  texInfo = viewInfo.texture.info;
                  this._isTextureView = true;
                }

                this._info.copy(texInfo);

                this._isPowerOf2 = IsPowerOf2(this._info.width) && IsPowerOf2(this._info.height);
                this._size = FormatSurfaceSize(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount;

                if (!this._isTextureView) {
                  this._gpuTexture = {
                    type: texInfo.type,
                    format: texInfo.format,
                    usage: texInfo.usage,
                    width: texInfo.width,
                    height: texInfo.height,
                    depth: texInfo.depth,
                    size: this._size,
                    arrayLayer: texInfo.layerCount,
                    mipLevel: texInfo.levelCount,
                    samples: texInfo.samples,
                    flags: texInfo.flags,
                    isPowerOf2: this._isPowerOf2,
                    glTarget: 0,
                    glInternalFmt: 0,
                    glFormat: 0,
                    glType: 0,
                    glUsage: 0,
                    glTexture: null,
                    glRenderbuffer: null,
                    glWrapS: 0,
                    glWrapT: 0,
                    glMinFilter: 0,
                    glMagFilter: 0,
                    isSwapchainTexture: isSwapchainTexture || false
                  };

                  if (!this._gpuTexture.isSwapchainTexture && this._gpuTexture) {
                    WebGL2CmdFuncCreateTexture(WebGL2DeviceManager.instance, this._gpuTexture);
                    WebGL2DeviceManager.instance.memoryStatus.textureSize += this._size;
                  }

                  this._viewInfo.texture = this;
                  this._viewInfo.type = info.type;
                  this._viewInfo.format = info.format;
                  this._viewInfo.baseLevel = 0;
                  this._viewInfo.levelCount = info.levelCount;
                  this._viewInfo.baseLayer = 0;
                  this._viewInfo.layerCount = info.layerCount;
                  this._gpuTextureView = {
                    gpuTexture: this._gpuTexture,
                    type: this._viewInfo.type,
                    format: this._viewInfo.format,
                    baseLevel: this._viewInfo.baseLevel,
                    levelCount: this._viewInfo.levelCount
                  };
                } else {
                  var _this$_gpuTexture;

                  this._viewInfo.copy(viewInfo);

                  this._gpuTexture = viewInfo.texture._gpuTexture;

                  if (((_this$_gpuTexture = this._gpuTexture) === null || _this$_gpuTexture === void 0 ? void 0 : _this$_gpuTexture.format) !== texInfo.format) {
                    console.log('GPU memory alias is not supported');
                    return;
                  }

                  this._gpuTextureView = {
                    gpuTexture: this._gpuTexture,
                    type: viewInfo.type,
                    format: viewInfo.format,
                    baseLevel: viewInfo.baseLevel,
                    levelCount: viewInfo.levelCount
                  };
                }
              };

              _proto.destroy = function destroy() {
                if (!this._isTextureView && this._gpuTexture) {
                  WebGL2CmdFuncDestroyTexture(WebGL2DeviceManager.instance, this._gpuTexture);
                  WebGL2DeviceManager.instance.memoryStatus.textureSize -= this._size;
                  this._gpuTexture = null;
                }
              };

              _proto.getGLTextureHandle = function getGLTextureHandle() {
                var gpuTexture = this._gpuTexture;

                if (!gpuTexture) {
                  return 0;
                }

                if (gpuTexture.glTexture) {
                  return gpuTexture.glTexture;
                } else if (gpuTexture.glRenderbuffer) {
                  return gpuTexture.glRenderbuffer;
                }

                return 0;
              };

              _proto.resize = function resize(width, height) {
                if (this._info.width === width && this._info.height === height) {
                  return;
                }

                if (this._info.levelCount === WebGL2Texture.getLevelCount(this._info.width, this._info.height)) {
                  this._info.levelCount = WebGL2Texture.getLevelCount(width, height);
                } else if (this._info.levelCount > 1) {
                  this._info.levelCount = Math.min(this._info.levelCount, WebGL2Texture.getLevelCount(width, height));
                }

                var oldSize = this._size;
                this._info.width = width;
                this._info.height = height;
                this._size = FormatSurfaceSize(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount;

                if (!this._isTextureView && this._gpuTexture) {
                  this._gpuTexture.width = width;
                  this._gpuTexture.height = height;
                  this._gpuTexture.size = this._size;

                  if (!this._gpuTexture.isSwapchainTexture) {
                    WebGL2CmdFuncResizeTexture(WebGL2DeviceManager.instance, this._gpuTexture);
                    WebGL2DeviceManager.instance.memoryStatus.textureSize -= oldSize;
                    WebGL2DeviceManager.instance.memoryStatus.textureSize += this._size;
                  }
                }
              };

              _proto.initAsSwapchainTexture = function initAsSwapchainTexture(info) {
                var texInfo = new TextureInfo();
                texInfo.format = info.format;
                texInfo.usage = FormatInfos[info.format].hasDepth ? TextureUsageBit.DEPTH_STENCIL_ATTACHMENT : TextureUsageBit.COLOR_ATTACHMENT;
                texInfo.width = info.width;
                texInfo.height = info.height;
                this.initialize(texInfo, true);
              };

              _createClass(WebGL2Texture, [{
                key: "gpuTexture",
                get: function get() {
                  return this._gpuTexture;
                }
              }, {
                key: "gpuTextureView",
                get: function get() {
                  return this._gpuTextureView;
                }
              }]);

              return WebGL2Texture;
            }(Texture);

            var eventWebGLContextLost$1 = 'webglcontextlost';

            function initStates$1(gl) {
              gl.activeTexture(gl.TEXTURE0);
              gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
              gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
              gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.enable(gl.SCISSOR_TEST);
              gl.enable(gl.CULL_FACE);
              gl.cullFace(gl.BACK);
              gl.frontFace(gl.CCW);
              gl.polygonOffset(0.0, 0.0);
              gl.enable(gl.DEPTH_TEST);
              gl.depthMask(true);
              gl.depthFunc(gl.LESS);
              gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 0xffff);
              gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
              gl.stencilMaskSeparate(gl.FRONT, 0xffff);
              gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 0xffff);
              gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
              gl.stencilMaskSeparate(gl.BACK, 0xffff);
              gl.disable(gl.STENCIL_TEST);
              gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
              gl.disable(gl.BLEND);
              gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
              gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
              gl.colorMask(true, true, true, true);
              gl.blendColor(0.0, 0.0, 0.0, 0.0);
            }

            function getExtension$1(gl, ext) {
              var prefixes = ['', 'WEBKIT_', 'MOZ_'];

              for (var i = 0; i < prefixes.length; ++i) {
                var _ext = gl.getExtension(prefixes[i] + ext);

                if (_ext) {
                  return _ext;
                }
              }

              return null;
            }

            function getExtensions$1(gl) {
              var res = {
                EXT_texture_filter_anisotropic: getExtension$1(gl, 'EXT_texture_filter_anisotropic'),
                EXT_color_buffer_half_float: getExtension$1(gl, 'EXT_color_buffer_half_float'),
                EXT_color_buffer_float: getExtension$1(gl, 'EXT_color_buffer_float'),
                WEBGL_compressed_texture_etc1: getExtension$1(gl, 'WEBGL_compressed_texture_etc1'),
                WEBGL_compressed_texture_etc: getExtension$1(gl, 'WEBGL_compressed_texture_etc'),
                WEBGL_compressed_texture_pvrtc: getExtension$1(gl, 'WEBGL_compressed_texture_pvrtc'),
                WEBGL_compressed_texture_astc: getExtension$1(gl, 'WEBGL_compressed_texture_astc'),
                WEBGL_compressed_texture_s3tc: getExtension$1(gl, 'WEBGL_compressed_texture_s3tc'),
                WEBGL_compressed_texture_s3tc_srgb: getExtension$1(gl, 'WEBGL_compressed_texture_s3tc_srgb'),
                WEBGL_debug_shaders: getExtension$1(gl, 'WEBGL_debug_shaders'),
                WEBGL_lose_context: getExtension$1(gl, 'WEBGL_lose_context'),
                WEBGL_debug_renderer_info: getExtension$1(gl, 'WEBGL_debug_renderer_info'),
                OES_texture_half_float_linear: getExtension$1(gl, 'OES_texture_half_float_linear'),
                OES_texture_float_linear: getExtension$1(gl, 'OES_texture_float_linear'),
                WEBGL_multi_draw: null,
                useVAO: true
              };
              {
                if (systemInfo.os !== OS.ANDROID && systemInfo.os !== OS.IOS) {
                  res.WEBGL_multi_draw = getExtension$1(gl, 'WEBGL_multi_draw');
                }
              }
              return res;
            }
            function getContext$1(canvas) {
              var context = null;

              try {
                var _globalThis$__globalX;

                if ((_globalThis$__globalX = globalThis.__globalXR) !== null && _globalThis$__globalX !== void 0 && _globalThis$__globalX.webxrCompatible) {
                  var glAttribs = {
                    alpha: macro.ENABLE_TRANSPARENT_CANVAS,
                    antialias: EDITOR || macro.ENABLE_WEBGL_ANTIALIAS,
                    depth: true,
                    stencil: true,
                    premultipliedAlpha: false,
                    preserveDrawingBuffer: false,
                    powerPreference: 'default',
                    failIfMajorPerformanceCaveat: false,
                    xrCompatible: true
                  };
                  context = canvas.getContext('webgl2', glAttribs);
                  return context;
                }

                var webGLCtxAttribs = {
                  alpha: macro.ENABLE_TRANSPARENT_CANVAS,
                  antialias: EDITOR || macro.ENABLE_WEBGL_ANTIALIAS,
                  depth: true,
                  stencil: true,
                  premultipliedAlpha: false,
                  preserveDrawingBuffer: false,
                  powerPreference: 'default',
                  failIfMajorPerformanceCaveat: false
                };
                context = canvas.getContext('webgl2', webGLCtxAttribs);
              } catch (err) {
                return null;
              }

              return context;
            }
            var WebGL2Swapchain = function (_Swapchain) {
              _inheritsLoose(WebGL2Swapchain, _Swapchain);

              function WebGL2Swapchain() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Swapchain.call.apply(_Swapchain, [this].concat(args)) || this;
                _this.stateCache = new WebGL2StateCache();
                _this.nullTex2D = null;
                _this.nullTexCube = null;
                _this._canvas = null;
                _this._webGL2ContextLostHandler = null;
                _this._extensions = null;
                _this._blitManager = null;
                return _this;
              }

              var _proto = WebGL2Swapchain.prototype;

              _proto.initialize = function initialize(info) {
                this._canvas = info.windowHandle;
                this._webGL2ContextLostHandler = this._onWebGLContextLost.bind(this);

                this._canvas.addEventListener(eventWebGLContextLost$1, this._onWebGLContextLost);

                var gl = WebGL2DeviceManager.instance.gl;
                this.stateCache.initialize(WebGL2DeviceManager.instance.capabilities.maxTextureUnits, WebGL2DeviceManager.instance.capabilities.maxUniformBufferBindings, WebGL2DeviceManager.instance.capabilities.maxVertexAttributes);
                this._extensions = getExtensions$1(gl);
                initStates$1(gl);
                var colorFmt = Format.RGBA8;
                var depthStencilFmt = Format.DEPTH_STENCIL;
                var depthBits = gl.getParameter(gl.DEPTH_BITS);
                var stencilBits = gl.getParameter(gl.STENCIL_BITS);
                if (depthBits && stencilBits) depthStencilFmt = Format.DEPTH_STENCIL;else if (depthBits) depthStencilFmt = Format.DEPTH;
                this._colorTexture = new WebGL2Texture();

                this._colorTexture.initAsSwapchainTexture({
                  swapchain: this,
                  format: colorFmt,
                  width: info.width,
                  height: info.height
                });

                this._depthStencilTexture = new WebGL2Texture();

                this._depthStencilTexture.initAsSwapchainTexture({
                  swapchain: this,
                  format: depthStencilFmt,
                  width: info.width,
                  height: info.height
                });

                this.nullTex2D = WebGL2DeviceManager.instance.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.NONE));
                this.nullTexCube = WebGL2DeviceManager.instance.createTexture(new TextureInfo(TextureType.CUBE, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.NONE, 6));
                var nullTexRegion = new BufferTextureCopy();
                nullTexRegion.texExtent.width = 2;
                nullTexRegion.texExtent.height = 2;
                var nullTexBuff = new Uint8Array(this.nullTex2D.size);
                nullTexBuff.fill(0);
                WebGL2DeviceManager.instance.copyBuffersToTexture([nullTexBuff], this.nullTex2D, [nullTexRegion]);
                nullTexRegion.texSubres.layerCount = 6;
                WebGL2DeviceManager.instance.copyBuffersToTexture([nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff], this.nullTexCube, [nullTexRegion]);
                this._blitManager = new IWebGL2BlitManager();
              };

              _proto.destroy = function destroy() {
                if (this._canvas && this._webGL2ContextLostHandler) {
                  this._canvas.removeEventListener(eventWebGLContextLost$1, this._webGL2ContextLostHandler);

                  this._webGL2ContextLostHandler = null;
                }

                if (this.nullTex2D) {
                  this.nullTex2D.destroy();
                  this.nullTex2D = null;
                }

                if (this.nullTexCube) {
                  this.nullTexCube.destroy();
                  this.nullTexCube = null;
                }

                if (this._blitManager) {
                  this._blitManager.destroy();

                  this._blitManager = null;
                }

                this._extensions = null;
                this._canvas = null;
              };

              _proto.resize = function resize(width, height, surfaceTransform) {
                if (this._colorTexture.width !== width || this._colorTexture.height !== height) {
                  debug("Resizing swapchain: " + width + "x" + height);
                  this._canvas.width = width;
                  this._canvas.height = height;

                  this._colorTexture.resize(width, height);

                  this._depthStencilTexture.resize(width, height);
                }
              };

              _proto._onWebGLContextLost = function _onWebGLContextLost(event) {
                warnID(11000);
                warn(event);
              };

              _createClass(WebGL2Swapchain, [{
                key: "extensions",
                get: function get() {
                  return this._extensions;
                }
              }, {
                key: "blitManager",
                get: function get() {
                  return this._blitManager;
                }
              }]);

              return WebGL2Swapchain;
            }(Swapchain);

            var WebGL2Device = exports('WebGL2Device', function (_Device) {
              _inheritsLoose(WebGL2Device, _Device);

              function WebGL2Device() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Device.call.apply(_Device, [this].concat(args)) || this;
                _this._swapchain = null;
                _this._context = null;
                _this._bindingMappings = null;
                _this._textureExclusive = new Array(Format.COUNT);
                return _this;
              }

              var _proto = WebGL2Device.prototype;

              _proto.initialize = function initialize(info) {
                WebGL2DeviceManager.setInstance(this);
                this._gfxAPI = API.WEBGL2;
                var mapping = this._bindingMappingInfo = info.bindingMappingInfo;
                var blockOffsets = [];
                var samplerTextureOffsets = [];
                var firstSet = mapping.setIndices[0];
                blockOffsets[firstSet] = 0;
                samplerTextureOffsets[firstSet] = 0;

                for (var i = 1; i < mapping.setIndices.length; ++i) {
                  var curSet = mapping.setIndices[i];
                  var prevSet = mapping.setIndices[i - 1];
                  blockOffsets[curSet] = mapping.maxBlockCounts[prevSet] + blockOffsets[prevSet];
                  samplerTextureOffsets[curSet] = mapping.maxSamplerTextureCounts[prevSet] + samplerTextureOffsets[prevSet];
                }

                for (var _i = 0; _i < mapping.setIndices.length; ++_i) {
                  var _curSet = mapping.setIndices[_i];
                  samplerTextureOffsets[_curSet] -= mapping.maxBlockCounts[_curSet];
                }

                this._bindingMappings = {
                  blockOffsets: blockOffsets,
                  samplerTextureOffsets: samplerTextureOffsets,
                  flexibleSet: mapping.setIndices[mapping.setIndices.length - 1]
                };
                var gl = this._context = getContext$1(Device.canvas);

                if (!gl) {
                  console.error('This device does not support WebGL.');
                  return false;
                }

                this._queue = this.createQueue(new QueueInfo(QueueType.GRAPHICS));
                this._cmdBuff = this.createCommandBuffer(new CommandBufferInfo(this._queue));
                this._caps.maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
                this._caps.maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);

                if (systemInfo.os === OS.IOS) {
                  var maxVertexUniformVectors = this._caps.maxVertexUniformVectors;

                  if (sys.browserType === BrowserType.WECHAT) {
                    this._caps.maxVertexUniformVectors = maxVertexUniformVectors < 256 ? maxVertexUniformVectors : 256;
                  } else if (sys.browserType === BrowserType.SAFARI) {
                    this._caps.maxVertexUniformVectors = maxVertexUniformVectors < 512 ? maxVertexUniformVectors : 512;
                  }
                }

                this._caps.maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
                this._caps.maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
                this._caps.maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
                this._caps.maxUniformBufferBindings = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
                this._caps.maxUniformBlockSize = gl.getParameter(gl.MAX_UNIFORM_BLOCK_SIZE);
                this._caps.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                this._caps.maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                this._caps.maxArrayTextureLayers = gl.getParameter(gl.MAX_ARRAY_TEXTURE_LAYERS);
                this._caps.max3DTextureSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
                this._caps.uboOffsetAlignment = gl.getParameter(gl.UNIFORM_BUFFER_OFFSET_ALIGNMENT);
                var extensions = gl.getSupportedExtensions();
                var extStr = '';

                if (extensions) {
                  for (var _iterator = _createForOfIteratorHelperLoose(extensions), _step; !(_step = _iterator()).done;) {
                    var ext = _step.value;
                    extStr += ext + " ";
                  }
                }

                var exts = getExtensions$1(gl);

                if (exts.WEBGL_debug_renderer_info) {
                  this._renderer = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL);
                  this._vendor = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL);
                } else {
                  this._renderer = gl.getParameter(gl.RENDERER);
                  this._vendor = gl.getParameter(gl.VENDOR);
                }

                var version = gl.getParameter(gl.VERSION);

                this._features.fill(false);

                this.initFormatFeatures(exts);
                this._features[Feature.ELEMENT_INDEX_UINT] = true;
                this._features[Feature.INSTANCED_ARRAYS] = true;
                this._features[Feature.MULTIPLE_RENDER_TARGETS] = true;
                this._features[Feature.BLEND_MINMAX] = true;
                var compressedFormat = '';

                if (this.getFormatFeatures(Format.ETC_RGB8)) {
                  compressedFormat += 'etc1 ';
                }

                if (this.getFormatFeatures(Format.ETC2_RGB8)) {
                  compressedFormat += 'etc2 ';
                }

                if (this.getFormatFeatures(Format.BC1)) {
                  compressedFormat += 'dxt ';
                }

                if (this.getFormatFeatures(Format.PVRTC_RGB2)) {
                  compressedFormat += 'pvrtc ';
                }

                if (this.getFormatFeatures(Format.ASTC_RGBA_4X4)) {
                  compressedFormat += 'astc ';
                }

                debug('WebGL2 device initialized.');
                debug("RENDERER: " + this._renderer);
                debug("VENDOR: " + this._vendor);
                debug("VERSION: " + version);
                debug("COMPRESSED_FORMAT: " + compressedFormat);
                debug("EXTENSIONS: " + extStr);
                return true;
              };

              _proto.destroy = function destroy() {
                if (this._queue) {
                  this._queue.destroy();

                  this._queue = null;
                }

                if (this._cmdBuff) {
                  this._cmdBuff.destroy();

                  this._cmdBuff = null;
                }

                var it = this._samplers.values();

                var res = it.next();

                while (!res.done) {
                  res.value.destroy();
                  res = it.next();
                }

                this._swapchain = null;
              };

              _proto.flushCommands = function flushCommands(cmdBuffs) {};

              _proto.acquire = function acquire(swapchains) {};

              _proto.present = function present() {
                var queue = this._queue;
                this._numDrawCalls = queue.numDrawCalls;
                this._numInstances = queue.numInstances;
                this._numTris = queue.numTris;
                queue.clear();
              };

              _proto.initFormatFeatures = function initFormatFeatures(exts) {
                this._formatFeatures.fill(FormatFeatureBit.NONE);

                this._textureExclusive.fill(true);

                var tempFeature = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.LINEAR_FILTER | FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.R8] = tempFeature;
                this._formatFeatures[Format.RG8] = tempFeature;
                this._formatFeatures[Format.RGB8] = tempFeature;
                this._formatFeatures[Format.RGBA8] = tempFeature;
                tempFeature = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.LINEAR_FILTER;
                this._formatFeatures[Format.R8SN] = tempFeature;
                this._formatFeatures[Format.RG8SN] = tempFeature;
                this._formatFeatures[Format.RGB8SN] = tempFeature;
                this._formatFeatures[Format.RGBA8SN] = tempFeature;
                this._formatFeatures[Format.R5G6B5] = tempFeature;
                this._formatFeatures[Format.RGBA4] = tempFeature;
                this._formatFeatures[Format.RGB5A1] = tempFeature;
                this._formatFeatures[Format.RGB10A2] = tempFeature;
                this._formatFeatures[Format.SRGB8] = tempFeature;
                this._formatFeatures[Format.SRGB8_A8] = tempFeature;
                this._formatFeatures[Format.R11G11B10F] = tempFeature;
                this._formatFeatures[Format.RGB9E5] = tempFeature;
                this._formatFeatures[Format.DEPTH] = tempFeature;
                this._formatFeatures[Format.DEPTH_STENCIL] = tempFeature;
                this._formatFeatures[Format.RGB10A2UI] = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;
                tempFeature = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.R16F] = tempFeature;
                this._formatFeatures[Format.RG16F] = tempFeature;
                this._formatFeatures[Format.RGB16F] = tempFeature;
                this._formatFeatures[Format.RGBA16F] = tempFeature;
                tempFeature = FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.R32F] = tempFeature;
                this._formatFeatures[Format.RG32F] = tempFeature;
                this._formatFeatures[Format.RGB32F] = tempFeature;
                this._formatFeatures[Format.RGBA32F] = tempFeature;
                this._formatFeatures[Format.RGB10A2UI] = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;
                tempFeature = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER | FormatFeatureBit.VERTEX_ATTRIBUTE;
                this._formatFeatures[Format.R8I] = tempFeature;
                this._formatFeatures[Format.R8UI] = tempFeature;
                this._formatFeatures[Format.R16I] = tempFeature;
                this._formatFeatures[Format.R16UI] = tempFeature;
                this._formatFeatures[Format.R32I] = tempFeature;
                this._formatFeatures[Format.R32UI] = tempFeature;
                this._formatFeatures[Format.RG8I] = tempFeature;
                this._formatFeatures[Format.RG8UI] = tempFeature;
                this._formatFeatures[Format.RG16I] = tempFeature;
                this._formatFeatures[Format.RG16UI] = tempFeature;
                this._formatFeatures[Format.RG32I] = tempFeature;
                this._formatFeatures[Format.RG32UI] = tempFeature;
                this._formatFeatures[Format.RGB8I] = tempFeature;
                this._formatFeatures[Format.RGB8UI] = tempFeature;
                this._formatFeatures[Format.RGB16I] = tempFeature;
                this._formatFeatures[Format.RGB16UI] = tempFeature;
                this._formatFeatures[Format.RGB32I] = tempFeature;
                this._formatFeatures[Format.RGB32UI] = tempFeature;
                this._formatFeatures[Format.RGBA8I] = tempFeature;
                this._formatFeatures[Format.RGBA8UI] = tempFeature;
                this._formatFeatures[Format.RGBA16I] = tempFeature;
                this._formatFeatures[Format.RGBA16UI] = tempFeature;
                this._formatFeatures[Format.RGBA32I] = tempFeature;
                this._formatFeatures[Format.RGBA32UI] = tempFeature;
                this._textureExclusive[Format.R8] = false;
                this._textureExclusive[Format.RG8] = false;
                this._textureExclusive[Format.RGB8] = false;
                this._textureExclusive[Format.R5G6B5] = false;
                this._textureExclusive[Format.RGBA4] = false;
                this._textureExclusive[Format.RGB5A1] = false;
                this._textureExclusive[Format.RGBA8] = false;
                this._textureExclusive[Format.RGB10A2] = false;
                this._textureExclusive[Format.RGB10A2UI] = false;
                this._textureExclusive[Format.SRGB8_A8] = false;
                this._textureExclusive[Format.R8I] = false;
                this._textureExclusive[Format.R8UI] = false;
                this._textureExclusive[Format.R16I] = false;
                this._textureExclusive[Format.R16UI] = false;
                this._textureExclusive[Format.R32I] = false;
                this._textureExclusive[Format.R32UI] = false;
                this._textureExclusive[Format.RG8I] = false;
                this._textureExclusive[Format.RG8UI] = false;
                this._textureExclusive[Format.RG16I] = false;
                this._textureExclusive[Format.RG16UI] = false;
                this._textureExclusive[Format.RG32I] = false;
                this._textureExclusive[Format.RG32UI] = false;
                this._textureExclusive[Format.RGBA8I] = false;
                this._textureExclusive[Format.RGBA8UI] = false;
                this._textureExclusive[Format.RGBA16I] = false;
                this._textureExclusive[Format.RGBA16UI] = false;
                this._textureExclusive[Format.RGBA32I] = false;
                this._textureExclusive[Format.RGBA32UI] = false;
                this._textureExclusive[Format.DEPTH] = false;
                this._textureExclusive[Format.DEPTH_STENCIL] = false;

                if (exts.EXT_color_buffer_float) {
                  this._formatFeatures[Format.R32F] |= FormatFeatureBit.RENDER_TARGET;
                  this._formatFeatures[Format.RG32F] |= FormatFeatureBit.RENDER_TARGET;
                  this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.RENDER_TARGET;
                  this._textureExclusive[Format.R32F] = false;
                  this._textureExclusive[Format.RG32F] = false;
                  this._textureExclusive[Format.RGBA32F] = false;
                }

                if (exts.EXT_color_buffer_half_float) {
                  this._textureExclusive[Format.R16F] = false;
                  this._textureExclusive[Format.RG16F] = false;
                  this._textureExclusive[Format.RGBA16F] = false;
                }

                if (exts.OES_texture_float_linear) {
                  this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.LINEAR_FILTER;
                  this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.LINEAR_FILTER;
                  this._formatFeatures[Format.R32F] |= FormatFeatureBit.LINEAR_FILTER;
                  this._formatFeatures[Format.RG32F] |= FormatFeatureBit.LINEAR_FILTER;
                }

                if (exts.OES_texture_half_float_linear) {
                  this._formatFeatures[Format.RGB16F] |= FormatFeatureBit.LINEAR_FILTER;
                  this._formatFeatures[Format.RGBA16F] |= FormatFeatureBit.LINEAR_FILTER;
                  this._formatFeatures[Format.R16F] |= FormatFeatureBit.LINEAR_FILTER;
                  this._formatFeatures[Format.RG16F] |= FormatFeatureBit.LINEAR_FILTER;
                }

                var compressedFeature = FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;

                if (exts.WEBGL_compressed_texture_etc1) {
                  this._formatFeatures[Format.ETC_RGB8] = compressedFeature;
                }

                if (exts.WEBGL_compressed_texture_etc) {
                  this._formatFeatures[Format.ETC2_RGB8] = compressedFeature;
                  this._formatFeatures[Format.ETC2_RGBA8] = compressedFeature;
                  this._formatFeatures[Format.ETC2_SRGB8] = compressedFeature;
                  this._formatFeatures[Format.ETC2_SRGB8_A8] = compressedFeature;
                  this._formatFeatures[Format.ETC2_RGB8_A1] = compressedFeature;
                  this._formatFeatures[Format.ETC2_SRGB8_A1] = compressedFeature;
                }

                if (exts.WEBGL_compressed_texture_s3tc) {
                  this._formatFeatures[Format.BC1] = compressedFeature;
                  this._formatFeatures[Format.BC1_ALPHA] = compressedFeature;
                  this._formatFeatures[Format.BC1_SRGB] = compressedFeature;
                  this._formatFeatures[Format.BC1_SRGB_ALPHA] = compressedFeature;
                  this._formatFeatures[Format.BC2] = compressedFeature;
                  this._formatFeatures[Format.BC2_SRGB] = compressedFeature;
                  this._formatFeatures[Format.BC3] = compressedFeature;
                  this._formatFeatures[Format.BC3_SRGB] = compressedFeature;
                }

                if (exts.WEBGL_compressed_texture_pvrtc) {
                  this._formatFeatures[Format.PVRTC_RGB2] = compressedFeature;
                  this._formatFeatures[Format.PVRTC_RGBA2] = compressedFeature;
                  this._formatFeatures[Format.PVRTC_RGB4] = compressedFeature;
                  this._formatFeatures[Format.PVRTC_RGBA4] = compressedFeature;
                }

                if (exts.WEBGL_compressed_texture_astc) {
                  this._formatFeatures[Format.ASTC_RGBA_4X4] = compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_5X4] = compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_5X5] = compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_6X5] = compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_6X6] = compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_8X5] = compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_8X6] = compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_8X8] = compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_10X5] = compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_10X6] = compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_10X8] = compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_10X10] = compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_12X10] = compressedFeature;
                  this._formatFeatures[Format.ASTC_RGBA_12X12] = compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_4X4] = compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_5X4] = compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_5X5] = compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_6X5] = compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_6X6] = compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_8X5] = compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_8X6] = compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_8X8] = compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_10X5] = compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_10X6] = compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_10X8] = compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_10X10] = compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_12X10] = compressedFeature;
                  this._formatFeatures[Format.ASTC_SRGBA_12X12] = compressedFeature;
                }
              };

              _proto.createCommandBuffer = function createCommandBuffer(info) {
                var Ctor = info.type === CommandBufferType.PRIMARY ? WebGL2PrimaryCommandBuffer : WebGL2CommandBuffer;
                var cmdBuff = new Ctor();
                cmdBuff.initialize(info);
                return cmdBuff;
              };

              _proto.createSwapchain = function createSwapchain(info) {
                var swapchain = new WebGL2Swapchain();
                this._swapchain = swapchain;
                swapchain.initialize(info);
                return swapchain;
              };

              _proto.createBuffer = function createBuffer(info) {
                var buffer = new WebGL2Buffer();
                buffer.initialize(info);
                return buffer;
              };

              _proto.createTexture = function createTexture(info) {
                var texture = new WebGL2Texture();
                texture.initialize(info);
                return texture;
              };

              _proto.createDescriptorSet = function createDescriptorSet(info) {
                var descriptorSet = new WebGL2DescriptorSet();
                descriptorSet.initialize(info);
                return descriptorSet;
              };

              _proto.createShader = function createShader(info) {
                var shader = new WebGL2Shader();
                shader.initialize(info);
                return shader;
              };

              _proto.createInputAssembler = function createInputAssembler(info) {
                var inputAssembler = new WebGL2InputAssembler();
                inputAssembler.initialize(info);
                return inputAssembler;
              };

              _proto.createRenderPass = function createRenderPass(info) {
                var renderPass = new WebGL2RenderPass();
                renderPass.initialize(info);
                return renderPass;
              };

              _proto.createFramebuffer = function createFramebuffer(info) {
                var framebuffer = new WebGL2Framebuffer();
                framebuffer.initialize(info);
                return framebuffer;
              };

              _proto.createDescriptorSetLayout = function createDescriptorSetLayout(info) {
                var descriptorSetLayout = new WebGL2DescriptorSetLayout();
                descriptorSetLayout.initialize(info);
                return descriptorSetLayout;
              };

              _proto.createPipelineLayout = function createPipelineLayout(info) {
                var pipelineLayout = new WebGL2PipelineLayout();
                pipelineLayout.initialize(info);
                return pipelineLayout;
              };

              _proto.createPipelineState = function createPipelineState(info) {
                var pipelineState = new WebGL2PipelineState();
                pipelineState.initialize(info);
                return pipelineState;
              };

              _proto.createQueue = function createQueue(info) {
                var queue = new WebGL2Queue();
                queue.initialize(info);
                return queue;
              };

              _proto.getSampler = function getSampler(info) {
                var hash = Sampler.computeHash(info);

                if (!this._samplers.has(hash)) {
                  this._samplers.set(hash, new WebGL2Sampler(info, hash));
                }

                return this._samplers.get(hash);
              };

              _proto.getSwapchains = function getSwapchains() {
                return [this._swapchain];
              };

              _proto.getGeneralBarrier = function getGeneralBarrier(info) {
                var hash = GeneralBarrier.computeHash(info);

                if (!this._generalBarrierss.has(hash)) {
                  this._generalBarrierss.set(hash, new GeneralBarrier(info, hash));
                }

                return this._generalBarrierss.get(hash);
              };

              _proto.getTextureBarrier = function getTextureBarrier(info) {
                var hash = TextureBarrier.computeHash(info);

                if (!this._textureBarriers.has(hash)) {
                  this._textureBarriers.set(hash, new TextureBarrier(info, hash));
                }

                return this._textureBarriers.get(hash);
              };

              _proto.getBufferBarrier = function getBufferBarrier(info) {
                var hash = BufferBarrier.computeHash(info);

                if (!this._bufferBarriers.has(hash)) {
                  this._bufferBarriers.set(hash, new BufferBarrier(info, hash));
                }

                return this._bufferBarriers.get(hash);
              };

              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                WebGL2CmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
              };

              _proto.copyTextureToBuffers = function copyTextureToBuffers(texture, buffers, regions) {
                WebGL2CmdFuncCopyTextureToBuffers(this, texture.gpuTexture, buffers, regions);
              };

              _proto.copyTexImagesToTexture = function copyTexImagesToTexture(texImages, texture, regions) {
                WebGL2CmdFuncCopyTexImagesToTexture(this, texImages, texture.gpuTexture, regions);
              };

              _createClass(WebGL2Device, [{
                key: "gl",
                get: function get() {
                  return this._context;
                }
              }, {
                key: "extensions",
                get: function get() {
                  return this._swapchain.extensions;
                }
              }, {
                key: "stateCache",
                get: function get() {
                  return this._swapchain.stateCache;
                }
              }, {
                key: "nullTex2D",
                get: function get() {
                  return this._swapchain.nullTex2D;
                }
              }, {
                key: "nullTexCube",
                get: function get() {
                  return this._swapchain.nullTexCube;
                }
              }, {
                key: "textureExclusive",
                get: function get() {
                  return this._textureExclusive;
                }
              }, {
                key: "bindingMappings",
                get: function get() {
                  return this._bindingMappings;
                }
              }, {
                key: "blitManager",
                get: function get() {
                  return this._swapchain.blitManager;
                }
              }]);

              return WebGL2Device;
            }(Device));

            legacyCC.WebGL2Device = WebGL2Device;

            var PlaceMethod = exports('PlaceMethod', Enum({
              UNIFORM: 0,
              ADAPTIVE: 1
            }));
            var AutoPlacement = exports('AutoPlacement', function () {
              function AutoPlacement() {}

              AutoPlacement.generate = function generate(info) {
                switch (info.method) {
                  case PlaceMethod.UNIFORM:
                    return this.doGenerateUniform(info);

                  case PlaceMethod.ADAPTIVE:
                    return this.doGenerateAdaptive(info);

                  default:
                    return [];
                }
              };

              AutoPlacement.doGenerateUniform = function doGenerateUniform(info) {
                if (info.nProbesX < 2 || info.nProbesY < 2 || info.nProbesZ < 2) {
                  return [];
                }

                var probes = [];
                var position = new Vec3(0.0, 0.0, 0.0);
                var gridSize = new Vec3((info.maxPos.x - info.minPos.x) / (info.nProbesX - 1), (info.maxPos.y - info.minPos.y) / (info.nProbesY - 1), (info.maxPos.z - info.minPos.z) / (info.nProbesZ - 1));

                for (var x = 0; x < info.nProbesX; x++) {
                  position.x = x * gridSize.x + info.minPos.x;

                  for (var y = 0; y < info.nProbesY; y++) {
                    position.y = y * gridSize.y + info.minPos.y;

                    for (var z = 0; z < info.nProbesZ; z++) {
                      position.z = z * gridSize.z + info.minPos.z;
                      probes.push(new Vec3(position));
                    }
                  }
                }

                return probes;
              };

              AutoPlacement.doGenerateAdaptive = function doGenerateAdaptive(info) {
                return this.doGenerateUniform(info);
              };

              return AutoPlacement;
            }());

            var _dec$1d, _class$1g, _class2$10, _initializer$Y, _initializer2$M, _initializer3$z, _class4$k, _initializer4$u, _initializer5$n, _initializer6$i, _initializer7$d, _class6$7, _initializer8$d, _initializer9$c, _initializer10$b, _initializer11$7, _initializer12$7, _initializer13$7, _initializer14$5, _initializer15$5, _dec2$Q, _class8$5, _class9$1, _initializer16$5, _initializer17$4, _dec3$x, _class11$3, _class12$2, _initializer18$3, _initializer19$3, _initializer20$2, _initializer21$1, _initializer22$1, _initializer23$1, _initializer24$1, _initializer25$1, _initializer26$1;
            var ccclass$m = ccclass$p,
                serializable$g = serializable$j;

            var _mat = new Mat3();

            var _n = new Vec3(0.0, 0.0, 0.0);

            var _a = new Vec3(0.0, 0.0, 0.0);

            var _ap = new Vec3(0.0, 0.0, 0.0);

            var _b = new Vec3(0.0, 0.0, 0.0);

            var _bp = new Vec3(0.0, 0.0, 0.0);

            var _p2 = new Vec3(0.0, 0.0, 0.0);

            var _cp = new Vec3(0.0, 0.0, 0.0);

            var Vertex = exports('Vertex', (_dec$1d = ccclass$m('cc.Vertex'), _dec$1d(_class$1g = (_class2$10 = function Vertex(pos) {
              this.position = _initializer$Y && _initializer$Y();
              this.normal = _initializer2$M && _initializer2$M();
              this.coefficients = _initializer3$z && _initializer3$z();
              this.position.set(pos);
            }, (_initializer$Y = applyDecoratedInitializer(_class2$10.prototype, "position", [serializable$g], function () {
              return new Vec3(0, 0, 0);
            }), _initializer2$M = applyDecoratedInitializer(_class2$10.prototype, "normal", [serializable$g], function () {
              return new Vec3(0, 0, 0);
            }), _initializer3$z = applyDecoratedInitializer(_class2$10.prototype, "coefficients", [serializable$g], function () {
              return [];
            })), _class2$10)) || _class$1g));
            var Edge = (_class4$k = function () {
              function Edge(tet, i, v0, v1) {
                this.tetrahedron = _initializer4$u && _initializer4$u();
                this.index = _initializer5$n && _initializer5$n();
                this.vertex0 = _initializer6$i && _initializer6$i();
                this.vertex1 = _initializer7$d && _initializer7$d();
                this.tetrahedron = tet;
                this.index = i;

                if (v0 < v1) {
                  this.vertex0 = v0;
                  this.vertex1 = v1;
                } else {
                  this.vertex0 = v1;
                  this.vertex1 = v0;
                }
              }

              var _proto = Edge.prototype;

              _proto.set = function set(tet, i, v0, v1) {
                this.tetrahedron = tet;
                this.index = i;

                if (v0 < v1) {
                  this.vertex0 = v0;
                  this.vertex1 = v1;
                } else {
                  this.vertex0 = v1;
                  this.vertex1 = v0;
                }
              };

              _proto.isSame = function isSame(other) {
                return this.vertex0 === other.vertex0 && this.vertex1 === other.vertex1;
              };

              return Edge;
            }(), (_initializer4$u = applyDecoratedInitializer(_class4$k.prototype, "tetrahedron", [serializable$g], function () {
              return -1;
            }), _initializer5$n = applyDecoratedInitializer(_class4$k.prototype, "index", [serializable$g], function () {
              return -1;
            }), _initializer6$i = applyDecoratedInitializer(_class4$k.prototype, "vertex0", [serializable$g], function () {
              return -1;
            }), _initializer7$d = applyDecoratedInitializer(_class4$k.prototype, "vertex1", [serializable$g], function () {
              return -1;
            })), _class4$k);
            var Triangle = (_class6$7 = function () {
              function Triangle(tet, i, v0, v1, v2, v3) {
                this.invalid = _initializer8$d && _initializer8$d();
                this.isOuterFace = _initializer9$c && _initializer9$c();
                this.tetrahedron = _initializer10$b && _initializer10$b();
                this.index = _initializer11$7 && _initializer11$7();
                this.vertex0 = _initializer12$7 && _initializer12$7();
                this.vertex1 = _initializer13$7 && _initializer13$7();
                this.vertex2 = _initializer14$5 && _initializer14$5();
                this.vertex3 = _initializer15$5 && _initializer15$5();
                this.tetrahedron = tet;
                this.index = i;
                this.vertex3 = v3;

                if (v0 < v1 && v0 < v2) {
                  this.vertex0 = v0;

                  if (v1 < v2) {
                    this.vertex1 = v1;
                    this.vertex2 = v2;
                  } else {
                    this.vertex1 = v2;
                    this.vertex2 = v1;
                  }
                } else if (v1 < v0 && v1 < v2) {
                  this.vertex0 = v1;

                  if (v0 < v2) {
                    this.vertex1 = v0;
                    this.vertex2 = v2;
                  } else {
                    this.vertex1 = v2;
                    this.vertex2 = v0;
                  }
                } else {
                  this.vertex0 = v2;

                  if (v0 < v1) {
                    this.vertex1 = v0;
                    this.vertex2 = v1;
                  } else {
                    this.vertex1 = v1;
                    this.vertex2 = v0;
                  }
                }
              }

              var _proto2 = Triangle.prototype;

              _proto2.set = function set(tet, i, v0, v1, v2, v3) {
                this.invalid = false;
                this.isOuterFace = true;
                this.tetrahedron = tet;
                this.index = i;
                this.vertex3 = v3;

                if (v0 < v1 && v0 < v2) {
                  this.vertex0 = v0;

                  if (v1 < v2) {
                    this.vertex1 = v1;
                    this.vertex2 = v2;
                  } else {
                    this.vertex1 = v2;
                    this.vertex2 = v1;
                  }
                } else if (v1 < v0 && v1 < v2) {
                  this.vertex0 = v1;

                  if (v0 < v2) {
                    this.vertex1 = v0;
                    this.vertex2 = v2;
                  } else {
                    this.vertex1 = v2;
                    this.vertex2 = v0;
                  }
                } else {
                  this.vertex0 = v2;

                  if (v0 < v1) {
                    this.vertex1 = v0;
                    this.vertex2 = v1;
                  } else {
                    this.vertex1 = v1;
                    this.vertex2 = v0;
                  }
                }
              };

              _proto2.isSame = function isSame(other) {
                return this.vertex0 === other.vertex0 && this.vertex1 === other.vertex1 && this.vertex2 === other.vertex2;
              };

              return Triangle;
            }(), (_initializer8$d = applyDecoratedInitializer(_class6$7.prototype, "invalid", [serializable$g], function () {
              return false;
            }), _initializer9$c = applyDecoratedInitializer(_class6$7.prototype, "isOuterFace", [serializable$g], function () {
              return true;
            }), _initializer10$b = applyDecoratedInitializer(_class6$7.prototype, "tetrahedron", [serializable$g], function () {
              return -1;
            }), _initializer11$7 = applyDecoratedInitializer(_class6$7.prototype, "index", [serializable$g], function () {
              return -1;
            }), _initializer12$7 = applyDecoratedInitializer(_class6$7.prototype, "vertex0", [serializable$g], function () {
              return -1;
            }), _initializer13$7 = applyDecoratedInitializer(_class6$7.prototype, "vertex1", [serializable$g], function () {
              return -1;
            }), _initializer14$5 = applyDecoratedInitializer(_class6$7.prototype, "vertex2", [serializable$g], function () {
              return -1;
            }), _initializer15$5 = applyDecoratedInitializer(_class6$7.prototype, "vertex3", [serializable$g], function () {
              return -1;
            })), _class6$7);
            var CircumSphere = exports('CircumSphere', (_dec2$Q = ccclass$m('cc.CircumSphere'), _dec2$Q(_class8$5 = (_class9$1 = function () {
              function CircumSphere() {
                this.center = _initializer16$5 && _initializer16$5();
                this.radiusSquared = _initializer17$4 && _initializer17$4();
              }

              var _proto3 = CircumSphere.prototype;

              _proto3.init = function init(p0, p1, p2, p3) {
                _mat.set(p1.x - p0.x, p1.y - p0.y, p1.z - p0.z, p2.x - p0.x, p2.y - p0.y, p2.z - p0.z, p3.x - p0.x, p3.y - p0.y, p3.z - p0.z);

                _mat.invert();

                _mat.transpose();

                _n.set(((p1.x + p0.x) * (p1.x - p0.x) + (p1.y + p0.y) * (p1.y - p0.y) + (p1.z + p0.z) * (p1.z - p0.z)) * 0.5, ((p2.x + p0.x) * (p2.x - p0.x) + (p2.y + p0.y) * (p2.y - p0.y) + (p2.z + p0.z) * (p2.z - p0.z)) * 0.5, ((p3.x + p0.x) * (p3.x - p0.x) + (p3.y + p0.y) * (p3.y - p0.y) + (p3.z + p0.z) * (p3.z - p0.z)) * 0.5);

                Vec3.transformMat3(this.center, _n, _mat);
                this.radiusSquared = Vec3.squaredDistance(p0, this.center);
              };

              return CircumSphere;
            }(), (_initializer16$5 = applyDecoratedInitializer(_class9$1.prototype, "center", [serializable$g], function () {
              return new Vec3(0, 0, 0);
            }), _initializer17$4 = applyDecoratedInitializer(_class9$1.prototype, "radiusSquared", [serializable$g], function () {
              return 0.0;
            })), _class9$1)) || _class8$5));
            var Tetrahedron = exports('Tetrahedron', (_dec3$x = ccclass$m('cc.Tetrahedron'), _dec3$x(_class11$3 = (_class12$2 = function () {
              function Tetrahedron(delaunay, v0, v1, v2, v3) {
                if (v3 === void 0) {
                  v3 = -1;
                }

                this.invalid = _initializer18$3 && _initializer18$3();
                this.vertex0 = _initializer19$3 && _initializer19$3();
                this.vertex1 = _initializer20$2 && _initializer20$2();
                this.vertex2 = _initializer21$1 && _initializer21$1();
                this.vertex3 = _initializer22$1 && _initializer22$1();
                this.neighbours = _initializer23$1 && _initializer23$1();
                this.matrix = _initializer24$1 && _initializer24$1();
                this.offset = _initializer25$1 && _initializer25$1();
                this.sphere = _initializer26$1 && _initializer26$1();
                this.vertex0 = v0;
                this.vertex1 = v1;
                this.vertex2 = v2;
                this.vertex3 = v3;

                if (v3 >= 0) {
                  var probes = delaunay._probes;
                  var p0 = probes[this.vertex0].position;
                  var p1 = probes[this.vertex1].position;
                  var p2 = probes[this.vertex2].position;
                  var p3 = probes[this.vertex3].position;
                  this.sphere.init(p0, p1, p2, p3);
                }
              }

              var _proto4 = Tetrahedron.prototype;

              _proto4.isInCircumSphere = function isInCircumSphere(point) {
                return Vec3.squaredDistance(point, this.sphere.center) < this.sphere.radiusSquared - EPSILON$2;
              };

              _proto4.contain = function contain(vertexIndex) {
                return this.vertex0 === vertexIndex || this.vertex1 === vertexIndex || this.vertex2 === vertexIndex || this.vertex3 === vertexIndex;
              };

              _proto4.isInnerTetrahedron = function isInnerTetrahedron() {
                return this.vertex3 >= 0;
              };

              _proto4.isOuterCell = function isOuterCell() {
                return this.vertex3 < 0;
              };

              return Tetrahedron;
            }(), (_initializer18$3 = applyDecoratedInitializer(_class12$2.prototype, "invalid", [serializable$g], function () {
              return false;
            }), _initializer19$3 = applyDecoratedInitializer(_class12$2.prototype, "vertex0", [serializable$g], function () {
              return -1;
            }), _initializer20$2 = applyDecoratedInitializer(_class12$2.prototype, "vertex1", [serializable$g], function () {
              return -1;
            }), _initializer21$1 = applyDecoratedInitializer(_class12$2.prototype, "vertex2", [serializable$g], function () {
              return -1;
            }), _initializer22$1 = applyDecoratedInitializer(_class12$2.prototype, "vertex3", [serializable$g], function () {
              return -1;
            }), _initializer23$1 = applyDecoratedInitializer(_class12$2.prototype, "neighbours", [serializable$g], function () {
              return [-1, -1, -1, -1];
            }), _initializer24$1 = applyDecoratedInitializer(_class12$2.prototype, "matrix", [serializable$g], function () {
              return new Mat3();
            }), _initializer25$1 = applyDecoratedInitializer(_class12$2.prototype, "offset", [serializable$g], function () {
              return new Vec3(0.0, 0.0, 0.0);
            }), _initializer26$1 = applyDecoratedInitializer(_class12$2.prototype, "sphere", [serializable$g], function () {
              return new CircumSphere();
            })), _class12$2)) || _class11$3));
            var Delaunay = exports('Delaunay', function () {
              function Delaunay(probes) {
                this._probes = [];
                this._tetrahedrons = [];
                this._triangles = [];
                this._edges = [];
                this._probes = probes;
              }

              var _proto5 = Delaunay.prototype;

              _proto5.build = function build() {
                this.reset();
                this.tetrahedralize();
                this.computeAdjacency();
                this.computeMatrices();
                return this._tetrahedrons;
              };

              _proto5.reset = function reset() {
                this._tetrahedrons.length = 0;
                this._triangles.length = 0;
                this._edges.length = 0;
              };

              _proto5.tetrahedralize = function tetrahedralize() {
                var probeCount = this._probes.length;
                var center = this.initTetrahedron();

                for (var i = 0; i < probeCount; i++) {
                  this.addProbe(i);
                }

                this._tetrahedrons = this._tetrahedrons.filter(function (tetrahedron) {
                  var vertexIndex = probeCount;
                  var isSuperTetrahedron = tetrahedron.contain(vertexIndex) || tetrahedron.contain(vertexIndex + 1) || tetrahedron.contain(vertexIndex + 2) || tetrahedron.contain(vertexIndex + 3);
                  return !isSuperTetrahedron;
                });
                this._probes.length = probeCount;
                this.reorder(center);
              };

              _proto5.initTetrahedron = function initTetrahedron() {
                var minPos = new Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                var maxPos = new Vec3(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);

                for (var i = 0; i < this._probes.length; i++) {
                  var position = this._probes[i].position;
                  minPos.x = Math.min(minPos.x, position.x);
                  maxPos.x = Math.max(maxPos.x, position.x);
                  minPos.y = Math.min(minPos.y, position.y);
                  maxPos.y = Math.max(maxPos.y, position.y);
                  minPos.z = Math.min(minPos.z, position.z);
                  maxPos.z = Math.max(maxPos.z, position.z);
                }

                var center = new Vec3(0.0, 0.0, 0.0);
                Vec3.add(center, minPos, maxPos);
                Vec3.multiplyScalar(center, center, 0.5);
                var extent = new Vec3(0.0, 0.0, 0.0);
                Vec3.subtract(extent, maxPos, minPos);
                var offset = Math.max(extent.x, extent.y, extent.z) * 10.0;
                var p0 = new Vec3(center.x, center.y + offset, center.z);
                var p1 = new Vec3(center.x - offset, center.y - offset, center.z - offset);
                var p2 = new Vec3(center.x - offset, center.y - offset, center.z + offset);
                var p3 = new Vec3(center.x + offset, center.y - offset, center.z);
                var index = this._probes.length;

                this._probes.push(new Vertex(p0));

                this._probes.push(new Vertex(p1));

                this._probes.push(new Vertex(p2));

                this._probes.push(new Vertex(p3));

                this._tetrahedrons.push(new Tetrahedron(this, index, index + 1, index + 2, index + 3));

                return center;
              };

              _proto5.addTriangle = function addTriangle(index, tet, i, v0, v1, v2, v3) {
                if (index < this._triangles.length) {
                  this._triangles[index].set(tet, i, v0, v1, v2, v3);
                } else {
                  this._triangles.push(new Triangle(tet, i, v0, v1, v2, v3));
                }
              };

              _proto5.addEdge = function addEdge(index, tet, i, v0, v1) {
                if (index < this._edges.length) {
                  this._edges[index].set(tet, i, v0, v1);
                } else {
                  this._edges.push(new Edge(tet, i, v0, v1));
                }
              };

              _proto5.addProbe = function addProbe(vertexIndex) {
                var probe = this._probes[vertexIndex];
                var position = probe.position;
                var triangleIndex = 0;

                for (var i = 0; i < this._tetrahedrons.length; i++) {
                  var tetrahedron = this._tetrahedrons[i];

                  if (tetrahedron.isInCircumSphere(position)) {
                    tetrahedron.invalid = true;
                    this.addTriangle(triangleIndex, i, 0, tetrahedron.vertex1, tetrahedron.vertex3, tetrahedron.vertex2, tetrahedron.vertex0);
                    this.addTriangle(triangleIndex + 1, i, 1, tetrahedron.vertex0, tetrahedron.vertex2, tetrahedron.vertex3, tetrahedron.vertex1);
                    this.addTriangle(triangleIndex + 2, i, 2, tetrahedron.vertex0, tetrahedron.vertex3, tetrahedron.vertex1, tetrahedron.vertex2);
                    this.addTriangle(triangleIndex + 3, i, 3, tetrahedron.vertex0, tetrahedron.vertex1, tetrahedron.vertex2, tetrahedron.vertex3);
                    triangleIndex += 4;
                  }
                }

                for (var _i = 0; _i < triangleIndex; _i++) {
                  if (this._triangles[_i].invalid) {
                    continue;
                  }

                  for (var k = _i + 1; k < triangleIndex; k++) {
                    if (this._triangles[_i].isSame(this._triangles[k])) {
                      this._triangles[_i].invalid = true;
                      this._triangles[k].invalid = true;
                      break;
                    }
                  }
                }

                this._tetrahedrons = this._tetrahedrons.filter(function (tetrahedron) {
                  return !tetrahedron.invalid;
                });

                for (var _i2 = 0; _i2 < triangleIndex; _i2++) {
                  var triangle = this._triangles[_i2];

                  if (!triangle.invalid) {
                    this._tetrahedrons.push(new Tetrahedron(this, triangle.vertex0, triangle.vertex1, triangle.vertex2, vertexIndex));
                  }
                }
              };

              _proto5.reorder = function reorder(center) {
                this._tetrahedrons.sort(function (a, b) {
                  return Vec3.squaredDistance(a.sphere.center, center) - Vec3.squaredDistance(b.sphere.center, center);
                });
              };

              _proto5.computeAdjacency = function computeAdjacency() {
                var normal = new Vec3(0.0, 0.0, 0.0);
                var edge1 = new Vec3(0.0, 0.0, 0.0);
                var edge2 = new Vec3(0.0, 0.0, 0.0);
                var edge3 = new Vec3(0.0, 0.0, 0.0);
                var tetrahedronCount = this._tetrahedrons.length;
                var triangleIndex = 0;

                for (var i = 0; i < this._tetrahedrons.length; i++) {
                  var tetrahedron = this._tetrahedrons[i];
                  this.addTriangle(triangleIndex, i, 0, tetrahedron.vertex1, tetrahedron.vertex3, tetrahedron.vertex2, tetrahedron.vertex0);
                  this.addTriangle(triangleIndex + 1, i, 1, tetrahedron.vertex0, tetrahedron.vertex2, tetrahedron.vertex3, tetrahedron.vertex1);
                  this.addTriangle(triangleIndex + 2, i, 2, tetrahedron.vertex0, tetrahedron.vertex3, tetrahedron.vertex1, tetrahedron.vertex2);
                  this.addTriangle(triangleIndex + 3, i, 3, tetrahedron.vertex0, tetrahedron.vertex1, tetrahedron.vertex2, tetrahedron.vertex3);
                  triangleIndex += 4;
                }

                for (var _i3 = 0; _i3 < triangleIndex; _i3++) {
                  if (!this._triangles[_i3].isOuterFace) {
                    continue;
                  }

                  for (var k = _i3 + 1; k < triangleIndex; k++) {
                    if (this._triangles[_i3].isSame(this._triangles[k])) {
                      this._tetrahedrons[this._triangles[_i3].tetrahedron].neighbours[this._triangles[_i3].index] = this._triangles[k].tetrahedron;
                      this._tetrahedrons[this._triangles[k].tetrahedron].neighbours[this._triangles[k].index] = this._triangles[_i3].tetrahedron;
                      this._triangles[_i3].isOuterFace = false;
                      this._triangles[k].isOuterFace = false;
                      break;
                    }
                  }

                  if (this._triangles[_i3].isOuterFace) {
                    var probe0 = this._probes[this._triangles[_i3].vertex0];
                    var probe1 = this._probes[this._triangles[_i3].vertex1];
                    var probe2 = this._probes[this._triangles[_i3].vertex2];
                    var probe3 = this._probes[this._triangles[_i3].vertex3];
                    Vec3.subtract(edge1, probe1.position, probe0.position);
                    Vec3.subtract(edge2, probe2.position, probe0.position);
                    Vec3.cross(normal, edge1, edge2);
                    Vec3.subtract(edge3, probe3.position, probe0.position);
                    var negative = Vec3.dot(normal, edge3);

                    if (negative > 0.0) {
                      Vec3.negate(normal, normal);
                    }

                    Vec3.add(probe0.normal, probe0.normal, normal);
                    Vec3.add(probe1.normal, probe1.normal, normal);
                    Vec3.add(probe2.normal, probe2.normal, normal);
                    var v0 = this._triangles[_i3].vertex0;
                    var v1 = negative > 0.0 ? this._triangles[_i3].vertex2 : this._triangles[_i3].vertex1;
                    var v2 = negative > 0.0 ? this._triangles[_i3].vertex1 : this._triangles[_i3].vertex2;

                    var _tetrahedron = new Tetrahedron(this, v0, v1, v2);

                    _tetrahedron.neighbours[3] = this._triangles[_i3].tetrahedron;
                    this._tetrahedrons[this._triangles[_i3].tetrahedron].neighbours[this._triangles[_i3].index] = this._tetrahedrons.length;

                    this._tetrahedrons.push(_tetrahedron);
                  }
                }

                var edgeIndex = 0;

                for (var _i4 = tetrahedronCount; _i4 < this._tetrahedrons.length; _i4++) {
                  var _tetrahedron2 = this._tetrahedrons[_i4];
                  this.addEdge(edgeIndex, _i4, 0, _tetrahedron2.vertex1, _tetrahedron2.vertex2);
                  this.addEdge(edgeIndex + 1, _i4, 1, _tetrahedron2.vertex2, _tetrahedron2.vertex0);
                  this.addEdge(edgeIndex + 2, _i4, 2, _tetrahedron2.vertex0, _tetrahedron2.vertex1);
                  edgeIndex += 3;
                }

                for (var _i5 = 0; _i5 < edgeIndex; _i5++) {
                  for (var _k = _i5 + 1; _k < edgeIndex; _k++) {
                    if (this._edges[_i5].isSame(this._edges[_k])) {
                      this._tetrahedrons[this._edges[_i5].tetrahedron].neighbours[this._edges[_i5].index] = this._edges[_k].tetrahedron;
                      this._tetrahedrons[this._edges[_k].tetrahedron].neighbours[this._edges[_k].index] = this._edges[_i5].tetrahedron;
                    }
                  }
                }

                for (var _i6 = 0; _i6 < this._probes.length; _i6++) {
                  this._probes[_i6].normal.normalize();
                }
              };

              _proto5.computeMatrices = function computeMatrices() {
                for (var i = 0; i < this._tetrahedrons.length; i++) {
                  var tetrahedron = this._tetrahedrons[i];

                  if (tetrahedron.vertex3 >= 0) {
                    this.computeTetrahedronMatrix(tetrahedron);
                  } else {
                    this.computeOuterCellMatrix(tetrahedron);
                  }
                }
              };

              _proto5.computeTetrahedronMatrix = function computeTetrahedronMatrix(tetrahedron) {
                var p0 = this._probes[tetrahedron.vertex0].position;
                var p1 = this._probes[tetrahedron.vertex1].position;
                var p2 = this._probes[tetrahedron.vertex2].position;
                var p3 = this._probes[tetrahedron.vertex3].position;
                tetrahedron.matrix.set(p0.x - p3.x, p1.x - p3.x, p2.x - p3.x, p0.y - p3.y, p1.y - p3.y, p2.y - p3.y, p0.z - p3.z, p1.z - p3.z, p2.z - p3.z);
                tetrahedron.matrix.invert();
                tetrahedron.matrix.transpose();
              };

              _proto5.computeOuterCellMatrix = function computeOuterCellMatrix(tetrahedron) {
                var v = [];
                var p = [];
                v[0] = this._probes[tetrahedron.vertex0].normal;
                v[1] = this._probes[tetrahedron.vertex1].normal;
                v[2] = this._probes[tetrahedron.vertex2].normal;
                p[0] = this._probes[tetrahedron.vertex0].position;
                p[1] = this._probes[tetrahedron.vertex1].position;
                p[2] = this._probes[tetrahedron.vertex2].position;
                Vec3.subtract(_a, p[0], p[2]);
                Vec3.subtract(_ap, v[0], v[2]);
                Vec3.subtract(_b, p[1], p[2]);
                Vec3.subtract(_bp, v[1], v[2]);

                _p2.set(p[2]);

                Vec3.negate(_cp, v[2]);
                var m = [];
                m[0] = _ap.y * _bp.z - _ap.z * _bp.y;
                m[3] = -_ap.x * _bp.z + _ap.z * _bp.x;
                m[6] = _ap.x * _bp.y - _ap.y * _bp.x;
                m[9] = _a.x * _bp.y * _cp.z - _a.y * _bp.x * _cp.z + _ap.x * _b.y * _cp.z - _ap.y * _b.x * _cp.z + _a.z * _bp.x * _cp.y - _a.z * _bp.y * _cp.x + _ap.z * _b.x * _cp.y - _ap.z * _b.y * _cp.x - _a.x * _bp.z * _cp.y + _a.y * _bp.z * _cp.x - _ap.x * _b.z * _cp.y + _ap.y * _b.z * _cp.x;
                m[9] -= _p2.x * m[0] + _p2.y * m[3] + _p2.z * m[6];
                m[1] = _ap.y * _b.z + _a.y * _bp.z - _ap.z * _b.y - _a.z * _bp.y;
                m[4] = -_a.x * _bp.z - _ap.x * _b.z + _a.z * _bp.x + _ap.z * _b.x;
                m[7] = _a.x * _bp.y - _a.y * _bp.x + _ap.x * _b.y - _ap.y * _b.x;
                m[10] = _a.x * _b.y * _cp.z - _a.y * _b.x * _cp.z - _a.x * _b.z * _cp.y + _a.y * _b.z * _cp.x + _a.z * _b.x * _cp.y - _a.z * _b.y * _cp.x;
                m[10] -= _p2.x * m[1] + _p2.y * m[4] + _p2.z * m[7];
                m[2] = -_a.z * _b.y + _a.y * _b.z;
                m[5] = -_a.x * _b.z + _a.z * _b.x;
                m[8] = _a.x * _b.y - _a.y * _b.x;
                m[11] = 0.0;
                m[11] -= _p2.x * m[2] + _p2.y * m[5] + _p2.z * m[8];
                var c = _ap.x * _bp.y * _cp.z - _ap.y * _bp.x * _cp.z + _ap.z * _bp.x * _cp.y - _ap.z * _bp.y * _cp.x + _ap.y * _bp.z * _cp.x - _ap.x * _bp.z * _cp.y;

                if (Math.abs(c) > EPSILON$2) {
                  for (var k = 0; k < 12; k++) {
                    m[k] /= c;
                  }
                } else {
                  tetrahedron.vertex3 = -2;
                }

                tetrahedron.matrix.set(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);
                tetrahedron.offset.set(m[9], m[10], m[11]);
              };

              return Delaunay;
            }());

            var SH_BASIS_COUNT = 9;
            var LightProbeSampler = exports('LightProbeSampler', function () {
              function LightProbeSampler() {}

              LightProbeSampler.uniformSampleSphere = function uniformSampleSphere(u1, u2) {
                var z = 1.0 - 2.0 * u1;
                var r = Math.sqrt(Math.max(0.0, 1.0 - z * z));
                var phi = 2.0 * Math.PI * u2;
                var x = r * Math.cos(phi);
                var y = r * Math.sin(phi);
                return new Vec3(x, y, z);
              };

              LightProbeSampler.uniformSampleSphereAll = function uniformSampleSphereAll(sampleCount) {
                assertIsTrue(sampleCount > 0);
                var uCount1 = Math.floor(Math.sqrt(sampleCount));
                var uCount2 = uCount1;
                var samples = [];
                var uDelta1 = 1.0 / uCount1;
                var uDelta2 = 1.0 / uCount2;

                for (var i = 0; i < uCount1; i++) {
                  var u1 = (i + 0.5) * uDelta1;

                  for (var j = 0; j < uCount2; j++) {
                    var u2 = (j + 0.5) * uDelta2;
                    var sample = this.uniformSampleSphere(u1, u2);
                    samples.push(sample);
                  }
                }

                return samples;
              };

              LightProbeSampler.uniformSpherePdf = function uniformSpherePdf() {
                return 1.0 / (4.0 * Math.PI);
              };

              return LightProbeSampler;
            }());
            var SH = exports('SH', function () {
              function SH() {}

              SH.updateUBOData = function updateUBOData(data, offset, coefficients) {
                data[offset++] = coefficients[3].x * this.basisOverPI[3];
                data[offset++] = coefficients[1].x * this.basisOverPI[1];
                data[offset++] = coefficients[2].x * this.basisOverPI[2];
                data[offset++] = coefficients[0].x * this.basisOverPI[0] - coefficients[6].x * this.basisOverPI[6] / 3.0;
                data[offset++] = coefficients[3].y * this.basisOverPI[3];
                data[offset++] = coefficients[1].y * this.basisOverPI[1];
                data[offset++] = coefficients[2].y * this.basisOverPI[2];
                data[offset++] = coefficients[0].y * this.basisOverPI[0] - coefficients[6].y * this.basisOverPI[6] / 3.0;
                data[offset++] = coefficients[3].z * this.basisOverPI[3];
                data[offset++] = coefficients[1].z * this.basisOverPI[1];
                data[offset++] = coefficients[2].z * this.basisOverPI[2];
                data[offset++] = coefficients[0].z * this.basisOverPI[0] - coefficients[6].z * this.basisOverPI[6] / 3.0;
                data[offset++] = coefficients[4].x * this.basisOverPI[4];
                data[offset++] = coefficients[5].x * this.basisOverPI[5];
                data[offset++] = coefficients[6].x * this.basisOverPI[6];
                data[offset++] = coefficients[7].x * this.basisOverPI[7];
                data[offset++] = coefficients[4].y * this.basisOverPI[4];
                data[offset++] = coefficients[5].y * this.basisOverPI[5];
                data[offset++] = coefficients[6].y * this.basisOverPI[6];
                data[offset++] = coefficients[7].y * this.basisOverPI[7];
                data[offset++] = coefficients[4].z * this.basisOverPI[4];
                data[offset++] = coefficients[5].z * this.basisOverPI[5];
                data[offset++] = coefficients[6].z * this.basisOverPI[6];
                data[offset++] = coefficients[7].z * this.basisOverPI[7];
                data[offset++] = coefficients[8].x * this.basisOverPI[8];
                data[offset++] = coefficients[8].y * this.basisOverPI[8];
                data[offset++] = coefficients[8].z * this.basisOverPI[8];
                data[offset++] = 0.0;
              };

              SH.shaderEvaluate = function shaderEvaluate(normal, coefficients) {
                var linearConstR = new Vec4(coefficients[3].x * this.basisOverPI[3], coefficients[1].x * this.basisOverPI[1], coefficients[2].x * this.basisOverPI[2], coefficients[0].x * this.basisOverPI[0] - coefficients[6].x * this.basisOverPI[6] / 3.0);
                var linearConstG = new Vec4(coefficients[3].y * this.basisOverPI[3], coefficients[1].y * this.basisOverPI[1], coefficients[2].y * this.basisOverPI[2], coefficients[0].y * this.basisOverPI[0] - coefficients[6].y * this.basisOverPI[6] / 3.0);
                var linearConstB = new Vec4(coefficients[3].z * this.basisOverPI[3], coefficients[1].z * this.basisOverPI[1], coefficients[2].z * this.basisOverPI[2], coefficients[0].z * this.basisOverPI[0] - coefficients[6].z * this.basisOverPI[6] / 3.0);
                var quadraticR = new Vec4(coefficients[4].x * this.basisOverPI[4], coefficients[5].x * this.basisOverPI[5], coefficients[6].x * this.basisOverPI[6], coefficients[7].x * this.basisOverPI[7]);
                var quadraticG = new Vec4(coefficients[4].y * this.basisOverPI[4], coefficients[5].y * this.basisOverPI[5], coefficients[6].y * this.basisOverPI[6], coefficients[7].y * this.basisOverPI[7]);
                var quadraticB = new Vec4(coefficients[4].z * this.basisOverPI[4], coefficients[5].z * this.basisOverPI[5], coefficients[6].z * this.basisOverPI[6], coefficients[7].z * this.basisOverPI[7]);
                var quadraticA = new Vec3(coefficients[8].x * this.basisOverPI[8], coefficients[8].y * this.basisOverPI[8], coefficients[8].z * this.basisOverPI[8]);
                var result = new Vec3(0.0, 0.0, 0.0);
                var normal4 = new Vec4(normal.x, normal.y, normal.z, 1.0);
                result.x = Vec4.dot(linearConstR, normal4);
                result.y = Vec4.dot(linearConstG, normal4);
                result.z = Vec4.dot(linearConstB, normal4);
                var n14 = new Vec4(normal.x * normal.y, normal.y * normal.z, normal.z * normal.z, normal.z * normal.x);
                var n5 = normal.x * normal.x - normal.y * normal.y;
                result.x += Vec4.dot(quadraticR, n14);
                result.y += Vec4.dot(quadraticG, n14);
                result.z += Vec4.dot(quadraticB, n14);
                Vec3.scaleAndAdd(result, result, quadraticA, n5);
                return result;
              };

              SH.evaluate = function evaluate(sample, coefficients) {
                var result = new Vec3(0.0, 0.0, 0.0);
                var size = coefficients.length;

                for (var i = 0; i < size; i++) {
                  var c = coefficients[i];
                  Vec3.scaleAndAdd(result, result, c, this.evaluateBasis(i, sample));
                }

                return result;
              };

              SH.project = function project(samples, values) {
                assertIsTrue(samples.length > 0 && samples.length === values.length);
                var basisCount = this.getBasisCount();
                var sampleCount = samples.length;
                var scale = 1.0 / (LightProbeSampler.uniformSpherePdf() * sampleCount);
                var coefficients = [];

                for (var i = 0; i < basisCount; i++) {
                  var coefficient = new Vec3(0.0, 0.0, 0.0);

                  for (var k = 0; k < sampleCount; k++) {
                    Vec3.scaleAndAdd(coefficient, coefficient, values[k], this.evaluateBasis(i, samples[k]));
                  }

                  Vec3.multiplyScalar(coefficient, coefficient, scale);
                  coefficients.push(coefficient);
                }

                return coefficients;
              };

              SH.convolveCosine = function convolveCosine(radianceCoefficients) {
                var cosTheta = [0.8862268925, 1.0233267546, 0.4954159260];
                var irradianceCoefficients = [];

                for (var l = 0; l <= this.LMAX; l++) {
                  for (var m = -l; m <= l; m++) {
                    var i = this.toIndex(l, m);
                    var coefficient = new Vec3(0.0, 0.0, 0.0);
                    Vec3.multiplyScalar(coefficient, radianceCoefficients[i], this.lambda(l) * cosTheta[l]);
                    irradianceCoefficients.push(coefficient);
                  }
                }

                return irradianceCoefficients;
              };

              SH.getBasisCount = function getBasisCount() {
                return SH_BASIS_COUNT;
              };

              SH.evaluateBasis = function evaluateBasis(index, sample) {
                assertIsTrue(index < this.getBasisCount());
                var func = this.basisFunctions[index];
                return func(sample);
              };

              SH.reduceRinging = function reduceRinging(coefficients, lambda) {
                if (lambda === 0.0) {
                  return;
                }

                for (var l = 0; l <= this.LMAX; ++l) {
                  var scale = 1.0 / (1.0 + lambda * l * l * (l + 1) * (l + 1));

                  for (var m = -l; m <= l; ++m) {
                    var i = this.toIndex(l, m);
                    Vec3.multiplyScalar(coefficients[i], coefficients[i], scale);
                  }
                }
              };

              SH.lambda = function lambda(l) {
                return Math.sqrt(4.0 * Math.PI / (2.0 * l + 1.0));
              };

              SH.toIndex = function toIndex(l, m) {
                return l * l + l + m;
              };

              return SH;
            }());
            SH.LMAX = 2;
            SH.basisFunctions = [function (v) {
              return 0.282095;
            }, function (v) {
              return 0.488603 * v.y;
            }, function (v) {
              return 0.488603 * v.z;
            }, function (v) {
              return 0.488603 * v.x;
            }, function (v) {
              return 1.09255 * v.y * v.x;
            }, function (v) {
              return 1.09255 * v.y * v.z;
            }, function (v) {
              return 0.946175 * (v.z * v.z - 1.0 / 3.0);
            }, function (v) {
              return 1.09255 * v.z * v.x;
            }, function (v) {
              return 0.546274 * (v.x * v.x - v.y * v.y);
            }];
            SH.basisOverPI = [0.0897936, 0.155527, 0.155527, 0.155527, 0.347769, 0.347769, 0.301177, 0.347769, 0.173884];
            legacyCC.internal.SH = SH;

            var PolynomialSolver = function () {
              function PolynomialSolver() {}

              PolynomialSolver.getQuadraticUniqueRoot = function getQuadraticUniqueRoot(b, c, d) {
                if (b !== 0.0) {
                  return -c / (2.0 * b);
                }

                if (c !== 0.0) {
                  return -d / c;
                }

                return 0.0;
              };

              PolynomialSolver.getCubicUniqueRoot = function getCubicUniqueRoot(b, c, d) {
                var roots = [];
                var offset = -b / 3.0;
                var p = c / 3.0 - b * b / 9.0;
                var q = d / 2.0 + b * b * b / 27.0 - b * c / 6.0;
                var delta = p * p * p + q * q;

                if (delta > 0.0) {
                  var sqrtDelta = Math.sqrt(delta);
                  roots.push(Math.cbrt(-q + sqrtDelta) + Math.cbrt(-q - sqrtDelta));
                } else if (delta < 0.0) {
                  var angle = Math.acos(-q * Math.sqrt(-p) / (p * p)) / 3.0;
                  roots.push(2.0 * Math.sqrt(-p) * Math.cos(angle));
                  roots.push(2.0 * Math.sqrt(-p) * Math.cos(angle + 2.0 * Math.PI / 3.0));
                  roots.push(2.0 * Math.sqrt(-p) * Math.cos(angle + 4.0 * Math.PI / 3.0));
                } else if (q === 0.0) {
                  roots.push(0.0);
                } else {
                  var root = Math.cbrt(q);
                  roots.push(root);
                  roots.push(-2.0 * root);
                }

                for (var i = 0; i < roots.length; i++) {
                  if (roots[i] + offset >= 0.0) {
                    return roots[i] + offset;
                  }
                }

                return 0.0;
              };

              return PolynomialSolver;
            }();

            var _dec$1e, _dec2$R, _dec3$y, _class$1h, _class2$11, _initializer$Z, _initializer2$N;

            var _v1 = new Vec3(0.0, 0.0, 0.0);

            var _v2 = new Vec3(0.0, 0.0, 0.0);

            var _normal = new Vec3(0.0, 0.0, 0.0);

            var _edgeP0 = new Vec3(0.0, 0.0, 0.0);

            var _edgeP1 = new Vec3(0.0, 0.0, 0.0);

            var _edgeP2 = new Vec3(0.0, 0.0, 0.0);

            var _crossP12 = new Vec3(0.0, 0.0, 0.0);

            var _crossP20 = new Vec3(0.0, 0.0, 0.0);

            var _normal2 = new Vec3(0.0, 0.0, 0.0);

            var _edge1 = new Vec3(0.0, 0.0, 0.0);

            var _edge2 = new Vec3(0.0, 0.0, 0.0);

            var _v = new Vec3(0.0, 0.0, 0.0);

            var _vp0 = new Vec3(0.0, 0.0, 0.0);

            var _vp1 = new Vec3(0.0, 0.0, 0.0);

            var _vp2 = new Vec3(0.0, 0.0, 0.0);

            var LightProbesData = exports('LightProbesData', (_dec$1e = ccclass$p('cc.LightProbesData'), _dec2$R = type$8([Vertex]), _dec3$y = type$8([Tetrahedron]), _dec$1e(_class$1h = (_class2$11 = function () {
              function LightProbesData() {
                this._probes = _initializer$Z && _initializer$Z();
                this._tetrahedrons = _initializer2$N && _initializer2$N();
              }

              var _proto = LightProbesData.prototype;

              _proto.empty = function empty() {
                return this._probes.length === 0 || this._tetrahedrons.length === 0;
              };

              _proto.reset = function reset() {
                this._probes.length = 0;
                this._tetrahedrons.length = 0;
              };

              _proto.updateProbes = function updateProbes(points) {
                this._probes.length = 0;
                var pointCount = points.length;

                for (var i = 0; i < pointCount; i++) {
                  this._probes.push(new Vertex(points[i]));
                }
              };

              _proto.updateTetrahedrons = function updateTetrahedrons() {
                var delaunay = new Delaunay(this._probes);
                this._tetrahedrons = delaunay.build();
              };

              _proto.getInterpolationSHCoefficients = function getInterpolationSHCoefficients(tetIndex, weights, coefficients) {
                if (!this.hasCoefficients()) {
                  return false;
                }

                var length = SH.getBasisCount();
                var tetrahedron = this._tetrahedrons[tetIndex];
                var c0 = this._probes[tetrahedron.vertex0].coefficients;
                var c1 = this._probes[tetrahedron.vertex1].coefficients;
                var c2 = this._probes[tetrahedron.vertex2].coefficients;

                if (tetrahedron.vertex3 >= 0) {
                  var c3 = this._probes[tetrahedron.vertex3].coefficients;

                  for (var i = 0; i < length; i++) {
                    coefficients[i] = new Vec3(0.0, 0.0, 0.0);
                    Vec3.scaleAndAdd(coefficients[i], coefficients[i], c0[i], weights.x);
                    Vec3.scaleAndAdd(coefficients[i], coefficients[i], c1[i], weights.y);
                    Vec3.scaleAndAdd(coefficients[i], coefficients[i], c2[i], weights.z);
                    Vec3.scaleAndAdd(coefficients[i], coefficients[i], c3[i], weights.w);
                  }
                } else {
                  for (var _i = 0; _i < length; _i++) {
                    coefficients[_i] = new Vec3(0.0, 0.0, 0.0);
                    Vec3.scaleAndAdd(coefficients[_i], coefficients[_i], c0[_i], weights.x);
                    Vec3.scaleAndAdd(coefficients[_i], coefficients[_i], c1[_i], weights.y);
                    Vec3.scaleAndAdd(coefficients[_i], coefficients[_i], c2[_i], weights.z);
                  }
                }

                return true;
              };

              _proto.getInterpolationWeights = function getInterpolationWeights(position, tetIndex, weights) {
                var tetrahedronCount = this._tetrahedrons.length;

                if (tetIndex < 0 || tetIndex >= tetrahedronCount) {
                  tetIndex = 0;
                }

                var lastIndex = -1;
                var nextIndex = -1;

                for (var i = 0; i < tetrahedronCount; i++) {
                  var tetrahedron = this._tetrahedrons[tetIndex];
                  this.getBarycentricCoord(position, tetrahedron, weights);

                  if (weights.x >= 0.0 && weights.y >= 0.0 && weights.z >= 0.0 && weights.w >= 0.0) {
                    break;
                  }

                  if (weights.x < weights.y && weights.x < weights.z && weights.x < weights.w) {
                    nextIndex = tetrahedron.neighbours[0];
                  } else if (weights.y < weights.z && weights.y < weights.w) {
                    nextIndex = tetrahedron.neighbours[1];
                  } else if (weights.z < weights.w) {
                    nextIndex = tetrahedron.neighbours[2];
                  } else {
                    nextIndex = tetrahedron.neighbours[3];
                  }

                  if (lastIndex === nextIndex) {
                    break;
                  }

                  lastIndex = tetIndex;
                  tetIndex = nextIndex;
                }

                return tetIndex;
              };

              _proto.hasCoefficients = function hasCoefficients() {
                return !this.empty() && this._probes[0].coefficients.length !== 0;
              };

              LightProbesData.getTriangleBarycentricCoord = function getTriangleBarycentricCoord(p0, p1, p2, position) {
                Vec3.subtract(_v1, p1, p0);
                Vec3.subtract(_v2, p2, p0);
                Vec3.cross(_normal, _v1, _v2);

                if (_normal.lengthSqr() <= EPSILON$2) {
                  return new Vec3(0.0, 0.0, 0.0);
                }

                var n = _normal.clone();

                n.normalize();
                var area012Inv = 1.0 / n.dot(_normal);
                Vec3.subtract(_edgeP0, p0, position);
                Vec3.subtract(_edgeP1, p1, position);
                Vec3.subtract(_edgeP2, p2, position);
                Vec3.cross(_crossP12, _edgeP1, _edgeP2);
                var areaP12 = n.dot(_crossP12);
                var alpha = areaP12 * area012Inv;
                Vec3.cross(_crossP20, _edgeP2, _edgeP0);
                var areaP20 = n.dot(_crossP20);
                var beta = areaP20 * area012Inv;
                return new Vec3(alpha, beta, 1.0 - alpha - beta);
              };

              _proto.getBarycentricCoord = function getBarycentricCoord(position, tetrahedron, weights) {
                if (tetrahedron.vertex3 >= 0) {
                  this.getTetrahedronBarycentricCoord(position, tetrahedron, weights);
                } else {
                  this.getOuterCellBarycentricCoord(position, tetrahedron, weights);
                }
              };

              _proto.getTetrahedronBarycentricCoord = function getTetrahedronBarycentricCoord(position, tetrahedron, weights) {
                var result = new Vec3(0.0, 0.0, 0.0);
                Vec3.subtract(result, position, this._probes[tetrahedron.vertex3].position);
                Vec3.transformMat3(result, result, tetrahedron.matrix);
                weights.set(result.x, result.y, result.z, 1.0 - result.x - result.y - result.z);
              };

              _proto.getOuterCellBarycentricCoord = function getOuterCellBarycentricCoord(position, tetrahedron, weights) {
                var p0 = this._probes[tetrahedron.vertex0].position;
                var p1 = this._probes[tetrahedron.vertex1].position;
                var p2 = this._probes[tetrahedron.vertex2].position;
                Vec3.subtract(_edge1, p1, p0);
                Vec3.subtract(_edge2, p2, p0);
                Vec3.cross(_normal2, _edge1, _edge2);
                Vec3.subtract(_v, position, p0);
                var t = Vec3.dot(_v, _normal2);

                if (t < 0.0) {
                  weights.set(0.0, 0.0, 0.0, -1.0);
                  return;
                }

                var coefficients = new Vec3(0.0, 0.0, 0.0);
                Vec3.transformMat3(coefficients, position, tetrahedron.matrix);
                Vec3.add(coefficients, coefficients, tetrahedron.offset);

                if (tetrahedron.vertex3 === -1) {
                  t = PolynomialSolver.getCubicUniqueRoot(coefficients.x, coefficients.y, coefficients.z);
                } else {
                  t = PolynomialSolver.getQuadraticUniqueRoot(coefficients.x, coefficients.y, coefficients.z);
                }

                Vec3.scaleAndAdd(_vp0, p0, this._probes[tetrahedron.vertex0].normal, t);
                Vec3.scaleAndAdd(_vp1, p1, this._probes[tetrahedron.vertex1].normal, t);
                Vec3.scaleAndAdd(_vp2, p2, this._probes[tetrahedron.vertex2].normal, t);
                var result = LightProbesData.getTriangleBarycentricCoord(_vp0, _vp1, _vp2, position);
                weights.set(result.x, result.y, result.z, 0.0);
              };

              _createClass(LightProbesData, [{
                key: "probes",
                get: function get() {
                  return this._probes;
                }
              }, {
                key: "tetrahedrons",
                get: function get() {
                  return this._tetrahedrons;
                }
              }]);

              return LightProbesData;
            }(), (_initializer$Z = applyDecoratedInitializer(_class2$11.prototype, "_probes", [serializable$j, _dec2$R], function () {
              return [];
            }), _initializer2$N = applyDecoratedInitializer(_class2$11.prototype, "_tetrahedrons", [serializable$j, _dec3$y], function () {
              return [];
            })), _class2$11)) || _class$1h));
            legacyCC.internal.LightProbesData = LightProbesData;
            var LightProbes = exports('LightProbes', function () {
              function LightProbes() {
                this._giScale = 1.0;
                this._giSamples = 1024;
                this._bounces = 2;
                this._reduceRinging = 0.0;
                this._showProbe = true;
                this._showWireframe = true;
                this._showConvex = false;
                this._data = null;
              }

              var _proto2 = LightProbes.prototype;

              _proto2.initialize = function initialize(info) {
                this._giScale = info.giScale;
                this._giSamples = info.giSamples;
                this._bounces = info.bounces;
                this._reduceRinging = info.reduceRinging;
                this._showProbe = info.showProbe;
                this._showWireframe = info.showWireframe;
                this._showConvex = info.showConvex;
                this._data = info.data;
              };

              _proto2.empty = function empty() {
                if (!this._data) {
                  return true;
                }

                return this._data.empty();
              };

              _createClass(LightProbes, [{
                key: "giScale",
                get: function get() {
                  return this._giScale;
                },
                set: function set(val) {
                  this._giScale = val;
                }
              }, {
                key: "giSamples",
                get: function get() {
                  return this._giSamples;
                },
                set: function set(val) {
                  this._giSamples = val;
                }
              }, {
                key: "bounces",
                get: function get() {
                  return this._bounces;
                },
                set: function set(val) {
                  this._bounces = val;
                }
              }, {
                key: "reduceRinging",
                get: function get() {
                  return this._reduceRinging;
                },
                set: function set(val) {
                  this._reduceRinging = val;
                }
              }, {
                key: "showProbe",
                get: function get() {
                  return this._showProbe;
                },
                set: function set(val) {
                  this._showProbe = val;
                }
              }, {
                key: "showWireframe",
                get: function get() {
                  return this._showWireframe;
                },
                set: function set(val) {
                  this._showWireframe = val;
                }
              }, {
                key: "showConvex",
                get: function get() {
                  return this._showConvex;
                },
                set: function set(val) {
                  this._showConvex = val;
                }
              }, {
                key: "data",
                get: function get() {
                  return this._data;
                },
                set: function set(val) {
                  this._data = val;
                }
              }]);

              return LightProbes;
            }());
            legacyCC.internal.LightProbes = LightProbes;

            var _dec$1f, _dec2$S, _dec3$z, _dec4$k, _dec5$f, _dec6$d, _class$1i, _class2$12, _initializer$_, _initializer2$O, _initializer3$A, _initializer4$v, _initializer5$o, _initializer6$j, _initializer7$e;
            var LightProbeGroup = exports('LightProbeGroup', (_dec$1f = ccclass$p('cc.LightProbeGroup'), _dec2$S = type$8([Vec3]), _dec3$z = type$8(PlaceMethod), _dec4$k = type$8(CCInteger), _dec5$f = type$8(CCInteger), _dec6$d = type$8(CCInteger), _dec$1f(_class$1i = disallowMultiple(_class$1i = (_class2$12 = function (_Component) {
              _inheritsLoose(LightProbeGroup, _Component);

              function LightProbeGroup() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._probes = _initializer$_ && _initializer$_();
                _this._method = _initializer2$O && _initializer2$O();
                _this._minPos = _initializer3$A && _initializer3$A();
                _this._maxPos = _initializer4$v && _initializer4$v();
                _this._nProbesX = _initializer5$o && _initializer5$o();
                _this._nProbesY = _initializer6$j && _initializer6$j();
                _this._nProbesZ = _initializer7$e && _initializer7$e();
                return _this;
              }

              var _proto = LightProbeGroup.prototype;

              _proto.onLoad = function onLoad() {
                {
                  return;
                }
              };

              _proto.onEnable = function onEnable() {
                {
                  return;
                }
              };

              _proto.onDisable = function onDisable() {
                {
                  return;
                }
              };

              _proto.generateLightProbes = function generateLightProbes() {
                if (!this.node) {
                  return;
                }

                this._probes = AutoPlacement.generate({
                  method: this._method,
                  nProbesX: this._nProbesX,
                  nProbesY: this._nProbesY,
                  nProbesZ: this._nProbesZ,
                  minPos: this._minPos,
                  maxPos: this._maxPos
                });
                this.onProbeChanged();
              };

              _proto.onProbeChanged = function onProbeChanged(updateTet, emitEvent) {
                if (updateTet === void 0) {
                  updateTet = true;
                }

                if (emitEvent === void 0) {
                  emitEvent = true;
                }

                this.node.scene.globals.lightProbeInfo.syncData(this.node, this.probes);
                this.node.scene.globals.lightProbeInfo.update(updateTet);

                if (emitEvent) {
                  this.node.emit(NodeEventType.LIGHT_PROBE_CHANGED);
                }
              };

              _createClass(LightProbeGroup, [{
                key: "probes",
                get: function get() {
                  return this._probes;
                },
                set: function set(val) {
                  this._probes = val;
                }
              }, {
                key: "method",
                get: function get() {
                  return this._method;
                }
              }, {
                key: "minPos",
                get: function get() {
                  return this._minPos;
                },
                set: function set(val) {
                  this._minPos = val;
                }
              }, {
                key: "maxPos",
                get: function get() {
                  return this._maxPos;
                },
                set: function set(val) {
                  this._maxPos = val;
                }
              }, {
                key: "nProbesX",
                get: function get() {
                  return this._nProbesX;
                },
                set: function set(val) {
                  this._nProbesX = val;
                }
              }, {
                key: "nProbesY",
                get: function get() {
                  return this._nProbesY;
                },
                set: function set(val) {
                  this._nProbesY = val;
                }
              }, {
                key: "nProbesZ",
                get: function get() {
                  return this._nProbesZ;
                },
                set: function set(val) {
                  this._nProbesZ = val;
                }
              }]);

              return LightProbeGroup;
            }(Component), (_initializer$_ = applyDecoratedInitializer(_class2$12.prototype, "_probes", [serializable$j], function () {
              return [];
            }), _initializer2$O = applyDecoratedInitializer(_class2$12.prototype, "_method", [serializable$j], function () {
              return PlaceMethod.UNIFORM;
            }), _initializer3$A = applyDecoratedInitializer(_class2$12.prototype, "_minPos", [serializable$j], function () {
              return new Vec3(-5, -5, -5);
            }), _initializer4$v = applyDecoratedInitializer(_class2$12.prototype, "_maxPos", [serializable$j], function () {
              return new Vec3(5, 5, 5);
            }), _initializer5$o = applyDecoratedInitializer(_class2$12.prototype, "_nProbesX", [serializable$j], function () {
              return 3;
            }), _initializer6$j = applyDecoratedInitializer(_class2$12.prototype, "_nProbesY", [serializable$j], function () {
              return 3;
            }), _initializer7$e = applyDecoratedInitializer(_class2$12.prototype, "_nProbesZ", [serializable$j], function () {
              return 3;
            }), _applyDecoratedDescriptor(_class2$12.prototype, "probes", [_dec2$S], Object.getOwnPropertyDescriptor(_class2$12.prototype, "probes"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "method", [_dec3$z], Object.getOwnPropertyDescriptor(_class2$12.prototype, "method"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "nProbesX", [_dec4$k], Object.getOwnPropertyDescriptor(_class2$12.prototype, "nProbesX"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "nProbesY", [_dec5$f], Object.getOwnPropertyDescriptor(_class2$12.prototype, "nProbesY"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "nProbesZ", [_dec6$d], Object.getOwnPropertyDescriptor(_class2$12.prototype, "nProbesZ"), _class2$12.prototype)), _class2$12)) || _class$1i) || _class$1i));

            var _dec$1g, _dec2$T, _dec3$A, _class$1j, _class2$13, _initializer$$, _initializer2$P, _initializer3$B, _initializer4$w;
            var Billboard = exports('Billboard', (_dec$1g = ccclass$p('cc.Billboard'), _dec2$T = type$8(Texture2D), _dec3$A = type$8(Texture2D), _dec$1g(_class$1j = (_class2$13 = function (_Component) {
              _inheritsLoose(Billboard, _Component);

              function Billboard() {
                var _this;

                _this = _Component.call(this) || this;
                _this._texture = _initializer$$ && _initializer$$();
                _this._height = _initializer2$P && _initializer2$P();
                _this._width = _initializer3$B && _initializer3$B();
                _this._rotation = _initializer4$w && _initializer4$w();
                _this._model = null;
                _this._mesh = null;
                _this._material = null;
                _this._uniform = new Vec4(1, 1, 0, 0);
                return _this;
              }

              var _proto = Billboard.prototype;

              _proto.onLoad = function onLoad() {
                this.createModel();
              };

              _proto.onEnable = function onEnable() {
                this.attachToScene();
                this._model.enabled = true;
                this.width = this._width;
                this.height = this._height;
                this.rotation = this.rotation;
                this.texture = this.texture;
              };

              _proto.onDisable = function onDisable() {
                this.detachFromScene();
              };

              _proto.attachToScene = function attachToScene() {
                if (this._model && this.node && this.node.scene) {
                  if (this._model.scene) {
                    this.detachFromScene();
                  }

                  this._getRenderScene().addModel(this._model);
                }
              };

              _proto.detachFromScene = function detachFromScene() {
                if (this._model && this._model.scene) {
                  this._model.scene.removeModel(this._model);
                }
              };

              _proto.createModel = function createModel() {
                this._mesh = _createMesh({
                  primitiveMode: PrimitiveMode.TRIANGLE_LIST,
                  positions: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  uvs: [0, 0, 1, 0, 0, 1, 1, 1],
                  colors: [Color$1.WHITE.r, Color$1.WHITE.g, Color$1.WHITE.b, Color$1.WHITE.a, Color$1.WHITE.r, Color$1.WHITE.g, Color$1.WHITE.b, Color$1.WHITE.a, Color$1.WHITE.r, Color$1.WHITE.g, Color$1.WHITE.b, Color$1.WHITE.a, Color$1.WHITE.r, Color$1.WHITE.g, Color$1.WHITE.b, Color$1.WHITE.a],
                  attributes: [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8UI, true)],
                  indices: [0, 1, 2, 1, 2, 3]
                }, undefined, {
                  calculateBounds: false
                });
                var model = this._model = legacyCC.director.root.createModel(Model, this.node);
                model.node = model.transform = this.node;

                if (this._material == null) {
                  this._material = new Material();

                  this._material.copy(builtinResMgr.get('default-billboard-material'));
                }

                model.initSubModel(0, this._mesh.renderingSubMeshes[0], this._material);
              };

              _createClass(Billboard, [{
                key: "texture",
                get: function get() {
                  return this._texture;
                },
                set: function set(val) {
                  this._texture = val;

                  if (this._material) {
                    this._material.setProperty('mainTexture', val);
                  }
                }
              }, {
                key: "height",
                get: function get() {
                  return this._height;
                },
                set: function set(val) {
                  this._height = val;

                  if (this._material) {
                    this._uniform.y = val;

                    this._material.setProperty('cc_size_rotation', this._uniform);
                  }
                }
              }, {
                key: "width",
                get: function get() {
                  return this._width;
                },
                set: function set(val) {
                  this._width = val;

                  if (this._material) {
                    this._uniform.x = val;

                    this._material.setProperty('cc_size_rotation', this._uniform);
                  }
                }
              }, {
                key: "rotation",
                get: function get() {
                  return Math.round(toDegree(this._rotation) * 100) / 100;
                },
                set: function set(val) {
                  this._rotation = toRadian(val);

                  if (this._material) {
                    this._uniform.z = this._rotation;

                    this._material.setProperty('cc_size_rotation', this._uniform);
                  }
                }
              }]);

              return Billboard;
            }(Component), (_initializer$$ = applyDecoratedInitializer(_class2$13.prototype, "_texture", [_dec2$T], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$13.prototype, "texture", [_dec3$A], Object.getOwnPropertyDescriptor(_class2$13.prototype, "texture"), _class2$13.prototype), _initializer2$P = applyDecoratedInitializer(_class2$13.prototype, "_height", [serializable$j], function () {
              return 0;
            }), _initializer3$B = applyDecoratedInitializer(_class2$13.prototype, "_width", [serializable$j], function () {
              return 0;
            }), _initializer4$w = applyDecoratedInitializer(_class2$13.prototype, "_rotation", [serializable$j], function () {
              return 0;
            })), _class2$13)) || _class$1j));

            var _vertex_attrs = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGBA32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true)];

            var _temp_v1 = new Vec3();

            var _temp_v2 = new Vec3();

            var LineModel = function (_scene$Model) {
              _inheritsLoose(LineModel, _scene$Model);

              function LineModel() {
                var _this;

                _this = _scene$Model.call(this) || this;
                _this._capacity = void 0;
                _this._vertSize = 0;
                _this._vBuffer = null;
                _this._vertAttrsFloatCount = 0;
                _this._vdataF32 = null;
                _this._vdataUint32 = null;
                _this._iaInfo = void 0;
                _this._iaInfoBuffer = void 0;
                _this._subMeshData = null;
                _this._vertCount = 0;
                _this._indexCount = 0;
                _this._material = null;

                _this.type = ModelType.LINE;
                _this._capacity = 100;
                _this._iaInfo = new IndirectBuffer([new DrawInfo()]);
                _this._iaInfoBuffer = _this._device.createBuffer(new BufferInfo(BufferUsageBit.INDIRECT, MemoryUsageBit.DEVICE, DRAW_INFO_SIZE, DRAW_INFO_SIZE));
                return _this;
              }

              var _proto = LineModel.prototype;

              _proto.setCapacity = function setCapacity(capacity) {
                this._capacity = capacity;
                this.createBuffer();
              };

              _proto.createBuffer = function createBuffer() {
                this._vertSize = 0;

                for (var _iterator = _createForOfIteratorHelperLoose(_vertex_attrs), _step; !(_step = _iterator()).done;) {
                  var a = _step.value;
                  a.offset = this._vertSize;
                  this._vertSize += FormatInfos[a.format].size;
                }

                this._vertAttrsFloatCount = this._vertSize / 4;
                this._vBuffer = this.createSubMeshData();
                this._vdataF32 = new Float32Array(this._vBuffer);
                this._vdataUint32 = new Uint32Array(this._vBuffer);
              };

              _proto.updateMaterial = function updateMaterial(mat) {
                this._material = mat;

                _scene$Model.prototype.setSubModelMaterial.call(this, 0, mat);
              };

              _proto.createSubMeshData = function createSubMeshData() {
                if (this._subMeshData) {
                  this.destroySubMeshData();
                }

                this._vertCount = 2;
                this._indexCount = 6;

                var vertexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, this._vertSize * this._capacity * this._vertCount, this._vertSize));

                var vBuffer = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);
                vertexBuffer.update(vBuffer);
                var indices = new Uint16Array((this._capacity - 1) * this._indexCount);
                var dst = 0;

                for (var i = 0; i < this._capacity - 1; ++i) {
                  var baseIdx = 2 * i;
                  indices[dst++] = baseIdx;
                  indices[dst++] = baseIdx + 1;
                  indices[dst++] = baseIdx + 2;
                  indices[dst++] = baseIdx + 3;
                  indices[dst++] = baseIdx + 2;
                  indices[dst++] = baseIdx + 1;
                }

                var indexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, (this._capacity - 1) * this._indexCount * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));

                indexBuffer.update(indices);
                this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount;
                this._iaInfo.drawInfos[0].indexCount = (this._capacity - 1) * this._indexCount;

                this._iaInfoBuffer.update(this._iaInfo);

                this._subMeshData = new RenderingSubMesh([vertexBuffer], _vertex_attrs, PrimitiveMode.TRIANGLE_LIST, indexBuffer, this._iaInfoBuffer);
                this.initSubModel(0, this._subMeshData, this._material);
                return vBuffer;
              };

              _proto.addLineVertexData = function addLineVertexData(positions, width, color) {
                if (positions.length > 1) {
                  var offset = 0;
                  Vec3.subtract(_temp_v1, positions[1], positions[0]);
                  this._vdataF32[offset++] = positions[0].x;
                  this._vdataF32[offset++] = positions[0].y;
                  this._vdataF32[offset++] = positions[0].z;
                  this._vdataF32[offset++] = 0;
                  this._vdataF32[offset++] = width.evaluate(0, 1);
                  this._vdataF32[offset++] = 0;
                  this._vdataF32[offset++] = 0;
                  this._vdataF32[offset++] = _temp_v1.x;
                  this._vdataF32[offset++] = _temp_v1.y;
                  this._vdataF32[offset++] = _temp_v1.z;
                  this._vdataUint32[offset++] = color.evaluate(0, 1)._val;
                  this._vdataF32[offset++] = positions[0].x;
                  this._vdataF32[offset++] = positions[0].y;
                  this._vdataF32[offset++] = positions[0].z;
                  this._vdataF32[offset++] = 1;
                  this._vdataF32[offset++] = width.evaluate(0, 1);
                  this._vdataF32[offset++] = 0;
                  this._vdataF32[offset++] = 1;
                  this._vdataF32[offset++] = _temp_v1.x;
                  this._vdataF32[offset++] = _temp_v1.y;
                  this._vdataF32[offset++] = _temp_v1.z;
                  this._vdataUint32[offset++] = color.evaluate(0, 1)._val;

                  for (var i = 1; i < positions.length - 1; i++) {
                    Vec3.subtract(_temp_v1, positions[i - 1], positions[i]);
                    Vec3.subtract(_temp_v2, positions[i + 1], positions[i]);
                    Vec3.subtract(_temp_v2, _temp_v2, _temp_v1);
                    var seg = i / positions.length;
                    this._vdataF32[offset++] = positions[i].x;
                    this._vdataF32[offset++] = positions[i].y;
                    this._vdataF32[offset++] = positions[i].z;
                    this._vdataF32[offset++] = 0;
                    this._vdataF32[offset++] = width.evaluate(seg, 1);
                    this._vdataF32[offset++] = seg;
                    this._vdataF32[offset++] = 0;
                    this._vdataF32[offset++] = _temp_v2.x;
                    this._vdataF32[offset++] = _temp_v2.y;
                    this._vdataF32[offset++] = _temp_v2.z;
                    this._vdataUint32[offset++] = color.evaluate(seg, 1)._val;
                    this._vdataF32[offset++] = positions[i].x;
                    this._vdataF32[offset++] = positions[i].y;
                    this._vdataF32[offset++] = positions[i].z;
                    this._vdataF32[offset++] = 1;
                    this._vdataF32[offset++] = width.evaluate(seg, 1);
                    this._vdataF32[offset++] = seg;
                    this._vdataF32[offset++] = 1;
                    this._vdataF32[offset++] = _temp_v2.x;
                    this._vdataF32[offset++] = _temp_v2.y;
                    this._vdataF32[offset++] = _temp_v2.z;
                    this._vdataUint32[offset++] = color.evaluate(seg, 1)._val;
                  }

                  Vec3.subtract(_temp_v1, positions[positions.length - 1], positions[positions.length - 2]);
                  this._vdataF32[offset++] = positions[positions.length - 1].x;
                  this._vdataF32[offset++] = positions[positions.length - 1].y;
                  this._vdataF32[offset++] = positions[positions.length - 1].z;
                  this._vdataF32[offset++] = 0;
                  this._vdataF32[offset++] = width.evaluate(1, 1);
                  this._vdataF32[offset++] = 1;
                  this._vdataF32[offset++] = 0;
                  this._vdataF32[offset++] = _temp_v1.x;
                  this._vdataF32[offset++] = _temp_v1.y;
                  this._vdataF32[offset++] = _temp_v1.z;
                  this._vdataUint32[offset++] = color.evaluate(1, 1)._val;
                  this._vdataF32[offset++] = positions[positions.length - 1].x;
                  this._vdataF32[offset++] = positions[positions.length - 1].y;
                  this._vdataF32[offset++] = positions[positions.length - 1].z;
                  this._vdataF32[offset++] = 1;
                  this._vdataF32[offset++] = width.evaluate(1, 1);
                  this._vdataF32[offset++] = 1;
                  this._vdataF32[offset++] = 1;
                  this._vdataF32[offset++] = _temp_v1.x;
                  this._vdataF32[offset++] = _temp_v1.y;
                  this._vdataF32[offset++] = _temp_v1.z;
                  this._vdataUint32[offset++] = color.evaluate(1, 1)._val;
                }

                this.updateIA(Math.max(0, positions.length - 1));
              };

              _proto.updateIA = function updateIA(count) {
                var ia = this._subModels[0].inputAssembler;
                ia.vertexBuffers[0].update(this._vdataF32);
                this._iaInfo.drawInfos[0].firstIndex = 0;
                this._iaInfo.drawInfos[0].indexCount = this._indexCount * count;

                this._iaInfoBuffer.update(this._iaInfo);
              };

              _proto.destroySubMeshData = function destroySubMeshData() {
                if (this._subMeshData) {
                  this._subMeshData.destroy();

                  this._subMeshData = null;
                }
              };

              return LineModel;
            }(Model);

            var _dec$1h, _class$1k, _class2$14, _temp$n;
            var setClassAttr = CCClass.Attr.setClassAttr;
            var SerializableTable = [['mode', 'constant', 'multiplier'], ['mode', 'spline', 'multiplier'], ['mode', 'splineMin', 'splineMax', 'multiplier'], ['mode', 'constantMin', 'constantMax', 'multiplier']];
            var Mode = Enum({
              Constant: 0,
              Curve: 1,
              TwoCurves: 2,
              TwoConstants: 3
            });
            var CurveRange = exports('CurveRange', (_dec$1h = ccclass$p('cc.CurveRange'), _dec$1h(_class$1k = (_temp$n = _class2$14 = function () {
              function CurveRange() {
                this.constant = 0;
                this.constantMin = 0;
                this.constantMax = 0;
                this.multiplier = 1;
                this._mode = Mode.Constant;
              }

              var _proto = CurveRange.prototype;

              _proto.evaluate = function evaluate(time, rndRatio) {
                switch (this._mode) {
                  default:
                  case Mode.Constant:
                    return this.constant;

                  case Mode.Curve:
                    return this.spline.evaluate(time) * this.multiplier;

                  case Mode.TwoCurves:
                    return lerp(this.splineMin.evaluate(time), this.splineMax.evaluate(time), rndRatio) * this.multiplier;

                  case Mode.TwoConstants:
                    return lerp(this.constantMin, this.constantMax, rndRatio);
                }
              };

              _proto.getMax = function getMax() {
                switch (this._mode) {
                  default:
                  case Mode.Constant:
                    return this.constant;

                  case Mode.Curve:
                    return this.multiplier;

                  case Mode.TwoConstants:
                    return this.constantMax;

                  case Mode.TwoCurves:
                    return this.multiplier;
                }
              };

              _proto.isZero = function isZero() {
                switch (this._mode) {
                  default:
                  case Mode.Constant:
                    return approx(this.constant, 0.0, EPSILON$2);

                  case Mode.Curve:
                    return approx(this.multiplier, 0.0, EPSILON$2);

                  case Mode.TwoConstants:
                    return approx(Math.max(Math.abs(this.constantMax), Math.abs(this.constantMin)), 0.0, EPSILON$2);

                  case Mode.TwoCurves:
                    return approx(this.multiplier, 0.0, EPSILON$2);
                }
              };

              _proto._onBeforeSerialize = function _onBeforeSerialize(props) {
                return SerializableTable[this._mode];
              };

              _createClass(CurveRange, [{
                key: "mode",
                get: function get() {
                  return this._mode;
                },
                set: function set(mode) {
                  this._mode = mode;

                  switch (mode) {
                    case Mode.Constant:
                      break;

                    case Mode.TwoConstants:
                      break;

                    case Mode.Curve:
                      if (!this.spline) this.spline = constructLegacyCurveAndConvert();
                      break;

                    case Mode.TwoCurves:
                      if (!this.splineMax) this.splineMax = constructLegacyCurveAndConvert();
                      if (!this.splineMin) this.splineMin = constructLegacyCurveAndConvert();
                      break;
                  }
                }
              }, {
                key: "curve",
                get: function get() {
                  var _this$_curve;

                  return (_this$_curve = this._curve) !== null && _this$_curve !== void 0 ? _this$_curve : this._curve = new AnimationCurve(this.spline);
                },
                set: function set(value) {
                  this._curve = value;
                  this.spline = value._internalCurve;
                }
              }, {
                key: "curveMin",
                get: function get() {
                  var _this$_curveMin;

                  return (_this$_curveMin = this._curveMin) !== null && _this$_curveMin !== void 0 ? _this$_curveMin : this._curveMin = new AnimationCurve(this.splineMin);
                },
                set: function set(value) {
                  this._curveMin = value;
                  this.splineMin = value._internalCurve;
                }
              }, {
                key: "curveMax",
                get: function get() {
                  var _this$_curveMax;

                  return (_this$_curveMax = this._curveMax) !== null && _this$_curveMax !== void 0 ? _this$_curveMax : this._curveMax = new AnimationCurve(this.splineMax);
                },
                set: function set(value) {
                  this._curveMax = value;
                  this.splineMax = value._internalCurve;
                }
              }]);

              return CurveRange;
            }(), _class2$14.Mode = Mode, _temp$n)) || _class$1k));
            CCClass.fastDefine('cc.CurveRange', CurveRange, {
              multiplier: 1,
              constantMax: 0,
              constantMin: 0,
              constant: 0,
              mode: Mode.Constant,
              splineMax: Object.freeze(constructLegacyCurveAndConvert()),
              splineMin: Object.freeze(constructLegacyCurveAndConvert()),
              spline: Object.freeze(constructLegacyCurveAndConvert())
            });
            setClassAttr(CurveRange, 'multiplier', 'visible', true);
            setClassAttr(CurveRange, 'constantMax', 'visible', true);
            setClassAttr(CurveRange, 'constantMin', 'visible', true);
            setClassAttr(CurveRange, 'constant', 'visible', true);
            setClassAttr(CurveRange, 'mode', 'type', 'Enum');
            setClassAttr(CurveRange, 'mode', 'enumList', Enum.getList(Mode));
            setClassAttr(CurveRange, 'mode', 'visible', true);
            setClassAttr(CurveRange, 'splineMax', 'type', 'Object');
            setClassAttr(CurveRange, 'splineMax', 'ctor', RealCurve);
            setClassAttr(CurveRange, 'splineMax', 'visible', true);
            setClassAttr(CurveRange, 'splineMin', 'type', 'Object');
            setClassAttr(CurveRange, 'splineMin', 'ctor', RealCurve);
            setClassAttr(CurveRange, 'splineMin', 'visible', true);
            setClassAttr(CurveRange, 'spline', 'type', 'Object');
            setClassAttr(CurveRange, 'spline', 'ctor', RealCurve);
            setClassAttr(CurveRange, 'spline', 'visible', true);

            function evaluateCurve(cr, time, index) {
              switch (cr.mode) {
                case Mode.Constant:
                  return cr.constant;

                case Mode.Curve:
                  return cr.spline.evaluate(time) * cr.multiplier;

                case Mode.TwoCurves:
                  return index === 0 ? cr.splineMin.evaluate(time) * cr.multiplier : cr.splineMax.evaluate(time) * cr.multiplier;

                case Mode.TwoConstants:
                  return index === 0 ? cr.constantMin : cr.constantMax;

                default:
                  return 0;
              }
            }

            function evaluateHeight(cr) {
              switch (cr.mode) {
                case Mode.TwoConstants:
                  return 2;

                case Mode.TwoCurves:
                  return 2;

                default:
                  return 1;
              }
            }

            function packTexture(data, width, height) {
              var image = new ImageAsset({
                width: width,
                height: height,
                _data: data,
                _compressed: false,
                format: PixelFormat.RGBA32F
              });
              var texture = new Texture2D();
              texture.setFilters(Filter$1.NEAREST, Filter$1.NEAREST);
              texture.setMipFilter(Filter$1.NONE);
              texture.setWrapMode(WrapMode$1.CLAMP_TO_EDGE, WrapMode$1.CLAMP_TO_EDGE, WrapMode$1.CLAMP_TO_EDGE);
              texture.image = image;
              return texture;
            }

            function updateTexture(tex, data, width, height) {
              if (tex === null || width !== tex.width || height !== tex.height) {
                if (tex) {
                  tex.destroy();
                }

                tex = packTexture(data, width, height);
              } else {
                tex.uploadData(data);
              }

              return tex;
            }

            function packCurveRangeZ(tex, data, samples, cr, discrete) {
              var height = evaluateHeight(cr);
              var len = samples * height * 4;

              if (data === null || data.length !== len) {
                data = new Float32Array(samples * height * 4);
              }

              var interval = 1.0 / (samples - 1);
              var offset = 0;

              for (var h = 0; h < height; h++) {

                for (var j = 0; j < samples; j++) {
                  var value = evaluateCurve(cr, interval * j, h);

                  data[offset + 2] = value;
                  offset += 4;
                }
              }

              return {
                texture: updateTexture(tex, data, samples, height),
                texdata: data
              };
            }
            function packCurveRangeN(tex, data, samples, cr, discrete) {
              var height = evaluateHeight(cr);
              var len = samples * height * 4;

              if (data === null || data.length !== len) {
                data = new Float32Array(samples * height * 4);
              }

              var interval = 1.0 / (samples - 1);
              var sum = 0;
              var average = 0;
              var offset = 0;

              for (var h = 0; h < height; h++) {
                sum = 0;

                for (var j = 0; j < samples; j++) {
                  var value = evaluateCurve(cr, interval * j, h);

                  if (discrete) {
                    average = value;
                  } else {
                    sum += value;
                    average = sum / (j + 1);
                  }

                  data[offset] = average;
                  data[offset + 1] = average;
                  data[offset + 2] = average;
                  offset += 4;
                }
              }

              return {
                texture: updateTexture(tex, data, samples, height),
                texdata: data
              };
            }
            function packCurveRangeXY(tex, data, samples, x, y, discrete) {
              var height = Math.max(evaluateHeight(x), evaluateHeight(y));
              var len = samples * height * 4;

              if (data === null || data.length !== len) {
                data = new Float32Array(samples * height * 4);
              }

              var curves = [x, y];
              var interval = 1.0 / (samples - 1);

              for (var h = 0; h < height; h++) {
                for (var i = 0; i < 2; i++) {
                  var cr = curves[i];
                  var sum = 0;
                  var average = 0;

                  for (var j = 0; j < samples; j++) {
                    var value = evaluateCurve(cr, interval * j, h);

                    if (discrete) {
                      average = value;
                    } else {
                      sum += value;
                      average = sum / (j + 1);
                    }

                    data[(h * samples + j) * 4 + i] = average;
                  }
                }
              }

              return {
                texture: updateTexture(tex, data, samples, height),
                texdata: data
              };
            }
            function packCurveRangeXYZ(tex, data, samples, x, y, z, discrete) {
              var height = Math.max(evaluateHeight(x), evaluateHeight(y), evaluateHeight(z));
              var len = samples * height * 4;

              if (data === null || data.length !== len) {
                data = new Float32Array(samples * height * 4);
              }

              var curves = [x, y, z];
              var interval = 1.0 / (samples - 1);

              for (var h = 0; h < height; h++) {
                for (var i = 0; i < 3; i++) {
                  var cr = curves[i];
                  var sum = 0;
                  var average = 0;

                  for (var j = 0; j < samples; j++) {
                    var value = evaluateCurve(cr, interval * j, h);

                    if (discrete) {
                      average = value;
                    } else {
                      sum += value;
                      average = sum / (j + 1);
                    }

                    data[(h * samples + j) * 4 + i] = average;
                  }
                }
              }

              return {
                texture: updateTexture(tex, data, samples, height),
                texdata: data
              };
            }
            function packCurveRangeXYZW(tex, data, samples, x, y, z, w, discrete) {
              var height = Math.max(evaluateHeight(x), evaluateHeight(y), evaluateHeight(z), evaluateHeight(w));
              var len = samples * height * 4;

              if (data === null || data.length !== len) {
                data = new Float32Array(samples * height * 4);
              }

              var curves = [x, y, z, w];
              var interval = 1.0 / (samples - 1);

              for (var h = 0; h < height; h++) {
                for (var i = 0; i < 4; i++) {
                  var cr = curves[i];
                  var sum = 0;
                  var average = 0;

                  for (var j = 0; j < samples; j++) {
                    var value = evaluateCurve(cr, interval * j, h);

                    if (discrete) {
                      average = value;
                    } else {
                      sum += value;
                      average = sum / (j + 1);
                    }

                    data[(h * samples + j) * 4 + i] = average;
                  }
                }
              }

              return {
                texture: updateTexture(tex, data, samples, height),
                texdata: data
              };
            }

            var Mode$1 = Enum({
              Blend: 0,
              Fixed: 1
            });
            var ColorKey = exports('ColorKey', function ColorKey() {
              this.color = Color$1.WHITE.clone();
              this.time = 0;
            });
            CCClass.fastDefine('cc.ColorKey', ColorKey, {
              color: Color$1.WHITE.clone(),
              time: 0
            });
            CCClass.Attr.setClassAttr(ColorKey, 'color', 'visible', true);
            CCClass.Attr.setClassAttr(ColorKey, 'time', 'visible', true);
            var AlphaKey = exports('AlphaKey', function AlphaKey() {
              this.alpha = 1;
              this.time = 0;
            });
            CCClass.fastDefine('cc.AlphaKey', AlphaKey, {
              alpha: 1,
              time: 0
            });
            CCClass.Attr.setClassAttr(AlphaKey, 'alpha', 'visible', true);
            CCClass.Attr.setClassAttr(AlphaKey, 'time', 'visible', true);

            var Gradient = exports('Gradient', function () {
              function Gradient() {
                this.colorKeys = new Array();
                this.alphaKeys = new Array();
                this.mode = Mode$1.Blend;
                this._color = void 0;
                this._color = Color$1.WHITE.clone();
              }

              var _proto = Gradient.prototype;

              _proto.setKeys = function setKeys(colorKeys, alphaKeys) {
                this.colorKeys = colorKeys;
                this.alphaKeys = alphaKeys;
              };

              _proto.sortKeys = function sortKeys() {
                if (this.colorKeys.length > 1) {
                  this.colorKeys.sort(function (a, b) {
                    return a.time - b.time;
                  });
                }

                if (this.alphaKeys.length > 1) {
                  this.alphaKeys.sort(function (a, b) {
                    return a.time - b.time;
                  });
                }
              };

              _proto.evaluate = function evaluate(time) {
                this.getRGB(time);

                this._color._set_a_unsafe(this.getAlpha(time));

                return this._color;
              };

              _proto.randomColor = function randomColor() {
                var c = this.colorKeys[Math.trunc(Math.random() * this.colorKeys.length)];
                var a = this.alphaKeys[Math.trunc(Math.random() * this.alphaKeys.length)];

                this._color.set(c.color);

                this._color._set_a_unsafe(a.alpha);

                return this._color;
              };

              _proto.getRGB = function getRGB(time) {
                if (this.colorKeys.length > 1) {
                  time = repeat$2(time, 1.0 + EPSILON$2);

                  for (var i = 1; i < this.colorKeys.length; ++i) {
                    var preTime = this.colorKeys[i - 1].time;
                    var curTime = this.colorKeys[i].time;

                    if (time >= preTime && time < curTime) {
                      if (this.mode === Mode$1.Fixed) {
                        return this.colorKeys[i].color;
                      }

                      var factor = (time - preTime) / (curTime - preTime);
                      Color$1.lerp(this._color, this.colorKeys[i - 1].color, this.colorKeys[i].color, factor);
                      return this._color;
                    }
                  }

                  var lastIndex = this.colorKeys.length - 1;

                  if (approx(time, this.colorKeys[lastIndex].time, EPSILON$2)) {
                    this._color.set(this.colorKeys[lastIndex].color);
                  } else if (time < this.colorKeys[0].time) {
                    Color$1.lerp(this._color, Color$1.BLACK, this.colorKeys[0].color, time / this.colorKeys[0].time);
                  } else if (time > this.colorKeys[lastIndex].time) {
                    Color$1.lerp(this._color, this.colorKeys[lastIndex].color, Color$1.BLACK, (time - this.colorKeys[lastIndex].time) / (1 - this.colorKeys[lastIndex].time));
                  }

                  return this._color;
                } else if (this.colorKeys.length === 1) {
                  this._color.set(this.colorKeys[0].color);

                  return this._color;
                } else {
                  this._color.set(Color$1.WHITE);

                  return this._color;
                }
              };

              _proto.getAlpha = function getAlpha(time) {
                var basicAlpha = 0;

                if (this.alphaKeys.length > 1) {
                  time = repeat$2(time, 1.0 + EPSILON$2);

                  for (var i = 1; i < this.alphaKeys.length; ++i) {
                    var preTime = this.alphaKeys[i - 1].time;
                    var curTime = this.alphaKeys[i].time;

                    if (time >= preTime && time < curTime) {
                      if (this.mode === Mode$1.Fixed) {
                        return this.alphaKeys[i].alpha;
                      }

                      var factor = (time - preTime) / (curTime - preTime);
                      return lerp(this.alphaKeys[i - 1].alpha, this.alphaKeys[i].alpha, factor);
                    }
                  }

                  var lastIndex = this.alphaKeys.length - 1;

                  if (approx(time, this.alphaKeys[lastIndex].time, EPSILON$2)) {
                    return this.alphaKeys[lastIndex].alpha;
                  } else if (time < this.alphaKeys[0].time) {
                    return lerp(basicAlpha, this.alphaKeys[0].alpha, time / this.alphaKeys[0].time);
                  } else if (time > this.alphaKeys[lastIndex].time) {
                    return lerp(this.alphaKeys[lastIndex].alpha, basicAlpha, (time - this.alphaKeys[lastIndex].time) / (1 - this.alphaKeys[lastIndex].time));
                  }

                  return 255;
                } else if (this.alphaKeys.length === 1) {
                  return this.alphaKeys[0].alpha;
                } else {
                  return 255;
                }
              };

              return Gradient;
            }());

            Gradient.Mode = Mode$1;
            CCClass.fastDefine('cc.Gradient', Gradient, {
              colorKeys: [],
              alphaKeys: [],
              mode: Mode$1.Blend
            });
            CCClass.Attr.setClassAttr(Gradient, 'colorKeys', 'visible', true);
            CCClass.Attr.setClassAttr(Gradient, 'alphaKeys', 'visible', true);
            CCClass.Attr.setClassAttr(Gradient, 'mode', 'visible', true);

            var _dec$1i, _dec2$U, _dec3$B, _dec4$l, _dec5$g, _dec6$e, _class$1l, _class2$15, _initializer$10, _initializer2$Q, _initializer3$C, _initializer4$x, _initializer5$p, _initializer6$k, _initializer7$f, _class3$f, _temp$o;
            var SerializableTable$1 = EDITOR ;
            var Mode$2 = Enum({
              Color: 0,
              Gradient: 1,
              TwoColors: 2,
              TwoGradients: 3,
              RandomColor: 4
            });
            var GradientRange = exports('GradientRange', (_dec$1i = ccclass$p('cc.GradientRange'), _dec2$U = type$8(Mode$2), _dec3$B = type$8(Gradient), _dec4$l = type$8(Gradient), _dec5$g = type$8(Gradient), _dec6$e = type$8(Mode$2), _dec$1i(_class$1l = (_class2$15 = (_temp$o = _class3$f = function () {
              function GradientRange() {
                this.color = _initializer$10 && _initializer$10();
                this.colorMin = _initializer2$Q && _initializer2$Q();
                this.colorMax = _initializer3$C && _initializer3$C();
                this.gradient = _initializer4$x && _initializer4$x();
                this.gradientMin = _initializer5$p && _initializer5$p();
                this.gradientMax = _initializer6$k && _initializer6$k();
                this._mode = _initializer7$f && _initializer7$f();
                this._color = Color$1.WHITE.clone();
              }

              var _proto = GradientRange.prototype;

              _proto.evaluate = function evaluate(time, rndRatio) {
                switch (this._mode) {
                  case Mode$2.Color:
                    return this.color;

                  case Mode$2.TwoColors:
                    Color$1.lerp(this._color, this.colorMin, this.colorMax, rndRatio);
                    return this._color;

                  case Mode$2.RandomColor:
                    return this.gradient.randomColor();

                  case Mode$2.Gradient:
                    return this.gradient.evaluate(time);

                  case Mode$2.TwoGradients:
                    Color$1.lerp(this._color, this.gradientMin.evaluate(time), this.gradientMax.evaluate(time), rndRatio);
                    return this._color;

                  default:
                    return this.color;
                }
              };

              _proto._onBeforeSerialize = function _onBeforeSerialize(props) {
                return SerializableTable$1[this._mode];
              };

              _createClass(GradientRange, [{
                key: "mode",
                get: function get() {
                  return this._mode;
                },
                set: function set(m) {

                  this._mode = m;
                }
              }]);

              return GradientRange;
            }(), _class3$f.Mode = Mode$2, _temp$o), (_applyDecoratedDescriptor(_class2$15.prototype, "mode", [_dec2$U], Object.getOwnPropertyDescriptor(_class2$15.prototype, "mode"), _class2$15.prototype), _initializer$10 = applyDecoratedInitializer(_class2$15.prototype, "color", [serializable$j], function () {
              return Color$1.WHITE.clone();
            }), _initializer2$Q = applyDecoratedInitializer(_class2$15.prototype, "colorMin", [serializable$j], function () {
              return Color$1.WHITE.clone();
            }), _initializer3$C = applyDecoratedInitializer(_class2$15.prototype, "colorMax", [serializable$j], function () {
              return Color$1.WHITE.clone();
            }), _initializer4$x = applyDecoratedInitializer(_class2$15.prototype, "gradient", [_dec3$B], function () {
              return new Gradient();
            }), _initializer5$p = applyDecoratedInitializer(_class2$15.prototype, "gradientMin", [_dec4$l], function () {
              return new Gradient();
            }), _initializer6$k = applyDecoratedInitializer(_class2$15.prototype, "gradientMax", [_dec5$g], function () {
              return new Gradient();
            }), _initializer7$f = applyDecoratedInitializer(_class2$15.prototype, "_mode", [_dec6$e], function () {
              return Mode$2.Color;
            })), _class2$15)) || _class$1l));

            function evaluateGradient(gr, time, index) {
              switch (gr.mode) {
                case Mode$2.Color:
                  return gr.color;

                case Mode$2.TwoColors:
                  return index === 0 ? gr.colorMin : gr.colorMax;

                case Mode$2.RandomColor:
                  return gr.gradient.randomColor();

                case Mode$2.Gradient:
                  return gr.gradient.evaluate(time);

                case Mode$2.TwoGradients:
                  return index === 0 ? gr.gradientMin.evaluate(time) : gr.gradientMax.evaluate(time);

                default:
                  return gr.color;
              }
            }

            function evaluateHeight$1(gr) {
              switch (gr.mode) {
                case Mode$2.TwoColors:
                  return 2;

                case Mode$2.TwoGradients:
                  return 2;

                default:
                  return 1;
              }
            }

            function packGradientRange(tex, data, samples, gr) {
              var height = evaluateHeight$1(gr);
              var len = samples * height * 4;

              if (data === null || data.length !== len) {
                data = new Uint8Array(samples * height * 4);
              }

              var interval = 1.0 / (samples - 1);
              var offset = 0;

              for (var h = 0; h < height; h++) {
                for (var j = 0; j < samples; j++) {
                  var color = evaluateGradient(gr, interval * j, h);
                  data[offset] = color.r;
                  data[offset + 1] = color.g;
                  data[offset + 2] = color.b;
                  data[offset + 3] = color.a;
                  offset += 4;
                }
              }

              if (tex === null || samples !== tex.width || height !== tex.height) {
                if (tex) {
                  tex.destroy();
                }

                tex = new Texture2D();
                tex.create(samples, height, PixelFormat.RGBA8888);
                tex.setFilters(Filter$1.LINEAR, Filter$1.LINEAR);
                tex.setWrapMode(WrapMode$1.CLAMP_TO_EDGE, WrapMode$1.CLAMP_TO_EDGE);
              }

              tex.uploadData(data);
              return {
                texture: tex,
                texdata: data
              };
            }

            var _dec$1j, _dec2$V, _dec3$C, _dec4$m, _dec5$h, _dec6$f, _dec7$c, _dec8$8, _dec9$7, _dec10$3, _class$1m, _class2$16, _initializer$11, _initializer2$R, _initializer3$D, _initializer4$y, _initializer5$q, _initializer6$l, _initializer7$g, _initializer8$e;
            var CC_USE_WORLD_SPACE = 'CC_USE_WORLD_SPACE';
            var define = {
              CC_USE_WORLD_SPACE: false,
              CC_USE_WORLD_SCALE: true
            };
            var Line = exports('Line', (_dec$1j = ccclass$p('cc.Line'), _dec2$V = type$8(Texture2D), _dec3$C = type$8(Texture2D), _dec4$m = type$8(Material), _dec5$h = type$8([Vec3]), _dec6$f = type$8([Vec3]), _dec7$c = type$8(CurveRange), _dec8$8 = type$8(GradientRange), _dec9$7 = type$8(Vec2), _dec10$3 = type$8(Vec2), _dec$1j(_class$1m = (_class2$16 = function (_ModelRenderer) {
              _inheritsLoose(Line, _ModelRenderer);

              function Line() {
                var _this;

                _this = _ModelRenderer.call(this) || this;
                _this._texture = _initializer$11 && _initializer$11();
                _this._material = _initializer2$R && _initializer2$R();
                _this._worldSpace = _initializer3$D && _initializer3$D();
                _this._positions = _initializer4$y && _initializer4$y();
                _this._width = _initializer5$q && _initializer5$q();
                _this._color = _initializer6$l && _initializer6$l();
                _this._tile = _initializer7$g && _initializer7$g();
                _this._tile_offset = new Vec4();
                _this._offset = _initializer8$e && _initializer8$e();
                return _this;
              }

              var _proto = Line.prototype;

              _proto.onLoad = function onLoad() {
                var model = legacyCC.director.root.createModel(LineModel);

                if (this._models.length === 0) {
                  this._models.push(model);
                } else {
                  this._models[0] = model;
                }

                model.node = model.transform = this.node;

                if (this._material) {
                  this.lineMaterial = this._material;
                  this._material = null;
                }

                if (this.lineMaterial === null) {
                  var mat = builtinResMgr.get('default-trail-material');
                  this.material = mat;
                }

                var matIns = this.getMaterialInstance(0);

                if (matIns) {
                  define[CC_USE_WORLD_SPACE] = this.worldSpace;
                  matIns.recompileShaders(define);
                  model.updateMaterial(matIns);
                }

                model.setCapacity(100);
              };

              _proto.onEnable = function onEnable() {
                _ModelRenderer.prototype.onEnable.call(this);

                if (this._models.length === 0 || !this._models[0]) {
                  return;
                }

                this._attachToScene();

                this.texture = this._texture;
                this.tile = this._tile;
                this.offset = this._offset;
                var lineModel = this._models[0];
                lineModel.addLineVertexData(this._positions, this.width, this.color);
              };

              _proto.onDisable = function onDisable() {
                if (this._models.length > 0 && this._models[0]) {
                  this._detachFromScene();
                }
              };

              _proto._attachToScene = function _attachToScene() {
                _ModelRenderer.prototype._attachToScene.call(this);

                if (this._models.length > 0 && this._models[0] && this.node && this.node.scene) {
                  var lineModel = this._models[0];

                  if (lineModel.scene) {
                    this._detachFromScene();
                  }

                  this._getRenderScene().addModel(lineModel);
                }
              };

              _proto._detachFromScene = function _detachFromScene() {
                _ModelRenderer.prototype._detachFromScene.call(this);

                if (this._models.length > 0 && this._models[0]) {
                  var lineModel = this._models[0];

                  if (lineModel.scene) {
                    lineModel.scene.removeModel(lineModel);
                  }
                }
              };

              _proto._onMaterialModified = function _onMaterialModified(index, material) {
                _ModelRenderer.prototype._onMaterialModified.call(this, index, material);

                var matIns = this.getMaterialInstance(0);

                if (matIns) {
                  define[CC_USE_WORLD_SPACE] = this.worldSpace;
                  matIns.recompileShaders(define);

                  if (this._models[0]) {
                    var lineModel = this._models[0];
                    lineModel.updateMaterial(matIns);
                  }
                }
              };

              _createClass(Line, [{
                key: "texture",
                get: function get() {
                  return this._texture;
                },
                set: function set(val) {
                  this._texture = val;

                  if (this.material) {
                    this.material.setProperty('mainTexture', val);
                  }
                }
              }, {
                key: "lineMaterial",
                get: function get() {
                  return this.getSharedMaterial(0);
                },
                set: function set(val) {
                  this.setMaterial(val, 0);
                }
              }, {
                key: "sharedMaterials",
                get: function get() {
                  return _ModelRenderer.prototype.sharedMaterials;
                },
                set: function set(val) {
                  this.sharedMaterials = val;
                }
              }, {
                key: "worldSpace",
                get: function get() {
                  return this._worldSpace;
                },
                set: function set(val) {
                  this._worldSpace = val;
                  var matIns = this.getMaterialInstance(0);

                  if (matIns) {
                    define[CC_USE_WORLD_SPACE] = this.worldSpace;
                    matIns.recompileShaders(define);

                    if (this._models[0]) {
                      this._models[0].setSubModelMaterial(0, matIns);
                    }
                  }
                }
              }, {
                key: "positions",
                get: function get() {
                  return this._positions;
                },
                set: function set(val) {
                  this._positions = val;

                  if (this._models[0]) {
                    var lineModel = this._models[0];
                    lineModel.addLineVertexData(this._positions, this.width, this.color);
                  }
                }
              }, {
                key: "width",
                get: function get() {
                  return this._width;
                },
                set: function set(val) {
                  this._width = val;

                  if (this._models[0]) {
                    var lineModel = this._models[0];
                    lineModel.addLineVertexData(this._positions, this._width, this._color);
                  }
                }
              }, {
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(val) {
                  this._color = val;

                  if (this._models[0]) {
                    var lineModel = this._models[0];
                    lineModel.addLineVertexData(this._positions, this._width, this._color);
                  }
                }
              }, {
                key: "tile",
                get: function get() {
                  return this._tile;
                },
                set: function set(val) {
                  this._tile.set(val);

                  if (this.material) {
                    this._tile_offset.x = this._tile.x;
                    this._tile_offset.y = this._tile.y;
                    this.material.setProperty('mainTiling_Offset', this._tile_offset);
                  }
                }
              }, {
                key: "offset",
                get: function get() {
                  return this._offset;
                },
                set: function set(val) {
                  this._offset.set(val);

                  if (this.material) {
                    this._tile_offset.z = this._offset.x;
                    this._tile_offset.w = this._offset.y;
                    this.material.setProperty('mainTiling_Offset', this._tile_offset);
                  }
                }
              }]);

              return Line;
            }(ModelRenderer), (_initializer$11 = applyDecoratedInitializer(_class2$16.prototype, "_texture", [_dec2$V], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$16.prototype, "texture", [_dec3$C], Object.getOwnPropertyDescriptor(_class2$16.prototype, "texture"), _class2$16.prototype), _initializer2$R = applyDecoratedInitializer(_class2$16.prototype, "_material", [serializable$j], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$16.prototype, "lineMaterial", [_dec4$m], Object.getOwnPropertyDescriptor(_class2$16.prototype, "lineMaterial"), _class2$16.prototype), _applyDecoratedDescriptor(_class2$16.prototype, "sharedMaterials", [override$1, serializable$j], Object.getOwnPropertyDescriptor(_class2$16.prototype, "sharedMaterials"), _class2$16.prototype), _initializer3$D = applyDecoratedInitializer(_class2$16.prototype, "_worldSpace", [serializable$j], function () {
              return false;
            }), _initializer4$y = applyDecoratedInitializer(_class2$16.prototype, "_positions", [_dec5$h], function () {
              return [];
            }), _applyDecoratedDescriptor(_class2$16.prototype, "positions", [_dec6$f], Object.getOwnPropertyDescriptor(_class2$16.prototype, "positions"), _class2$16.prototype), _applyDecoratedDescriptor(_class2$16.prototype, "width", [_dec7$c], Object.getOwnPropertyDescriptor(_class2$16.prototype, "width"), _class2$16.prototype), _initializer5$q = applyDecoratedInitializer(_class2$16.prototype, "_width", [serializable$j], function () {
              return new CurveRange();
            }), _applyDecoratedDescriptor(_class2$16.prototype, "color", [_dec8$8], Object.getOwnPropertyDescriptor(_class2$16.prototype, "color"), _class2$16.prototype), _initializer6$l = applyDecoratedInitializer(_class2$16.prototype, "_color", [serializable$j], function () {
              return new GradientRange();
            }), _initializer7$g = applyDecoratedInitializer(_class2$16.prototype, "_tile", [serializable$j], function () {
              return new Vec2(1, 1);
            }), _applyDecoratedDescriptor(_class2$16.prototype, "tile", [_dec9$7], Object.getOwnPropertyDescriptor(_class2$16.prototype, "tile"), _class2$16.prototype), _initializer8$e = applyDecoratedInitializer(_class2$16.prototype, "_offset", [serializable$j], function () {
              return new Vec2(0, 0);
            }), _applyDecoratedDescriptor(_class2$16.prototype, "offset", [_dec10$3], Object.getOwnPropertyDescriptor(_class2$16.prototype, "offset"), _class2$16.prototype)), _class2$16)) || _class$1m));

            var Particle = function () {
              function Particle(particleSystem) {
                this.particleSystem = void 0;
                this.position = void 0;
                this.velocity = void 0;
                this.animatedVelocity = void 0;
                this.ultimateVelocity = void 0;
                this.angularVelocity = void 0;
                this.axisOfRotation = void 0;
                this.rotation = void 0;
                this.startEuler = void 0;
                this.startRotation = void 0;
                this.startRotated = void 0;
                this.deltaQuat = void 0;
                this.deltaMat = void 0;
                this.localMat = void 0;
                this.startSize = void 0;
                this.size = void 0;
                this.startColor = void 0;
                this.color = void 0;
                this.randomSeed = void 0;
                this.remainingLifetime = void 0;
                this.loopCount = void 0;
                this.lastLoop = void 0;
                this.trailDelay = void 0;
                this.startLifetime = void 0;
                this.emitAccumulator0 = void 0;
                this.emitAccumulator1 = void 0;
                this.frameIndex = void 0;
                this.startRow = void 0;
                this.particleSystem = particleSystem;
                this.position = new Vec3(0, 0, 0);
                this.velocity = new Vec3(0, 0, 0);
                this.animatedVelocity = new Vec3(0, 0, 0);
                this.ultimateVelocity = new Vec3(0, 0, 0);
                this.angularVelocity = new Vec3(0, 0, 0);
                this.axisOfRotation = new Vec3(0, 0, 0);
                this.rotation = new Vec3(0, 0, 0);
                this.startEuler = new Vec3(0, 0, 0);
                this.startRotation = new Quat();
                this.startRotated = false;
                this.deltaQuat = new Quat();
                this.deltaMat = new Mat4();
                this.localMat = new Mat4();
                this.startSize = new Vec3(0, 0, 0);
                this.size = new Vec3(0, 0, 0);
                this.startColor = Color$1.WHITE.clone();
                this.color = Color$1.WHITE.clone();
                this.randomSeed = 0;
                this.remainingLifetime = 0.0;
                this.loopCount = 0;
                this.lastLoop = 0;
                this.trailDelay = 0;
                this.startLifetime = 0.0;
                this.emitAccumulator0 = 0.0;
                this.emitAccumulator1 = 0.0;
                this.frameIndex = 0.0;
                this.startRow = 0;
              }

              var _proto = Particle.prototype;

              _proto.reset = function reset() {
                this.rotation.set(0, 0, 0);
                this.startEuler.set(0, 0, 0);
                this.startRotation.set(0, 0, 0, 1);
                this.startRotated = false;
                this.deltaQuat.set(0, 0, 0, 1);
                this.deltaMat.identity();
                this.localMat.identity();
              };

              return Particle;
            }();
            Particle.INDENTIFY_NEG_QUAT = 10;
            Particle.R2D = 180.0 / Math.PI;
            var PARTICLE_MODULE_NAME = {
              COLOR: 'colorModule',
              FORCE: 'forceModule',
              LIMIT: 'limitModule',
              ROTATION: 'rotationModule',
              SIZE: 'sizeModule',
              VELOCITY: 'velocityModule',
              TEXTURE: 'textureModule',
              NOISE: 'noiseModule'
            };
            var PARTICLE_MODULE_ORDER = ['sizeModule', 'colorModule', 'forceModule', 'velocityModule', 'limitModule', 'rotationModule', 'textureModule', 'noiseModule'];
            var PARTICLE_MODULE_PROPERTY = ['_colorOverLifetimeModule', '_shapeModule', '_sizeOvertimeModule', '_velocityOvertimeModule', '_forceOvertimeModule', '_limitVelocityOvertimeModule', '_rotationOvertimeModule', '_textureAnimationModule', '_noiseModule', '_trailModule'];
            var ParticleModuleBase = function () {
              function ParticleModuleBase() {
                this.target = null;
                this.needUpdate = false;
                this.needAnimate = true;
                this.name = void 0;
              }

              var _proto2 = ParticleModuleBase.prototype;

              _proto2.bindTarget = function bindTarget(target) {
                this.target = target;
              };

              _proto2.update = function update(space, trans) {};

              return ParticleModuleBase;
            }();

            var Space = Enum({
              World: 0,
              Local: 1,
              Custom: 2
            });
            var CullingMode = Enum({
              Pause: 0,
              PauseAndCatchup: 1,
              AlwaysSimulate: 2
            });
            var AlignmentSpace = Enum({
              World: 0,
              Local: 1,
              View: 2
            });
            var RenderMode$1 = Enum({
              Billboard: 0,
              StrecthedBillboard: 1,
              HorizontalBillboard: 2,
              VerticalBillboard: 3,
              Mesh: 4
            });
            var ShapeType = Enum({
              Box: 0,
              Circle: 1,
              Cone: 2,
              Sphere: 3,
              Hemisphere: 4
            });
            var EmitLocation = Enum({
              Base: 0,
              Edge: 1,
              Shell: 2,
              Volume: 3
            });
            var ArcMode = Enum({
              Random: 0,
              Loop: 1,
              PingPong: 2
            });
            var TrailMode = Enum({
              Particles: 0
            });
            var TextureMode = Enum({
              Stretch: 0
            });
            var ModuleRandSeed = {
              LIMIT: 23541,
              SIZE: 39825,
              TEXTURE: 90794,
              COLOR: 91041,
              FORCE: 212165,
              ROTATION: 125292,
              VELOCITY_X: 197866,
              VELOCITY_Y: 156497,
              VELOCITY_Z: 984136
            };

            var particleEmitZAxis = new Vec3(0, 0, -1);
            function calculateTransform(systemSpace, moduleSpace, worldTransform, outQuat) {
              if (moduleSpace !== systemSpace) {
                if (systemSpace === Space.World) {
                  Mat4.getRotation(outQuat, worldTransform);
                } else {
                  Mat4.invert(worldTransform, worldTransform);
                  Mat4.getRotation(outQuat, worldTransform);
                }

                return true;
              } else {
                Quat.set(outQuat, 0, 0, 0, 1);
                return false;
              }
            }
            function fixedAngleUnitVector2(out, theta) {
              Vec2.set(out, Math.cos(theta), Math.sin(theta));
            }
            function randomUnitVector(out) {
              var z = randomRange(-1, 1);
              var a = randomRange(0, 2 * Math.PI);
              var r = Math.sqrt(1 - z * z);
              var x = r * Math.cos(a);
              var y = r * Math.sin(a);
              Vec3.set(out, x, y, z);
            }
            function randomPointBetweenSphere(out, minRadius, maxRadius) {
              randomUnitVector(out);
              Vec3.multiplyScalar(out, out, minRadius + (maxRadius - minRadius) * random());
            }
            function randomPointBetweenCircleAtFixedAngle(out, minRadius, maxRadius, theta) {
              fixedAngleUnitVector2(out, theta);
              out.z = 0;
              Vec3.multiplyScalar(out, out, minRadius + (maxRadius - minRadius) * random());
            }
            function randomPointInCube(out, extents) {
              Vec3.set(out, randomRange(-extents.x, extents.x), randomRange(-extents.y, extents.y), randomRange(-extents.z, extents.z));
            }
            function randomSortArray(arr) {
              for (var i = 0; i < arr.length; i++) {
                var transpose = i + randomRangeInt(0, arr.length - i);
                var val = arr[transpose];
                arr[transpose] = arr[i];
                arr[i] = val;
              }
            }
            function randomSign() {
              var sgn = randomRange(-1, 1);

              if (sgn === 0) {
                sgn++;
              }

              return sign$1(sgn);
            }
            function isCurveTwoValues(curve) {
              var Mode = CurveRange.Mode;

              switch (curve.mode) {
                case Mode.TwoCurves:
                case Mode.TwoConstants:
                  return true;

                default:
                  return false;
              }
            }
            function isGradientTwoValues(color) {
              var Mode = GradientRange.Mode;

              switch (color.mode) {
                case Mode.TwoGradients:
                case Mode.TwoColors:
                  return true;

                default:
                  return false;
              }
            }

            var _dec$1k, _dec2$W, _class$1n, _class2$17, _initializer$12, _initializer2$S;
            var COLOR_OVERTIME_RAND_OFFSET = ModuleRandSeed.COLOR;
            var ColorOvertimeModule = (_dec$1k = ccclass$p('cc.ColorOvertimeModule'), _dec2$W = type$8(GradientRange), _dec$1k(_class$1n = (_class2$17 = function (_ParticleModuleBase) {
              _inheritsLoose(ColorOvertimeModule, _ParticleModuleBase);

              function ColorOvertimeModule() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _ParticleModuleBase.call.apply(_ParticleModuleBase, [this].concat(args)) || this;
                _this._enable = _initializer$12 && _initializer$12();
                _this.color = _initializer2$S && _initializer2$S();
                _this.name = PARTICLE_MODULE_NAME.COLOR;
                return _this;
              }

              var _proto = ColorOvertimeModule.prototype;

              _proto.animate = function animate(particle) {
                particle.color.set(particle.startColor);
                var rand = isGradientTwoValues(this.color) ? pseudoRandom(particle.randomSeed + COLOR_OVERTIME_RAND_OFFSET) : 0;
                particle.color.multiply(this.color.evaluate(1.0 - particle.remainingLifetime / particle.startLifetime, rand));
              };

              _createClass(ColorOvertimeModule, [{
                key: "enable",
                get: function get() {
                  return this._enable;
                },
                set: function set(val) {
                  if (this._enable === val) return;
                  this._enable = val;
                  if (!this.target) return;
                  this.target.enableModule(this.name, val, this);
                }
              }]);

              return ColorOvertimeModule;
            }(ParticleModuleBase), (_initializer$12 = applyDecoratedInitializer(_class2$17.prototype, "_enable", [serializable$j], function () {
              return false;
            }), _initializer2$S = applyDecoratedInitializer(_class2$17.prototype, "color", [_dec2$W, serializable$j], function () {
              return new GradientRange();
            })), _class2$17)) || _class$1n);

            var _dec$1l, _dec2$X, _dec3$D, _dec4$n, _dec5$i, _class$1o, _class2$18, _initializer$13, _initializer2$T, _initializer3$E, _initializer4$z, _initializer5$r;
            var FORCE_OVERTIME_RAND_OFFSET = ModuleRandSeed.FORCE;

            var _temp_v3 = new Vec3();

            var ForceOvertimeModule = (_dec$1l = ccclass$p('cc.ForceOvertimeModule'), _dec2$X = type$8(CurveRange), _dec3$D = type$8(CurveRange), _dec4$n = type$8(CurveRange), _dec5$i = type$8(Space), _dec$1l(_class$1o = (_class2$18 = function (_ParticleModuleBase) {
              _inheritsLoose(ForceOvertimeModule, _ParticleModuleBase);

              function ForceOvertimeModule() {
                var _this;

                _this = _ParticleModuleBase.call(this) || this;
                _this._enable = _initializer$13 && _initializer$13();
                _this.x = _initializer2$T && _initializer2$T();
                _this.y = _initializer3$E && _initializer3$E();
                _this.z = _initializer4$z && _initializer4$z();
                _this.space = _initializer5$r && _initializer5$r();
                _this.randomized = false;
                _this.rotation = void 0;
                _this.needTransform = void 0;
                _this.name = PARTICLE_MODULE_NAME.FORCE;
                _this.rotation = new Quat();
                _this.needTransform = false;
                _this.needUpdate = true;
                return _this;
              }

              var _proto = ForceOvertimeModule.prototype;

              _proto.update = function update(space, worldTransform) {
                this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
              };

              _proto.animate = function animate(p, dt) {
                var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
                var randX = isCurveTwoValues(this.x) ? pseudoRandom(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET) : 0;
                var randY = isCurveTwoValues(this.y) ? pseudoRandom(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET) : 0;
                var randZ = isCurveTwoValues(this.z) ? pseudoRandom(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET) : 0;
                var force = Vec3.set(_temp_v3, this.x.evaluate(normalizedTime, randX), this.y.evaluate(normalizedTime, randY), this.z.evaluate(normalizedTime, randZ));

                if (this.needTransform) {
                  Vec3.transformQuat(force, force, this.rotation);
                }

                Vec3.scaleAndAdd(p.velocity, p.velocity, force, dt);
                Vec3.copy(p.ultimateVelocity, p.velocity);
              };

              _createClass(ForceOvertimeModule, [{
                key: "enable",
                get: function get() {
                  return this._enable;
                },
                set: function set(val) {
                  if (this._enable === val) return;
                  this._enable = val;
                  if (!this.target) return;
                  this.target.enableModule(this.name, val, this);
                }
              }]);

              return ForceOvertimeModule;
            }(ParticleModuleBase), (_initializer$13 = applyDecoratedInitializer(_class2$18.prototype, "_enable", [serializable$j], function () {
              return false;
            }), _initializer2$T = applyDecoratedInitializer(_class2$18.prototype, "x", [_dec2$X, serializable$j], function () {
              return new CurveRange();
            }), _initializer3$E = applyDecoratedInitializer(_class2$18.prototype, "y", [_dec3$D, serializable$j], function () {
              return new CurveRange();
            }), _initializer4$z = applyDecoratedInitializer(_class2$18.prototype, "z", [_dec4$n, serializable$j], function () {
              return new CurveRange();
            }), _initializer5$r = applyDecoratedInitializer(_class2$18.prototype, "space", [_dec5$i, serializable$j], function () {
              return Space.Local;
            })), _class2$18)) || _class$1o);

            var _dec$1m, _dec2$Y, _dec3$E, _dec4$o, _dec5$j, _dec6$g, _class$1p, _class2$19, _initializer$14, _initializer2$U, _initializer3$F, _initializer4$A, _initializer5$s, _initializer6$m, _initializer7$h, _initializer8$f;
            var LIMIT_VELOCITY_RAND_OFFSET = ModuleRandSeed.LIMIT;

            var _temp_v3$1 = new Vec3();

            var _temp_v3_1 = new Vec3();

            var LimitVelocityOvertimeModule = (_dec$1m = ccclass$p('cc.LimitVelocityOvertimeModule'), _dec2$Y = type$8(CurveRange), _dec3$E = type$8(CurveRange), _dec4$o = type$8(CurveRange), _dec5$j = type$8(CurveRange), _dec6$g = type$8(Space), _dec$1m(_class$1p = (_class2$19 = function (_ParticleModuleBase) {
              _inheritsLoose(LimitVelocityOvertimeModule, _ParticleModuleBase);

              function LimitVelocityOvertimeModule() {
                var _this;

                _this = _ParticleModuleBase.call(this) || this;
                _this._enable = _initializer$14 && _initializer$14();
                _this.limitX = _initializer2$U && _initializer2$U();
                _this.limitY = _initializer3$F && _initializer3$F();
                _this.limitZ = _initializer4$A && _initializer4$A();
                _this.limit = _initializer5$s && _initializer5$s();
                _this.dampen = _initializer6$m && _initializer6$m();
                _this.separateAxes = _initializer7$h && _initializer7$h();
                _this.space = _initializer8$f && _initializer8$f();
                _this.drag = null;
                _this.multiplyDragByParticleSize = false;
                _this.multiplyDragByParticleVelocity = false;
                _this.name = PARTICLE_MODULE_NAME.LIMIT;
                _this.rotation = void 0;
                _this.needTransform = void 0;
                _this.rotation = new Quat();
                _this.needTransform = false;
                _this.needUpdate = true;
                return _this;
              }

              var _proto = LimitVelocityOvertimeModule.prototype;

              _proto.update = function update(space, worldTransform) {
                this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
              };

              _proto.animate = function animate(p, dt) {
                var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
                var dampedVel = _temp_v3$1;

                if (this.separateAxes) {
                  var randX = isCurveTwoValues(this.limitX) ? pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET) : 0;
                  var randY = isCurveTwoValues(this.limitY) ? pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET) : 0;
                  var randZ = isCurveTwoValues(this.limitZ) ? pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET) : 0;
                  Vec3.set(_temp_v3_1, this.limitX.evaluate(normalizedTime, randX), this.limitY.evaluate(normalizedTime, randY), this.limitZ.evaluate(normalizedTime, randZ));

                  if (this.needTransform) {
                    Vec3.transformQuat(_temp_v3_1, _temp_v3_1, this.rotation);
                  }

                  Vec3.set(dampedVel, dampenBeyondLimit(p.ultimateVelocity.x, _temp_v3_1.x, this.dampen), dampenBeyondLimit(p.ultimateVelocity.y, _temp_v3_1.y, this.dampen), dampenBeyondLimit(p.ultimateVelocity.z, _temp_v3_1.z, this.dampen));
                } else {
                  Vec3.normalize(dampedVel, p.ultimateVelocity);
                  var rand = isCurveTwoValues(this.limit) ? pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET) : 0;
                  Vec3.multiplyScalar(dampedVel, dampedVel, dampenBeyondLimit(p.ultimateVelocity.length(), this.limit.evaluate(normalizedTime, rand), this.dampen));
                }

                Vec3.copy(p.ultimateVelocity, dampedVel);
                Vec3.copy(p.velocity, p.ultimateVelocity);
              };

              _createClass(LimitVelocityOvertimeModule, [{
                key: "enable",
                get: function get() {
                  return this._enable;
                },
                set: function set(val) {
                  if (this._enable === val) return;
                  this._enable = val;
                  if (!this.target) return;
                  this.target.enableModule(this.name, val, this);
                }
              }]);

              return LimitVelocityOvertimeModule;
            }(ParticleModuleBase), (_initializer$14 = applyDecoratedInitializer(_class2$19.prototype, "_enable", [serializable$j], function () {
              return false;
            }), _initializer2$U = applyDecoratedInitializer(_class2$19.prototype, "limitX", [_dec2$Y, serializable$j], function () {
              return new CurveRange();
            }), _initializer3$F = applyDecoratedInitializer(_class2$19.prototype, "limitY", [_dec3$E, serializable$j], function () {
              return new CurveRange();
            }), _initializer4$A = applyDecoratedInitializer(_class2$19.prototype, "limitZ", [_dec4$o, serializable$j], function () {
              return new CurveRange();
            }), _initializer5$s = applyDecoratedInitializer(_class2$19.prototype, "limit", [_dec5$j, serializable$j], function () {
              return new CurveRange();
            }), _initializer6$m = applyDecoratedInitializer(_class2$19.prototype, "dampen", [serializable$j], function () {
              return 3;
            }), _initializer7$h = applyDecoratedInitializer(_class2$19.prototype, "separateAxes", [serializable$j], function () {
              return false;
            }), _initializer8$f = applyDecoratedInitializer(_class2$19.prototype, "space", [_dec6$g, serializable$j], function () {
              return Space.Local;
            })), _class2$19)) || _class$1p);

            function dampenBeyondLimit(vel, limit, dampen) {
              var sgn = Math.sign(vel);
              var abs = Math.abs(vel);

              if (abs > limit) {
                var absToGive = abs - abs * dampen;

                if (absToGive > limit) {
                  abs = absToGive;
                } else {
                  abs = limit;
                }
              }

              return abs * sgn;
            }

            var _dec$1n, _dec2$Z, _dec3$F, _dec4$p, _class$1q, _class2$1a, _initializer$15, _initializer2$V, _initializer3$G, _initializer4$B, _initializer5$t;
            var ROTATION_OVERTIME_RAND_OFFSET = ModuleRandSeed.ROTATION;
            var RotationOvertimeModule = (_dec$1n = ccclass$p('cc.RotationOvertimeModule'), _dec2$Z = type$8(CurveRange), _dec3$F = type$8(CurveRange), _dec4$p = type$8(CurveRange), _dec$1n(_class$1q = (_class2$1a = function (_ParticleModuleBase) {
              _inheritsLoose(RotationOvertimeModule, _ParticleModuleBase);

              function RotationOvertimeModule() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _ParticleModuleBase.call.apply(_ParticleModuleBase, [this].concat(args)) || this;
                _this._enable = _initializer$15 && _initializer$15();
                _this._separateAxes = _initializer2$V && _initializer2$V();
                _this.x = _initializer3$G && _initializer3$G();
                _this.y = _initializer4$B && _initializer4$B();
                _this.z = _initializer5$t && _initializer5$t();
                _this.name = PARTICLE_MODULE_NAME.ROTATION;
                _this._startMat = new Mat4();
                _this._matRot = new Mat4();
                _this._quatRot = new Quat();
                _this._otherEuler = new Vec3();
                return _this;
              }

              var _proto = RotationOvertimeModule.prototype;

              _proto._processRotation = function _processRotation(p, r2d) {
                var renderMode = p.particleSystem.processor.getInfo().renderMode;

                if (renderMode !== RenderMode$1.Mesh) {
                  if (renderMode === RenderMode$1.StrecthedBillboard) {
                    this._quatRot.set(0, 0, 0, 1);
                  }
                }

                Quat.normalize(this._quatRot, this._quatRot);

                if (this._quatRot.w < 0.0) {
                  this._quatRot.x += Particle.INDENTIFY_NEG_QUAT;
                }
              };

              _proto.animate = function animate(p, dt) {
                var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
                var randZ = isCurveTwoValues(this.z) ? pseudoRandom(p.randomSeed + ROTATION_OVERTIME_RAND_OFFSET) : 0;
                var renderMode = p.particleSystem.processor.getInfo().renderMode;

                if (!this._separateAxes || renderMode === RenderMode$1.VerticalBillboard || renderMode === RenderMode$1.HorizontalBillboard) {
                  Quat.fromEuler(p.deltaQuat, 0, 0, this.z.evaluate(normalizedTime, randZ) * dt * Particle.R2D);
                } else {
                  var randX = isCurveTwoValues(this.x) ? pseudoRandom(p.randomSeed + ROTATION_OVERTIME_RAND_OFFSET) : 0;
                  var randY = isCurveTwoValues(this.y) ? pseudoRandom(p.randomSeed + ROTATION_OVERTIME_RAND_OFFSET) : 0;
                  Quat.fromEuler(p.deltaQuat, this.x.evaluate(normalizedTime, randX) * dt * Particle.R2D, this.y.evaluate(normalizedTime, randY) * dt * Particle.R2D, this.z.evaluate(normalizedTime, randZ) * dt * Particle.R2D);
                }

                p.deltaMat = Mat4.fromQuat(p.deltaMat, p.deltaQuat);
                p.localMat = p.localMat.multiply(p.deltaMat);

                if (!p.startRotated) {
                  if (renderMode !== RenderMode$1.Mesh) {
                    if (renderMode === RenderMode$1.StrecthedBillboard) {
                      p.startEuler.set(0, 0, 0);
                    } else if (renderMode !== RenderMode$1.Billboard) {
                      p.startEuler.set(0, 0, p.startEuler.z);
                    }
                  }

                  Quat.fromEuler(p.startRotation, p.startEuler.x * Particle.R2D, p.startEuler.y * Particle.R2D, p.startEuler.z * Particle.R2D);
                  p.startRotated = true;
                }

                this._startMat = Mat4.fromQuat(this._startMat, p.startRotation);
                this._matRot = this._startMat.multiply(p.localMat);
                Mat4.getRotation(this._quatRot, this._matRot);

                this._processRotation(p, Particle.R2D);

                p.rotation.set(this._quatRot.x, this._quatRot.y, this._quatRot.z);
              };

              _createClass(RotationOvertimeModule, [{
                key: "enable",
                get: function get() {
                  return this._enable;
                },
                set: function set(val) {
                  if (this._enable === val) return;
                  this._enable = val;
                  if (!this.target) return;
                  this.target.enableModule(this.name, val, this);
                }
              }, {
                key: "separateAxes",
                get: function get() {
                  return this._separateAxes;
                },
                set: function set(val) {
                  this._separateAxes = val;
                }
              }]);

              return RotationOvertimeModule;
            }(ParticleModuleBase), (_initializer$15 = applyDecoratedInitializer(_class2$1a.prototype, "_enable", [serializable$j], function () {
              return false;
            }), _initializer2$V = applyDecoratedInitializer(_class2$1a.prototype, "_separateAxes", [serializable$j], function () {
              return false;
            }), _initializer3$G = applyDecoratedInitializer(_class2$1a.prototype, "x", [_dec2$Z, serializable$j], function () {
              return new CurveRange();
            }), _initializer4$B = applyDecoratedInitializer(_class2$1a.prototype, "y", [_dec3$F, serializable$j], function () {
              return new CurveRange();
            }), _initializer5$t = applyDecoratedInitializer(_class2$1a.prototype, "z", [_dec4$p, serializable$j], function () {
              return new CurveRange();
            })), _class2$1a)) || _class$1q);

            var _dec$1o, _dec2$_, _dec3$G, _dec4$q, _dec5$k, _class$1r, _class2$1b, _initializer$16, _initializer2$W, _initializer3$H, _initializer4$C, _initializer5$u, _initializer6$n;
            var SIZE_OVERTIME_RAND_OFFSET = ModuleRandSeed.SIZE;
            var SizeOvertimeModule = (_dec$1o = ccclass$p('cc.SizeOvertimeModule'), _dec2$_ = type$8(CurveRange), _dec3$G = type$8(CurveRange), _dec4$q = type$8(CurveRange), _dec5$k = type$8(CurveRange), _dec$1o(_class$1r = (_class2$1b = function (_ParticleModuleBase) {
              _inheritsLoose(SizeOvertimeModule, _ParticleModuleBase);

              function SizeOvertimeModule() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _ParticleModuleBase.call.apply(_ParticleModuleBase, [this].concat(args)) || this;
                _this._enable = _initializer$16 && _initializer$16();
                _this.separateAxes = _initializer2$W && _initializer2$W();
                _this.size = _initializer3$H && _initializer3$H();
                _this.x = _initializer4$C && _initializer4$C();
                _this.y = _initializer5$u && _initializer5$u();
                _this.z = _initializer6$n && _initializer6$n();
                _this.name = PARTICLE_MODULE_NAME.SIZE;
                return _this;
              }

              var _proto = SizeOvertimeModule.prototype;

              _proto.animate = function animate(particle, dt) {
                if (!this.separateAxes) {
                  var rand = isCurveTwoValues(this.size) ? pseudoRandom(particle.randomSeed + SIZE_OVERTIME_RAND_OFFSET) : 0;
                  Vec3.multiplyScalar(particle.size, particle.startSize, this.size.evaluate(1 - particle.remainingLifetime / particle.startLifetime, rand));
                } else {
                  var currLifetime = 1 - particle.remainingLifetime / particle.startLifetime;
                  var randX = isCurveTwoValues(this.x) ? pseudoRandom(particle.randomSeed + SIZE_OVERTIME_RAND_OFFSET) : 0;
                  var randY = isCurveTwoValues(this.y) ? pseudoRandom(particle.randomSeed + SIZE_OVERTIME_RAND_OFFSET) : 0;
                  var randZ = isCurveTwoValues(this.z) ? pseudoRandom(particle.randomSeed + SIZE_OVERTIME_RAND_OFFSET) : 0;
                  particle.size.x = particle.startSize.x * this.x.evaluate(currLifetime, randX);
                  particle.size.y = particle.startSize.y * this.y.evaluate(currLifetime, randY);
                  particle.size.z = particle.startSize.z * this.z.evaluate(currLifetime, randZ);
                }
              };

              _createClass(SizeOvertimeModule, [{
                key: "enable",
                get: function get() {
                  return this._enable;
                },
                set: function set(val) {
                  if (this._enable === val) return;
                  this._enable = val;
                  if (!this.target) return;
                  this.target.enableModule(this.name, val, this);
                }
              }]);

              return SizeOvertimeModule;
            }(ParticleModuleBase), (_initializer$16 = applyDecoratedInitializer(_class2$1b.prototype, "_enable", [serializable$j], function () {
              return false;
            }), _initializer2$W = applyDecoratedInitializer(_class2$1b.prototype, "separateAxes", [serializable$j], function () {
              return false;
            }), _initializer3$H = applyDecoratedInitializer(_class2$1b.prototype, "size", [_dec2$_, serializable$j], function () {
              return new CurveRange();
            }), _initializer4$C = applyDecoratedInitializer(_class2$1b.prototype, "x", [_dec3$G, serializable$j], function () {
              return new CurveRange();
            }), _initializer5$u = applyDecoratedInitializer(_class2$1b.prototype, "y", [_dec4$q, serializable$j], function () {
              return new CurveRange();
            }), _initializer6$n = applyDecoratedInitializer(_class2$1b.prototype, "z", [_dec5$k, serializable$j], function () {
              return new CurveRange();
            })), _class2$1b)) || _class$1r);

            var _dec$1p, _dec2$$, _dec3$H, _dec4$r, _dec5$l, _dec6$h, _dec7$d, _dec8$9, _class$1s, _class2$1c, _initializer$17, _initializer2$X, _initializer3$I, _initializer4$D, _initializer5$v, _initializer6$o, _initializer7$i, _initializer8$g, _initializer9$d, _initializer10$c, _initializer11$8, _initializer12$8, _initializer13$8;
            var TEXTURE_ANIMATION_RAND_OFFSET = ModuleRandSeed.TEXTURE;
            var Mode$3 = Enum({
              Grid: 0
            });
            var Animation$2 = Enum({
              WholeSheet: 0,
              SingleRow: 1
            });
            var TextureAnimationModule = (_dec$1p = ccclass$p('cc.TextureAnimationModule'), _dec2$$ = formerlySerializedAs$3('numTilesX'), _dec3$H = formerlySerializedAs$3('numTilesY'), _dec4$r = type$8(Mode$3), _dec5$l = type$8(Mode$3), _dec6$h = type$8(Animation$2), _dec7$d = type$8(CurveRange), _dec8$9 = type$8(CurveRange), _dec$1p(_class$1s = (_class2$1c = function (_ParticleModuleBase) {
              _inheritsLoose(TextureAnimationModule, _ParticleModuleBase);

              function TextureAnimationModule() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _ParticleModuleBase.call.apply(_ParticleModuleBase, [this].concat(args)) || this;
                _this._enable = _initializer$17 && _initializer$17();
                _this._numTilesX = _initializer2$X && _initializer2$X();
                _this._numTilesY = _initializer3$I && _initializer3$I();
                _this._mode = _initializer4$D && _initializer4$D();
                _this.animation = _initializer5$v && _initializer5$v();
                _this.frameOverTime = _initializer6$o && _initializer6$o();
                _this.startFrame = _initializer7$i && _initializer7$i();
                _this.cycleCount = _initializer8$g && _initializer8$g();
                _this._flipU = _initializer9$d && _initializer9$d();
                _this._flipV = _initializer10$c && _initializer10$c();
                _this._uvChannelMask = _initializer11$8 && _initializer11$8();
                _this.randomRow = _initializer12$8 && _initializer12$8();
                _this.rowIndex = _initializer13$8 && _initializer13$8();
                _this.name = PARTICLE_MODULE_NAME.TEXTURE;
                return _this;
              }

              var _proto = TextureAnimationModule.prototype;

              _proto.init = function init(p) {
                p.startRow = Math.floor(Math.random() * this.numTilesY);
              };

              _proto.animate = function animate(p, dt) {
                var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
                var randStart = isCurveTwoValues(this.startFrame) ? pseudoRandom(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET) : 0;
                var randFrame = isCurveTwoValues(this.frameOverTime) ? pseudoRandom(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET) : 0;
                var startFrame = this.startFrame.evaluate(normalizedTime, randStart) / (this.numTilesX * this.numTilesY);

                if (this.animation === Animation$2.WholeSheet) {
                  p.frameIndex = repeat$2(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, randFrame) + startFrame), 1);
                } else if (this.animation === Animation$2.SingleRow) {
                  var rowLength = 1 / this.numTilesY;

                  if (this.randomRow) {
                    var f = repeat$2(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, randFrame) + startFrame), 1);
                    var from = p.startRow * rowLength;
                    var to = from + rowLength;
                    p.frameIndex = lerp(from, to, f);
                  } else {
                    var _from = this.rowIndex * rowLength;

                    var _to = _from + rowLength;

                    p.frameIndex = lerp(_from, _to, repeat$2(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, randFrame) + startFrame), 1));
                  }
                }
              };

              _createClass(TextureAnimationModule, [{
                key: "enable",
                get: function get() {
                  return this._enable;
                },
                set: function set(val) {
                  if (this._enable === val) return;
                  this._enable = val;
                  if (!this.target) return;
                  this.target.updateMaterialParams();
                  this.target.enableModule(this.name, val, this);
                }
              }, {
                key: "mode",
                get: function get() {
                  return this._mode;
                },
                set: function set(val) {
                  if (val !== Mode$3.Grid) {
                    console.error('particle texture animation\'s sprites is not supported!');
                  }
                }
              }, {
                key: "numTilesX",
                get: function get() {
                  return this._numTilesX;
                },
                set: function set(val) {
                  if (this._numTilesX !== val) {
                    this._numTilesX = val;
                    this.target.updateMaterialParams();
                  }
                }
              }, {
                key: "numTilesY",
                get: function get() {
                  return this._numTilesY;
                },
                set: function set(val) {
                  if (this._numTilesY !== val) {
                    this._numTilesY = val;
                    this.target.updateMaterialParams();
                  }
                }
              }, {
                key: "flipU",
                get: function get() {
                  return this._flipU;
                },
                set: function set(val) {
                  console.error('particle texture animation\'s flipU is not supported!');
                }
              }, {
                key: "flipV",
                get: function get() {
                  return this._flipV;
                },
                set: function set(val) {
                  console.error('particle texture animation\'s flipV is not supported!');
                }
              }, {
                key: "uvChannelMask",
                get: function get() {
                  return this._uvChannelMask;
                },
                set: function set(val) {
                  console.error('particle texture animation\'s uvChannelMask is not supported!');
                }
              }]);

              return TextureAnimationModule;
            }(ParticleModuleBase), (_initializer$17 = applyDecoratedInitializer(_class2$1c.prototype, "_enable", [serializable$j], function () {
              return false;
            }), _initializer2$X = applyDecoratedInitializer(_class2$1c.prototype, "_numTilesX", [_dec2$$], function () {
              return 0;
            }), _initializer3$I = applyDecoratedInitializer(_class2$1c.prototype, "_numTilesY", [_dec3$H], function () {
              return 0;
            }), _initializer4$D = applyDecoratedInitializer(_class2$1c.prototype, "_mode", [_dec4$r], function () {
              return Mode$3.Grid;
            }), _applyDecoratedDescriptor(_class2$1c.prototype, "mode", [_dec5$l], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "mode"), _class2$1c.prototype), _initializer5$v = applyDecoratedInitializer(_class2$1c.prototype, "animation", [_dec6$h, serializable$j], function () {
              return Animation$2.WholeSheet;
            }), _initializer6$o = applyDecoratedInitializer(_class2$1c.prototype, "frameOverTime", [_dec7$d, serializable$j], function () {
              return new CurveRange();
            }), _initializer7$i = applyDecoratedInitializer(_class2$1c.prototype, "startFrame", [_dec8$9, serializable$j], function () {
              return new CurveRange();
            }), _initializer8$g = applyDecoratedInitializer(_class2$1c.prototype, "cycleCount", [serializable$j], function () {
              return 0;
            }), _initializer9$d = applyDecoratedInitializer(_class2$1c.prototype, "_flipU", [serializable$j], function () {
              return 0;
            }), _initializer10$c = applyDecoratedInitializer(_class2$1c.prototype, "_flipV", [serializable$j], function () {
              return 0;
            }), _initializer11$8 = applyDecoratedInitializer(_class2$1c.prototype, "_uvChannelMask", [serializable$j], function () {
              return -1;
            }), _initializer12$8 = applyDecoratedInitializer(_class2$1c.prototype, "randomRow", [serializable$j], function () {
              return false;
            }), _initializer13$8 = applyDecoratedInitializer(_class2$1c.prototype, "rowIndex", [serializable$j], function () {
              return 0;
            })), _class2$1c)) || _class$1s);

            var _dec$1q, _dec2$10, _dec3$I, _dec4$s, _dec5$m, _dec6$i, _class$1t, _class2$1d, _initializer$18, _initializer2$Y, _initializer3$J, _initializer4$E, _initializer5$w, _initializer6$p;
            var VELOCITY_X_OVERTIME_RAND_OFFSET = ModuleRandSeed.VELOCITY_X;
            var VELOCITY_Y_OVERTIME_RAND_OFFSET = ModuleRandSeed.VELOCITY_Y;
            var VELOCITY_Z_OVERTIME_RAND_OFFSET = ModuleRandSeed.VELOCITY_Z;

            var _temp_v3$2 = new Vec3();

            var VelocityOvertimeModule = (_dec$1q = ccclass$p('cc.VelocityOvertimeModule'), _dec2$10 = type$8(CurveRange), _dec3$I = type$8(CurveRange), _dec4$s = type$8(CurveRange), _dec5$m = type$8(CurveRange), _dec6$i = type$8(Space), _dec$1q(_class$1t = (_class2$1d = function (_ParticleModuleBase) {
              _inheritsLoose(VelocityOvertimeModule, _ParticleModuleBase);

              function VelocityOvertimeModule() {
                var _this;

                _this = _ParticleModuleBase.call(this) || this;
                _this._enable = _initializer$18 && _initializer$18();
                _this.x = _initializer2$Y && _initializer2$Y();
                _this.y = _initializer3$J && _initializer3$J();
                _this.z = _initializer4$E && _initializer4$E();
                _this.speedModifier = _initializer5$w && _initializer5$w();
                _this.space = _initializer6$p && _initializer6$p();
                _this.rotation = void 0;
                _this.needTransform = void 0;
                _this.name = PARTICLE_MODULE_NAME.VELOCITY;
                _this.rotation = new Quat();
                _this.speedModifier.constant = 1;
                _this.needTransform = false;
                _this.needUpdate = true;
                return _this;
              }

              var _proto = VelocityOvertimeModule.prototype;

              _proto.update = function update(space, worldTransform) {
                this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
              };

              _proto.animate = function animate(p, dt) {
                var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
                var randX = isCurveTwoValues(this.x) ? pseudoRandom(p.randomSeed ^ VELOCITY_X_OVERTIME_RAND_OFFSET) : 0;
                var randY = isCurveTwoValues(this.y) ? pseudoRandom(p.randomSeed ^ VELOCITY_Y_OVERTIME_RAND_OFFSET) : 0;
                var randZ = isCurveTwoValues(this.z) ? pseudoRandom(p.randomSeed ^ VELOCITY_Z_OVERTIME_RAND_OFFSET) : 0;
                var randSpeed = isCurveTwoValues(this.speedModifier) ? pseudoRandom(p.randomSeed + VELOCITY_X_OVERTIME_RAND_OFFSET) : 0;
                var vel = Vec3.set(_temp_v3$2, this.x.evaluate(normalizedTime, randX), this.y.evaluate(normalizedTime, randY), this.z.evaluate(normalizedTime, randZ));

                if (this.needTransform) {
                  Vec3.transformQuat(vel, vel, this.rotation);
                }

                Vec3.add(p.animatedVelocity, p.animatedVelocity, vel);
                Vec3.add(p.ultimateVelocity, p.velocity, p.animatedVelocity);
                Vec3.multiplyScalar(p.ultimateVelocity, p.ultimateVelocity, this.speedModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, randSpeed));
              };

              _createClass(VelocityOvertimeModule, [{
                key: "enable",
                get: function get() {
                  return this._enable;
                },
                set: function set(val) {
                  if (this._enable === val) return;
                  this._enable = val;
                  if (!this.target) return;
                  this.target.enableModule(this.name, val, this);
                }
              }]);

              return VelocityOvertimeModule;
            }(ParticleModuleBase), (_initializer$18 = applyDecoratedInitializer(_class2$1d.prototype, "_enable", [serializable$j], function () {
              return false;
            }), _initializer2$Y = applyDecoratedInitializer(_class2$1d.prototype, "x", [_dec2$10, serializable$j], function () {
              return new CurveRange();
            }), _initializer3$J = applyDecoratedInitializer(_class2$1d.prototype, "y", [_dec3$I, serializable$j], function () {
              return new CurveRange();
            }), _initializer4$E = applyDecoratedInitializer(_class2$1d.prototype, "z", [_dec4$s, serializable$j], function () {
              return new CurveRange();
            }), _initializer5$w = applyDecoratedInitializer(_class2$1d.prototype, "speedModifier", [_dec5$m, serializable$j], function () {
              return new CurveRange();
            }), _initializer6$p = applyDecoratedInitializer(_class2$1d.prototype, "space", [_dec6$i, serializable$j], function () {
              return Space.Local;
            })), _class2$1d)) || _class$1t);

            var _dec$1r, _dec2$11, _class$1u, _class2$1e, _initializer$19, _initializer2$Z, _initializer3$K, _initializer4$F;
            var Burst = exports('Burst', (_dec$1r = ccclass$p('cc.Burst'), _dec2$11 = type$8(CurveRange), _dec$1r(_class$1u = (_class2$1e = function () {
              function Burst() {
                this._time = _initializer$19 && _initializer$19();
                this._repeatCount = _initializer2$Z && _initializer2$Z();
                this.repeatInterval = _initializer3$K && _initializer3$K();
                this.count = _initializer4$F && _initializer4$F();
                this._remainingCount = void 0;
                this._curTime = void 0;
                this._remainingCount = 0;
                this._curTime = 0.0;
              }

              var _proto = Burst.prototype;

              _proto.update = function update(psys, dt) {
                if (this._remainingCount === 0) {
                  this._remainingCount = this._repeatCount;
                  this._curTime = this._time;
                }

                if (this._remainingCount > 0) {
                  var preFrameTime = repeat$2(psys._time - psys.startDelay.evaluate(0, 1), psys.duration) - dt;
                  preFrameTime = preFrameTime > 0.0 ? preFrameTime : 0.0;
                  var curFrameTime = repeat$2(psys.time - psys.startDelay.evaluate(0, 1), psys.duration);

                  if (this._curTime >= preFrameTime && this._curTime < curFrameTime) {
                    psys.emit(this.count.evaluate(this._curTime / psys.duration, 1), dt - (curFrameTime - this._curTime));
                    this._curTime += this.repeatInterval;
                    --this._remainingCount;
                  }
                }
              };

              _proto.reset = function reset() {
                this._remainingCount = 0;
                this._curTime = 0.0;
              };

              _proto.getMaxCount = function getMaxCount(psys) {
                return this.count.getMax() * Math.min(Math.ceil(psys.duration / this.repeatInterval), this.repeatCount);
              };

              _createClass(Burst, [{
                key: "time",
                get: function get() {
                  return this._time;
                },
                set: function set(val) {
                  this._time = val;
                  this._curTime = val;
                }
              }, {
                key: "repeatCount",
                get: function get() {
                  return this._repeatCount;
                },
                set: function set(val) {
                  this._repeatCount = val;
                  this._remainingCount = val;
                }
              }]);

              return Burst;
            }(), (_initializer$19 = applyDecoratedInitializer(_class2$1e.prototype, "_time", [serializable$j], function () {
              return 0;
            }), _initializer2$Z = applyDecoratedInitializer(_class2$1e.prototype, "_repeatCount", [serializable$j], function () {
              return 1;
            }), _initializer3$K = applyDecoratedInitializer(_class2$1e.prototype, "repeatInterval", [serializable$j], function () {
              return 1;
            }), _initializer4$F = applyDecoratedInitializer(_class2$1e.prototype, "count", [_dec2$11, serializable$j], function () {
              return new CurveRange();
            })), _class2$1e)) || _class$1u));

            var _dec$1s, _dec2$12, _dec3$J, _dec4$t, _dec5$n, _dec6$j, _dec7$e, _class$1v, _class2$1f, _initializer$1a, _initializer2$_, _initializer3$L, _initializer4$G, _initializer5$x, _initializer6$q, _initializer7$j, _initializer8$h, _initializer9$e, _initializer10$d, _initializer11$9, _initializer12$9, _initializer13$9, _initializer14$6, _initializer15$6, _initializer16$6, _initializer17$5, _initializer18$4, _initializer19$4;

            var _intermediVec = new Vec3(0, 0, 0);

            var _intermediArr = [];

            var _unitBoxExtent = new Vec3(0.5, 0.5, 0.5);

            var ShapeModule = (_dec$1s = ccclass$p('cc.ShapeModule'), _dec2$12 = type$8(ShapeType), _dec3$J = formerlySerializedAs$3('shapeType'), _dec4$t = type$8(ShapeType), _dec5$n = type$8(EmitLocation), _dec6$j = type$8(ArcMode), _dec7$e = type$8(CurveRange), _dec$1s(_class$1v = (_class2$1f = function () {
              function ShapeModule() {
                this._enable = _initializer$1a && _initializer$1a();
                this._shapeType = _initializer2$_ && _initializer2$_();
                this.emitFrom = _initializer3$L && _initializer3$L();
                this.alignToDirection = _initializer4$G && _initializer4$G();
                this.randomDirectionAmount = _initializer5$x && _initializer5$x();
                this.sphericalDirectionAmount = _initializer6$q && _initializer6$q();
                this.randomPositionAmount = _initializer7$j && _initializer7$j();
                this.radius = _initializer8$h && _initializer8$h();
                this.radiusThickness = _initializer9$e && _initializer9$e();
                this.arcMode = _initializer10$d && _initializer10$d();
                this.arcSpread = _initializer11$9 && _initializer11$9();
                this.arcSpeed = _initializer12$9 && _initializer12$9();
                this.length = _initializer13$9 && _initializer13$9();
                this.boxThickness = _initializer14$6 && _initializer14$6();
                this._position = _initializer15$6 && _initializer15$6();
                this._rotation = _initializer16$6 && _initializer16$6();
                this._scale = _initializer17$5 && _initializer17$5();
                this._arc = _initializer18$4 && _initializer18$4();
                this._angle = _initializer19$4 && _initializer19$4();
                this.mat = void 0;
                this.quat = void 0;
                this.particleSystem = void 0;
                this.lastTime = void 0;
                this.totalAngle = void 0;
                this.mat = new Mat4();
                this.quat = new Quat();
                this.particleSystem = null;
                this.lastTime = 0;
                this.totalAngle = 0;
              }

              var _proto = ShapeModule.prototype;

              _proto.onInit = function onInit(ps) {
                this.particleSystem = ps;
                this.constructMat();
                this.lastTime = this.particleSystem._time;
              };

              _proto.emit = function emit(p) {
                switch (this.shapeType) {
                  case ShapeType.Box:
                    boxEmit(this.emitFrom, this.boxThickness, p.position, p.velocity);
                    break;

                  case ShapeType.Circle:
                    circleEmit(this.radius, this.radiusThickness, this.generateArcAngle(), p.position, p.velocity);
                    break;

                  case ShapeType.Cone:
                    coneEmit(this.emitFrom, this.radius, this.radiusThickness, this.generateArcAngle(), this._angle, this.length, p.position, p.velocity);
                    break;

                  case ShapeType.Sphere:
                    sphereEmit(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
                    break;

                  case ShapeType.Hemisphere:
                    hemisphereEmit(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
                    break;

                  default:
                    console.warn(this.shapeType + " shapeType is not supported by ShapeModule.");
                }

                if (this.randomPositionAmount > 0) {
                  p.position.x += randomRange(-this.randomPositionAmount, this.randomPositionAmount);
                  p.position.y += randomRange(-this.randomPositionAmount, this.randomPositionAmount);
                  p.position.z += randomRange(-this.randomPositionAmount, this.randomPositionAmount);
                }

                Vec3.transformQuat(p.velocity, p.velocity, this.quat);
                Vec3.transformMat4(p.position, p.position, this.mat);

                if (this.sphericalDirectionAmount > 0) {
                  var sphericalVel = Vec3.normalize(_intermediVec, p.position);
                  Vec3.lerp(p.velocity, p.velocity, sphericalVel, this.sphericalDirectionAmount);
                }

                this.lastTime = this.particleSystem._time;
              };

              _proto.constructMat = function constructMat() {
                Quat.fromEuler(this.quat, this._rotation.x, this._rotation.y, this._rotation.z);
                Mat4.fromRTS(this.mat, this.quat, this._position, this._scale);
              };

              _proto.generateArcAngle = function generateArcAngle() {
                if (this.arcMode === ArcMode.Random) {
                  return randomRange(0, this._arc);
                }

                var angle = this.totalAngle + 2 * Math.PI * this.arcSpeed.evaluate(this.particleSystem._time, 1) * (this.particleSystem._time - this.lastTime);
                this.totalAngle = angle;

                if (this.arcSpread !== 0) {
                  angle = Math.floor(angle / (this._arc * this.arcSpread)) * this._arc * this.arcSpread;
                }

                switch (this.arcMode) {
                  case ArcMode.Loop:
                    return repeat$2(angle, this._arc);

                  case ArcMode.PingPong:
                    return pingPong(angle, this._arc);

                  default:
                    return repeat$2(angle, this._arc);
                }
              };

              _createClass(ShapeModule, [{
                key: "position",
                get: function get() {
                  return this._position;
                },
                set: function set(val) {
                  this._position = val;
                  this.constructMat();
                }
              }, {
                key: "rotation",
                get: function get() {
                  return this._rotation;
                },
                set: function set(val) {
                  this._rotation = val;
                  this.constructMat();
                }
              }, {
                key: "scale",
                get: function get() {
                  return this._scale;
                },
                set: function set(val) {
                  this._scale = val;
                  this.constructMat();
                }
              }, {
                key: "arc",
                get: function get() {
                  return toDegree(this._arc);
                },
                set: function set(val) {
                  this._arc = toRadian(val);
                }
              }, {
                key: "angle",
                get: function get() {
                  return Math.round(toDegree(this._angle) * 100) / 100;
                },
                set: function set(val) {
                  this._angle = toRadian(val);
                }
              }, {
                key: "enable",
                get: function get() {
                  return this._enable;
                },
                set: function set(val) {
                  this._enable = val;
                }
              }, {
                key: "shapeType",
                get: function get() {
                  return this._shapeType;
                },
                set: function set(val) {
                  this._shapeType = val;

                  switch (this._shapeType) {
                    case ShapeType.Box:
                      if (this.emitFrom === EmitLocation.Base) {
                        this.emitFrom = EmitLocation.Volume;
                      }

                      break;

                    case ShapeType.Cone:
                      if (this.emitFrom === EmitLocation.Edge) {
                        this.emitFrom = EmitLocation.Base;
                      }

                      break;

                    case ShapeType.Sphere:
                    case ShapeType.Hemisphere:
                      if (this.emitFrom === EmitLocation.Base || this.emitFrom === EmitLocation.Edge) {
                        this.emitFrom = EmitLocation.Volume;
                      }

                      break;
                  }
                }
              }]);

              return ShapeModule;
            }(), (_initializer$1a = applyDecoratedInitializer(_class2$1f.prototype, "_enable", [serializable$j], function () {
              return false;
            }), _initializer2$_ = applyDecoratedInitializer(_class2$1f.prototype, "_shapeType", [_dec2$12, _dec3$J], function () {
              return ShapeType.Cone;
            }), _applyDecoratedDescriptor(_class2$1f.prototype, "shapeType", [_dec4$t], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "shapeType"), _class2$1f.prototype), _initializer3$L = applyDecoratedInitializer(_class2$1f.prototype, "emitFrom", [_dec5$n, serializable$j], function () {
              return EmitLocation.Volume;
            }), _initializer4$G = applyDecoratedInitializer(_class2$1f.prototype, "alignToDirection", [serializable$j], function () {
              return false;
            }), _initializer5$x = applyDecoratedInitializer(_class2$1f.prototype, "randomDirectionAmount", [serializable$j], function () {
              return 0;
            }), _initializer6$q = applyDecoratedInitializer(_class2$1f.prototype, "sphericalDirectionAmount", [serializable$j], function () {
              return 0;
            }), _initializer7$j = applyDecoratedInitializer(_class2$1f.prototype, "randomPositionAmount", [serializable$j], function () {
              return 0;
            }), _initializer8$h = applyDecoratedInitializer(_class2$1f.prototype, "radius", [serializable$j], function () {
              return 1;
            }), _initializer9$e = applyDecoratedInitializer(_class2$1f.prototype, "radiusThickness", [serializable$j], function () {
              return 1;
            }), _initializer10$d = applyDecoratedInitializer(_class2$1f.prototype, "arcMode", [_dec6$j, serializable$j], function () {
              return ArcMode.Random;
            }), _initializer11$9 = applyDecoratedInitializer(_class2$1f.prototype, "arcSpread", [serializable$j], function () {
              return 0;
            }), _initializer12$9 = applyDecoratedInitializer(_class2$1f.prototype, "arcSpeed", [_dec7$e, serializable$j], function () {
              return new CurveRange();
            }), _initializer13$9 = applyDecoratedInitializer(_class2$1f.prototype, "length", [serializable$j], function () {
              return 5;
            }), _initializer14$6 = applyDecoratedInitializer(_class2$1f.prototype, "boxThickness", [serializable$j], function () {
              return new Vec3(0, 0, 0);
            }), _initializer15$6 = applyDecoratedInitializer(_class2$1f.prototype, "_position", [serializable$j], function () {
              return new Vec3(0, 0, 0);
            }), _initializer16$6 = applyDecoratedInitializer(_class2$1f.prototype, "_rotation", [serializable$j], function () {
              return new Vec3(0, 0, 0);
            }), _initializer17$5 = applyDecoratedInitializer(_class2$1f.prototype, "_scale", [serializable$j], function () {
              return new Vec3(1, 1, 1);
            }), _initializer18$4 = applyDecoratedInitializer(_class2$1f.prototype, "_arc", [serializable$j], function () {
              return toRadian(360);
            }), _initializer19$4 = applyDecoratedInitializer(_class2$1f.prototype, "_angle", [serializable$j], function () {
              return toRadian(25);
            })), _class2$1f)) || _class$1v);

            function sphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
              switch (emitFrom) {
                case EmitLocation.Volume:
                  randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius);
                  Vec3.normalize(dir, pos);
                  break;

                case EmitLocation.Shell:
                  randomUnitVector(pos);
                  Vec3.multiplyScalar(pos, pos, radius);
                  Vec3.normalize(dir, pos);
                  break;

                default:
                  console.warn(emitFrom + " is not supported for sphere emitter.");
              }
            }

            function hemisphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
              switch (emitFrom) {
                case EmitLocation.Volume:
                  randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius);

                  if (pos.z > 0) {
                    pos.z *= -1;
                  }

                  Vec3.normalize(dir, pos);
                  break;

                case EmitLocation.Shell:
                  randomUnitVector(pos);
                  Vec3.multiplyScalar(pos, pos, radius);

                  if (pos.z > 0) {
                    pos.z *= -1;
                  }

                  Vec3.normalize(dir, pos);
                  break;

                default:
                  console.warn(emitFrom + " is not supported for hemisphere emitter.");
              }
            }

            function coneEmit(emitFrom, radius, radiusThickness, theta, angle, length, pos, dir) {
              switch (emitFrom) {
                case EmitLocation.Base:
                  randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta);
                  Vec2.multiplyScalar(dir, pos, Math.sin(angle));
                  dir.z = -Math.cos(angle) * radius;
                  Vec3.normalize(dir, dir);
                  pos.z = 0;
                  break;

                case EmitLocation.Shell:
                  fixedAngleUnitVector2(pos, theta);
                  Vec2.multiplyScalar(dir, pos, Math.sin(angle));
                  dir.z = -Math.cos(angle);
                  Vec3.normalize(dir, dir);
                  Vec2.multiplyScalar(pos, pos, radius);
                  pos.z = 0;
                  break;

                case EmitLocation.Volume:
                  randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta);
                  Vec2.multiplyScalar(dir, pos, Math.sin(angle));
                  dir.z = -Math.cos(angle) * radius;
                  Vec3.normalize(dir, dir);
                  pos.z = 0;
                  Vec3.add(pos, pos, Vec3.multiplyScalar(_intermediVec, dir, length * random() / -dir.z));
                  break;

                default:
                  console.warn(emitFrom + " is not supported for cone emitter.");
              }
            }

            function boxEmit(emitFrom, boxThickness, pos, dir) {
              switch (emitFrom) {
                case EmitLocation.Volume:
                  randomPointInCube(pos, _unitBoxExtent);
                  break;

                case EmitLocation.Shell:
                  _intermediArr.splice(0, _intermediArr.length);

                  _intermediArr.push(randomRange(-0.5, 0.5));

                  _intermediArr.push(randomRange(-0.5, 0.5));

                  _intermediArr.push(randomSign() * 0.5);

                  randomSortArray(_intermediArr);
                  applyBoxThickness(_intermediArr, boxThickness);
                  Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
                  break;

                case EmitLocation.Edge:
                  _intermediArr.splice(0, _intermediArr.length);

                  _intermediArr.push(randomRange(-0.5, 0.5));

                  _intermediArr.push(randomSign() * 0.5);

                  _intermediArr.push(randomSign() * 0.5);

                  randomSortArray(_intermediArr);
                  applyBoxThickness(_intermediArr, boxThickness);
                  Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
                  break;

                default:
                  console.warn(emitFrom + " is not supported for box emitter.");
              }

              Vec3.copy(dir, particleEmitZAxis);
            }

            function circleEmit(radius, radiusThickness, theta, pos, dir) {
              randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta);
              Vec3.normalize(dir, pos);
            }

            function applyBoxThickness(pos, thickness) {
              if (thickness.x > 0) {
                pos[0] += 0.5 * randomRange(-thickness.x, thickness.x);
                pos[0] = clamp$1(pos[0], -0.5, 0.5);
              }

              if (thickness.y > 0) {
                pos[1] += 0.5 * randomRange(-thickness.y, thickness.y);
                pos[1] = clamp$1(pos[1], -0.5, 0.5);
              }

              if (thickness.z > 0) {
                pos[2] += 0.5 * randomRange(-thickness.z, thickness.z);
                pos[2] = clamp$1(pos[2], -0.5, 0.5);
              }
            }

            var _uvs$1 = [0, 0, 1, 0, 0, 1, 1, 1];
            var _uvs_ins = [0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0];

            var ParticleBatchModel = function (_scene$Model) {
              _inheritsLoose(ParticleBatchModel, _scene$Model);

              function ParticleBatchModel() {
                var _this;

                _this = _scene$Model.call(this) || this;
                _this._capacity = void 0;
                _this._vertAttrs = void 0;
                _this._vertAttribSize = void 0;
                _this._vBuffer = void 0;
                _this._vertAttrsFloatCount = void 0;
                _this._vdataF32 = void 0;
                _this._vdataUint32 = void 0;
                _this._iaInfo = void 0;
                _this._iaInfoBuffer = void 0;
                _this._subMeshData = void 0;
                _this._mesh = void 0;
                _this._vertCount = 0;
                _this._indexCount = 0;
                _this._startTimeOffset = 0;
                _this._lifeTimeOffset = 0;
                _this._material = null;
                _this._vertAttribSizeStatic = void 0;
                _this._vertStaticAttrsFloatCount = void 0;
                _this._insBuffers = void 0;
                _this._insIndices = void 0;
                _this._useInstance = void 0;

                _this.type = ModelType.PARTICLE_BATCH;
                _this._capacity = 0;
                _this._vertAttrs = null;
                _this._vertAttribSize = 0;
                _this._vBuffer = null;
                _this._vertAttrsFloatCount = 0;
                _this._vdataF32 = null;
                _this._vdataUint32 = null;
                _this._vertAttribSizeStatic = 0;
                _this._vertStaticAttrsFloatCount = 0;
                _this._insBuffers = [];
                _this._insIndices = null;

                if (!deviceManager.gfxDevice.hasFeature(Feature.INSTANCED_ARRAYS)) {
                  _this._useInstance = false;
                } else {
                  _this._useInstance = true;
                }

                _this._iaInfo = new IndirectBuffer([new DrawInfo()]);
                _this._iaInfoBuffer = _this._device.createBuffer(new BufferInfo(BufferUsageBit.INDIRECT, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, DRAW_INFO_SIZE, DRAW_INFO_SIZE));
                _this._subMeshData = null;
                _this._mesh = null;
                return _this;
              }

              var _proto = ParticleBatchModel.prototype;

              _proto.setCapacity = function setCapacity(capacity) {
                var capChanged = this._capacity !== capacity;
                this._capacity = capacity;

                if (this._subMeshData && capChanged) {
                  this.rebuild();
                }
              };

              _proto.setVertexAttributes = function setVertexAttributes(mesh, attrs) {
                if (!this._useInstance) {
                  if (this._mesh === mesh && this._vertAttrs === attrs) {
                    return;
                  }

                  this._mesh = mesh;
                  this._vertAttrs = attrs;
                  this._vertAttribSize = 0;

                  for (var _iterator = _createForOfIteratorHelperLoose(this._vertAttrs), _step; !(_step = _iterator()).done;) {
                    var a = _step.value;
                    a.offset = this._vertAttribSize;
                    this._vertAttribSize += FormatInfos[a.format].size;
                  }

                  this._vertAttrsFloatCount = this._vertAttribSize / 4;
                  this.rebuild();
                } else {
                  this.setVertexAttributesIns(mesh, attrs);
                }
              };

              _proto.setVertexAttributesIns = function setVertexAttributesIns(mesh, attrs) {
                if (this._mesh === mesh && this._vertAttrs === attrs) {
                  return;
                }

                this._mesh = mesh;
                this._vertAttrs = attrs;
                this._vertAttribSize = 0;
                this._vertAttribSizeStatic = 0;

                for (var _iterator2 = _createForOfIteratorHelperLoose(this._vertAttrs), _step2; !(_step2 = _iterator2()).done;) {
                  var a = _step2.value;

                  if (a.stream === 0) {
                    a.offset = this._vertAttribSize;
                    this._vertAttribSize += FormatInfos[a.format].size;
                  } else if (a.stream === 1) {
                    a.offset = this._vertAttribSizeStatic;
                    this._vertAttribSizeStatic += FormatInfos[a.format].size;
                  }
                }

                this._vertAttrsFloatCount = this._vertAttribSize / 4;
                this._vertStaticAttrsFloatCount = this._vertAttribSizeStatic / 4;
                this.rebuild();
              };

              _proto.createSubMeshData = function createSubMeshData() {
                this.destroySubMeshData();
                this._vertCount = 4;
                this._indexCount = 6;

                if (this._mesh) {
                  this._vertCount = this._mesh.struct.vertexBundles[this._mesh.struct.primitives[0].vertexBundelIndices[0]].view.count;
                  this._indexCount = this._mesh.struct.primitives[0].indexView.count;
                }

                var vertexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, this._vertAttribSize * this._capacity * this._vertCount, this._vertAttribSize));

                var vBuffer = new ArrayBuffer(this._vertAttribSize * this._capacity * this._vertCount);

                if (this._mesh && this._capacity > 0) {
                  var vOffset = this._vertAttrs[this._vertAttrs.findIndex(function (val) {
                    return val.name === AttributeName.ATTR_TEX_COORD;
                  })].offset;

                  this._mesh.copyAttribute(0, AttributeName.ATTR_TEX_COORD, vBuffer, this._vertAttribSize, vOffset);

                  var vIdx = this._vertAttrs.findIndex(function (val) {
                    return val.name === AttributeName.ATTR_TEX_COORD3;
                  });

                  vOffset = this._vertAttrs[vIdx++].offset;

                  this._mesh.copyAttribute(0, AttributeName.ATTR_POSITION, vBuffer, this._vertAttribSize, vOffset);

                  vOffset = this._vertAttrs[vIdx++].offset;

                  this._mesh.copyAttribute(0, AttributeName.ATTR_NORMAL, vBuffer, this._vertAttribSize, vOffset);

                  vOffset = this._vertAttrs[vIdx++].offset;

                  if (!this._mesh.copyAttribute(0, AttributeName.ATTR_COLOR, vBuffer, this._vertAttribSize, vOffset)) {
                    var vb = new Uint32Array(vBuffer);

                    for (var iVertex = 0; iVertex < this._vertCount; ++iVertex) {
                      vb[iVertex * this._vertAttrsFloatCount + vOffset / 4] = Color$1.WHITE._val;
                    }
                  }

                  var vbFloatArray = new Float32Array(vBuffer);

                  for (var i = 1; i < this._capacity; i++) {
                    vbFloatArray.copyWithin(i * this._vertAttribSize * this._vertCount / 4, 0, this._vertAttribSize * this._vertCount / 4);
                  }
                }

                vertexBuffer.update(vBuffer);
                var indices = new Uint16Array(this._capacity * this._indexCount);

                if (this._mesh && this._capacity > 0) {
                  this._mesh.copyIndices(0, indices);

                  for (var _i = 1; _i < this._capacity; _i++) {
                    for (var j = 0; j < this._indexCount; j++) {
                      indices[_i * this._indexCount + j] = indices[j] + _i * this._vertCount;
                    }
                  }
                } else {
                  var dst = 0;

                  for (var _i2 = 0; _i2 < this._capacity; ++_i2) {
                    var baseIdx = 4 * _i2;
                    indices[dst++] = baseIdx;
                    indices[dst++] = baseIdx + 1;
                    indices[dst++] = baseIdx + 2;
                    indices[dst++] = baseIdx + 3;
                    indices[dst++] = baseIdx + 2;
                    indices[dst++] = baseIdx + 1;
                  }
                }

                var indexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, this._capacity * this._indexCount * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));

                indexBuffer.update(indices);
                this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount;
                this._iaInfo.drawInfos[0].indexCount = this._capacity * this._indexCount;

                if (!this._iaInfoBuffer) {
                  this._iaInfoBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDIRECT, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, DRAW_INFO_SIZE, DRAW_INFO_SIZE));
                }

                this._iaInfoBuffer.update(this._iaInfo);

                this._subMeshData = new RenderingSubMesh([vertexBuffer], this._vertAttrs, PrimitiveMode.TRIANGLE_LIST, indexBuffer, this._iaInfoBuffer);
                this.initSubModel(0, this._subMeshData, this._material);
                return vBuffer;
              };

              _proto.createSubMeshDataInsDynamic = function createSubMeshDataInsDynamic() {
                this._insBuffers.length = 0;
                this.destroySubMeshData();

                var vertexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, this._vertAttribSize * this._capacity, this._vertAttribSize));

                var vBuffer = new ArrayBuffer(this._vertAttribSize * this._capacity);
                vertexBuffer.update(vBuffer);

                this._insBuffers.push(vertexBuffer);

                return vBuffer;
              };

              _proto.createSubMeshDataInsStatic = function createSubMeshDataInsStatic() {
                this._vertCount = 4;
                this._indexCount = 6;

                if (this._mesh) {
                  this._vertCount = this._mesh.struct.vertexBundles[this._mesh.struct.primitives[0].vertexBundelIndices[0]].view.count;
                  this._indexCount = this._mesh.struct.primitives[0].indexView.count;
                }

                var vertexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, this._vertAttribSizeStatic * this._vertCount, this._vertAttribSizeStatic));

                var vBuffer = new ArrayBuffer(this._vertAttribSizeStatic * this._vertCount);

                if (this._mesh) {
                  var vIdx = this._vertAttrs.findIndex(function (val) {
                    return val.name === AttributeName.ATTR_TEX_COORD;
                  });

                  var vOffset = this._vertAttrs[vIdx].offset;

                  this._mesh.copyAttribute(0, AttributeName.ATTR_TEX_COORD, vBuffer, this._vertAttribSizeStatic, vOffset);

                  vIdx = this._vertAttrs.findIndex(function (val) {
                    return val.name === AttributeName.ATTR_TEX_COORD3;
                  });
                  vOffset = this._vertAttrs[vIdx++].offset;

                  this._mesh.copyAttribute(0, AttributeName.ATTR_POSITION, vBuffer, this._vertAttribSizeStatic, vOffset);

                  vOffset = this._vertAttrs[vIdx++].offset;

                  this._mesh.copyAttribute(0, AttributeName.ATTR_NORMAL, vBuffer, this._vertAttribSizeStatic, vOffset);

                  vOffset = this._vertAttrs[vIdx++].offset;

                  if (!this._mesh.copyAttribute(0, AttributeName.ATTR_COLOR, vBuffer, this._vertAttribSizeStatic, vOffset)) {
                    var vb = new Uint32Array(vBuffer);

                    for (var iVertex = 0; iVertex < this._vertCount; ++iVertex) {
                      vb[iVertex * this._vertStaticAttrsFloatCount + vOffset / 4] = Color$1.WHITE._val;
                    }
                  }
                } else {
                  var vbFloatArray = new Float32Array(vBuffer);

                  for (var i = 0; i < _uvs_ins.length; ++i) {
                    vbFloatArray[i] = _uvs_ins[i];
                  }
                }

                vertexBuffer.update(vBuffer);
                var indices = new Uint16Array(this._indexCount);

                if (this._mesh) {
                  this._mesh.copyIndices(0, indices);
                } else {
                  indices[0] = 0;
                  indices[1] = 1;
                  indices[2] = 2;
                  indices[3] = 3;
                  indices[4] = 2;
                  indices[5] = 1;
                }

                var indexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, this._indexCount * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));

                indexBuffer.update(indices);
                this._insIndices = indexBuffer;
                this._iaInfo.drawInfos[0].vertexCount = this._vertCount;
                this._iaInfo.drawInfos[0].indexCount = this._indexCount;

                if (!this._iaInfoBuffer) {
                  this._iaInfoBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDIRECT, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, DRAW_INFO_SIZE, DRAW_INFO_SIZE));
                }

                this._iaInfoBuffer.update(this._iaInfo);

                this._insBuffers.push(vertexBuffer);
              };

              _proto.createInsSubmesh = function createInsSubmesh() {
                this._subMeshData = new RenderingSubMesh(this._insBuffers, this._vertAttrs, PrimitiveMode.TRIANGLE_LIST, this._insIndices, this._iaInfoBuffer);
                this.initSubModel(0, this._subMeshData, this._material);
              };

              _proto.updateMaterial = function updateMaterial(mat) {
                this._material = mat;
                this.setSubModelMaterial(0, mat);
              };

              _proto.addParticleVertexData = function addParticleVertexData(index, pvdata) {
                if (!this._useInstance) {
                  if (!this._mesh) {
                    var offset = index * this._vertAttrsFloatCount;
                    this._vdataF32[offset++] = pvdata[0].x;
                    this._vdataF32[offset++] = pvdata[0].y;
                    this._vdataF32[offset++] = pvdata[0].z;
                    this._vdataF32[offset++] = pvdata[1].x;
                    this._vdataF32[offset++] = pvdata[1].y;
                    this._vdataF32[offset++] = pvdata[1].z;
                    this._vdataF32[offset++] = pvdata[2].x;
                    this._vdataF32[offset++] = pvdata[2].y;
                    this._vdataF32[offset++] = pvdata[2].z;
                    this._vdataF32[offset++] = pvdata[3].x;
                    this._vdataF32[offset++] = pvdata[3].y;
                    this._vdataF32[offset++] = pvdata[3].z;
                    this._vdataUint32[offset++] = pvdata[4];

                    if (pvdata[5]) {
                      this._vdataF32[offset++] = pvdata[5].x;
                      this._vdataF32[offset++] = pvdata[5].y;
                      this._vdataF32[offset++] = pvdata[5].z;
                    }
                  } else {
                    for (var i = 0; i < this._vertCount; i++) {
                      var _offset = (index * this._vertCount + i) * this._vertAttrsFloatCount;

                      this._vdataF32[_offset++] = pvdata[0].x;
                      this._vdataF32[_offset++] = pvdata[0].y;
                      this._vdataF32[_offset++] = pvdata[0].z;
                      _offset += 2;
                      this._vdataF32[_offset++] = pvdata[1].z;
                      this._vdataF32[_offset++] = pvdata[2].x;
                      this._vdataF32[_offset++] = pvdata[2].y;
                      this._vdataF32[_offset++] = pvdata[2].z;
                      this._vdataF32[_offset++] = pvdata[3].x;
                      this._vdataF32[_offset++] = pvdata[3].y;
                      this._vdataF32[_offset++] = pvdata[3].z;
                      this._vdataUint32[_offset++] = pvdata[4];
                    }
                  }
                } else {
                  this.addParticleVertexDataIns(index, pvdata);
                }
              };

              _proto.addParticleVertexDataIns = function addParticleVertexDataIns(index, pvdata) {
                var offset = index * this._vertAttrsFloatCount;

                if (!this._mesh) {
                  this._vdataF32[offset++] = pvdata[0].x;
                  this._vdataF32[offset++] = pvdata[0].y;
                  this._vdataF32[offset++] = pvdata[0].z;
                  this._vdataF32[offset++] = pvdata[1].z;
                  this._vdataF32[offset++] = pvdata[2].x;
                  this._vdataF32[offset++] = pvdata[2].y;
                  this._vdataF32[offset++] = pvdata[2].z;
                  this._vdataF32[offset++] = pvdata[3].x;
                  this._vdataF32[offset++] = pvdata[3].y;
                  this._vdataF32[offset++] = pvdata[3].z;
                  this._vdataUint32[offset++] = pvdata[4];

                  if (pvdata[5]) {
                    this._vdataF32[offset++] = pvdata[5].x;
                    this._vdataF32[offset++] = pvdata[5].y;
                    this._vdataF32[offset++] = pvdata[5].z;
                  }
                } else {
                  this._vdataF32[offset++] = pvdata[0].x;
                  this._vdataF32[offset++] = pvdata[0].y;
                  this._vdataF32[offset++] = pvdata[0].z;
                  this._vdataF32[offset++] = pvdata[1].z;
                  this._vdataF32[offset++] = pvdata[2].x;
                  this._vdataF32[offset++] = pvdata[2].y;
                  this._vdataF32[offset++] = pvdata[2].z;
                  this._vdataF32[offset++] = pvdata[3].x;
                  this._vdataF32[offset++] = pvdata[3].y;
                  this._vdataF32[offset++] = pvdata[3].z;
                  this._vdataUint32[offset++] = pvdata[4];
                }
              };

              _proto.addGPUParticleVertexData = function addGPUParticleVertexData(p, num, time) {
                if (!this._useInstance) {
                  var offset = num * this._vertAttrsFloatCount * this._vertCount;

                  for (var i = 0; i < this._vertCount; i++) {
                    var idx = offset;
                    this._vdataF32[idx++] = p.position.x;
                    this._vdataF32[idx++] = p.position.y;
                    this._vdataF32[idx++] = p.position.z;
                    this._vdataF32[idx++] = time;
                    this._vdataF32[idx++] = p.startSize.x;
                    this._vdataF32[idx++] = p.startSize.y;
                    this._vdataF32[idx++] = p.startSize.z;
                    this._vdataF32[idx++] = _uvs$1[2 * i];
                    this._vdataF32[idx++] = p.rotation.x;
                    this._vdataF32[idx++] = p.rotation.y;
                    this._vdataF32[idx++] = p.rotation.z;
                    this._vdataF32[idx++] = _uvs$1[2 * i + 1];
                    this._vdataF32[idx++] = p.startColor.r / 255.0;
                    this._vdataF32[idx++] = p.startColor.g / 255.0;
                    this._vdataF32[idx++] = p.startColor.b / 255.0;
                    this._vdataF32[idx++] = p.startColor.a / 255.0;
                    this._vdataF32[idx++] = p.velocity.x;
                    this._vdataF32[idx++] = p.velocity.y;
                    this._vdataF32[idx++] = p.velocity.z;
                    this._vdataF32[idx++] = p.startLifetime;
                    this._vdataF32[idx++] = p.randomSeed;
                    offset += this._vertAttrsFloatCount;
                  }
                } else {
                  this.addGPUParticleVertexDataIns(p, num, time);
                }
              };

              _proto.addGPUParticleVertexDataIns = function addGPUParticleVertexDataIns(p, num, time) {
                var offset = num * this._vertAttrsFloatCount;
                var idx = offset;
                this._vdataF32[idx++] = p.position.x;
                this._vdataF32[idx++] = p.position.y;
                this._vdataF32[idx++] = p.position.z;
                this._vdataF32[idx++] = time;
                this._vdataF32[idx++] = p.startSize.x;
                this._vdataF32[idx++] = p.startSize.y;
                this._vdataF32[idx++] = p.startSize.z;
                this._vdataF32[idx++] = p.frameIndex;
                this._vdataF32[idx++] = p.rotation.x;
                this._vdataF32[idx++] = p.rotation.y;
                this._vdataF32[idx++] = p.rotation.z;
                this._vdataF32[idx++] = p.startColor.r / 255.0;
                this._vdataF32[idx++] = p.startColor.g / 255.0;
                this._vdataF32[idx++] = p.startColor.b / 255.0;
                this._vdataF32[idx++] = p.startColor.a / 255.0;
                this._vdataF32[idx++] = p.velocity.x;
                this._vdataF32[idx++] = p.velocity.y;
                this._vdataF32[idx++] = p.velocity.z;
                this._vdataF32[idx++] = p.startLifetime;
                this._vdataF32[idx++] = p.randomSeed;
                offset += this._vertAttrsFloatCount;
              };

              _proto.updateGPUParticles = function updateGPUParticles(num, time, dt) {
                if (!this._useInstance) {
                  var pSize = this._vertAttrsFloatCount * this._vertCount;
                  var pBaseIndex = 0;
                  var startTime = 0;
                  var lifeTime = 0;
                  var lastBaseIndex = 0;
                  var interval = 0;

                  for (var i = 0; i < num; ++i) {
                    pBaseIndex = i * pSize;
                    startTime = this._vdataF32[pBaseIndex + this._startTimeOffset];
                    lifeTime = this._vdataF32[pBaseIndex + this._lifeTimeOffset];
                    interval = time - startTime;

                    if (lifeTime - interval < dt) {
                      lastBaseIndex = --num * pSize;

                      this._vdataF32.copyWithin(pBaseIndex, lastBaseIndex, lastBaseIndex + pSize);

                      i--;
                    }
                  }

                  return num;
                } else {
                  return this.updateGPUParticlesIns(num, time, dt);
                }
              };

              _proto.updateGPUParticlesIns = function updateGPUParticlesIns(num, time, dt) {
                var pSize = this._vertAttrsFloatCount;
                var pBaseIndex = 0;
                var startTime = 0;
                var lifeTime = 0;
                var lastBaseIndex = 0;
                var interval = 0;

                for (var i = 0; i < num; ++i) {
                  pBaseIndex = i * pSize;
                  startTime = this._vdataF32[pBaseIndex + this._startTimeOffset];
                  lifeTime = this._vdataF32[pBaseIndex + this._lifeTimeOffset];
                  interval = time - startTime;

                  if (lifeTime - interval < dt) {
                    lastBaseIndex = --num * pSize;

                    this._vdataF32.copyWithin(pBaseIndex, lastBaseIndex, lastBaseIndex + pSize);

                    i--;
                  }
                }

                return num;
              };

              _proto.constructAttributeIndex = function constructAttributeIndex() {
                if (!this._vertAttrs) {
                  return;
                }

                var vIdx = this._vertAttrs.findIndex(function (val) {
                  return val.name === 'a_position_starttime';
                });

                var vOffset = this._vertAttrs[vIdx].offset;
                this._startTimeOffset = vOffset / 4 + 3;
                vIdx = this._vertAttrs.findIndex(function (val) {
                  return val.name === 'a_dir_life';
                });
                vOffset = this._vertAttrs[vIdx].offset;
                this._lifeTimeOffset = vOffset / 4 + 3;
              };

              _proto.updateIA = function updateIA(count) {
                if (!this._useInstance) {
                  if (count <= 0) {
                    return;
                  }

                  var ia = this._subModels[0].inputAssembler;
                  ia.vertexBuffers[0].update(this._vdataF32);
                  this._iaInfo.drawInfos[0].firstIndex = 0;
                  this._iaInfo.drawInfos[0].indexCount = this._indexCount * count;

                  this._iaInfoBuffer.update(this._iaInfo);
                } else {
                  this.updateIAIns(count);
                }
              };

              _proto.updateIAIns = function updateIAIns(count) {
                if (count <= 0) {
                  return;
                }

                var ia = this._subModels[0].inputAssembler;
                ia.vertexBuffers[0].update(this._vdataF32);
                ia.instanceCount = count;
                this._iaInfo.drawInfos[0].firstIndex = 0;
                this._iaInfo.drawInfos[0].indexCount = this._indexCount;
                this._iaInfo.drawInfos[0].instanceCount = count;

                this._iaInfoBuffer.update(this._iaInfo);
              };

              _proto.clear = function clear() {
                if (!this._useInstance) {
                  this._subModels[0].inputAssembler.indexCount = 0;
                } else {
                  this.clearIns();
                }
              };

              _proto.clearIns = function clearIns() {
                this._subModels[0].inputAssembler.instanceCount = 0;
              };

              _proto.destroy = function destroy() {
                _scene$Model.prototype.destroy.call(this);

                this.doDestroy();
              };

              _proto.doDestroy = function doDestroy() {
                this._vBuffer = null;
                this._vdataF32 = null;
                this._vdataUint32 = null;
                this._insBuffers = [];
                this._insIndices = null;
                this._vertAttrs = null;
                this._material = null;
                this._mesh = null;
                this.destroySubMeshData();
              };

              _proto.rebuild = function rebuild() {
                if (!this._useInstance) {
                  this._vBuffer = this.createSubMeshData();
                  this._vdataF32 = new Float32Array(this._vBuffer);
                  this._vdataUint32 = new Uint32Array(this._vBuffer);
                } else {
                  this.rebuildIns();
                }
              };

              _proto.rebuildIns = function rebuildIns() {
                this._vBuffer = this.createSubMeshDataInsDynamic();
                this._vdataF32 = new Float32Array(this._vBuffer);
                this._vdataUint32 = new Uint32Array(this._vBuffer);
                this.createSubMeshDataInsStatic();
                this.createInsSubmesh();
              };

              _proto.destroySubMeshData = function destroySubMeshData() {
                if (this._subMeshData) {
                  this._subMeshData.destroy();

                  this._subMeshData = null;
                }

                if (this._iaInfoBuffer) {
                  this._iaInfoBuffer = null;
                }
              };

              _createClass(ParticleBatchModel, [{
                key: "useInstance",
                get: function get() {
                  return this._useInstance;
                },
                set: function set(value) {
                  if (this._useInstance !== value) {
                    this._useInstance = value;
                  }
                }
              }]);

              return ParticleBatchModel;
            }(Model);

            var ParticleSystemRendererBase = function () {
              function ParticleSystemRendererBase(info) {
                this._particleSystem = null;
                this._model = null;
                this._renderInfo = null;
                this._vertAttrs = [];
                this._useInstance = void 0;
                this._renderInfo = info;

                if (!deviceManager.gfxDevice.hasFeature(Feature.INSTANCED_ARRAYS)) {
                  this._useInstance = false;
                } else {
                  this._useInstance = true;
                }
              }

              var _proto = ParticleSystemRendererBase.prototype;

              _proto.getUseInstance = function getUseInstance() {
                return this._useInstance;
              };

              _proto.getInfo = function getInfo() {
                return this._renderInfo;
              };

              _proto.onInit = function onInit(ps) {
                this._particleSystem = ps;
              };

              _proto.onEnable = function onEnable() {
                if (!this._particleSystem) {
                  return;
                }

                this.attachToScene();
                var model = this._model;

                if (model) {
                  model.node = model.transform = this._particleSystem.node;
                }
              };

              _proto.onDisable = function onDisable() {
                this.detachFromScene();
              };

              _proto.onDestroy = function onDestroy() {
                if (this._model) {
                  legacyCC.director.root.destroyModel(this._model);
                  this._model = null;
                }
              };

              _proto.attachToScene = function attachToScene() {
                if (this._model) {
                  if (this._model.scene) {
                    this.detachFromScene();
                  }

                  this._particleSystem._getRenderScene().addModel(this._model);
                }
              };

              _proto.detachFromScene = function detachFromScene() {
                if (this._model && this._model.scene) {
                  this._model.scene.removeModel(this._model);
                }
              };

              _proto.setVertexAttributes = function setVertexAttributes() {
                if (this._model) {
                  this.updateVertexAttrib();

                  this._model.setVertexAttributes(this._renderInfo.renderMode === RenderMode$1.Mesh ? this._renderInfo.mesh : null, this._vertAttrs);
                }
              };

              _proto.clear = function clear() {
                if (this._model) this._model.enabled = false;
              };

              _proto.getModel = function getModel() {
                return this._model;
              };

              _proto._initModel = function _initModel() {
                if (!this._model) {
                  this._model = legacyCC.director.root.createModel(ParticleBatchModel);

                  this._model.setCapacity(this._particleSystem.capacity);

                  this._model.visFlags = this._particleSystem.visibility;
                }
              };

              _proto.updateTrailMaterial = function updateTrailMaterial() {};

              _proto.getDefaultTrailMaterial = function getDefaultTrailMaterial() {
                return null;
              };

              return ParticleSystemRendererBase;
            }();

            var ParticleNoise = function () {
              function ParticleNoise(permutation) {
                this.permutation = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];
                this.accSpeed = new Vec3();
                this.noiseSpeed = new Vec3();
                this.noiseFrequency = 0.0;
                this.noiseAbs = new Vec3();
                this.noiseAmplitude = new Vec3();
                this.octaves = new Vec3();
                this.dt = 0.0;
                this.point = new Vec3();
                this.result = new Vec3();
                this.mixOut = new Vec2();

                if (permutation) {
                  this.permutation = permutation;
                }
              }

              var _proto = ParticleNoise.prototype;

              _proto.noise = function noise(x, y, z, min, max) {
                if (min === void 0) {
                  min = 0;
                }

                if (max === void 0) {
                  max = 1;
                }

                var p = new Array(512);

                for (var i = 0; i < 256; i++) {
                  p[256 + i] = p[i] = this.permutation[i];
                }

                var X = Math.floor(x) & 255;
                var Y = Math.floor(y) & 255;
                var Z = Math.floor(z) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);
                var u = this.fade(x);
                var v = this.fade(y);
                var w = this.fade(z);
                var A = p[X] + Y;
                var AA = p[A] + Z;
                var AB = p[A + 1] + Z;
                var B = p[X + 1] + Y;
                var BA = p[B] + Z;
                var BB = p[B + 1] + Z;
                var val = this.scale(this.lerp(w, this.lerp(v, this.lerp(u, this.grad(p[AA], x, y, z), this.grad(p[BA], x - 1, y, z)), this.lerp(u, this.grad(p[AB], x, y - 1, z), this.grad(p[BB], x - 1, y - 1, z))), this.lerp(v, this.lerp(u, this.grad(p[AA + 1], x, y, z - 1), this.grad(p[BA + 1], x - 1, y, z - 1)), this.lerp(u, this.grad(p[AB + 1], x, y - 1, z - 1), this.grad(p[BB + 1], x - 1, y - 1, z - 1)))));
                return min + val * (max - min);
              };

              _proto.fade = function fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
              };

              _proto.lerp = function lerp(t, a, b) {
                return a + t * (b - a);
              };

              _proto.grad = function grad(hash, x, y, z) {
                var h = hash & 15;
                var u = h < 8 ? x : y;
                var v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
              };

              _proto.scale = function scale(n) {
                return (1 + n) / 2;
              };

              _proto.setSpeed = function setSpeed(x, y, z) {
                this.noiseSpeed.set(x, y, z);
              };

              _proto.setFrequency = function setFrequency(f) {
                this.noiseFrequency = f;
              };

              _proto.setAbs = function setAbs(x, y, z) {
                this.noiseAbs.set(x, y, z);
              };

              _proto.setAmplititude = function setAmplititude(x, y, z) {
                this.noiseAmplitude.set(x, y, z);
              };

              _proto.setOctaves = function setOctaves(x, y, z) {
                this.octaves.set(x, y, z);
              };

              _proto.setTime = function setTime(t) {
                this.dt = t;
              };

              _proto.setSamplePoint = function setSamplePoint(p) {
                this.point.set(p);
              };

              _proto.getResult = function getResult() {
                return this.result;
              };

              _proto.getNoise = function getNoise(sx, sy, sz, time, offset, noiseFrequency, octaves) {
                var frequency = noiseFrequency;
                var sum = 0.0;
                sum += this.noise(sx * frequency, sy * frequency, sz * frequency, -1.0, 1.0);

                if (octaves.x === 1) {
                  return sum;
                }

                var amplitude = 1.0;
                var range = 1.0;

                for (var i = 1; i < octaves.x; ++i) {
                  amplitude *= octaves.y;
                  frequency *= octaves.z;
                  range += amplitude;
                  sum += this.noise(sx * frequency, sy * frequency, sz * frequency, -1.0, 1.0) * amplitude;
                }

                return sum / range;
              };

              _proto.getNoiseMix = function getNoiseMix(out, point, time, offSpeed, noiseFrequency, octaves) {
                out.x = this.getNoise(point.x, point.y, point.z, time, offSpeed, noiseFrequency, octaves);
                out.y = this.getNoise(point.y, point.z, point.x, time, offSpeed, noiseFrequency, octaves);
              };

              _proto.getNoiseParticle = function getNoiseParticle() {
                this.accSpeed.set(this.noiseSpeed.x * this.dt, this.noiseSpeed.y * this.dt, this.noiseSpeed.z * this.dt);
                var axisOffset = 1000.0;
                var sampX = this.getNoise(this.point.z + this.accSpeed.x, this.point.y, this.point.x, this.dt, this.accSpeed, this.noiseFrequency, this.octaves);
                var sampY = this.getNoise(this.point.x + axisOffset, this.point.z + this.accSpeed.y, this.point.y, this.dt, this.accSpeed, this.noiseFrequency, this.octaves);
                var sampZ = this.getNoise(this.point.y, this.point.x + axisOffset, this.point.z + this.accSpeed.z, this.dt, this.accSpeed, this.noiseFrequency, this.octaves);
                this.result.set(sampX * this.noiseAmplitude.x, sampY * this.noiseAmplitude.y, sampZ * this.noiseAmplitude.z);
              };

              _proto.getPreview = function getPreview(out, width, height) {
                for (var h = 0; h < height; ++h) {
                  for (var w = 0; w < width; ++w) {
                    var sampx = (w - width * 0.5) / width + this.noiseSpeed.x * this.dt;
                    var sampy = (h - height * 0.5) / height + this.noiseSpeed.y * this.dt;
                    var pix = this.getNoise(sampx, sampy, 0.0, this.dt, this.accSpeed, this.noiseFrequency, this.octaves);
                    out[h * width + w] = (pix + 1.0) * 0.5;
                  }
                }
              };

              return ParticleNoise;
            }();

            var _tempAttribUV = new Vec3();

            var _tempWorldTrans = new Mat4();

            var _tempParentInverse = new Mat4();

            var _node_rot = new Quat();

            var _node_euler = new Vec3();

            var _anim_module = ['_colorOverLifetimeModule', '_sizeOvertimeModule', '_velocityOvertimeModule', '_forceOvertimeModule', '_limitVelocityOvertimeModule', '_rotationOvertimeModule', '_textureAnimationModule', '_noiseModule'];
            var _uvs$2 = [0, 0, 1, 0, 0, 1, 1, 1];
            var CC_USE_WORLD_SPACE$1 = 'CC_USE_WORLD_SPACE';
            var CC_RENDER_MODE = 'CC_RENDER_MODE';
            var ROTATION_OVER_TIME_MODULE_ENABLE = 'ROTATION_OVER_TIME_MODULE_ENABLE';
            var INSTANCE_PARTICLE = 'CC_INSTANCE_PARTICLE';
            var RENDER_MODE_BILLBOARD = 0;
            var RENDER_MODE_STRETCHED_BILLBOARD = 1;
            var RENDER_MODE_HORIZONTAL_BILLBOARD = 2;
            var RENDER_MODE_VERTICAL_BILLBOARD = 3;
            var RENDER_MODE_MESH = 4;
            var _vertex_attrs$1 = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true)];
            var _vertex_attrs_stretch = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true), new Attribute(AttributeName.ATTR_COLOR1, Format.RGB32F)];
            var _vertex_attrs_mesh = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true), new Attribute(AttributeName.ATTR_TEX_COORD3, Format.RGB32F), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR1, Format.RGBA8, true)];
            var _vertex_attrs_ins = [new Attribute(AttributeName.ATTR_TEX_COORD4, Format.RGBA32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F, false, 1)];
            var _vertex_attrs_stretch_ins = [new Attribute(AttributeName.ATTR_TEX_COORD4, Format.RGBA32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true, 0, true), new Attribute(AttributeName.ATTR_COLOR1, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F, false, 1)];
            var _vertex_attrs_mesh_ins = [new Attribute(AttributeName.ATTR_TEX_COORD4, Format.RGBA32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_TEX_COORD3, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_COLOR1, Format.RGBA8, true, 1)];
            var _matInsInfo = {
              parent: null,
              owner: null,
              subModelIdx: 0
            };

            var ParticleSystemRendererCPU = function (_ParticleSystemRender) {
              _inheritsLoose(ParticleSystemRendererCPU, _ParticleSystemRender);

              function ParticleSystemRendererCPU(info) {
                var _this;

                _this = _ParticleSystemRender.call(this, info) || this;
                _this._defines = void 0;
                _this._trailDefines = void 0;
                _this._frameTile_velLenScale = void 0;
                _this._tmp_velLenScale = void 0;
                _this._defaultMat = null;
                _this._node_scale = void 0;
                _this._attrs = void 0;
                _this._particles = null;
                _this._defaultTrailMat = null;
                _this._updateList = new Map();
                _this._animateList = new Map();
                _this._runAnimateList = new Array();
                _this._fillDataFunc = null;
                _this._uScaleHandle = 0;
                _this._uLenHandle = 0;
                _this._uNodeRotHandle = 0;
                _this._alignSpace = AlignmentSpace.View;
                _this._inited = false;
                _this._localMat = new Mat4();
                _this._gravity = new Vec4();
                _this.noise = new ParticleNoise();
                _this._model = null;
                _this._frameTile_velLenScale = new Vec4(1, 1, 0, 0);
                _this._tmp_velLenScale = _this._frameTile_velLenScale.clone();
                _this._node_scale = new Vec4();
                _this._attrs = new Array(7);
                _this._defines = {
                  CC_USE_WORLD_SPACE: true,
                  CC_USE_BILLBOARD: true,
                  CC_USE_STRETCHED_BILLBOARD: false,
                  CC_USE_HORIZONTAL_BILLBOARD: false,
                  CC_USE_VERTICAL_BILLBOARD: false
                };
                _this._trailDefines = {
                  CC_USE_WORLD_SPACE: true
                };
                return _this;
              }

              var _proto = ParticleSystemRendererCPU.prototype;

              _proto.onInit = function onInit(ps) {
                var _this2 = this;

                _ParticleSystemRender.prototype.onInit.call(this, ps);

                this._particles = new RecyclePool(function () {
                  return new Particle(_this2);
                }, 16);

                this._setVertexAttrib();

                this._setFillFunc();

                this._initModuleList();

                this._initModel();

                this.updateMaterialParams();
                this.updateTrailMaterial();
                this.setVertexAttributes();
                this._inited = true;
              };

              _proto.clear = function clear() {
                _ParticleSystemRender.prototype.clear.call(this);

                this._particles.reset();

                if (this._particleSystem._trailModule) {
                  this._particleSystem._trailModule.clear();
                }

                this.updateRenderData();
                this._model.enabled = false;
              };

              _proto.updateRenderMode = function updateRenderMode() {
                this._setVertexAttrib();

                this._setFillFunc();

                this.updateMaterialParams();
                this.setVertexAttributes();
              };

              _proto.onDestroy = function onDestroy() {
                var _this$_particles;

                (_this$_particles = this._particles) === null || _this$_particles === void 0 ? void 0 : _this$_particles.destroy();

                _ParticleSystemRender.prototype.onDestroy.call(this);
              };

              _proto.getFreeParticle = function getFreeParticle() {
                if (this._particles.length >= this._particleSystem.capacity) {
                  return null;
                }

                return this._particles.add();
              };

              _proto.getDefaultTrailMaterial = function getDefaultTrailMaterial() {
                return this._defaultTrailMat;
              };

              _proto.setNewParticle = function setNewParticle(p) {};

              _proto._initModuleList = function _initModuleList() {
                var _this3 = this;

                _anim_module.forEach(function (val) {
                  var pm = _this3._particleSystem[val];

                  if (pm && pm.enable) {
                    if (pm.needUpdate) {
                      _this3._updateList[pm.name] = pm;
                    }

                    if (pm.needAnimate) {
                      _this3._animateList[pm.name] = pm;
                    }
                  }
                });

                this._runAnimateList.length = 0;

                for (var i = 0, len = PARTICLE_MODULE_ORDER.length; i < len; i++) {
                  var p = this._animateList[PARTICLE_MODULE_ORDER[i]];

                  if (p) {
                    this._runAnimateList.push(p);
                  }
                }
              };

              _proto.enableModule = function enableModule(name, val, pm) {
                if (val) {
                  if (pm.needUpdate) {
                    this._updateList[pm.name] = pm;
                  }

                  if (pm.needAnimate) {
                    this._animateList[pm.name] = pm;
                  }
                } else {
                  delete this._animateList[name];
                  delete this._updateList[name];
                }

                this._runAnimateList.length = 0;

                for (var i = 0, len = PARTICLE_MODULE_ORDER.length; i < len; i++) {
                  var p = this._animateList[PARTICLE_MODULE_ORDER[i]];

                  if (p) {
                    this._runAnimateList.push(p);
                  }
                }

                this.updateMaterialParams();
              };

              _proto.updateAlignSpace = function updateAlignSpace(space) {
                this._alignSpace = space;
              };

              _proto.getDefaultMaterial = function getDefaultMaterial() {
                return this._defaultMat;
              };

              _proto.updateRotation = function updateRotation(pass) {
                if (pass) {
                  this.doUpdateRotation(pass);
                }
              };

              _proto.doUpdateRotation = function doUpdateRotation(pass) {
                var mode = this._renderInfo.renderMode;

                if (mode !== RenderMode$1.Mesh && this._alignSpace === AlignmentSpace.View) {
                  return;
                }

                if (this._alignSpace === AlignmentSpace.Local) {
                  this._particleSystem.node.getRotation(_node_rot);
                } else if (this._alignSpace === AlignmentSpace.World) {
                  this._particleSystem.node.getWorldRotation(_node_rot);
                } else if (this._alignSpace === AlignmentSpace.View) {
                  var _this$_particleSystem;

                  _node_rot.set(0.0, 0.0, 0.0, 1.0);

                  var cameraLst = (_this$_particleSystem = this._particleSystem.node.scene.renderScene) === null || _this$_particleSystem === void 0 ? void 0 : _this$_particleSystem.cameras;

                  if (cameraLst !== undefined) {
                    for (var i = 0; i < (cameraLst === null || cameraLst === void 0 ? void 0 : cameraLst.length); ++i) {
                      var camera = cameraLst[i];
                      var checkCamera =  (camera.visibility & this._particleSystem.node.layer) === this._particleSystem.node.layer ;

                      if (checkCamera) {
                        Quat.fromViewUp(_node_rot, camera.forward);
                        break;
                      }
                    }
                  }
                } else {
                  _node_rot.set(0.0, 0.0, 0.0, 1.0);
                }

                pass.setUniform(this._uNodeRotHandle, _node_rot);
              };

              _proto.updateScale = function updateScale(pass) {
                if (pass) {
                  this.doUpdateScale(pass);
                }
              };

              _proto.doUpdateScale = function doUpdateScale(pass) {
                switch (this._particleSystem.scaleSpace) {
                  case Space.Local:
                    this._particleSystem.node.getScale(this._node_scale);

                    break;

                  case Space.World:
                    this._particleSystem.node.getWorldScale(this._node_scale);

                    break;
                }

                pass.setUniform(this._uScaleHandle, this._node_scale);
              };

              _proto.updateParticles = function updateParticles(dt) {
                var _this4 = this;

                var ps = this._particleSystem;

                if (!ps) {
                  return this._particles.length;
                }

                ps.node.getWorldMatrix(_tempWorldTrans);

                var mat = ps.getMaterialInstance(0) || this._defaultMat;

                var pass = mat.passes[0];
                this.doUpdateScale(pass);
                this.doUpdateRotation(pass);

                this._updateList.forEach(function (value, key) {
                  value.update(ps._simulationSpace, _tempWorldTrans);
                });

                var trailModule = ps._trailModule;
                var trailEnable = trailModule && trailModule.enable;

                if (trailEnable) {
                  trailModule.update();
                }

                var useGravity = !ps.gravityModifier.isZero();

                if (useGravity) {
                  if (ps.simulationSpace === Space.Local) {
                    var r = ps.node.getRotation();
                    Mat4.fromQuat(this._localMat, r);

                    this._localMat.transpose();
                  }

                  if (ps.node.parent) {
                    var _r = ps.node.parent.getWorldRotation();

                    Mat4.fromQuat(_tempParentInverse, _r);

                    _tempParentInverse.transpose();
                  }
                }

                var _loop = function _loop(_i) {
                  var p = _this4._particles.data[_i];
                  p.remainingLifetime -= dt;
                  Vec3.set(p.animatedVelocity, 0, 0, 0);

                  if (p.remainingLifetime < 0.0) {
                    if (trailEnable) {
                      trailModule.removeParticle(p);
                    }

                    _this4._particles.removeAt(_i);

                    --_i;
                    i = _i;
                    return "continue";
                  }

                  if (useGravity) {
                    var rand = isCurveTwoValues(ps.gravityModifier) ? pseudoRandom(p.randomSeed) : 0;

                    if (ps.simulationSpace === Space.Local) {
                      var time = 1 - p.remainingLifetime / p.startLifetime;
                      var gravityFactor = -ps.gravityModifier.evaluate(time, rand) * 9.8 * dt;
                      _this4._gravity.x = 0.0;
                      _this4._gravity.y = gravityFactor;
                      _this4._gravity.z = 0.0;
                      _this4._gravity.w = 1.0;

                      if (!approx(gravityFactor, 0.0, EPSILON$2)) {
                        if (ps.node.parent) {
                          _this4._gravity = _this4._gravity.transformMat4(_tempParentInverse);
                        }

                        _this4._gravity = _this4._gravity.transformMat4(_this4._localMat);
                        p.velocity.x += _this4._gravity.x;
                        p.velocity.y += _this4._gravity.y;
                        p.velocity.z += _this4._gravity.z;
                      }
                    } else {
                      p.velocity.y -= ps.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, rand) * 9.8 * dt;
                    }
                  }

                  Vec3.copy(p.ultimateVelocity, p.velocity);

                  _this4._runAnimateList.forEach(function (value) {
                    value.animate(p, dt);
                  });

                  Vec3.scaleAndAdd(p.position, p.position, p.ultimateVelocity, dt);

                  if (trailEnable) {
                    trailModule.animate(p, dt);
                  }

                  i = _i;
                };

                for (var i = 0; i < this._particles.length; ++i) {
                  var _ret = _loop(i);

                  if (_ret === "continue") continue;
                }

                this._model.enabled = this._particles.length > 0;
                return this._particles.length;
              };

              _proto.getNoisePreview = function getNoisePreview(out, width, height) {
                var _this5 = this;

                this._runAnimateList.forEach(function (value) {
                  if (value.name === PARTICLE_MODULE_NAME.NOISE) {
                    var m = value;
                    m.getNoisePreview(out, _this5._particleSystem, width, height);
                  }
                });
              };

              _proto.updateRenderData = function updateRenderData() {
                var idx = 0;

                for (var _i2 = 0; _i2 < this._particles.length; ++_i2) {
                  var p = this._particles.data[_i2];
                  var fi = 0;
                  var textureModule = this._particleSystem._textureAnimationModule;

                  if (textureModule && textureModule.enable) {
                    fi = p.frameIndex;
                  }

                  idx = _i2 * 4;

                  this._fillDataFunc(p, idx, fi);
                }
              };

              _proto.beforeRender = function beforeRender() {
                this._model.updateIA(this._particles.length);
              };

              _proto.getParticleCount = function getParticleCount() {
                return this._particles.length;
              };

              _proto.onMaterialModified = function onMaterialModified(index, material) {
                if (!this._inited) {
                  return;
                }

                if (index === 0) {
                  this.updateMaterialParams();
                } else {
                  this.updateTrailMaterial();
                }
              };

              _proto.onRebuildPSO = function onRebuildPSO(index, material) {
                if (this._model && index === 0) {
                  this._model.setSubModelMaterial(0, material);
                }

                var trailModule = this._particleSystem._trailModule;

                if (trailModule && trailModule._trailModel && index === 1) {
                  trailModule._trailModel.setSubModelMaterial(0, material);
                }
              };

              _proto._setFillFunc = function _setFillFunc() {
                if (this._renderInfo.renderMode === RenderMode$1.Mesh) {
                  this._fillDataFunc = this._fillMeshData;
                } else if (this._renderInfo.renderMode === RenderMode$1.StrecthedBillboard) {
                  this._fillDataFunc = this._fillStrecthedData;
                } else {
                  this._fillDataFunc = this._fillNormalData;
                }
              };

              _proto._fillMeshData = function _fillMeshData(p, idx, fi) {
                var i = idx / 4;
                this._attrs[0] = p.position;
                _tempAttribUV.z = fi;
                this._attrs[1] = _tempAttribUV;
                this._attrs[2] = p.size;
                this._attrs[3] = p.rotation;
                this._attrs[4] = p.color._val;

                this._model.addParticleVertexData(i, this._attrs);
              };

              _proto._fillStrecthedData = function _fillStrecthedData(p, idx, fi) {
                if (!this._useInstance) {
                  for (var j = 0; j < 4; ++j) {
                    this._attrs[0] = p.position;
                    _tempAttribUV.x = _uvs$2[2 * j];
                    _tempAttribUV.y = _uvs$2[2 * j + 1];
                    _tempAttribUV.z = fi;
                    this._attrs[1] = _tempAttribUV;
                    this._attrs[2] = p.size;
                    this._attrs[3] = p.rotation;
                    this._attrs[4] = p.color._val;
                    this._attrs[5] = p.ultimateVelocity;
                    this._attrs[6] = null;

                    this._model.addParticleVertexData(idx++, this._attrs);
                  }
                } else {
                  this._fillStrecthedDataIns(p, idx, fi);
                }
              };

              _proto._fillStrecthedDataIns = function _fillStrecthedDataIns(p, idx, fi) {
                var i = idx / 4;
                this._attrs[0] = p.position;
                _tempAttribUV.z = fi;
                this._attrs[1] = _tempAttribUV;
                this._attrs[2] = p.size;
                this._attrs[3] = p.rotation;
                this._attrs[4] = p.color._val;
                this._attrs[5] = p.ultimateVelocity;

                this._model.addParticleVertexData(i, this._attrs);
              };

              _proto._fillNormalData = function _fillNormalData(p, idx, fi) {
                if (!this._useInstance) {
                  for (var j = 0; j < 4; ++j) {
                    this._attrs[0] = p.position;
                    _tempAttribUV.x = _uvs$2[2 * j];
                    _tempAttribUV.y = _uvs$2[2 * j + 1];
                    _tempAttribUV.z = fi;
                    this._attrs[1] = _tempAttribUV;
                    this._attrs[2] = p.size;
                    this._attrs[3] = p.rotation;
                    this._attrs[4] = p.color._val;
                    this._attrs[5] = null;

                    this._model.addParticleVertexData(idx++, this._attrs);
                  }
                } else {
                  this._fillNormalDataIns(p, idx, fi);
                }
              };

              _proto._fillNormalDataIns = function _fillNormalDataIns(p, idx, fi) {
                var i = idx / 4;
                this._attrs[0] = p.position;
                _tempAttribUV.z = fi;
                this._attrs[1] = _tempAttribUV;
                this._attrs[2] = p.size;
                this._attrs[3] = p.rotation;
                this._attrs[4] = p.color._val;
                this._attrs[5] = null;

                this._model.addParticleVertexData(i, this._attrs);
              };

              _proto.updateVertexAttrib = function updateVertexAttrib() {
                if (this._renderInfo.renderMode !== RenderMode$1.Mesh) {
                  return;
                }

                if (this._renderInfo.mesh) {
                  var format = this._renderInfo.mesh.readAttributeFormat(0, AttributeName.ATTR_COLOR);

                  if (format) {
                    var type = Format.RGBA8;

                    for (var _i3 = 0; _i3 < FormatInfos.length; ++_i3) {
                      if (FormatInfos[_i3].name === format.name) {
                        type = _i3;
                        break;
                      }
                    }

                    this._vertAttrs[7] = new Attribute(AttributeName.ATTR_COLOR1, type, true, !this._useInstance ? 0 : 1);
                  } else {
                    var _type = Format.RGBA8;
                    this._vertAttrs[7] = new Attribute(AttributeName.ATTR_COLOR1, _type, true, !this._useInstance ? 0 : 1);
                  }
                }
              };

              _proto._setVertexAttrib = function _setVertexAttrib() {
                if (!this._useInstance) {
                  switch (this._renderInfo.renderMode) {
                    case RenderMode$1.StrecthedBillboard:
                      this._vertAttrs = _vertex_attrs_stretch.slice();
                      break;

                    case RenderMode$1.Mesh:
                      this._vertAttrs = _vertex_attrs_mesh.slice();
                      break;

                    default:
                      this._vertAttrs = _vertex_attrs$1.slice();
                  }
                } else {
                  this._setVertexAttribIns();
                }
              };

              _proto._setVertexAttribIns = function _setVertexAttribIns() {
                switch (this._renderInfo.renderMode) {
                  case RenderMode$1.StrecthedBillboard:
                    this._vertAttrs = _vertex_attrs_stretch_ins.slice();
                    break;

                  case RenderMode$1.Mesh:
                    this._vertAttrs = _vertex_attrs_mesh_ins.slice();
                    break;

                  default:
                    this._vertAttrs = _vertex_attrs_ins.slice();
                }
              };

              _proto.updateMaterialParams = function updateMaterialParams() {
                if (!this._particleSystem) {
                  return;
                }

                var ps = this._particleSystem;
                var shareMaterial = ps.sharedMaterial;

                if (shareMaterial != null) {
                  var effectName = shareMaterial._effectAsset._name;
                  this._renderInfo.mainTexture = shareMaterial.getProperty('mainTexture', 0);
                }

                if (ps.sharedMaterial == null && this._defaultMat == null) {
                  _matInsInfo.parent = builtinResMgr.get('default-particle-material');
                  _matInsInfo.owner = this._particleSystem;
                  _matInsInfo.subModelIdx = 0;
                  this._defaultMat = new MaterialInstance(_matInsInfo);
                  _matInsInfo.parent = null;
                  _matInsInfo.owner = null;
                  _matInsInfo.subModelIdx = 0;

                  if (this._renderInfo.mainTexture !== null) {
                    this._defaultMat.setProperty('mainTexture', this._renderInfo.mainTexture);
                  }
                }

                var mat = ps.getMaterialInstance(0) || this._defaultMat;

                if (ps._simulationSpace === Space.World) {
                  this._defines[CC_USE_WORLD_SPACE$1] = true;
                } else {
                  this._defines[CC_USE_WORLD_SPACE$1] = false;
                }

                var pass = mat.passes[0];
                this._uScaleHandle = pass.getHandle('scale');
                this._uLenHandle = pass.getHandle('frameTile_velLenScale');
                this._uNodeRotHandle = pass.getHandle('nodeRotation');
                var renderMode = this._renderInfo.renderMode;
                var vlenScale = this._frameTile_velLenScale;

                if (renderMode === RenderMode$1.Billboard) {
                  this._defines[CC_RENDER_MODE] = RENDER_MODE_BILLBOARD;
                } else if (renderMode === RenderMode$1.StrecthedBillboard) {
                  this._defines[CC_RENDER_MODE] = RENDER_MODE_STRETCHED_BILLBOARD;
                  vlenScale.z = this._renderInfo.velocityScale;
                  vlenScale.w = this._renderInfo.lengthScale;
                } else if (renderMode === RenderMode$1.HorizontalBillboard) {
                  this._defines[CC_RENDER_MODE] = RENDER_MODE_HORIZONTAL_BILLBOARD;
                } else if (renderMode === RenderMode$1.VerticalBillboard) {
                  this._defines[CC_RENDER_MODE] = RENDER_MODE_VERTICAL_BILLBOARD;
                } else if (renderMode === RenderMode$1.Mesh) {
                  this._defines[CC_RENDER_MODE] = RENDER_MODE_MESH;
                } else {
                  console.warn("particle system renderMode " + renderMode + " not support.");
                }

                var textureModule = ps._textureAnimationModule;

                if (textureModule && textureModule.enable) {
                  Vec4.copy(this._tmp_velLenScale, vlenScale);
                  Vec2.set(this._tmp_velLenScale, textureModule.numTilesX, textureModule.numTilesY);
                  pass.setUniform(this._uLenHandle, this._tmp_velLenScale);
                } else {
                  pass.setUniform(this._uLenHandle, vlenScale);
                }

                var enable = false;
                var roationModule = this._particleSystem._rotationOvertimeModule;
                enable = roationModule ? roationModule.enable : false;
                this._defines[ROTATION_OVER_TIME_MODULE_ENABLE] = enable;
                this._defines[INSTANCE_PARTICLE] = this._useInstance;
                mat.recompileShaders(this._defines);

                if (this._model) {
                  this._model.updateMaterial(mat);
                }
              };

              _proto.updateTrailMaterial = function updateTrailMaterial() {
                if (!this._particleSystem) {
                  return;
                }

                var ps = this._particleSystem;
                var trailModule = ps._trailModule;

                if (trailModule && trailModule.enable) {
                  if (ps.simulationSpace === Space.World || trailModule.space === Space.World) {
                    this._trailDefines[CC_USE_WORLD_SPACE$1] = true;
                  } else {
                    this._trailDefines[CC_USE_WORLD_SPACE$1] = false;
                  }

                  var mat = ps.getMaterialInstance(1);

                  if (mat === null && this._defaultTrailMat === null) {
                    _matInsInfo.parent = builtinResMgr.get('default-trail-material');
                    _matInsInfo.owner = this._particleSystem;
                    _matInsInfo.subModelIdx = 1;
                    this._defaultTrailMat = new MaterialInstance(_matInsInfo);
                    _matInsInfo.parent = null;
                    _matInsInfo.owner = null;
                    _matInsInfo.subModelIdx = 0;
                  }

                  mat = mat || this._defaultTrailMat;
                  mat.recompileShaders(this._trailDefines);
                  trailModule.updateMaterial();
                }
              };

              _proto.setUseInstance = function setUseInstance(value) {
                if (this._useInstance === value) {
                  return;
                }

                this._useInstance = value;

                if (this._model) {
                  this._model.useInstance = value;

                  this._model.doDestroy();
                }

                this.updateRenderMode();
              };

              return ParticleSystemRendererCPU;
            }(ParticleSystemRendererBase);

            var _tempWorldTrans$1 = new Mat4();

            var _tempVec4 = new Vec4();

            var _world_rot = new Quat();

            var _node_rot$1 = new Quat();

            var _node_euler$1 = new Vec3();

            var _sample_num = 32;

            var _sample_interval = 1.0 / _sample_num;

            var CC_USE_WORLD_SPACE$2 = 'CC_USE_WORLD_SPACE';
            var CC_RENDER_MODE$1 = 'CC_RENDER_MODE';
            var RENDER_MODE_BILLBOARD$1 = 0;
            var RENDER_MODE_STRETCHED_BILLBOARD$1 = 1;
            var RENDER_MODE_HORIZONTAL_BILLBOARD$1 = 2;
            var RENDER_MODE_VERTICAL_BILLBOARD$1 = 3;
            var RENDER_MODE_MESH$1 = 4;
            var COLOR_OVER_TIME_MODULE_ENABLE = 'COLOR_OVER_TIME_MODULE_ENABLE';
            var ROTATION_OVER_TIME_MODULE_ENABLE$1 = 'ROTATION_OVER_TIME_MODULE_ENABLE';
            var SIZE_OVER_TIME_MODULE_ENABLE = 'SIZE_OVER_TIME_MODULE_ENABLE';
            var VELOCITY_OVER_TIME_MODULE_ENABLE = 'VELOCITY_OVER_TIME_MODULE_ENABLE';
            var FORCE_OVER_TIME_MODULE_ENABLE = 'FORCE_OVER_TIME_MODULE_ENABLE';
            var TEXTURE_ANIMATION_MODULE_ENABLE = 'TEXTURE_ANIMATION_MODULE_ENABLE';
            var USE_VK_SHADER = 'USE_VK_SHADER';
            var INSTANCE_PARTICLE$1 = 'CC_INSTANCE_PARTICLE';
            var _vert_attr_name = {
              POSITION_STARTTIME: 'a_position_starttime',
              VERT_SIZE_UV: 'a_size_uv',
              VERT_ROTATION_UV: 'a_rotation_uv',
              COLOR: 'a_color',
              DIR_LIFE: 'a_dir_life',
              RANDOM_SEED: 'a_rndSeed',
              VERT_SIZE_FID: 'a_size_fid',
              VERT_ROTATION: 'a_rotation',
              VERT_UV: 'a_uv'
            };
            var _gpu_vert_attr = [new Attribute(_vert_attr_name.POSITION_STARTTIME, Format.RGBA32F), new Attribute(_vert_attr_name.VERT_SIZE_UV, Format.RGBA32F), new Attribute(_vert_attr_name.VERT_ROTATION_UV, Format.RGBA32F), new Attribute(_vert_attr_name.COLOR, Format.RGBA32F), new Attribute(_vert_attr_name.DIR_LIFE, Format.RGBA32F), new Attribute(_vert_attr_name.RANDOM_SEED, Format.R32F)];
            var _gpu_vert_attr_mesh = [new Attribute(_vert_attr_name.POSITION_STARTTIME, Format.RGBA32F), new Attribute(_vert_attr_name.VERT_SIZE_UV, Format.RGBA32F), new Attribute(_vert_attr_name.VERT_ROTATION_UV, Format.RGBA32F), new Attribute(_vert_attr_name.COLOR, Format.RGBA32F), new Attribute(_vert_attr_name.DIR_LIFE, Format.RGBA32F), new Attribute(_vert_attr_name.RANDOM_SEED, Format.R32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD3, Format.RGB32F), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR1, Format.RGBA8, true)];
            var _gpu_vert_attr_ins = [new Attribute(_vert_attr_name.POSITION_STARTTIME, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.VERT_SIZE_FID, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.VERT_ROTATION, Format.RGB32F, false, 0, true), new Attribute(_vert_attr_name.COLOR, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.DIR_LIFE, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.RANDOM_SEED, Format.R32F, false, 0, true), new Attribute(_vert_attr_name.VERT_UV, Format.RGB32F, false, 1)];
            var _gpu_vert_attr_mesh_ins = [new Attribute(_vert_attr_name.POSITION_STARTTIME, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.VERT_SIZE_FID, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.VERT_ROTATION, Format.RGB32F, false, 0, true), new Attribute(_vert_attr_name.COLOR, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.DIR_LIFE, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.RANDOM_SEED, Format.R32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_TEX_COORD3, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_COLOR1, Format.RGBA8, true, 1)];
            var _matInsInfo$1 = {
              parent: null,
              owner: null,
              subModelIdx: 0
            };

            var ParticleSystemRendererGPU = function (_ParticleSystemRender) {
              _inheritsLoose(ParticleSystemRendererGPU, _ParticleSystemRender);

              function ParticleSystemRendererGPU(info) {
                var _this;

                _this = _ParticleSystemRender.call(this, info) || this;
                _this._defines = void 0;
                _this._frameTile_velLenScale = void 0;
                _this._unifrom_velLenScale = void 0;
                _this._tmp_velLenScale = void 0;
                _this._node_scale = void 0;
                _this._vertAttrs = [];
                _this._defaultMat = null;
                _this._particleNum = 0;
                _this._tempParticle = null;
                _this._colorTexture = null;
                _this._forceTexture = null;
                _this._velocityTexture = null;
                _this._rotationTexture = null;
                _this._sizeTexture = null;
                _this._animTexture = null;
                _this._colorData = null;
                _this._forceData = null;
                _this._velocityData = null;
                _this._rotationData = null;
                _this._sizeData = null;
                _this._animData = null;
                _this._uTimeHandle = 0;
                _this._uRotHandle = 0;
                _this._uNodeRotHandle = 0;
                _this._alignSpace = AlignmentSpace.View;
                _this._inited = false;
                _this._frameTile_velLenScale = new Vec4(1, 1, 0, 0);
                _this._unifrom_velLenScale = _this._frameTile_velLenScale.clone();
                _this._tmp_velLenScale = _this._frameTile_velLenScale.clone();
                _this._node_scale = new Vec4();
                _this._defines = {
                  CC_USE_WORLD_SPACE: true,
                  CC_USE_BILLBOARD: true,
                  CC_USE_STRETCHED_BILLBOARD: false,
                  CC_USE_HORIZONTAL_BILLBOARD: false,
                  CC_USE_VERTICAL_BILLBOARD: false,
                  COLOR_OVER_TIME_MODULE_ENABLE: false
                };
                _this._tempParticle = new Particle(null);
                _this._particleNum = 0;
                return _this;
              }

              var _proto = ParticleSystemRendererGPU.prototype;

              _proto.onInit = function onInit(ps) {
                _ParticleSystemRender.prototype.onInit.call(this, ps);

                this._setVertexAttrib();

                this._initModel();

                this.updateMaterialParams();
                this.setVertexAttributes();
                this._inited = true;
              };

              _proto.updateRenderMode = function updateRenderMode() {
                this._setVertexAttrib();

                this.updateMaterialParams();
                this.setVertexAttributes();
              };

              _proto.setVertexAttributes = function setVertexAttributes() {
                _ParticleSystemRender.prototype.setVertexAttributes.call(this);

                this._model.constructAttributeIndex();
              };

              _proto.clear = function clear() {
                _ParticleSystemRender.prototype.clear.call(this);

                this._particleNum = 0;
                this.updateRenderData();
              };

              _proto.onDestroy = function onDestroy() {
                _ParticleSystemRender.prototype.onDestroy.call(this);

                if (this._forceTexture) this._forceTexture.destroy();
                if (this._velocityTexture) this._velocityTexture.destroy();
                if (this._colorTexture) this._colorTexture.destroy();
                if (this._sizeTexture) this._sizeTexture.destroy();
                if (this._rotationTexture) this._rotationTexture.destroy();
                if (this._animTexture) this._animTexture.destroy();
                this._forceData = null;
                this._velocityData = null;
                this._colorData = null;
                this._sizeData = null;
                this._rotationData = null;
                this._animData = null;
              };

              _proto.enableModule = function enableModule(name, val, pm) {
                var mat = this._particleSystem.getMaterialInstance(0) || this._defaultMat;

                if (!mat) {
                  return;
                }

                this.initShaderUniform(mat);
                mat.recompileShaders(this._defines);

                if (this._model) {
                  this._model.setSubModelMaterial(0, mat);
                }
              };

              _proto.getFreeParticle = function getFreeParticle() {
                if (this._particleNum >= this._particleSystem._capacity) {
                  return null;
                }

                return this._tempParticle;
              };

              _proto.setNewParticle = function setNewParticle(p) {
                this._model.addGPUParticleVertexData(p, this._particleNum, this._particleSystem._time);

                this._particleNum++;
              };

              _proto.getDefaultMaterial = function getDefaultMaterial() {
                return this._defaultMat;
              };

              _proto.updateRotation = function updateRotation(pass) {
                if (pass) {
                  this.doUpdateRotation(pass);
                }
              };

              _proto.doUpdateRotation = function doUpdateRotation(pass) {
                var mode = this._renderInfo.renderMode;

                if (mode !== RenderMode$1.Mesh && this._alignSpace === AlignmentSpace.View) {
                  return;
                }

                if (this._alignSpace === AlignmentSpace.Local) {
                  this._particleSystem.node.getRotation(_node_rot$1);
                } else if (this._alignSpace === AlignmentSpace.World) {
                  this._particleSystem.node.getWorldRotation(_node_rot$1);
                } else if (this._alignSpace === AlignmentSpace.View) {
                  var _this$_particleSystem;

                  _node_rot$1.set(0.0, 0.0, 0.0, 1.0);

                  var cameraLst = (_this$_particleSystem = this._particleSystem.node.scene.renderScene) === null || _this$_particleSystem === void 0 ? void 0 : _this$_particleSystem.cameras;

                  if (cameraLst !== undefined) {
                    for (var i = 0; i < (cameraLst === null || cameraLst === void 0 ? void 0 : cameraLst.length); ++i) {
                      var camera = cameraLst[i];
                      var checkCamera =  (camera.visibility & this._particleSystem.node.layer) === this._particleSystem.node.layer ;

                      if (checkCamera) {
                        Quat.fromViewUp(_node_rot$1, camera.forward);
                        break;
                      }
                    }
                  }
                } else {
                  _node_rot$1.set(0.0, 0.0, 0.0, 1.0);
                }

                pass.setUniform(this._uNodeRotHandle, _node_rot$1);
              };

              _proto.updateScale = function updateScale(pass) {
                if (pass) {
                  this.doUpdateScale(pass);
                }
              };

              _proto.doUpdateScale = function doUpdateScale(pass) {
                switch (this._particleSystem.scaleSpace) {
                  case Space.Local:
                    this._particleSystem.node.getScale(this._node_scale);

                    break;

                  case Space.World:
                    this._particleSystem.node.getWorldScale(this._node_scale);

                    break;
                }

                pass.setUniform(pass.getHandle('scale'), this._node_scale);
              };

              _proto.updateParticles = function updateParticles(dt) {

                this._particleNum = this._model.updateGPUParticles(this._particleNum, this._particleSystem._time, dt);
                this.updateShaderUniform(dt);
                this._model.enabled = this._particleNum > 0;
                return this._particleNum;
              };

              _proto.updateRenderData = function updateRenderData() {};

              _proto.beforeRender = function beforeRender() {
                this._model.updateIA(this._particleNum);
              };

              _proto.updateAlignSpace = function updateAlignSpace(space) {
                this._alignSpace = space;
              };

              _proto.updateShaderUniform = function updateShaderUniform(dt) {
                var mat = this._particleSystem.getMaterialInstance(0) || this._defaultMat;

                if (!mat) {
                  return;
                }

                var pass = mat.passes[0];
                _tempVec4.x = this._particleSystem._time;
                _tempVec4.y = dt;
                pass.setUniform(this._uTimeHandle, _tempVec4);

                this._particleSystem.node.getWorldRotation(_world_rot);

                pass.setUniform(this._uRotHandle, _world_rot);
                this.doUpdateRotation(pass);
              };

              _proto.initShaderUniform = function initShaderUniform(mat) {
                var pass = mat.passes[0];
                this._uTimeHandle = pass.getHandle('u_timeDelta');
                this._uRotHandle = pass.getHandle('u_worldRot');
                this._uNodeRotHandle = pass.getHandle('nodeRotation');
                this.doUpdateScale(pass);
                pass.setUniform(pass.getHandle('frameTile_velLenScale'), this._unifrom_velLenScale);
                _tempVec4.x = _sample_num;
                _tempVec4.y = _sample_interval;
                pass.setUniform(pass.getHandle('u_sampleInfo'), _tempVec4);
                var enable = false;
                var forceModule = this._particleSystem._forceOvertimeModule;
                enable = forceModule ? forceModule.enable : false;
                this._defines[FORCE_OVER_TIME_MODULE_ENABLE] = enable;

                if (enable) {
                  var packed = packCurveRangeXYZ(this._forceTexture, this._forceData, _sample_num, forceModule.x, forceModule.y, forceModule.z);
                  this._forceTexture = packed.texture;
                  this._forceData = packed.texdata;
                  var handle = pass.getHandle('force_over_time_tex0');
                  var binding = Pass.getBindingFromHandle(handle);
                  pass.bindSampler(binding, this._forceTexture.getGFXSampler());
                  pass.bindTexture(binding, this._forceTexture.getGFXTexture());
                  var spaceHandle = pass.getHandle('u_force_space');
                  pass.setUniform(spaceHandle, forceModule.space);
                  var modeHandle = pass.getHandle('u_force_mode');
                  pass.setUniform(modeHandle, this._forceTexture.height);
                }

                var velocityModule = this._particleSystem._velocityOvertimeModule;
                enable = velocityModule ? velocityModule.enable : false;
                this._defines[VELOCITY_OVER_TIME_MODULE_ENABLE] = enable;

                if (enable) {
                  var _packed = packCurveRangeXYZW(this._velocityTexture, this._velocityData, _sample_num, velocityModule.x, velocityModule.y, velocityModule.z, velocityModule.speedModifier);

                  this._velocityTexture = _packed.texture;
                  this._velocityData = _packed.texdata;

                  var _handle = pass.getHandle('velocity_over_time_tex0');

                  var _binding = Pass.getBindingFromHandle(_handle);

                  pass.bindSampler(_binding, this._velocityTexture.getGFXSampler());
                  pass.bindTexture(_binding, this._velocityTexture.getGFXTexture());

                  var _spaceHandle = pass.getHandle('u_velocity_space');

                  pass.setUniform(_spaceHandle, velocityModule.space);

                  var _modeHandle = pass.getHandle('u_velocity_mode');

                  pass.setUniform(_modeHandle, this._velocityTexture.height);
                }

                var colorModule = this._particleSystem._colorOverLifetimeModule;
                enable = colorModule ? colorModule.enable : false;
                this._defines[COLOR_OVER_TIME_MODULE_ENABLE] = enable;

                if (enable) {
                  var _packed2 = packGradientRange(this._colorTexture, this._colorData, _sample_num, colorModule.color);

                  this._colorTexture = _packed2.texture;
                  this._colorData = _packed2.texdata;

                  var _handle2 = pass.getHandle('color_over_time_tex0');

                  var _binding2 = Pass.getBindingFromHandle(_handle2);

                  pass.bindSampler(_binding2, this._colorTexture.getGFXSampler());
                  pass.bindTexture(_binding2, this._colorTexture.getGFXTexture());

                  var _modeHandle2 = pass.getHandle('u_color_mode');

                  pass.setUniform(_modeHandle2, this._colorTexture.height);
                }

                var roationModule = this._particleSystem._rotationOvertimeModule;
                enable = roationModule ? roationModule.enable : false;
                this._defines[ROTATION_OVER_TIME_MODULE_ENABLE$1] = enable;

                if (enable) {
                  var _packed3;

                  if (roationModule.separateAxes) {
                    _packed3 = packCurveRangeXYZ(this._rotationTexture, this._rotationData, _sample_num, roationModule.x, roationModule.y, roationModule.z);
                  } else {
                    _packed3 = packCurveRangeZ(this._rotationTexture, this._rotationData, _sample_num, roationModule.z);
                  }

                  this._rotationTexture = _packed3.texture;
                  this._rotationData = _packed3.texdata;

                  if (this._rotationTexture) {
                    var _handle3 = pass.getHandle('rotation_over_time_tex0');

                    var _binding3 = Pass.getBindingFromHandle(_handle3);

                    pass.bindSampler(_binding3, this._rotationTexture.getGFXSampler());
                    pass.bindTexture(_binding3, this._rotationTexture.getGFXTexture());

                    var _modeHandle3 = pass.getHandle('u_rotation_mode');

                    pass.setUniform(_modeHandle3, this._rotationTexture.height);
                  }
                }

                var sizeModule = this._particleSystem._sizeOvertimeModule;
                enable = sizeModule ? sizeModule.enable : false;
                this._defines[SIZE_OVER_TIME_MODULE_ENABLE] = enable;

                if (enable) {
                  var _packed4;

                  if (sizeModule.separateAxes) {
                    _packed4 = packCurveRangeXYZ(this._sizeTexture, this._sizeData, _sample_num, sizeModule.x, sizeModule.y, sizeModule.z, true);
                  } else {
                    _packed4 = packCurveRangeN(this._sizeTexture, this._sizeData, _sample_num, sizeModule.size, true);
                  }

                  this._sizeTexture = _packed4.texture;
                  this._sizeData = _packed4.texdata;

                  if (this._sizeTexture) {
                    var _handle4 = pass.getHandle('size_over_time_tex0');

                    var _binding4 = Pass.getBindingFromHandle(_handle4);

                    pass.bindSampler(_binding4, this._sizeTexture.getGFXSampler());
                    pass.bindTexture(_binding4, this._sizeTexture.getGFXTexture());

                    var _modeHandle4 = pass.getHandle('u_size_mode');

                    pass.setUniform(_modeHandle4, this._sizeTexture.height);
                  }
                }

                var textureModule = this._particleSystem._textureAnimationModule;
                enable = textureModule ? textureModule.enable : false;
                this._defines[TEXTURE_ANIMATION_MODULE_ENABLE] = enable;

                if (enable) {
                  var _packed5 = packCurveRangeXY(this._animTexture, this._animData, _sample_num, textureModule.startFrame, textureModule.frameOverTime, true);

                  this._animTexture = _packed5.texture;
                  this._animData = _packed5.texdata;

                  var _handle5 = pass.getHandle('texture_animation_tex0');

                  var _binding5 = Pass.getBindingFromHandle(_handle5);

                  pass.bindSampler(_binding5, this._animTexture.getGFXSampler());
                  pass.bindTexture(_binding5, this._animTexture.getGFXTexture());
                  var infoHandle = pass.getHandle('u_anim_info');
                  _tempVec4.x = this._animTexture.height;
                  _tempVec4.y = textureModule.numTilesX * textureModule.numTilesY;
                  _tempVec4.z = textureModule.cycleCount;
                  pass.setUniform(infoHandle, _tempVec4);
                }

                this._defines[USE_VK_SHADER] = deviceManager.gfxDevice.gfxAPI === API.VULKAN;
                this._defines[INSTANCE_PARTICLE$1] = this._useInstance;
              };

              _proto.getParticleCount = function getParticleCount() {
                return this._particleNum;
              };

              _proto.onMaterialModified = function onMaterialModified(index, material) {
                if (!this._inited) {
                  return;
                }

                this.updateMaterialParams();
              };

              _proto.onRebuildPSO = function onRebuildPSO(index, material) {
                if (this._model && index === 0) {
                  this._model.setSubModelMaterial(0, material);
                }
              };

              _proto.updateVertexAttrib = function updateVertexAttrib() {
                if (this._renderInfo.renderMode !== RenderMode$1.Mesh) {
                  return;
                }

                if (this._renderInfo.mesh) {
                  var format = this._renderInfo.mesh.readAttributeFormat(0, AttributeName.ATTR_COLOR);

                  if (format) {
                    var type = Format.RGBA8;

                    for (var i = 0; i < FormatInfos.length; ++i) {
                      if (FormatInfos[i].name === format.name) {
                        type = i;
                        break;
                      }
                    }

                    this._vertAttrs[9] = new Attribute(AttributeName.ATTR_COLOR1, type, true, !this._useInstance ? 0 : 1);
                  } else {
                    var _type = Format.RGBA8;
                    this._vertAttrs[9] = new Attribute(AttributeName.ATTR_COLOR1, _type, true, !this._useInstance ? 0 : 1);
                  }
                }
              };

              _proto._setVertexAttrib = function _setVertexAttrib() {
                if (!this._useInstance) {
                  switch (this._renderInfo.renderMode) {
                    case RenderMode$1.StrecthedBillboard:
                      this._vertAttrs = _gpu_vert_attr.slice();
                      break;

                    case RenderMode$1.Mesh:
                      this._vertAttrs = _gpu_vert_attr_mesh.slice();
                      break;

                    default:
                      this._vertAttrs = _gpu_vert_attr.slice();
                  }
                } else {
                  this._setVertexAttribIns();
                }
              };

              _proto._setVertexAttribIns = function _setVertexAttribIns() {
                switch (this._renderInfo.renderMode) {
                  case RenderMode$1.StrecthedBillboard:
                    this._vertAttrs = _gpu_vert_attr_ins.slice();
                    break;

                  case RenderMode$1.Mesh:
                    this._vertAttrs = _gpu_vert_attr_mesh_ins.slice();
                    break;

                  default:
                    this._vertAttrs = _gpu_vert_attr_ins.slice();
                }
              };

              _proto.updateMaterialParams = function updateMaterialParams() {
                if (!this._particleSystem) {
                  return;
                }

                var ps = this._particleSystem;
                var shareMaterial = ps.sharedMaterial;

                if (shareMaterial !== null) {
                  var effectName = shareMaterial._effectAsset._name;
                  this._renderInfo.mainTexture = shareMaterial.getProperty('mainTexture', 0);
                }

                if (ps.sharedMaterial == null && this._defaultMat == null) {
                  _matInsInfo$1.parent = builtinResMgr.get('default-particle-gpu-material');
                  _matInsInfo$1.owner = ps;
                  _matInsInfo$1.subModelIdx = 0;
                  this._defaultMat = new MaterialInstance(_matInsInfo$1);
                  _matInsInfo$1.parent = null;
                  _matInsInfo$1.owner = null;
                  _matInsInfo$1.subModelIdx = 0;

                  if (this._renderInfo.mainTexture !== null) {
                    this._defaultMat.setProperty('mainTexture', this._renderInfo.mainTexture);
                  }
                }

                var mat = ps.getMaterialInstance(0) || this._defaultMat;

                ps.node.getWorldMatrix(_tempWorldTrans$1);

                if (ps._simulationSpace === Space.World) {
                  this._defines[CC_USE_WORLD_SPACE$2] = true;
                } else {
                  this._defines[CC_USE_WORLD_SPACE$2] = false;
                }

                var renderMode = this._renderInfo.renderMode;

                if (renderMode === RenderMode$1.Billboard) {
                  this._defines[CC_RENDER_MODE$1] = RENDER_MODE_BILLBOARD$1;
                } else if (renderMode === RenderMode$1.StrecthedBillboard) {
                  this._defines[CC_RENDER_MODE$1] = RENDER_MODE_STRETCHED_BILLBOARD$1;
                  this._frameTile_velLenScale.z = this._renderInfo.velocityScale;
                  this._frameTile_velLenScale.w = this._renderInfo.lengthScale;
                } else if (renderMode === RenderMode$1.HorizontalBillboard) {
                  this._defines[CC_RENDER_MODE$1] = RENDER_MODE_HORIZONTAL_BILLBOARD$1;
                } else if (renderMode === RenderMode$1.VerticalBillboard) {
                  this._defines[CC_RENDER_MODE$1] = RENDER_MODE_VERTICAL_BILLBOARD$1;
                } else if (renderMode === RenderMode$1.Mesh) {
                  this._defines[CC_RENDER_MODE$1] = RENDER_MODE_MESH$1;
                } else {
                  console.warn("particle system renderMode " + renderMode + " not support.");
                }

                var textureModule = ps._textureAnimationModule;

                if (textureModule && textureModule.enable) {
                  Vec2.set(this._frameTile_velLenScale, textureModule.numTilesX, textureModule.numTilesY);
                  Vec4.copy(this._unifrom_velLenScale, this._frameTile_velLenScale);
                } else {
                  this._tmp_velLenScale.z = this._frameTile_velLenScale.z;
                  this._tmp_velLenScale.w = this._frameTile_velLenScale.w;
                  Vec4.copy(this._unifrom_velLenScale, this._tmp_velLenScale);
                }

                this.initShaderUniform(mat);
                mat.recompileShaders(this._defines);

                if (this._model) {
                  this._model.updateMaterial(mat);
                }
              };

              _proto.setUseInstance = function setUseInstance(value) {
                if (this._useInstance === value) {
                  return;
                }

                this._useInstance = value;

                if (this._model) {
                  this._model.useInstance = value;

                  this._model.doDestroy();
                }

                this.updateRenderMode();
              };

              _proto.getNoisePreview = function getNoisePreview(out, width, height) {};

              return ParticleSystemRendererGPU;
            }(ParticleSystemRendererBase);

            var _dec$1t, _dec2$13, _dec3$K, _dec4$u, _dec5$o, _dec6$k, _dec7$f, _dec8$a, _dec9$8, _class$1w, _class2$1g, _initializer$1b, _initializer2$$, _initializer3$M, _initializer4$H, _initializer5$y, _initializer6$r, _initializer7$k, _initializer8$i, _initializer9$f, _class3$g, _temp$p;

            function isSupportGPUParticle() {
              var device = director.root.device;

              if (device.capabilities.maxVertexTextureUnits >= 8 && device.getFormatFeatures(Format.RGBA32F) & (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE)) {
                return true;
              }

              legacyCC.warn('Maybe the device has restrictions on vertex textures or does not support float textures.');
              return false;
            }

            var ParticleSystemRenderer = (_dec$1t = ccclass$p('cc.ParticleSystemRenderer'), _dec2$13 = type$8(RenderMode$1), _dec3$K = type$8(RenderMode$1), _dec4$u = type$8(Mesh), _dec5$o = type$8(Material), _dec6$k = type$8(Material), _dec7$f = type$8(Material), _dec8$a = type$8(Material), _dec9$8 = type$8(AlignmentSpace), _dec$1t(_class$1w = (_class2$1g = (_temp$p = _class3$g = function () {
              function ParticleSystemRenderer() {
                this._renderMode = _initializer$1b && _initializer$1b();
                this._velocityScale = _initializer2$$ && _initializer2$$();
                this._lengthScale = _initializer3$M && _initializer3$M();
                this._mesh = _initializer4$H && _initializer4$H();
                this._cpuMaterial = _initializer5$y && _initializer5$y();
                this._gpuMaterial = _initializer6$r && _initializer6$r();
                this._mainTexture = _initializer7$k && _initializer7$k();
                this._useGPU = _initializer8$i && _initializer8$i();
                this._alignSpace = _initializer9$f && _initializer9$f();
                this._particleSystem = null;
              }

              var _proto = ParticleSystemRenderer.prototype;

              _proto.create = function create(ps) {
                if (this._particleSystem === null) {
                  this._particleSystem = ps;
                } else if (this._particleSystem !== ps) {
                  errorID(6033);
                }
              };

              _proto.onInit = function onInit(ps) {
                this.create(ps);
                var useGPU = this._useGPU && isSupportGPUParticle();

                if (!this._particleSystem.processor) {
                  this._particleSystem.processor = useGPU ? new ParticleSystemRendererGPU(this) : new ParticleSystemRendererCPU(this);

                  this._particleSystem.processor.updateAlignSpace(this.alignSpace);

                  this._particleSystem.processor.onInit(ps);
                } else {
                  errorID(6034);
                }

                if (!useGPU) {
                  if (this.particleMaterial && this.particleMaterial.effectName.indexOf('particle-gpu') !== -1) {
                    this.particleMaterial = null;
                    warnID(6035);
                  }

                  this.cpuMaterial = this.particleMaterial;
                } else {
                  this.gpuMaterial = this.particleMaterial;
                }
              };

              _proto._switchProcessor = function _switchProcessor() {
                if (!this._particleSystem) {
                  return;
                }

                if (this._particleSystem.processor) {
                  this._particleSystem.processor.detachFromScene();

                  this._particleSystem.processor.clear();

                  this._particleSystem.processor = null;
                }

                var useGPU = this._useGPU && isSupportGPUParticle();

                if (!useGPU && this.cpuMaterial) {
                  this.particleMaterial = this.cpuMaterial;
                }

                if (useGPU && this.gpuMaterial) {
                  this.particleMaterial = this.gpuMaterial;
                }

                this._particleSystem.processor = useGPU ? new ParticleSystemRendererGPU(this) : new ParticleSystemRendererCPU(this);

                this._particleSystem.processor.updateAlignSpace(this.alignSpace);

                this._particleSystem.processor.onInit(this._particleSystem);

                this._particleSystem.processor.onEnable();

                this._particleSystem.bindModule();
              };

              _createClass(ParticleSystemRenderer, [{
                key: "renderMode",
                get: function get() {
                  return this._renderMode;
                },
                set: function set(val) {
                  if (this._renderMode === val) {
                    return;
                  }

                  this._renderMode = val;

                  if (this._particleSystem) {
                    this._particleSystem.processor.updateRenderMode();
                  }
                }
              }, {
                key: "velocityScale",
                get: function get() {
                  return this._velocityScale;
                },
                set: function set(val) {
                  this._velocityScale = val;

                  if (this._particleSystem) {
                    this._particleSystem.processor.updateMaterialParams();
                  }
                }
              }, {
                key: "lengthScale",
                get: function get() {
                  return this._lengthScale;
                },
                set: function set(val) {
                  this._lengthScale = val;

                  if (this._particleSystem) {
                    this._particleSystem.processor.updateMaterialParams();
                  }
                }
              }, {
                key: "mesh",
                get: function get() {
                  return this._mesh;
                },
                set: function set(val) {
                  this._mesh = val;

                  if (this._particleSystem) {
                    this._particleSystem.processor.setVertexAttributes();
                  }
                }
              }, {
                key: "particleMaterial",
                get: function get() {
                  if (!this._particleSystem) {
                    return null;
                  }

                  return this._particleSystem.getSharedMaterial(0);
                },
                set: function set(val) {
                  if (this._particleSystem) {
                    this._particleSystem.setMaterial(val, 0);
                  }
                }
              }, {
                key: "cpuMaterial",
                get: function get() {
                  return this._cpuMaterial;
                },
                set: function set(val) {
                  if (val === null) {
                    return;
                  } else {
                    var effectName = val.effectName;

                    if (effectName.indexOf('particle') === -1 || effectName.indexOf('particle-gpu') !== -1) {
                      warnID(6035);
                      return;
                    }
                  }

                  this._cpuMaterial = val;
                  this.particleMaterial = this._cpuMaterial;
                }
              }, {
                key: "gpuMaterial",
                get: function get() {
                  return this._gpuMaterial;
                },
                set: function set(val) {
                  if (val === null) {
                    return;
                  } else {
                    var effectName = val.effectName;

                    if (effectName.indexOf('particle-gpu') === -1) {
                      warnID(6035);
                      return;
                    }
                  }

                  this._gpuMaterial = val;
                  this.particleMaterial = this._gpuMaterial;
                }
              }, {
                key: "trailMaterial",
                get: function get() {
                  if (!this._particleSystem) {
                    return null;
                  }

                  return this._particleSystem.getSharedMaterial(1);
                },
                set: function set(val) {
                  if (this._particleSystem) {
                    this._particleSystem.setMaterial(val, 1);
                  }
                }
              }, {
                key: "mainTexture",
                get: function get() {
                  return this._mainTexture;
                },
                set: function set(val) {
                  this._mainTexture = val;
                }
              }, {
                key: "useGPU",
                get: function get() {
                  return this._useGPU;
                },
                set: function set(val) {
                  if (this._useGPU === val) {
                    return;
                  }

                  if (!isSupportGPUParticle()) {
                    this._useGPU = false;
                  } else {
                    this._useGPU = val;
                  }

                  this._switchProcessor();
                }
              }, {
                key: "alignSpace",
                get: function get() {
                  return this._alignSpace;
                },
                set: function set(val) {
                  this._alignSpace = val;

                  this._particleSystem.processor.updateAlignSpace(this._alignSpace);
                }
              }]);

              return ParticleSystemRenderer;
            }(), _class3$g.AlignmentSpace = AlignmentSpace, _temp$p), (_applyDecoratedDescriptor(_class2$1g.prototype, "renderMode", [_dec2$13], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "renderMode"), _class2$1g.prototype), _initializer$1b = applyDecoratedInitializer(_class2$1g.prototype, "_renderMode", [_dec3$K, serializable$j], function () {
              return RenderMode$1.Billboard;
            }), _initializer2$$ = applyDecoratedInitializer(_class2$1g.prototype, "_velocityScale", [serializable$j], function () {
              return 1;
            }), _initializer3$M = applyDecoratedInitializer(_class2$1g.prototype, "_lengthScale", [serializable$j], function () {
              return 1;
            }), _initializer4$H = applyDecoratedInitializer(_class2$1g.prototype, "_mesh", [serializable$j], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$1g.prototype, "mesh", [_dec4$u], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "mesh"), _class2$1g.prototype), _applyDecoratedDescriptor(_class2$1g.prototype, "particleMaterial", [_dec5$o], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "particleMaterial"), _class2$1g.prototype), _applyDecoratedDescriptor(_class2$1g.prototype, "cpuMaterial", [_dec6$k], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "cpuMaterial"), _class2$1g.prototype), _initializer5$y = applyDecoratedInitializer(_class2$1g.prototype, "_cpuMaterial", [serializable$j], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$1g.prototype, "gpuMaterial", [_dec7$f], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "gpuMaterial"), _class2$1g.prototype), _initializer6$r = applyDecoratedInitializer(_class2$1g.prototype, "_gpuMaterial", [serializable$j], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$1g.prototype, "trailMaterial", [_dec8$a], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "trailMaterial"), _class2$1g.prototype), _initializer7$k = applyDecoratedInitializer(_class2$1g.prototype, "_mainTexture", [serializable$j], function () {
              return null;
            }), _initializer8$i = applyDecoratedInitializer(_class2$1g.prototype, "_useGPU", [serializable$j], function () {
              return false;
            }), _applyDecoratedDescriptor(_class2$1g.prototype, "alignSpace", [_dec9$8], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "alignSpace"), _class2$1g.prototype), _initializer9$f = applyDecoratedInitializer(_class2$1g.prototype, "_alignSpace", [serializable$j], function () {
              return AlignmentSpace.View;
            })), _class2$1g)) || _class$1w);

            var _dec$1u, _dec2$14, _dec3$L, _dec4$v, _dec5$p, _dec6$l, _dec7$g, _dec8$b, _dec9$9, _class$1x, _class2$1h, _initializer$1c, _initializer2$10, _initializer3$N, _initializer4$I, _initializer5$z, _initializer6$s, _initializer7$l, _initializer8$j, _initializer9$g, _initializer10$e, _initializer11$a, _initializer12$a, _initializer13$a;
            var PRE_TRIANGLE_INDEX = 1;
            var NEXT_TRIANGLE_INDEX = 1 << 2;
            var DIRECTION_THRESHOLD = Math.cos(toRadian(100));
            var _temp_trailEle = {
              position: new Vec3(),
              velocity: new Vec3()
            };

            var _temp_quat = new Quat();

            var _temp_xform = new Mat4();

            var _temp_vec3 = new Vec3();

            var _temp_vec3_1$1 = new Vec3();

            var _temp_color = new Color$1();

            var TrailSegment = function () {
              function TrailSegment(maxTrailElementNum) {
                this.start = void 0;
                this.end = void 0;
                this.trailElements = void 0;
                this.start = -1;
                this.end = -1;
                this.trailElements = [];

                while (maxTrailElementNum--) {
                  this.trailElements.push({
                    position: new Vec3(),
                    lifetime: 0,
                    width: 0,
                    velocity: new Vec3(),
                    direction: 0,
                    color: new Color$1()
                  });
                }
              }

              var _proto = TrailSegment.prototype;

              _proto.getElement = function getElement(idx) {
                if (this.start === -1) {
                  return null;
                }

                if (idx < 0) {
                  idx = (idx + this.trailElements.length) % this.trailElements.length;
                }

                if (idx >= this.trailElements.length) {
                  idx %= this.trailElements.length;
                }

                return this.trailElements[idx];
              };

              _proto.addElement = function addElement() {
                if (this.trailElements.length === 0) {
                  return null;
                }

                if (this.start === -1) {
                  this.start = 0;
                  this.end = 1;
                  return this.trailElements[0];
                }

                if (this.start === this.end) {
                  this.trailElements.splice(this.end, 0, {
                    position: new Vec3(),
                    lifetime: 0,
                    width: 0,
                    velocity: new Vec3(),
                    direction: 0,
                    color: new Color$1()
                  });
                  this.start++;
                  this.start %= this.trailElements.length;
                }

                var newEleLoc = this.end++;
                this.end %= this.trailElements.length;
                return this.trailElements[newEleLoc];
              };

              _proto.iterateElement = function iterateElement(target, f, p, dt) {
                var end = this.start >= this.end ? this.end + this.trailElements.length : this.end;

                for (var i = this.start; i < end; i++) {
                  if (f(target, this.trailElements[i % this.trailElements.length], p, dt)) {
                    this.start++;
                    this.start %= this.trailElements.length;
                  }
                }

                if (this.start === end) {
                  this.start = -1;
                  this.end = -1;
                }
              };

              _proto.count = function count() {
                if (this.start < this.end) {
                  return this.end - this.start;
                } else {
                  return this.trailElements.length + this.end - this.start;
                }
              };

              _proto.clear = function clear() {
                this.start = -1;
                this.end = -1;
              };

              return TrailSegment;
            }();

            var TrailModule = (_dec$1u = ccclass$p('cc.TrailModule'), _dec2$14 = type$8(TrailMode), _dec3$L = type$8(CurveRange), _dec4$v = type$8(Space), _dec5$p = type$8(TextureMode), _dec6$l = type$8(CurveRange), _dec7$g = type$8(GradientRange), _dec8$b = type$8(GradientRange), _dec9$9 = type$8(Space), _dec$1u(_class$1x = (_class2$1h = function () {
              var _proto2 = TrailModule.prototype;

              _proto2.getModel = function getModel() {
                return this._trailModel;
              };

              function TrailModule() {
                this._enable = _initializer$1c && _initializer$1c();
                this.mode = _initializer2$10 && _initializer2$10();
                this.lifeTime = _initializer3$N && _initializer3$N();
                this._minParticleDistance = _initializer4$I && _initializer4$I();
                this.existWithParticles = _initializer5$z && _initializer5$z();
                this.textureMode = _initializer6$s && _initializer6$s();
                this.widthFromParticle = _initializer7$l && _initializer7$l();
                this.widthRatio = _initializer8$j && _initializer8$j();
                this.colorFromParticle = _initializer9$g && _initializer9$g();
                this.colorOverTrail = _initializer10$e && _initializer10$e();
                this.colorOvertime = _initializer11$a && _initializer11$a();
                this._space = _initializer12$a && _initializer12$a();
                this._particleSystem = _initializer13$a && _initializer13$a();
                this._minSquaredDistance = 0;
                this._vertSize = void 0;
                this._trailNum = 0;
                this._trailLifetime = 0;
                this.vbOffset = 0;
                this.ibOffset = 0;
                this._trailSegments = null;
                this._particleTrail = void 0;
                this._trailModel = null;
                this._iaInfo = void 0;
                this._iaInfoBuffer = null;
                this._subMeshData = null;
                this._vertAttrs = void 0;
                this._vbF32 = null;
                this._vbUint32 = null;
                this._iBuffer = null;
                this._needTransform = false;
                this._material = null;
                this._inited = void 0;
                this._iaInfo = new IndirectBuffer([new DrawInfo()]);
                this._vertAttrs = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGBA32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true)];
                this._vertSize = 0;

                for (var _iterator = _createForOfIteratorHelperLoose(this._vertAttrs), _step; !(_step = _iterator()).done;) {
                  var a = _step.value;
                  this._vertSize += FormatInfos[a.format].size;
                }

                this._particleTrail = new Map();
                this._inited = false;
              }

              _proto2.onInit = function onInit(ps) {
                this._particleSystem = ps;
                this.minParticleDistance = this._minParticleDistance;
                var burstCount = 0;
                var psTime = ps.startLifetime.getMax();
                var psRate = ps.rateOverTime.getMax();
                var duration = ps.duration;

                for (var i = 0, len = ps.bursts.length; i < len; i++) {
                  var b = ps.bursts[i];
                  burstCount += b.getMaxCount(ps) * Math.ceil(psTime / duration);
                }

                if (this.lifeTime.getMax() < 1.0) {
                  warnID(6036);
                }

                this._trailNum = Math.ceil(psTime * Math.ceil(this.lifeTime.getMax()) * 60 * (psRate * duration + burstCount));
                this._trailSegments = new Pool(function () {
                  return new TrailSegment(10);
                }, Math.ceil(psRate * duration), function (obj) {
                  return obj.trailElements.length = 0;
                });

                if (this._enable) {
                  this.enable = this._enable;
                }

                this._inited = true;
              };

              _proto2.onEnable = function onEnable() {
                this._attachToScene();
              };

              _proto2.onDisable = function onDisable() {
                this._particleTrail.clear();

                this._detachFromScene();
              };

              _proto2._attachToScene = function _attachToScene() {
                if (this._trailModel) {
                  if (this._trailModel.scene) {
                    this._detachFromScene();
                  }

                  this._particleSystem._getRenderScene().addModel(this._trailModel);
                }
              };

              _proto2._detachFromScene = function _detachFromScene() {
                if (this._trailModel && this._trailModel.scene) {
                  this._trailModel.scene.removeModel(this._trailModel);
                }
              };

              _proto2.destroy = function destroy() {
                this.destroySubMeshData();

                if (this._trailModel) {
                  director.root.destroyModel(this._trailModel);
                  this._trailModel = null;
                }

                if (this._trailSegments) {
                  this._trailSegments.destroy();

                  this._trailSegments = null;
                }
              };

              _proto2.play = function play() {
                if (this._trailModel && this._enable) {
                  this._trailModel.enabled = true;
                }
              };

              _proto2.clear = function clear() {
                if (this.enable) {
                  var trailIter = this._particleTrail.values();

                  var trail = trailIter.next();

                  while (!trail.done) {
                    trail.value.clear();
                    trail = trailIter.next();
                  }

                  this._particleTrail.clear();

                  this.updateRenderData();
                  if (this._trailModel) this._trailModel.enabled = false;
                }
              };

              _proto2.updateMaterial = function updateMaterial() {
                if (this._particleSystem) {
                  this._material = this._particleSystem.getMaterialInstance(1) || this._particleSystem.processor._defaultTrailMat;

                  if (this._trailModel) {
                    this._trailModel.setSubModelMaterial(0, this._material);
                  }
                }
              };

              _proto2.update = function update() {
                this._trailLifetime = this.lifeTime.evaluate(this._particleSystem._time, 1);

                if (this.space === Space.World && this._particleSystem._simulationSpace === Space.Local) {
                  this._needTransform = true;

                  this._particleSystem.node.getWorldMatrix(_temp_xform);

                  this._particleSystem.node.getWorldRotation(_temp_quat);
                } else {
                  this._needTransform = false;
                }
              };

              _proto2.animate = function animate(p, scaledDt) {
                if (!this._trailSegments) {
                  return;
                }

                if (p.loopCount > p.lastLoop) {
                  if (p.trailDelay > 1) {
                    p.lastLoop = p.loopCount;
                    p.trailDelay = 0;
                  } else {
                    p.trailDelay++;
                  }

                  return;
                }

                var trail = this._particleTrail.get(p);

                if (!trail) {
                  trail = this._trailSegments.alloc();

                  this._particleTrail.set(p, trail);

                  return;
                }

                var lastSeg = trail.getElement(trail.end - 1);

                if (this._needTransform) {
                  Vec3.transformMat4(_temp_vec3, p.position, _temp_xform);
                } else {
                  Vec3.copy(_temp_vec3, p.position);
                }

                if (lastSeg) {
                  trail.iterateElement(this, this._updateTrailElement, p, scaledDt);

                  if (Vec3.squaredDistance(lastSeg.position, _temp_vec3) < this._minSquaredDistance) {
                    return;
                  }
                }

                lastSeg = trail.addElement();

                if (!lastSeg) {
                  return;
                }

                Vec3.copy(lastSeg.position, _temp_vec3);
                lastSeg.lifetime = 0;

                if (this.widthFromParticle) {
                  lastSeg.width = p.size.x * this.widthRatio.evaluate(0, 1);
                } else {
                  lastSeg.width = this.widthRatio.evaluate(0, 1);
                }

                var trailNum = trail.count();

                if (trailNum === 2) {
                  var lastSecondTrail = trail.getElement(trail.end - 2);
                  Vec3.subtract(lastSecondTrail.velocity, lastSeg.position, lastSecondTrail.position);
                } else if (trailNum > 2) {
                  var _lastSecondTrail = trail.getElement(trail.end - 2);

                  var lastThirdTrail = trail.getElement(trail.end - 3);
                  Vec3.subtract(_temp_vec3, lastThirdTrail.position, _lastSecondTrail.position);
                  Vec3.subtract(_temp_vec3_1$1, lastSeg.position, _lastSecondTrail.position);
                  Vec3.subtract(_lastSecondTrail.velocity, _temp_vec3_1$1, _temp_vec3);

                  if (Vec3.equals(Vec3.ZERO, _lastSecondTrail.velocity)) {
                    Vec3.copy(_lastSecondTrail.velocity, _temp_vec3);
                  }

                  Vec3.normalize(_lastSecondTrail.velocity, _lastSecondTrail.velocity);

                  this._checkDirectionReverse(_lastSecondTrail, lastThirdTrail);
                }

                if (this.colorFromParticle) {
                  lastSeg.color.set(p.color);
                } else {
                  lastSeg.color.set(this.colorOvertime.evaluate(0, 1));
                }
              };

              _proto2.removeParticle = function removeParticle(p) {
                var trail = this._particleTrail.get(p);

                if (trail && this._trailSegments) {
                  trail.clear();

                  this._trailSegments.free(trail);

                  this._particleTrail["delete"](p);
                }
              };

              _proto2.updateRenderData = function updateRenderData() {
                this.vbOffset = 0;
                this.ibOffset = 0;

                for (var _iterator2 = _createForOfIteratorHelperLoose(this._particleTrail.keys()), _step2; !(_step2 = _iterator2()).done;) {
                  var p = _step2.value;

                  var trailSeg = this._particleTrail.get(p);

                  if (trailSeg.start === -1) {
                    continue;
                  }

                  var indexOffset = this.vbOffset * 4 / this._vertSize;
                  var end = trailSeg.start >= trailSeg.end ? trailSeg.end + trailSeg.trailElements.length : trailSeg.end;
                  var trailNum = end - trailSeg.start;
                  var textCoordSeg = 1 / trailNum;
                  var startSegEle = trailSeg.trailElements[trailSeg.start];

                  this._fillVertexBuffer(startSegEle, this.colorOverTrail.evaluate(1, 1), indexOffset, 1, 0, NEXT_TRIANGLE_INDEX);

                  for (var i = trailSeg.start + 1; i < end; i++) {
                    var segEle = trailSeg.trailElements[i % trailSeg.trailElements.length];
                    var j = i - trailSeg.start;

                    this._fillVertexBuffer(segEle, this.colorOverTrail.evaluate(1 - j / trailNum, 1), indexOffset, 1 - j * textCoordSeg, j, PRE_TRIANGLE_INDEX | NEXT_TRIANGLE_INDEX);
                  }

                  if (this._needTransform) {
                    Vec3.transformMat4(_temp_trailEle.position, p.position, _temp_xform);
                  } else {
                    Vec3.copy(_temp_trailEle.position, p.position);
                  }

                  var trailModel = this._trailModel;

                  if (trailModel) {
                    trailModel.node.invalidateChildren(TransformBit.POSITION);
                  }

                  if (trailNum === 1 || trailNum === 2) {
                    var lastSecondTrail = trailSeg.getElement(trailSeg.end - 1);
                    Vec3.subtract(lastSecondTrail.velocity, _temp_trailEle.position, lastSecondTrail.position);
                    this._vbF32[this.vbOffset - this._vertSize / 4 - 4] = lastSecondTrail.velocity.x;
                    this._vbF32[this.vbOffset - this._vertSize / 4 - 3] = lastSecondTrail.velocity.y;
                    this._vbF32[this.vbOffset - this._vertSize / 4 - 2] = lastSecondTrail.velocity.z;
                    this._vbF32[this.vbOffset - 4] = lastSecondTrail.velocity.x;
                    this._vbF32[this.vbOffset - 3] = lastSecondTrail.velocity.y;
                    this._vbF32[this.vbOffset - 2] = lastSecondTrail.velocity.z;
                    Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, lastSecondTrail.position);

                    this._checkDirectionReverse(_temp_trailEle, lastSecondTrail);
                  } else if (trailNum > 2) {
                    var _lastSecondTrail2 = trailSeg.getElement(trailSeg.end - 1);

                    var lastThirdTrail = trailSeg.getElement(trailSeg.end - 2);
                    Vec3.subtract(_temp_vec3, lastThirdTrail.position, _lastSecondTrail2.position);
                    Vec3.subtract(_temp_vec3_1$1, _temp_trailEle.position, _lastSecondTrail2.position);
                    Vec3.normalize(_temp_vec3, _temp_vec3);
                    Vec3.normalize(_temp_vec3_1$1, _temp_vec3_1$1);
                    Vec3.subtract(_lastSecondTrail2.velocity, _temp_vec3_1$1, _temp_vec3);
                    Vec3.normalize(_lastSecondTrail2.velocity, _lastSecondTrail2.velocity);

                    this._checkDirectionReverse(_lastSecondTrail2, lastThirdTrail);

                    this.vbOffset -= this._vertSize / 4 * 2;
                    this.ibOffset -= 6;

                    this._fillVertexBuffer(_lastSecondTrail2, this.colorOverTrail.evaluate(textCoordSeg, 1), indexOffset, textCoordSeg, trailNum - 1, PRE_TRIANGLE_INDEX | NEXT_TRIANGLE_INDEX);

                    Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, _lastSecondTrail2.position);
                    Vec3.normalize(_temp_trailEle.velocity, _temp_trailEle.velocity);

                    this._checkDirectionReverse(_temp_trailEle, _lastSecondTrail2);
                  }

                  if (this.widthFromParticle) {
                    _temp_trailEle.width = p.size.x * this.widthRatio.evaluate(0, 1);
                  } else {
                    _temp_trailEle.width = this.widthRatio.evaluate(0, 1);
                  }

                  _temp_trailEle.color = p.color;

                  if (Vec3.equals(_temp_trailEle.velocity, Vec3.ZERO)) {
                    this.ibOffset -= 3;
                  } else {
                    this._fillVertexBuffer(_temp_trailEle, this.colorOverTrail.evaluate(0, 1), indexOffset, 0, trailNum, PRE_TRIANGLE_INDEX);
                  }
                }

                if (this._trailModel) {
                  this._trailModel.enabled = this.ibOffset > 0;
                }
              };

              _proto2.updateIA = function updateIA(count) {
                var subModels = this._trailModel && this._trailModel.subModels;

                if (subModels && subModels.length > 0) {
                  var subModel = subModels[0];
                  subModel.inputAssembler.vertexBuffers[0].update(this._vbF32);
                  subModel.inputAssembler.indexBuffer.update(this._iBuffer);
                  this._iaInfo.drawInfos[0].firstIndex = 0;
                  this._iaInfo.drawInfos[0].indexCount = count;

                  this._iaInfoBuffer.update(this._iaInfo);
                }
              };

              _proto2.beforeRender = function beforeRender() {
                this.updateIA(this.ibOffset);
              };

              _proto2._createModel = function _createModel() {
                if (this._trailModel) {
                  return;
                }

                this._trailModel = legacyCC.director.root.createModel(Model);
              };

              _proto2.rebuild = function rebuild() {
                var device = director.root.device;
                var vertexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, this._vertSize * (this._trailNum + 1) * 2, this._vertSize));
                var vBuffer = new ArrayBuffer(this._vertSize * (this._trailNum + 1) * 2);
                this._vbF32 = new Float32Array(vBuffer);
                this._vbUint32 = new Uint32Array(vBuffer);
                vertexBuffer.update(vBuffer);
                var indexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, Math.max(1, this._trailNum) * 6 * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));
                this._iBuffer = new Uint16Array(Math.max(1, this._trailNum) * 6);
                indexBuffer.update(this._iBuffer);
                this._iaInfoBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDIRECT, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, DRAW_INFO_SIZE, DRAW_INFO_SIZE));
                this._iaInfo.drawInfos[0].vertexCount = (this._trailNum + 1) * 2;
                this._iaInfo.drawInfos[0].indexCount = this._trailNum * 6;

                this._iaInfoBuffer.update(this._iaInfo);

                this._subMeshData = new RenderingSubMesh([vertexBuffer], this._vertAttrs, PrimitiveMode.TRIANGLE_LIST, indexBuffer, this._iaInfoBuffer);
                var trailModel = this._trailModel;

                if (trailModel && this._material) {
                  trailModel.node = trailModel.transform = this._particleSystem.node;
                  trailModel.visFlags = this._particleSystem.visibility;
                  trailModel.initSubModel(0, this._subMeshData, this._material);
                  trailModel.enabled = true;
                }
              };

              _proto2._updateTrailElement = function _updateTrailElement(module, trailEle, p, dt) {
                trailEle.lifetime += dt;

                if (module.colorFromParticle) {
                  trailEle.color.set(p.color);
                  trailEle.color.multiply(module.colorOvertime.evaluate(1.0 - p.remainingLifetime / p.startLifetime, 1));
                } else {
                  trailEle.color.set(module.colorOvertime.evaluate(1.0 - p.remainingLifetime / p.startLifetime, 1));
                }

                if (module.widthFromParticle) {
                  trailEle.width = p.size.x * module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1);
                } else {
                  trailEle.width = module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1);
                }

                return trailEle.lifetime > module._trailLifetime;
              };

              _proto2._fillVertexBuffer = function _fillVertexBuffer(trailSeg, colorModifer, indexOffset, xTexCoord, trailEleIdx, indexSet) {
                this._vbF32[this.vbOffset++] = trailSeg.position.x;
                this._vbF32[this.vbOffset++] = trailSeg.position.y;
                this._vbF32[this.vbOffset++] = trailSeg.position.z;
                this._vbF32[this.vbOffset++] = trailSeg.direction;
                this._vbF32[this.vbOffset++] = trailSeg.width;
                this._vbF32[this.vbOffset++] = xTexCoord;
                this._vbF32[this.vbOffset++] = 0;
                this._vbF32[this.vbOffset++] = trailSeg.velocity.x;
                this._vbF32[this.vbOffset++] = trailSeg.velocity.y;
                this._vbF32[this.vbOffset++] = trailSeg.velocity.z;

                _temp_color.set(trailSeg.color);

                _temp_color.multiply(colorModifer);

                this._vbUint32[this.vbOffset++] = _temp_color._val;
                this._vbF32[this.vbOffset++] = trailSeg.position.x;
                this._vbF32[this.vbOffset++] = trailSeg.position.y;
                this._vbF32[this.vbOffset++] = trailSeg.position.z;
                this._vbF32[this.vbOffset++] = 1 - trailSeg.direction;
                this._vbF32[this.vbOffset++] = trailSeg.width;
                this._vbF32[this.vbOffset++] = xTexCoord;
                this._vbF32[this.vbOffset++] = 1;
                this._vbF32[this.vbOffset++] = trailSeg.velocity.x;
                this._vbF32[this.vbOffset++] = trailSeg.velocity.y;
                this._vbF32[this.vbOffset++] = trailSeg.velocity.z;
                this._vbUint32[this.vbOffset++] = _temp_color._val;

                if (indexSet & PRE_TRIANGLE_INDEX) {
                  this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx;
                  this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx - 1;
                  this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1;
                }

                if (indexSet & NEXT_TRIANGLE_INDEX) {
                  this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx;
                  this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1;
                  this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 2;
                }
              };

              _proto2._checkDirectionReverse = function _checkDirectionReverse(currElement, prevElement) {
                if (Vec3.dot(currElement.velocity, prevElement.velocity) < DIRECTION_THRESHOLD) {
                  currElement.direction = 1 - prevElement.direction;
                } else {
                  currElement.direction = prevElement.direction;
                }
              };

              _proto2.destroySubMeshData = function destroySubMeshData() {
                if (this._subMeshData) {
                  this._subMeshData.destroy();

                  this._subMeshData = null;
                }
              };

              _createClass(TrailModule, [{
                key: "enable",
                get: function get() {
                  return this._enable;
                },
                set: function set(val) {
                  if (val === this._enable && this._trailModel) {
                    return;
                  }

                  if (val && !this._enable) {
                    this._enable = val;
                    if (this._particleSystem.processor) this._particleSystem.processor.updateTrailMaterial();
                  }

                  if (val && !this._trailModel) {
                    this._createModel();

                    this.rebuild();
                  }

                  this._enable = val;

                  if (this._trailModel) {
                    this._trailModel.enabled = val;
                  }

                  if (val) this.onEnable();else this.onDisable();
                }
              }, {
                key: "minParticleDistance",
                get: function get() {
                  return this._minParticleDistance;
                },
                set: function set(val) {
                  this._minParticleDistance = val;
                  this._minSquaredDistance = val * val;
                }
              }, {
                key: "space",
                get: function get() {
                  return this._space;
                },
                set: function set(val) {
                  this._space = val;
                  var ps = this._particleSystem;

                  if (ps && ps.processor) {
                    ps.processor.updateTrailMaterial();
                  }
                }
              }]);

              return TrailModule;
            }(), (_initializer$1c = applyDecoratedInitializer(_class2$1h.prototype, "_enable", [serializable$j], function () {
              return false;
            }), _initializer2$10 = applyDecoratedInitializer(_class2$1h.prototype, "mode", [_dec2$14, serializable$j], function () {
              return TrailMode.Particles;
            }), _initializer3$N = applyDecoratedInitializer(_class2$1h.prototype, "lifeTime", [_dec3$L, serializable$j], function () {
              return new CurveRange();
            }), _initializer4$I = applyDecoratedInitializer(_class2$1h.prototype, "_minParticleDistance", [serializable$j], function () {
              return 0.1;
            }), _applyDecoratedDescriptor(_class2$1h.prototype, "space", [_dec4$v], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "space"), _class2$1h.prototype), _initializer5$z = applyDecoratedInitializer(_class2$1h.prototype, "existWithParticles", [serializable$j], function () {
              return true;
            }), _initializer6$s = applyDecoratedInitializer(_class2$1h.prototype, "textureMode", [_dec5$p, serializable$j], function () {
              return TextureMode.Stretch;
            }), _initializer7$l = applyDecoratedInitializer(_class2$1h.prototype, "widthFromParticle", [serializable$j], function () {
              return true;
            }), _initializer8$j = applyDecoratedInitializer(_class2$1h.prototype, "widthRatio", [_dec6$l, serializable$j], function () {
              return new CurveRange();
            }), _initializer9$g = applyDecoratedInitializer(_class2$1h.prototype, "colorFromParticle", [serializable$j], function () {
              return false;
            }), _initializer10$e = applyDecoratedInitializer(_class2$1h.prototype, "colorOverTrail", [_dec7$g, serializable$j], function () {
              return new GradientRange();
            }), _initializer11$a = applyDecoratedInitializer(_class2$1h.prototype, "colorOvertime", [_dec8$b, serializable$j], function () {
              return new GradientRange();
            }), _initializer12$a = applyDecoratedInitializer(_class2$1h.prototype, "_space", [_dec9$9], function () {
              return Space.World;
            }), _initializer13$a = applyDecoratedInitializer(_class2$1h.prototype, "_particleSystem", [serializable$j], function () {
              return null;
            })), _class2$1h)) || _class$1x);

            var _node_mat = new Mat4();

            var _node_parent_inv = new Mat4();

            var _node_rol = new Quat();

            var _node_scale = new Vec3();

            var _anim_module$1 = ['_colorOverLifetimeModule', '_sizeOvertimeModule', '_velocityOvertimeModule', '_forceOvertimeModule', '_limitVelocityOvertimeModule', '_rotationOvertimeModule', '_textureAnimationModule'];
            var ParticleCuller = function () {
              function ParticleCuller(ps) {
                this._particleSystem = void 0;
                this._processor = void 0;
                this._node = void 0;
                this._particlesAll = void 0;
                this._updateList = new Map();
                this._animateList = new Map();
                this._runAnimateList = new Array();
                this._localMat = new Mat4();
                this._gravity = new Vec4();
                this.minPos = new Vec3();
                this.maxPos = new Vec3();
                this._nodePos = new Vec3();
                this._nodeSize = new Vec3();
                this._particleSystem = ps;
                this._processor = this._particleSystem.processor;
                this._node = ps.node;
                this._particlesAll = [];

                this._initModuleList();
              }

              var _proto = ParticleCuller.prototype;

              _proto._updateBoundingNode = function _updateBoundingNode() {
                this._nodeSize.set(this.maxPos.x - this.minPos.x, this.maxPos.y - this.minPos.y, this.maxPos.z - this.minPos.z);

                this._nodePos.set(this.minPos.x + this._nodeSize.x * 0.5, this.minPos.y + this._nodeSize.y * 0.5, this.minPos.z + this._nodeSize.z * 0.5);
              };

              _proto.setBoundingBoxSize = function setBoundingBoxSize(halfExt) {
                this.maxPos.x = this._nodePos.x + halfExt.x;
                this.maxPos.y = this._nodePos.y + halfExt.y;
                this.maxPos.z = this._nodePos.z + halfExt.z;
                this.minPos.x = this._nodePos.x - halfExt.x;
                this.minPos.y = this._nodePos.y - halfExt.y;
                this.minPos.z = this._nodePos.z - halfExt.z;

                this._updateBoundingNode();
              };

              _proto.setBoundingBoxCenter = function setBoundingBoxCenter(px, py, pz) {
                this.maxPos.x = px + this._nodeSize.x * 0.5;
                this.maxPos.y = py + this._nodeSize.y * 0.5;
                this.maxPos.z = pz + this._nodeSize.z * 0.5;
                this.minPos.x = px - this._nodeSize.x * 0.5;
                this.minPos.y = py - this._nodeSize.y * 0.5;
                this.minPos.z = pz - this._nodeSize.z * 0.5;

                this._updateBoundingNode();
              };

              _proto._initModuleList = function _initModuleList() {
                var _this = this;

                _anim_module$1.forEach(function (val) {
                  var pm = _this._particleSystem[val];

                  if (pm && pm.enable) {
                    if (pm.needUpdate) {
                      _this._updateList[pm.name] = pm;
                    }

                    if (pm.needAnimate) {
                      _this._animateList[pm.name] = pm;
                    }
                  }
                });

                this._runAnimateList.length = 0;

                for (var i = 0, len = PARTICLE_MODULE_ORDER.length; i < len; i++) {
                  var p = this._animateList[PARTICLE_MODULE_ORDER[i]];

                  if (p) {
                    this._runAnimateList.push(p);
                  }
                }
              };

              _proto._emit = function _emit(count, dt, particleLst) {
                var ps = this._particleSystem;
                var node = this._node;
                var loopDelta = ps.time % ps.duration / ps.duration;
                node.invalidateChildren(TransformBit.POSITION);

                if (ps.simulationSpace === Space.World) {
                  node.getWorldMatrix(_node_mat);
                  node.getWorldRotation(_node_rol);
                }

                for (var i = 0; i < count; ++i) {
                  var particle = new Particle(ps);
                  particle.particleSystem = ps;
                  particle.reset();
                  var rand = pseudoRandom(randomRangeInt(0, INT_MAX));

                  if (ps._shapeModule && ps._shapeModule.enable) {
                    ps._shapeModule.emit(particle);
                  } else {
                    Vec3.set(particle.position, 0, 0, 0);
                    Vec3.copy(particle.velocity, particleEmitZAxis);
                  }

                  if (ps._textureAnimationModule && ps._textureAnimationModule.enable) {
                    ps._textureAnimationModule.init(particle);
                  }

                  var curveStartSpeed = ps.startSpeed.evaluate(loopDelta, rand);
                  Vec3.multiplyScalar(particle.velocity, particle.velocity, curveStartSpeed);

                  if (ps.simulationSpace === Space.World) {
                    Vec3.transformMat4(particle.position, particle.position, _node_mat);
                    Vec3.transformQuat(particle.velocity, particle.velocity, _node_rol);
                  }

                  Vec3.copy(particle.ultimateVelocity, particle.velocity);
                  Vec3.set(particle.rotation, 0, 0, 0);

                  if (ps.startSize3D) {
                    Vec3.set(particle.startSize, ps.startSizeX.evaluate(loopDelta, rand), ps.startSizeY.evaluate(loopDelta, rand), ps.startSizeZ.evaluate(loopDelta, rand));
                  } else {
                    Vec3.set(particle.startSize, ps.startSizeX.evaluate(loopDelta, rand), 1, 1);
                    particle.startSize.y = particle.startSize.x;
                  }

                  Vec3.copy(particle.size, particle.startSize);
                  particle.startLifetime = ps.startLifetime.evaluate(loopDelta, rand) + dt;
                  particle.remainingLifetime = particle.startLifetime;
                  particleLst.push(particle);
                }
              };

              _proto._updateParticles = function _updateParticles(dt, particleLst) {
                var _this2 = this;

                var ps = this._particleSystem;
                ps.node.getWorldMatrix(_node_mat);

                switch (ps.scaleSpace) {
                  case Space.Local:
                    ps.node.getScale(_node_scale);
                    break;

                  case Space.World:
                    ps.node.getWorldScale(_node_scale);
                    break;
                }

                this._updateList.forEach(function (value, key) {
                  value.update(ps.simulationSpace, _node_mat);
                });

                if (ps.simulationSpace === Space.Local) {
                  var r = ps.node.getRotation();
                  Mat4.fromQuat(this._localMat, r);

                  this._localMat.transpose();
                }

                if (ps.node.parent) {
                  ps.node.parent.getWorldMatrix(_node_parent_inv);

                  _node_parent_inv.invert();
                }

                var _loop = function _loop(i) {
                  var p = particleLst[i];
                  p.remainingLifetime -= dt;
                  Vec3.set(p.animatedVelocity, 0, 0, 0);
                  var useGravity = ps.gravityModifier.mode !== Mode.Constant || ps.gravityModifier.constant !== 0;

                  if (useGravity) {
                    var rand = isCurveTwoValues(ps.gravityModifier) ? pseudoRandom(p.randomSeed) : 0;

                    if (ps.simulationSpace === Space.Local) {
                      var gravityFactor = -ps.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, rand) * 9.8 * dt;
                      _this2._gravity.x = 0.0;
                      _this2._gravity.y = gravityFactor;
                      _this2._gravity.z = 0.0;
                      _this2._gravity.w = 1.0;

                      if (!approx(gravityFactor, 0.0, EPSILON$2)) {
                        if (ps.node.parent) {
                          _this2._gravity = _this2._gravity.transformMat4(_node_parent_inv);
                        }

                        _this2._gravity = _this2._gravity.transformMat4(_this2._localMat);
                        p.velocity.x += _this2._gravity.x;
                        p.velocity.y += _this2._gravity.y;
                        p.velocity.z += _this2._gravity.z;
                      }
                    } else {
                      p.velocity.y -= ps.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, rand) * 9.8 * dt;
                    }
                  }

                  Vec3.copy(p.ultimateVelocity, p.velocity);

                  _this2._runAnimateList.forEach(function (value) {
                    value.animate(p, dt);
                  });

                  Vec3.scaleAndAdd(p.position, p.position, p.ultimateVelocity, dt);
                };

                for (var i = 0; i < particleLst.length; ++i) {
                  _loop(i);
                }
              };

              _proto._calculateBounding = function _calculateBounding(isInit) {
                var size = new Vec3();
                var position = new Vec3();
                var subPos = new Vec3();
                var addPos = new Vec3();
                var meshSize = new Vec3(1.0, 1.0, 1.0);

                if (this._processor.getInfo().renderMode === RenderMode$1.Mesh) {
                  var mesh = this._processor.getInfo().mesh;

                  if (mesh && mesh.struct.minPosition && mesh.struct.maxPosition) {
                    var meshAABB = new AABB();
                    AABB.fromPoints(meshAABB, mesh.struct.minPosition, mesh.struct.maxPosition);
                    var meshMax = Math.max(meshAABB.halfExtents.x, meshAABB.halfExtents.y, meshAABB.halfExtents.z);
                    meshSize.set(meshMax, meshMax, meshMax);
                  }
                }

                var worldMat = this._particleSystem.node.worldMatrix;

                for (var i = 0; i < this._particlesAll.length; ++i) {
                  var p = this._particlesAll[i];
                  Vec3.multiply(size, _node_scale, p.size);
                  Vec3.multiply(size, size, meshSize);
                  position.set(p.position);

                  if (this._particleSystem.simulationSpace !== Space.World) {
                    Vec3.transformMat4(position, position, worldMat);
                  }

                  if (isInit && i === 0) {
                    Vec3.subtract(this.minPos, position, size);
                    Vec3.add(this.maxPos, position, size);
                  } else {
                    Vec3.subtract(subPos, position, size);
                    Vec3.add(addPos, position, size);
                    Vec3.min(this.minPos, this.minPos, subPos);
                    Vec3.max(this.maxPos, this.maxPos, addPos);
                  }
                }
              };

              _proto.calculatePositions = function calculatePositions() {
                this._emit(this._particleSystem.capacity, 0, this._particlesAll);

                var rand = isCurveTwoValues(this._particleSystem.startLifetime) ? pseudoRandom(randomRangeInt(0, INT_MAX)) : 0;

                this._updateParticles(0, this._particlesAll);

                this._calculateBounding(true);

                this._updateParticles(this._particleSystem.startLifetime.evaluate(0, rand), this._particlesAll);

                this._calculateBounding(false);

                this._updateBoundingNode();
              };

              _proto.clear = function clear() {
                this._particlesAll.length = 0;
              };

              _proto.destroy = function destroy() {};

              return ParticleCuller;
            }();

            var _dec$1v, _dec2$15, _dec3$M, _dec4$w, _dec5$q, _dec6$m, _dec7$h, _dec8$c, _dec9$a, _dec10$4, _dec11$2, _dec12$1, _dec13$1, _dec14$1, _class$1y, _class2$1i, _initializer$1d, _initializer2$11, _initializer3$O, _initializer4$J, _initializer5$A, _initializer6$t, _initializer7$m, _initializer8$k, _initializer9$h, _initializer10$f, _initializer11$b, _initializer12$b, _initializer13$b, _initializer14$7;
            var ccclass$n = ccclass$p,
                serializable$h = serializable$j,
                type$7 = type$8;
            var NoiseModule = (_dec$1v = ccclass$n('cc.NoiseModule'), _dec2$15 = type$7(CCFloat), _dec3$M = type$7(CCFloat), _dec4$w = type$7(CCFloat), _dec5$q = type$7(CCFloat), _dec6$m = type$7(CCFloat), _dec7$h = type$7(CCFloat), _dec8$c = type$7(CCFloat), _dec9$a = type$7(CCFloat), _dec10$4 = type$7(CCFloat), _dec11$2 = type$7(CCFloat), _dec12$1 = type$7(CCInteger), _dec13$1 = type$7(CCFloat), _dec14$1 = type$7(CCFloat), _dec$1v(_class$1y = (_class2$1i = function (_ParticleModuleBase) {
              _inheritsLoose(NoiseModule, _ParticleModuleBase);

              function NoiseModule() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _ParticleModuleBase.call.apply(_ParticleModuleBase, [this].concat(args)) || this;
                _this._enable = _initializer$1d && _initializer$1d();
                _this._strengthX = _initializer2$11 && _initializer2$11();
                _this._strengthY = _initializer3$O && _initializer3$O();
                _this._strengthZ = _initializer4$J && _initializer4$J();
                _this._noiseSpeedX = _initializer5$A && _initializer5$A();
                _this._noiseSpeedY = _initializer6$t && _initializer6$t();
                _this._noiseSpeedZ = _initializer7$m && _initializer7$m();
                _this._noiseFrequency = _initializer8$k && _initializer8$k();
                _this._remapX = _initializer9$h && _initializer9$h();
                _this._remapY = _initializer10$f && _initializer10$f();
                _this._remapZ = _initializer11$b && _initializer11$b();
                _this._octaves = _initializer12$b && _initializer12$b();
                _this._octaveMultiplier = _initializer13$b && _initializer13$b();
                _this._octaveScale = _initializer14$7 && _initializer14$7();
                _this.name = PARTICLE_MODULE_NAME.NOISE;
                _this.noise = new ParticleNoise();
                _this.samplePosition = new Vec3();
                return _this;
              }

              var _proto = NoiseModule.prototype;

              _proto.animate = function animate(particle, dt) {
                this.noise.setTime(particle.particleSystem.time);
                this.noise.setSpeed(this.noiseSpeedX, this.noiseSpeedY, this.noiseSpeedZ);
                this.noise.setFrequency(this.noiseFrequency);
                this.noise.setAbs(this.remapX, this.remapY, this.remapZ);
                this.noise.setAmplititude(this.strengthX, this.strengthY, this.strengthZ);
                this.noise.setOctaves(this.octaves, this.octaveMultiplier, this.octaveScale);
                this.samplePosition.set(particle.position);
                this.samplePosition.add3f(Math.random() * 1.0, Math.random() * 1.0, Math.random() * 1.0);
                this.noise.setSamplePoint(this.samplePosition);
                this.noise.getNoiseParticle();
                var noisePosition = this.noise.getResult();
                noisePosition.multiply3f(Math.random(), Math.random(), Math.random());
                Vec3.add(particle.position, particle.position, noisePosition.multiplyScalar(dt));
              };

              _proto.getNoisePreview = function getNoisePreview(out, ps, width, height) {
                this.noise.setTime(ps.time);
                this.noise.setSpeed(this.noiseSpeedX, this.noiseSpeedY, this.noiseSpeedZ);
                this.noise.setFrequency(this.noiseFrequency);
                this.noise.setAbs(this.remapX, this.remapY, this.remapZ);
                this.noise.setAmplititude(this.strengthX, this.strengthY, this.strengthZ);
                this.noise.setOctaves(this.octaves, this.octaveMultiplier, this.octaveScale);
                this.noise.getNoiseParticle();
                this.noise.getPreview(out, width, height);
              };

              _createClass(NoiseModule, [{
                key: "enable",
                get: function get() {
                  return this._enable;
                },
                set: function set(val) {
                  if (this._enable === val) return;
                  this._enable = val;
                  if (!this.target) return;
                  this.target.enableModule(this.name, val, this);
                }
              }, {
                key: "strengthX",
                get: function get() {
                  return this._strengthX;
                },
                set: function set(value) {
                  this._strengthX = value;
                }
              }, {
                key: "strengthY",
                get: function get() {
                  return this._strengthY;
                },
                set: function set(value) {
                  this._strengthY = value;
                }
              }, {
                key: "strengthZ",
                get: function get() {
                  return this._strengthZ;
                },
                set: function set(value) {
                  this._strengthZ = value;
                }
              }, {
                key: "noiseSpeedX",
                get: function get() {
                  return this._noiseSpeedX;
                },
                set: function set(value) {
                  this._noiseSpeedX = value;
                }
              }, {
                key: "noiseSpeedY",
                get: function get() {
                  return this._noiseSpeedY;
                },
                set: function set(value) {
                  this._noiseSpeedY = value;
                }
              }, {
                key: "noiseSpeedZ",
                get: function get() {
                  return this._noiseSpeedZ;
                },
                set: function set(value) {
                  this._noiseSpeedZ = value;
                }
              }, {
                key: "noiseFrequency",
                get: function get() {
                  return this._noiseFrequency;
                },
                set: function set(value) {
                  this._noiseFrequency = value;
                }
              }, {
                key: "remapX",
                get: function get() {
                  return this._remapX;
                },
                set: function set(value) {
                  this._remapX = value;
                }
              }, {
                key: "remapY",
                get: function get() {
                  return this._remapY;
                },
                set: function set(value) {
                  this._remapY = value;
                }
              }, {
                key: "remapZ",
                get: function get() {
                  return this._remapZ;
                },
                set: function set(value) {
                  this._remapZ = value;
                }
              }, {
                key: "octaves",
                get: function get() {
                  return this._octaves;
                },
                set: function set(value) {
                  this._octaves = value;
                }
              }, {
                key: "octaveMultiplier",
                get: function get() {
                  return this._octaveMultiplier;
                },
                set: function set(value) {
                  this._octaveMultiplier = value;
                }
              }, {
                key: "octaveScale",
                get: function get() {
                  return this._octaveScale;
                },
                set: function set(value) {
                  this._octaveScale = value;
                }
              }]);

              return NoiseModule;
            }(ParticleModuleBase), (_initializer$1d = applyDecoratedInitializer(_class2$1i.prototype, "_enable", [serializable$h], function () {
              return false;
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "strengthX", [_dec2$15], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "strengthX"), _class2$1i.prototype), _initializer2$11 = applyDecoratedInitializer(_class2$1i.prototype, "_strengthX", [serializable$h], function () {
              return 10;
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "strengthY", [_dec3$M], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "strengthY"), _class2$1i.prototype), _initializer3$O = applyDecoratedInitializer(_class2$1i.prototype, "_strengthY", [serializable$h], function () {
              return 10;
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "strengthZ", [_dec4$w], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "strengthZ"), _class2$1i.prototype), _initializer4$J = applyDecoratedInitializer(_class2$1i.prototype, "_strengthZ", [serializable$h], function () {
              return 10;
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "noiseSpeedX", [_dec5$q], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "noiseSpeedX"), _class2$1i.prototype), _initializer5$A = applyDecoratedInitializer(_class2$1i.prototype, "_noiseSpeedX", [serializable$h], function () {
              return 0;
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "noiseSpeedY", [_dec6$m], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "noiseSpeedY"), _class2$1i.prototype), _initializer6$t = applyDecoratedInitializer(_class2$1i.prototype, "_noiseSpeedY", [serializable$h], function () {
              return 0;
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "noiseSpeedZ", [_dec7$h], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "noiseSpeedZ"), _class2$1i.prototype), _initializer7$m = applyDecoratedInitializer(_class2$1i.prototype, "_noiseSpeedZ", [serializable$h], function () {
              return 0;
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "noiseFrequency", [_dec8$c], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "noiseFrequency"), _class2$1i.prototype), _initializer8$k = applyDecoratedInitializer(_class2$1i.prototype, "_noiseFrequency", [serializable$h], function () {
              return 1;
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "remapX", [_dec9$a], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "remapX"), _class2$1i.prototype), _initializer9$h = applyDecoratedInitializer(_class2$1i.prototype, "_remapX", [serializable$h], function () {
              return 0;
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "remapY", [_dec10$4], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "remapY"), _class2$1i.prototype), _initializer10$f = applyDecoratedInitializer(_class2$1i.prototype, "_remapY", [serializable$h], function () {
              return 0;
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "remapZ", [_dec11$2], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "remapZ"), _class2$1i.prototype), _initializer11$b = applyDecoratedInitializer(_class2$1i.prototype, "_remapZ", [serializable$h], function () {
              return 0;
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "octaves", [_dec12$1], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "octaves"), _class2$1i.prototype), _initializer12$b = applyDecoratedInitializer(_class2$1i.prototype, "_octaves", [serializable$h], function () {
              return 1;
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "octaveMultiplier", [_dec13$1], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "octaveMultiplier"), _class2$1i.prototype), _initializer13$b = applyDecoratedInitializer(_class2$1i.prototype, "_octaveMultiplier", [serializable$h], function () {
              return 0.5;
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "octaveScale", [_dec14$1], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "octaveScale"), _class2$1i.prototype), _initializer14$7 = applyDecoratedInitializer(_class2$1i.prototype, "_octaveScale", [serializable$h], function () {
              return 2;
            })), _class2$1i)) || _class$1y);

            var _dec$1w, _dec2$16, _dec3$N, _dec4$x, _dec5$r, _dec6$n, _dec7$i, _dec8$d, _dec9$b, _dec10$5, _dec11$3, _dec12$2, _dec13$2, _dec14$2, _dec15$1, _dec16$1, _dec17$1, _dec18$1, _dec19$1, _dec20$1, _dec21$1, _dec22$1, _dec23$1, _dec24$1, _dec25$1, _dec26$1, _dec27$1, _dec28$1, _dec29$1, _dec30$1, _dec31$1, _dec32$1, _dec33$1, _dec34$1, _dec35$1, _dec36$1, _dec37$1, _dec38$1, _dec39, _dec40, _dec41, _dec42, _dec43, _dec44, _dec45, _dec46, _dec47, _class$1z, _class2$1j, _initializer$1e, _initializer2$12, _initializer3$P, _initializer4$K, _initializer5$B, _initializer6$u, _initializer7$n, _initializer8$l, _initializer9$i, _initializer10$g, _initializer11$c, _initializer12$c, _initializer13$c, _initializer14$8, _initializer15$7, _initializer16$7, _initializer17$6, _initializer18$5, _initializer19$5, _initializer20$3, _initializer21$2, _initializer22$2, _initializer23$2, _initializer24$2, _initializer25$2, _initializer26$2, _initializer27$1, _initializer28$1, _initializer29, _initializer30, _initializer31, _initializer32, _initializer33, _initializer34, _initializer35, _initializer36, _initializer37, _initializer38, _initializer39, _initializer40, _initializer41, _class3$h, _temp$q;

            var _world_mat = new Mat4();

            var _world_rol = new Quat();

            var superMaterials = Object.getOwnPropertyDescriptor(Renderer.prototype, 'sharedMaterials');
            var ParticleSystem = exports('ParticleSystem', (_dec$1w = ccclass$p('cc.ParticleSystem'), _dec2$16 = executionOrder(99), _dec3$N = type$8(GradientRange), _dec4$x = type$8(Space), _dec5$r = formerlySerializedAs$3('startSize'), _dec6$n = type$8(CurveRange), _dec7$i = type$8(CurveRange), _dec8$d = type$8(CurveRange), _dec9$b = type$8(CurveRange), _dec10$5 = type$8(CurveRange), _dec11$3 = type$8(CurveRange), _dec12$2 = type$8(CurveRange), _dec13$2 = formerlySerializedAs$3('startRotation'), _dec14$2 = type$8(CurveRange), _dec15$1 = type$8(CurveRange), _dec16$1 = type$8(Space), _dec17$1 = type$8(CurveRange), _dec18$1 = type$8(CurveRange), _dec19$1 = type$8(CurveRange), _dec20$1 = type$8([Burst]), _dec21$1 = type$8(CCBoolean), _dec22$1 = type$8(CullingMode), _dec23$1 = type$8(CCFloat), _dec24$1 = type$8(CCFloat), _dec25$1 = type$8(CCFloat), _dec26$1 = formerlySerializedAs$3('enableCulling'), _dec27$1 = type$8(ColorOvertimeModule), _dec28$1 = type$8(ColorOvertimeModule), _dec29$1 = type$8(ShapeModule), _dec30$1 = type$8(ShapeModule), _dec31$1 = type$8(SizeOvertimeModule), _dec32$1 = type$8(SizeOvertimeModule), _dec33$1 = type$8(VelocityOvertimeModule), _dec34$1 = type$8(VelocityOvertimeModule), _dec35$1 = type$8(ForceOvertimeModule), _dec36$1 = type$8(ForceOvertimeModule), _dec37$1 = type$8(LimitVelocityOvertimeModule), _dec38$1 = type$8(LimitVelocityOvertimeModule), _dec39 = type$8(RotationOvertimeModule), _dec40 = type$8(RotationOvertimeModule), _dec41 = type$8(TextureAnimationModule), _dec42 = type$8(TextureAnimationModule), _dec43 = type$8(NoiseModule), _dec44 = type$8(NoiseModule), _dec45 = type$8(TrailModule), _dec46 = type$8(TrailModule), _dec47 = type$8(ParticleSystemRenderer), _dec$1w(_class$1z = _dec2$16(_class$1z = (_class2$1j = (_temp$q = _class3$h = function (_ModelRenderer) {
              _inheritsLoose(ParticleSystem, _ModelRenderer);

              function ParticleSystem() {
                var _this;

                _this = _ModelRenderer.call(this) || this;
                _this.startColor = _initializer$1e && _initializer$1e();
                _this.scaleSpace = _initializer2$12 && _initializer2$12();
                _this.startSize3D = _initializer3$P && _initializer3$P();
                _this.startSizeX = _initializer4$K && _initializer4$K();
                _this.startSizeY = _initializer5$B && _initializer5$B();
                _this.startSizeZ = _initializer6$u && _initializer6$u();
                _this.startSpeed = _initializer7$n && _initializer7$n();
                _this.startRotation3D = _initializer8$l && _initializer8$l();
                _this.startRotationX = _initializer9$i && _initializer9$i();
                _this.startRotationY = _initializer10$g && _initializer10$g();
                _this.startRotationZ = _initializer11$c && _initializer11$c();
                _this.startDelay = _initializer12$c && _initializer12$c();
                _this.startLifetime = _initializer13$c && _initializer13$c();
                _this.duration = _initializer14$8 && _initializer14$8();
                _this.loop = _initializer15$7 && _initializer15$7();
                _this.simulationSpeed = _initializer16$7 && _initializer16$7();
                _this.playOnAwake = _initializer17$6 && _initializer17$6();
                _this.gravityModifier = _initializer18$5 && _initializer18$5();
                _this.rateOverTime = _initializer19$5 && _initializer19$5();
                _this.rateOverDistance = _initializer20$3 && _initializer20$3();
                _this.bursts = _initializer21$2 && _initializer21$2();
                _this._renderCulling = _initializer22$2 && _initializer22$2();
                _this._cullingMode = _initializer23$2 && _initializer23$2();
                _this._aabbHalfX = _initializer24$2 && _initializer24$2();
                _this._aabbHalfY = _initializer25$2 && _initializer25$2();
                _this._aabbHalfZ = _initializer26$2 && _initializer26$2();
                _this._dataCulling = _initializer27$1 && _initializer27$1();
                _this._colorOverLifetimeModule = _initializer28$1 && _initializer28$1();
                _this._shapeModule = _initializer29 && _initializer29();
                _this._sizeOvertimeModule = _initializer30 && _initializer30();
                _this._velocityOvertimeModule = _initializer31 && _initializer31();
                _this._forceOvertimeModule = _initializer32 && _initializer32();
                _this._limitVelocityOvertimeModule = _initializer33 && _initializer33();
                _this._rotationOvertimeModule = _initializer34 && _initializer34();
                _this._textureAnimationModule = _initializer35 && _initializer35();
                _this._noiseModule = _initializer36 && _initializer36();
                _this._trailModule = _initializer37 && _initializer37();
                _this.renderer = _initializer38 && _initializer38();
                _this._isPlaying = void 0;
                _this._isPaused = void 0;
                _this._isStopped = void 0;
                _this._isEmitting = void 0;
                _this._needRefresh = void 0;
                _this._time = void 0;
                _this._emitRateTimeCounter = void 0;
                _this._emitRateDistanceCounter = void 0;
                _this._oldWPos = void 0;
                _this._curWPos = void 0;
                _this._boundingBox = void 0;
                _this._culler = void 0;
                _this._oldPos = void 0;
                _this._curPos = void 0;
                _this._isCulled = void 0;
                _this._isSimulating = void 0;
                _this._customData1 = void 0;
                _this._customData2 = void 0;
                _this._subEmitters = void 0;
                _this._needAttach = void 0;
                _this._prewarm = _initializer39 && _initializer39();
                _this._capacity = _initializer40 && _initializer40();
                _this._simulationSpace = _initializer41 && _initializer41();
                _this.processor = null;
                _this.rateOverTime.constant = 10;
                _this.startLifetime.constant = 5;
                _this.startSizeX.constant = 1;
                _this.startSpeed.constant = 5;
                _this._isPlaying = false;
                _this._isPaused = false;
                _this._isStopped = true;
                _this._isEmitting = false;
                _this._needRefresh = true;
                _this._needAttach = false;
                _this._time = 0.0;
                _this._emitRateTimeCounter = 0.0;
                _this._emitRateDistanceCounter = 0.0;
                _this._oldWPos = new Vec3();
                _this._curWPos = new Vec3();
                _this._boundingBox = null;
                _this._culler = null;
                _this._oldPos = null;
                _this._curPos = null;
                _this._isCulled = false;
                _this._isSimulating = true;
                _this._customData1 = new Vec2();
                _this._customData2 = new Vec2();
                _this._subEmitters = [];
                return _this;
              }

              var _proto = ParticleSystem.prototype;

              _proto.onFocusInEditor = function onFocusInEditor() {
                this.renderer.create(this);
              };

              _proto.onLoad = function onLoad() {
                this.renderer.onInit(this);
                if (this._shapeModule) this._shapeModule.onInit(this);

                if (this._trailModule && !this.renderer.useGPU && this._trailModule.enable) {
                  this._trailModule.onInit(this);
                }

                this.bindModule();

                this._resetPosition();
              };

              _proto._onMaterialModified = function _onMaterialModified(index, material) {
                if (this.processor !== null) {
                  this.processor.onMaterialModified(index, material);
                }
              };

              _proto._onRebuildPSO = function _onRebuildPSO(index, material) {
                this.processor.onRebuildPSO(index, material);
              };

              _proto._collectModels = function _collectModels() {
                this._models.length = 0;

                this._models.push(this.processor._model);

                if (this._trailModule && this._trailModule.enable && this._trailModule._trailModel) {
                  this._models.push(this._trailModule._trailModel);
                }

                return this._models;
              };

              _proto._attachToScene = function _attachToScene() {
                this.processor.attachToScene();

                if (this._trailModule && this._trailModule.enable) {
                  this._trailModule._attachToScene();
                }
              };

              _proto._detachFromScene = function _detachFromScene() {
                this.processor.detachFromScene();

                if (this._trailModule && this._trailModule.enable) {
                  this._trailModule._detachFromScene();
                }

                if (this._boundingBox) {
                  this._boundingBox = null;
                }

                if (this._culler) {
                  this._culler.clear();

                  this._culler.destroy();

                  this._culler = null;
                }
              };

              _proto.bindModule = function bindModule() {
                if (this._colorOverLifetimeModule) this._colorOverLifetimeModule.bindTarget(this.processor);
                if (this._sizeOvertimeModule) this._sizeOvertimeModule.bindTarget(this.processor);
                if (this._rotationOvertimeModule) this._rotationOvertimeModule.bindTarget(this.processor);
                if (this._forceOvertimeModule) this._forceOvertimeModule.bindTarget(this.processor);
                if (this._limitVelocityOvertimeModule) this._limitVelocityOvertimeModule.bindTarget(this.processor);
                if (this._velocityOvertimeModule) this._velocityOvertimeModule.bindTarget(this.processor);
                if (this._textureAnimationModule) this._textureAnimationModule.bindTarget(this.processor);
                if (this._noiseModule) this._noiseModule.bindTarget(this.processor);
              };

              _proto.play = function play() {
                if (this._isPaused) {
                  this._isPaused = false;
                }

                if (this._isStopped) {
                  this._isStopped = false;
                }

                this._isPlaying = true;
                this._isEmitting = true;

                this._resetPosition();

                if (this._prewarm) {
                  this._prewarmSystem();
                }

                if (this._trailModule) {
                  this._trailModule.play();
                }

                if (this.processor) {
                  var model = this.processor.getModel();

                  if (model) {
                    model.enabled = this.enabledInHierarchy;
                  }
                }
              };

              _proto.pause = function pause() {
                if (this._isStopped) {
                  console.warn('pause(): particle system is already stopped.');
                  return;
                }

                if (this._isPlaying) {
                  this._isPlaying = false;
                }

                this._isPaused = true;
              };

              _proto.stopEmitting = function stopEmitting() {
                this._isEmitting = false;
              };

              _proto.stop = function stop() {
                if (this._isPlaying || this._isPaused) {
                  this.clear();
                }

                if (this._isPlaying) {
                  this._isPlaying = false;
                }

                if (this._isPaused) {
                  this._isPaused = false;
                }

                if (this._isEmitting) {
                  this._isEmitting = false;
                }

                this._time = 0.0;
                this._emitRateTimeCounter = 0.0;
                this._emitRateDistanceCounter = 0.0;
                this._isStopped = true;
                this._needRefresh = true;

                for (var _iterator = _createForOfIteratorHelperLoose(this.bursts), _step; !(_step = _iterator()).done;) {
                  var burst = _step.value;
                  burst.reset();
                }
              };

              _proto.clear = function clear() {
                if (this.enabledInHierarchy) {
                  this.processor.clear();
                  if (this._trailModule) this._trailModule.clear();
                }

                this._calculateBounding(false);
              };

              _proto.getParticleCount = function getParticleCount() {
                if (this.processor) {
                  return this.processor.getParticleCount();
                } else {
                  return 0;
                }
              };

              _proto.setCustomData1 = function setCustomData1(x, y) {
                Vec2.set(this._customData1, x, y);
              };

              _proto.setCustomData2 = function setCustomData2(x, y) {
                Vec2.set(this._customData2, x, y);
              };

              _proto.onDestroy = function onDestroy() {
                var _this$processor$getMo;

                this.stop();

                if ((_this$processor$getMo = this.processor.getModel()) !== null && _this$processor$getMo !== void 0 && _this$processor$getMo.scene) {
                  this.processor.detachFromScene();

                  if (this._trailModule && this._trailModule.enable) {
                    this._trailModule._detachFromScene();
                  }
                }

                legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_COMMIT, this.beforeRender, this);
                this.processor.onDestroy();
                if (this._trailModule) this._trailModule.destroy();

                if (this._culler) {
                  this._culler.clear();

                  this._culler.destroy();

                  this._culler = null;
                }
              };

              _proto.onEnable = function onEnable() {
                _ModelRenderer.prototype.onEnable.call(this);

                legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_COMMIT, this.beforeRender, this);

                if (this.playOnAwake && (!EDITOR )) {
                  this.play();
                }

                this.processor.onEnable();
                if (this._trailModule) this._trailModule.onEnable();
              };

              _proto.onDisable = function onDisable() {
                legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_COMMIT, this.beforeRender, this);
                this.processor.onDisable();
                if (this._trailModule) this._trailModule.onDisable();

                if (this._boundingBox) {
                  this._boundingBox = null;
                }

                if (this._culler) {
                  this._culler.clear();

                  this._culler.destroy();

                  this._culler = null;
                }
              };

              _proto._calculateBounding = function _calculateBounding(forceRefresh) {
                if (this._boundingBox) {
                  if (!this._culler) {
                    this._culler = new ParticleCuller(this);
                  }

                  this._culler.calculatePositions();

                  AABB.fromPoints(this._boundingBox, this._culler.minPos, this._culler.maxPos);

                  if (forceRefresh) {
                    this.aabbHalfX = this._boundingBox.halfExtents.x;
                    this.aabbHalfY = this._boundingBox.halfExtents.y;
                    this.aabbHalfZ = this._boundingBox.halfExtents.z;
                  } else {
                    if (this.aabbHalfX) {
                      this.setBoundingX(this.aabbHalfX);
                    } else {
                      this.aabbHalfX = this._boundingBox.halfExtents.x;
                    }

                    if (this.aabbHalfY) {
                      this.setBoundingY(this.aabbHalfY);
                    } else {
                      this.aabbHalfY = this._boundingBox.halfExtents.y;
                    }

                    if (this.aabbHalfZ) {
                      this.setBoundingZ(this.aabbHalfZ);
                    } else {
                      this.aabbHalfZ = this._boundingBox.halfExtents.z;
                    }
                  }

                  this._culler.clear();
                }
              };

              _proto.update = function update(dt) {
                var scaledDeltaTime = dt * this.simulationSpeed;

                if (!this.renderCulling) {
                  if (this._boundingBox) {
                    this._boundingBox = null;
                  }

                  if (this._culler) {
                    this._culler.clear();

                    this._culler.destroy();

                    this._culler = null;
                  }

                  this._isSimulating = true;
                } else {
                  var _this$node$scene$rend;

                  if (!this._boundingBox) {
                    this._boundingBox = new AABB();

                    this._calculateBounding(false);
                  }

                  if (!this._curPos) {
                    this._curPos = new Vec3();
                  }

                  this.node.getWorldPosition(this._curPos);

                  if (!this._oldPos) {
                    this._oldPos = new Vec3();

                    this._oldPos.set(this._curPos);
                  }

                  if (!this._curPos.equals(this._oldPos) && this._boundingBox && this._culler) {
                    var dx = this._curPos.x - this._oldPos.x;
                    var dy = this._curPos.y - this._oldPos.y;
                    var dz = this._curPos.z - this._oldPos.z;
                    var center = this._boundingBox.center;
                    center.x += dx;
                    center.y += dy;
                    center.z += dz;

                    this._culler.setBoundingBoxCenter(center.x, center.y, center.z);

                    this._oldPos.set(this._curPos);
                  }

                  var cameraLst = (_this$node$scene$rend = this.node.scene.renderScene) === null || _this$node$scene$rend === void 0 ? void 0 : _this$node$scene$rend.cameras;
                  var culled = true;

                  if (cameraLst !== undefined && this._boundingBox) {
                    for (var i = 0; i < cameraLst.length; ++i) {
                      var camera = cameraLst[i];
                      var visibility = camera.visibility;

                      if ((visibility & this.node.layer) === this.node.layer) {
                        if (intersect.aabbFrustum(this._boundingBox, camera.frustum)) {
                          culled = false;
                          break;
                        }
                      }
                    }
                  }

                  if (culled) {
                    if (this._cullingMode !== CullingMode.AlwaysSimulate) {
                      this._isSimulating = false;
                    }

                    if (!this._isCulled) {
                      this.processor.detachFromScene();
                      this._isCulled = true;
                    }

                    if (this._trailModule && this._trailModule.enable) {
                      this._trailModule._detachFromScene();
                    }

                    if (this._cullingMode === CullingMode.PauseAndCatchup) {
                      this._time += scaledDeltaTime;
                    }

                    if (this._cullingMode !== CullingMode.AlwaysSimulate) {
                      return;
                    }
                  } else {
                    if (this._isCulled) {
                      this._attachToScene();

                      this._isCulled = false;
                    }

                    if (!this._isSimulating) {
                      this._isSimulating = true;
                    }
                  }

                  if (!this._isSimulating) {
                    return;
                  }
                }

                if (this._isPlaying) {
                  this._time += scaledDeltaTime;

                  this._emit(scaledDeltaTime);

                  if (this.processor.updateParticles(scaledDeltaTime) === 0 && !this._isEmitting) {
                    this.stop();
                  }
                } else {
                  var mat = this.getMaterialInstance(0) || this.processor.getDefaultMaterial();
                  var pass = mat.passes[0];
                  this.processor.updateRotation(pass);
                  this.processor.updateScale(pass);
                }

                this.processor.updateRenderData();

                if (this._trailModule && this._trailModule.enable) {
                  this._trailModule.updateRenderData();
                }

                if (this._needAttach) {
                  if (this.getParticleCount() > 0) {
                    if (!this._isCulled) {
                      var _this$processor$getMo2;

                      if (!((_this$processor$getMo2 = this.processor.getModel()) !== null && _this$processor$getMo2 !== void 0 && _this$processor$getMo2.scene)) {
                        this.processor.attachToScene();
                      }

                      if (this._trailModule && this._trailModule.enable) {
                        var _this$_trailModule$ge;

                        if (!((_this$_trailModule$ge = this._trailModule.getModel()) !== null && _this$_trailModule$ge !== void 0 && _this$_trailModule$ge.scene)) {
                          this._trailModule._attachToScene();
                        }
                      }

                      this._needAttach = false;
                    }
                  }
                }

                if (!this.renderer.useGPU && this._trailModule && this._trailModule.enable) {
                  if (!this._trailModule._inited) {
                    this._trailModule.clear();

                    this._trailModule.destroy();

                    this._trailModule.onInit(this);

                    this._trailModule.enable = false;
                    this._trailModule.enable = true;
                  }
                }
              };

              _proto.beforeRender = function beforeRender() {
                var _this$processor$getMo4;

                if (this.getParticleCount() <= 0) {
                  var _this$processor$getMo3;

                  if ((_this$processor$getMo3 = this.processor.getModel()) !== null && _this$processor$getMo3 !== void 0 && _this$processor$getMo3.scene) {
                    this.processor.detachFromScene();

                    if (this._trailModule && this._trailModule.enable) {
                      this._trailModule._detachFromScene();
                    }

                    this._needAttach = false;
                  }
                } else if (!((_this$processor$getMo4 = this.processor.getModel()) !== null && _this$processor$getMo4 !== void 0 && _this$processor$getMo4.scene)) {
                  this._needAttach = true;
                }

                if (!this._isPlaying) return;
                this.processor.beforeRender();

                if (this._trailModule && this._trailModule.enable) {
                  this._trailModule.beforeRender();
                }
              };

              _proto._onVisibilityChange = function _onVisibilityChange(val) {
                if (this.processor._model) {
                  this.processor._model.visFlags = val;
                }
              };

              _proto.emit = function emit(count, dt) {
                var loopDelta = this._time % this.duration / this.duration;

                if (this._needRefresh) {
                  this.node.invalidateChildren(TransformBit.POSITION);
                  this._needRefresh = false;
                }

                if (this._simulationSpace === Space.World) {
                  this.node.getWorldMatrix(_world_mat);
                  this.node.getWorldRotation(_world_rol);
                }

                for (var i = 0; i < count; ++i) {
                  var particle = this.processor.getFreeParticle();

                  if (particle === null) {
                    return;
                  }

                  particle.particleSystem = this;
                  particle.reset();
                  var rand = pseudoRandom(randomRangeInt(0, INT_MAX));

                  if (this._shapeModule && this._shapeModule.enable) {
                    this._shapeModule.emit(particle);
                  } else {
                    Vec3.set(particle.position, 0, 0, 0);
                    Vec3.copy(particle.velocity, particleEmitZAxis);
                  }

                  if (this._textureAnimationModule && this._textureAnimationModule.enable) {
                    this._textureAnimationModule.init(particle);
                  }

                  var curveStartSpeed = this.startSpeed.evaluate(loopDelta, rand);
                  Vec3.multiplyScalar(particle.velocity, particle.velocity, curveStartSpeed);

                  if (this._simulationSpace === Space.World) {
                    Vec3.transformMat4(particle.position, particle.position, _world_mat);
                    Vec3.transformQuat(particle.velocity, particle.velocity, _world_rol);
                  }

                  Vec3.copy(particle.ultimateVelocity, particle.velocity);

                  if (this.startRotation3D) {
                    particle.startEuler.set(this.startRotationX.evaluate(loopDelta, rand), this.startRotationY.evaluate(loopDelta, rand), this.startRotationZ.evaluate(loopDelta, rand));
                  } else {
                    particle.startEuler.set(0, 0, this.startRotationZ.evaluate(loopDelta, rand));
                  }

                  particle.rotation.set(particle.startEuler);

                  if (this.startSize3D) {
                    Vec3.set(particle.startSize, this.startSizeX.evaluate(loopDelta, rand), this.startSizeY.evaluate(loopDelta, rand), this.startSizeZ.evaluate(loopDelta, rand));
                  } else {
                    Vec3.set(particle.startSize, this.startSizeX.evaluate(loopDelta, rand), 1, 1);
                    particle.startSize.y = particle.startSize.x;
                  }

                  Vec3.copy(particle.size, particle.startSize);
                  particle.startColor.set(this.startColor.evaluate(loopDelta, rand));
                  particle.color.set(particle.startColor);
                  particle.startLifetime = this.startLifetime.evaluate(loopDelta, rand) + dt;
                  particle.remainingLifetime = particle.startLifetime;
                  particle.randomSeed = randomRangeInt(0, 233280);
                  particle.loopCount++;
                  this.processor.setNewParticle(particle);
                }
              };

              _proto._prewarmSystem = function _prewarmSystem() {
                this.startDelay.mode = Mode.Constant;
                this.startDelay.constant = 0;
                var dt = 1.0;
                var cnt = this.duration / dt;

                for (var i = 0; i < cnt; ++i) {
                  this._time += dt;

                  this._emit(dt);

                  this.processor.updateParticles(dt);
                }
              };

              _proto._emit = function _emit(dt) {
                var startDelay = this.startDelay.evaluate(0, 1);

                if (this._time > startDelay) {
                  if (this._time > this.duration + startDelay) {
                    if (!this.loop) {
                      this._isEmitting = false;
                    }
                  }

                  if (!this._isEmitting) return;
                  this._emitRateTimeCounter += this.rateOverTime.evaluate(this._time / this.duration, 1) * dt;

                  if (this._emitRateTimeCounter > 1) {
                    var emitNum = Math.floor(this._emitRateTimeCounter);
                    this._emitRateTimeCounter -= emitNum;
                    this.emit(emitNum, dt);
                  }

                  var rateOverDistance = this.rateOverDistance.evaluate(this._time / this.duration, 1);

                  if (rateOverDistance > 0) {
                    Vec3.copy(this._oldWPos, this._curWPos);
                    this.node.getWorldPosition(this._curWPos);
                    var distance = Vec3.distance(this._curWPos, this._oldWPos);
                    this._emitRateDistanceCounter += distance * rateOverDistance;
                  }

                  if (this._emitRateDistanceCounter > 1) {
                    var _emitNum = Math.floor(this._emitRateDistanceCounter);

                    this._emitRateDistanceCounter -= _emitNum;
                    this.emit(_emitNum, dt);
                  }

                  for (var _iterator2 = _createForOfIteratorHelperLoose(this.bursts), _step2; !(_step2 = _iterator2()).done;) {
                    var burst = _step2.value;
                    burst.update(this, dt);
                  }
                }
              };

              _proto._resetPosition = function _resetPosition() {
                this.node.getWorldPosition(this._oldWPos);
                Vec3.copy(this._curWPos, this._oldWPos);
              };

              _proto.addSubEmitter = function addSubEmitter(subEmitter) {
                this._subEmitters.push(subEmitter);
              };

              _proto.removeSubEmitter = function removeSubEmitter(idx) {
                this._subEmitters.splice(this._subEmitters.indexOf(idx), 1);
              };

              _proto.addBurst = function addBurst(burst) {
                this.bursts.push(burst);
              };

              _proto.removeBurst = function removeBurst(idx) {
                this.bursts.splice(this.bursts.indexOf(idx), 1);
              };

              _proto.getBoundingX = function getBoundingX() {
                return this._aabbHalfX;
              };

              _proto.getBoundingY = function getBoundingY() {
                return this._aabbHalfY;
              };

              _proto.getBoundingZ = function getBoundingZ() {
                return this._aabbHalfZ;
              };

              _proto.setBoundingX = function setBoundingX(value) {
                if (this._boundingBox && this._culler) {
                  this._boundingBox.halfExtents.x = value;

                  this._culler.setBoundingBoxSize(this._boundingBox.halfExtents);

                  this._aabbHalfX = value;
                }
              };

              _proto.setBoundingY = function setBoundingY(value) {
                if (this._boundingBox && this._culler) {
                  this._boundingBox.halfExtents.y = value;

                  this._culler.setBoundingBoxSize(this._boundingBox.halfExtents);

                  this._aabbHalfY = value;
                }
              };

              _proto.setBoundingZ = function setBoundingZ(value) {
                if (this._boundingBox && this._culler) {
                  this._boundingBox.halfExtents.z = value;

                  this._culler.setBoundingBoxSize(this._boundingBox.halfExtents);

                  this._aabbHalfZ = value;
                }
              };

              _proto._onBeforeSerialize = function _onBeforeSerialize(props) {
                var _this2 = this;

                return this.dataCulling ? props.filter(function (p) {
                  return !PARTICLE_MODULE_PROPERTY.includes(p) || _this2[p] && _this2[p].enable;
                }) : props;
              };

              _proto.getNoisePreview = function getNoisePreview(width, height) {
                var out = [];

                if (this.processor) {
                  this.processor.getNoisePreview(out, width, height);
                }

                return out;
              };

              _createClass(ParticleSystem, [{
                key: "capacity",
                get: function get() {
                  return this._capacity;
                },
                set: function set(val) {
                  this._capacity = Math.floor(val > 0 ? val : 0);

                  if (this.processor && this.processor._model) {
                    this.processor._model.setCapacity(this._capacity);
                  }
                }
              }, {
                key: "prewarm",
                get: function get() {
                  return this._prewarm;
                },
                set: function set(val) {
                  if (val === true && this.loop === false) ;

                  this._prewarm = val;
                }
              }, {
                key: "simulationSpace",
                get: function get() {
                  return this._simulationSpace;
                },
                set: function set(val) {
                  if (val !== this._simulationSpace) {
                    this._simulationSpace = val;

                    if (this.processor) {
                      this.processor.updateMaterialParams();
                      this.processor.updateTrailMaterial();
                    }
                  }
                }
              }, {
                key: "renderCulling",
                get: function get() {
                  return this._renderCulling;
                },
                set: function set(value) {
                  this._renderCulling = value;

                  if (value) {
                    if (!this._boundingBox) {
                      this._boundingBox = new AABB();

                      this._calculateBounding(false);
                    }
                  }
                }
              }, {
                key: "cullingMode",
                get: function get() {
                  return this._cullingMode;
                },
                set: function set(value) {
                  this._cullingMode = value;
                }
              }, {
                key: "aabbHalfX",
                get: function get() {
                  var res = this.getBoundingX();

                  if (res) {
                    return res;
                  } else {
                    return 0;
                  }
                },
                set: function set(value) {
                  this.setBoundingX(value);
                }
              }, {
                key: "aabbHalfY",
                get: function get() {
                  var res = this.getBoundingY();

                  if (res) {
                    return res;
                  } else {
                    return 0;
                  }
                },
                set: function set(value) {
                  this.setBoundingY(value);
                }
              }, {
                key: "aabbHalfZ",
                get: function get() {
                  var res = this.getBoundingZ();

                  if (res) {
                    return res;
                  } else {
                    return 0;
                  }
                },
                set: function set(value) {
                  this.setBoundingZ(value);
                }
              }, {
                key: "dataCulling",
                get: function get() {
                  return this._dataCulling;
                },
                set: function set(value) {
                  this._dataCulling = value;
                }
              }, {
                key: "sharedMaterials",
                get: function get() {
                  return superMaterials.get.call(this);
                },
                set: function set(val) {
                  superMaterials.set.call(this, val);
                }
              }, {
                key: "colorOverLifetimeModule",
                get: function get() {

                  return this._colorOverLifetimeModule;
                },
                set: function set(val) {
                  if (!val) return;
                  this._colorOverLifetimeModule = val;
                }
              }, {
                key: "shapeModule",
                get: function get() {

                  return this._shapeModule;
                },
                set: function set(val) {
                  if (!val) return;
                  this._shapeModule = val;
                }
              }, {
                key: "sizeOvertimeModule",
                get: function get() {

                  return this._sizeOvertimeModule;
                },
                set: function set(val) {
                  if (!val) return;
                  this._sizeOvertimeModule = val;
                }
              }, {
                key: "velocityOvertimeModule",
                get: function get() {

                  return this._velocityOvertimeModule;
                },
                set: function set(val) {
                  if (!val) return;
                  this._velocityOvertimeModule = val;
                }
              }, {
                key: "forceOvertimeModule",
                get: function get() {

                  return this._forceOvertimeModule;
                },
                set: function set(val) {
                  if (!val) return;
                  this._forceOvertimeModule = val;
                }
              }, {
                key: "limitVelocityOvertimeModule",
                get: function get() {

                  return this._limitVelocityOvertimeModule;
                },
                set: function set(val) {
                  if (!val) return;
                  this._limitVelocityOvertimeModule = val;
                }
              }, {
                key: "rotationOvertimeModule",
                get: function get() {

                  return this._rotationOvertimeModule;
                },
                set: function set(val) {
                  if (!val) return;
                  this._rotationOvertimeModule = val;
                }
              }, {
                key: "textureAnimationModule",
                get: function get() {

                  return this._textureAnimationModule;
                },
                set: function set(val) {
                  if (!val) return;
                  this._textureAnimationModule = val;
                }
              }, {
                key: "noiseModule",
                get: function get() {

                  return this._noiseModule;
                },
                set: function set(val) {
                  if (!val) return;
                  this._noiseModule = val;
                }
              }, {
                key: "trailModule",
                get: function get() {

                  return this._trailModule;
                },
                set: function set(val) {
                  if (!val) return;
                  this._trailModule = val;
                }
              }, {
                key: "isPlaying",
                get: function get() {
                  return this._isPlaying;
                }
              }, {
                key: "isPaused",
                get: function get() {
                  return this._isPaused;
                }
              }, {
                key: "isStopped",
                get: function get() {
                  return this._isStopped;
                }
              }, {
                key: "isEmitting",
                get: function get() {
                  return this._isEmitting;
                }
              }, {
                key: "time",
                get: function get() {
                  return this._time;
                }
              }]);

              return ParticleSystem;
            }(ModelRenderer), _class3$h.CullingMode = CullingMode, _temp$q), (_initializer$1e = applyDecoratedInitializer(_class2$1j.prototype, "startColor", [_dec3$N, serializable$j], function () {
              return new GradientRange();
            }), _initializer2$12 = applyDecoratedInitializer(_class2$1j.prototype, "scaleSpace", [_dec4$x, serializable$j], function () {
              return Space.Local;
            }), _initializer3$P = applyDecoratedInitializer(_class2$1j.prototype, "startSize3D", [serializable$j], function () {
              return false;
            }), _initializer4$K = applyDecoratedInitializer(_class2$1j.prototype, "startSizeX", [_dec5$r, _dec6$n], function () {
              return new CurveRange();
            }), _initializer5$B = applyDecoratedInitializer(_class2$1j.prototype, "startSizeY", [_dec7$i, serializable$j], function () {
              return new CurveRange();
            }), _initializer6$u = applyDecoratedInitializer(_class2$1j.prototype, "startSizeZ", [_dec8$d, serializable$j], function () {
              return new CurveRange();
            }), _initializer7$n = applyDecoratedInitializer(_class2$1j.prototype, "startSpeed", [_dec9$b, serializable$j], function () {
              return new CurveRange();
            }), _initializer8$l = applyDecoratedInitializer(_class2$1j.prototype, "startRotation3D", [serializable$j], function () {
              return false;
            }), _initializer9$i = applyDecoratedInitializer(_class2$1j.prototype, "startRotationX", [_dec10$5, serializable$j], function () {
              return new CurveRange();
            }), _initializer10$g = applyDecoratedInitializer(_class2$1j.prototype, "startRotationY", [_dec11$3, serializable$j], function () {
              return new CurveRange();
            }), _initializer11$c = applyDecoratedInitializer(_class2$1j.prototype, "startRotationZ", [_dec12$2, _dec13$2], function () {
              return new CurveRange();
            }), _initializer12$c = applyDecoratedInitializer(_class2$1j.prototype, "startDelay", [_dec14$2, serializable$j], function () {
              return new CurveRange();
            }), _initializer13$c = applyDecoratedInitializer(_class2$1j.prototype, "startLifetime", [_dec15$1, serializable$j], function () {
              return new CurveRange();
            }), _initializer14$8 = applyDecoratedInitializer(_class2$1j.prototype, "duration", [serializable$j], function () {
              return 5.0;
            }), _initializer15$7 = applyDecoratedInitializer(_class2$1j.prototype, "loop", [serializable$j], function () {
              return true;
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "simulationSpace", [_dec16$1, serializable$j], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "simulationSpace"), _class2$1j.prototype), _initializer16$7 = applyDecoratedInitializer(_class2$1j.prototype, "simulationSpeed", [serializable$j], function () {
              return 1.0;
            }), _initializer17$6 = applyDecoratedInitializer(_class2$1j.prototype, "playOnAwake", [serializable$j], function () {
              return true;
            }), _initializer18$5 = applyDecoratedInitializer(_class2$1j.prototype, "gravityModifier", [_dec17$1, serializable$j], function () {
              return new CurveRange();
            }), _initializer19$5 = applyDecoratedInitializer(_class2$1j.prototype, "rateOverTime", [_dec18$1, serializable$j], function () {
              return new CurveRange();
            }), _initializer20$3 = applyDecoratedInitializer(_class2$1j.prototype, "rateOverDistance", [_dec19$1, serializable$j], function () {
              return new CurveRange();
            }), _initializer21$2 = applyDecoratedInitializer(_class2$1j.prototype, "bursts", [_dec20$1, serializable$j], function () {
              return [];
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "renderCulling", [_dec21$1], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "renderCulling"), _class2$1j.prototype), _initializer22$2 = applyDecoratedInitializer(_class2$1j.prototype, "_renderCulling", [serializable$j], function () {
              return false;
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "cullingMode", [_dec22$1], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "cullingMode"), _class2$1j.prototype), _initializer23$2 = applyDecoratedInitializer(_class2$1j.prototype, "_cullingMode", [serializable$j], function () {
              return CullingMode.Pause;
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "aabbHalfX", [_dec23$1], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "aabbHalfX"), _class2$1j.prototype), _initializer24$2 = applyDecoratedInitializer(_class2$1j.prototype, "_aabbHalfX", [serializable$j], function () {
              return 0;
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "aabbHalfY", [_dec24$1], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "aabbHalfY"), _class2$1j.prototype), _initializer25$2 = applyDecoratedInitializer(_class2$1j.prototype, "_aabbHalfY", [serializable$j], function () {
              return 0;
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "aabbHalfZ", [_dec25$1], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "aabbHalfZ"), _class2$1j.prototype), _initializer26$2 = applyDecoratedInitializer(_class2$1j.prototype, "_aabbHalfZ", [serializable$j], function () {
              return 0;
            }), _initializer27$1 = applyDecoratedInitializer(_class2$1j.prototype, "_dataCulling", [serializable$j, _dec26$1], function () {
              return false;
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "sharedMaterials", [override$1, serializable$j], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "sharedMaterials"), _class2$1j.prototype), _initializer28$1 = applyDecoratedInitializer(_class2$1j.prototype, "_colorOverLifetimeModule", [_dec27$1], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "colorOverLifetimeModule", [_dec28$1], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "colorOverLifetimeModule"), _class2$1j.prototype), _initializer29 = applyDecoratedInitializer(_class2$1j.prototype, "_shapeModule", [_dec29$1], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "shapeModule", [_dec30$1], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "shapeModule"), _class2$1j.prototype), _initializer30 = applyDecoratedInitializer(_class2$1j.prototype, "_sizeOvertimeModule", [_dec31$1], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "sizeOvertimeModule", [_dec32$1], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "sizeOvertimeModule"), _class2$1j.prototype), _initializer31 = applyDecoratedInitializer(_class2$1j.prototype, "_velocityOvertimeModule", [_dec33$1], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "velocityOvertimeModule", [_dec34$1], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "velocityOvertimeModule"), _class2$1j.prototype), _initializer32 = applyDecoratedInitializer(_class2$1j.prototype, "_forceOvertimeModule", [_dec35$1], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "forceOvertimeModule", [_dec36$1], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "forceOvertimeModule"), _class2$1j.prototype), _initializer33 = applyDecoratedInitializer(_class2$1j.prototype, "_limitVelocityOvertimeModule", [_dec37$1], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "limitVelocityOvertimeModule", [_dec38$1], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "limitVelocityOvertimeModule"), _class2$1j.prototype), _initializer34 = applyDecoratedInitializer(_class2$1j.prototype, "_rotationOvertimeModule", [_dec39], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "rotationOvertimeModule", [_dec40], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "rotationOvertimeModule"), _class2$1j.prototype), _initializer35 = applyDecoratedInitializer(_class2$1j.prototype, "_textureAnimationModule", [_dec41], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "textureAnimationModule", [_dec42], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "textureAnimationModule"), _class2$1j.prototype), _initializer36 = applyDecoratedInitializer(_class2$1j.prototype, "_noiseModule", [_dec43], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "noiseModule", [_dec44], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "noiseModule"), _class2$1j.prototype), _initializer37 = applyDecoratedInitializer(_class2$1j.prototype, "_trailModule", [_dec45], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$1j.prototype, "trailModule", [_dec46], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "trailModule"), _class2$1j.prototype), _initializer38 = applyDecoratedInitializer(_class2$1j.prototype, "renderer", [_dec47, serializable$j], function () {
              return new ParticleSystemRenderer();
            }), _initializer39 = applyDecoratedInitializer(_class2$1j.prototype, "_prewarm", [serializable$j], function () {
              return false;
            }), _initializer40 = applyDecoratedInitializer(_class2$1j.prototype, "_capacity", [serializable$j], function () {
              return 100;
            }), _initializer41 = applyDecoratedInitializer(_class2$1j.prototype, "_simulationSpace", [serializable$j], function () {
              return Space.Local;
            })), _class2$1j)) || _class$1z) || _class$1z));

            var ParticleUtils = exports('ParticleUtils', function () {
              function ParticleUtils() {}

              ParticleUtils.instantiate = function instantiate$1(prefab) {
                if (!this.registeredSceneEvent) {
                  director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.onSceneUnload, this);
                  this.registeredSceneEvent = true;
                }

                if (!this.particleSystemPool.has(prefab._uuid)) {
                  this.particleSystemPool.set(prefab._uuid, new Pool(function () {
                    return instantiate(prefab) || new Node();
                  }, 1, function (prefab) {
                    return prefab.destroy();
                  }));
                }

                return this.particleSystemPool.get(prefab._uuid).alloc();
              };

              ParticleUtils.destroy = function destroy(prefab) {
                if (this.particleSystemPool.has(prefab._prefab.asset._uuid)) {
                  this.stop(prefab);
                  this.particleSystemPool.get(prefab._prefab.asset._uuid).free(prefab);
                }
              };

              ParticleUtils.play = function play(rootNode) {
                for (var _iterator = _createForOfIteratorHelperLoose(rootNode.getComponentsInChildren(ParticleSystem)), _step; !(_step = _iterator()).done;) {
                  var ps = _step.value;
                  ps.play();
                }
              };

              ParticleUtils.stop = function stop(rootNode) {
                for (var _iterator2 = _createForOfIteratorHelperLoose(rootNode.getComponentsInChildren(ParticleSystem)), _step2; !(_step2 = _iterator2()).done;) {
                  var ps = _step2.value;
                  ps.stop();
                }
              };

              ParticleUtils.onSceneUnload = function onSceneUnload() {
                this.particleSystemPool.forEach(function (value) {
                  return value.destroy();
                });
                this.particleSystemPool.clear();
              };

              return ParticleUtils;
            }());
            ParticleUtils.particleSystemPool = new Map();
            ParticleUtils.registeredSceneEvent = false;

            legacyCC.ParticleUtils = ParticleUtils;

            var DURATION_INFINITY = -1;
            var START_SIZE_EQUAL_TO_END_SIZE = -1;
            var START_RADIUS_EQUAL_TO_END_RADIUS = -1;
            var EmitterMode = Enum({
              GRAVITY: 0,
              RADIUS: 1
            });
            var PositionType = Enum({
              FREE: 0,
              RELATIVE: 1,
              GROUPED: 2
            });

            var ZERO_VEC2 = new Vec2(0, 0);

            var _pos = new Vec2();

            var _tpa = new Vec2();

            var _tpb = new Vec2();

            var _tpc = new Vec2();

            var formatBytes = getComponentPerVertex(vfmtPosUvColor);

            function getWorldRotation(node) {
              var rotation = 0;
              var tempNode = node;

              while (tempNode) {
                rotation += tempNode.eulerAngles.z;
                tempNode = tempNode.parent;
              }

              return rotation;
            }

            var Particle$1 = function Particle() {
              this.pos = new Vec2(0, 0);
              this.startPos = new Vec2(0, 0);
              this.color = new Color$1(0, 0, 0, 255);
              this.deltaColor = {
                r: 0,
                g: 0,
                b: 0,
                a: 255
              };
              this.size = 0;
              this.deltaSize = 0;
              this.rotation = 0;
              this.deltaRotation = 0;
              this.timeToLive = 0;
              this.drawPos = new Vec2(0, 0);
              this.aspectRatio = 1;
              this.dir = new Vec2(0, 0);
              this.radialAccel = 0;
              this.tangentialAccel = 0;
              this.angle = 0;
              this.degreesPerSecond = 0;
              this.radius = 0;
              this.deltaRadius = 0;
            };

            var ParticlePool = function (_js$Pool) {
              _inheritsLoose(ParticlePool, _js$Pool);

              function ParticlePool() {
                return _js$Pool.apply(this, arguments) || this;
              }

              var _proto = ParticlePool.prototype;

              _proto.get = function get() {
                return this._get() || new Particle$1();
              };

              return ParticlePool;
            }(Pool$1);

            var pool$2 = new ParticlePool(function (par) {
              par.pos.set(ZERO_VEC2);
              par.startPos.set(ZERO_VEC2);
              par.color._val = 0xFF000000;
              par.deltaColor.r = par.deltaColor.g = par.deltaColor.b = 0;
              par.deltaColor.a = 255;
              par.size = 0;
              par.deltaSize = 0;
              par.rotation = 0;
              par.deltaRotation = 0;
              par.timeToLive = 0;
              par.drawPos.set(ZERO_VEC2);
              par.aspectRatio = 1;
              par.dir.set(ZERO_VEC2);
              par.radialAccel = 0;
              par.tangentialAccel = 0;
              par.angle = 0;
              par.degreesPerSecond = 0;
              par.radius = 0;
              par.deltaRadius = 0;
            }, 1024);
            var Simulator = function () {
              function Simulator(system) {
                this.particles = [];
                this.active = false;
                this.uvFilled = 0;
                this.finished = false;
                this.readyToPlay = true;
                this.elapsed = 0;
                this.emitCounter = 0;
                this._worldRotation = 0;
                this.sys = system;
                this.particles = [];
                this.active = false;
                this.readyToPlay = true;
                this.finished = false;
                this.elapsed = 0;
                this.emitCounter = 0;
                this.uvFilled = 0;
                this._worldRotation = 0;
              }

              var _proto2 = Simulator.prototype;

              _proto2.stop = function stop() {
                this.active = false;
                this.readyToPlay = false;
                this.elapsed = this.sys.duration;
                this.emitCounter = 0;
              };

              _proto2.reset = function reset() {
                this.active = true;
                this.readyToPlay = true;
                this.elapsed = 0;
                this.emitCounter = 0;
                this.finished = false;
                var particles = this.particles;

                for (var id = 0; id < particles.length; ++id) {
                  pool$2.put(particles[id]);
                }

                particles.length = 0;
              };

              _proto2.emitParticle = function emitParticle(pos) {
                var psys = this.sys;
                var particle = pool$2.get();
                this.particles.push(particle);
                particle.timeToLive = psys.life + psys.lifeVar * (Math.random() - 0.5) * 2;
                var timeToLive = particle.timeToLive = Math.max(0, particle.timeToLive);
                particle.pos.x = psys.sourcePos.x + psys.posVar.x * (Math.random() - 0.5) * 2;
                particle.pos.y = psys.sourcePos.y + psys.posVar.y * (Math.random() - 0.5) * 2;
                var sr = 0;
                var sg = 0;
                var sb = 0;
                var sa = 0;
                var startColor = psys.startColor;
                var startColorVar = psys.startColorVar;
                var endColor = psys.endColor;
                var endColorVar = psys.endColorVar;
                particle.color.r = sr = clampf(startColor.r + startColorVar.r * (Math.random() - 0.5) * 2, 0, 255);
                particle.color.g = sg = clampf(startColor.g + startColorVar.g * (Math.random() - 0.5) * 2, 0, 255);
                particle.color.b = sb = clampf(startColor.b + startColorVar.b * (Math.random() - 0.5) * 2, 0, 255);
                particle.color.a = sa = clampf(startColor.a + startColorVar.a * (Math.random() - 0.5) * 2, 0, 255);
                particle.deltaColor.r = (clampf(endColor.r + endColorVar.r * (Math.random() - 0.5) * 2, 0, 255) - sr) / timeToLive;
                particle.deltaColor.g = (clampf(endColor.g + endColorVar.g * (Math.random() - 0.5) * 2, 0, 255) - sg) / timeToLive;
                particle.deltaColor.b = (clampf(endColor.b + endColorVar.b * (Math.random() - 0.5) * 2, 0, 255) - sb) / timeToLive;
                particle.deltaColor.a = (clampf(endColor.a + endColorVar.a * (Math.random() - 0.5) * 2, 0, 255) - sa) / timeToLive;
                var startS = psys.startSize + psys.startSizeVar * (Math.random() - 0.5) * 2;
                startS = Math.max(0, startS);
                particle.size = startS;

                if (psys.endSize === START_SIZE_EQUAL_TO_END_SIZE) {
                  particle.deltaSize = 0;
                } else {
                  var endS = psys.endSize + psys.endSizeVar * (Math.random() - 0.5) * 2;
                  endS = Math.max(0, endS);
                  particle.deltaSize = (endS - startS) / timeToLive;
                }

                var startA = psys.startSpin + psys.startSpinVar * (Math.random() - 0.5) * 2;
                var endA = psys.endSpin + psys.endSpinVar * (Math.random() - 0.5) * 2;
                particle.rotation = startA;
                particle.deltaRotation = (endA - startA) / timeToLive;
                particle.startPos.x = pos.x;
                particle.startPos.y = pos.y;
                particle.aspectRatio = psys.aspectRatio || 1;
                var a = degreesToRadians(psys.angle + this._worldRotation + psys.angleVar * (Math.random() - 0.5) * 2);

                if (psys.emitterMode === EmitterMode.GRAVITY) {
                  var s = psys.speed + psys.speedVar * (Math.random() - 0.5) * 2;
                  particle.dir.x = Math.cos(a);
                  particle.dir.y = Math.sin(a);
                  particle.dir.multiplyScalar(s);
                  particle.radialAccel = psys.radialAccel + psys.radialAccelVar * (Math.random() - 0.5) * 2;
                  particle.tangentialAccel = psys.tangentialAccel + psys.tangentialAccelVar * (Math.random() - 0.5) * 2;

                  if (psys.rotationIsDir) {
                    particle.rotation = -radiansToDegrees(Math.atan2(particle.dir.y, particle.dir.x));
                  }
                } else {
                  var startRadius = psys.startRadius + psys.startRadiusVar * (Math.random() - 0.5) * 2;
                  var endRadius = psys.endRadius + psys.endRadiusVar * (Math.random() - 0.5) * 2;
                  particle.radius = startRadius;
                  particle.deltaRadius = psys.endRadius === START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (endRadius - startRadius) / timeToLive;
                  particle.angle = a;
                  particle.degreesPerSecond = degreesToRadians(psys.rotatePerS + psys.rotatePerSVar * (Math.random() - 0.5) * 2);
                }
              };

              _proto2.updateUVs = function updateUVs(force) {
                var renderData = this.renderData;

                if (renderData && this.sys._renderSpriteFrame) {
                  var vbuf = renderData.vData;
                  var uv = this.sys._renderSpriteFrame.uv;
                  var start = force ? 0 : this.uvFilled;
                  var particleCount = this.particles.length;

                  for (var i = start; i < particleCount; i++) {
                    var offset = i * formatBytes * 4;
                    vbuf[offset + 3] = uv[0];
                    vbuf[offset + 4] = uv[1];
                    vbuf[offset + 12] = uv[2];
                    vbuf[offset + 13] = uv[3];
                    vbuf[offset + 21] = uv[4];
                    vbuf[offset + 22] = uv[5];
                    vbuf[offset + 30] = uv[6];
                    vbuf[offset + 31] = uv[7];
                  }

                  this.uvFilled = particleCount;
                }
              };

              _proto2.updateParticleBuffer = function updateParticleBuffer(particle, pos, buffer, offset) {
                var vbuf = buffer.vData;
                var x = pos.x;
                var y = pos.y;
                var width = particle.size;
                var height = width;
                var aspectRatio = particle.aspectRatio;

                if (aspectRatio > 1) {
                  height = width / aspectRatio;
                } else {
                  width = height * aspectRatio;
                }

                var halfWidth = width / 2;
                var halfHeight = height / 2;

                if (particle.rotation) {
                  var x1 = -halfWidth;
                  var y1 = -halfHeight;
                  var x2 = halfWidth;
                  var y2 = halfHeight;
                  var rad = -degreesToRadians(particle.rotation);
                  var cr = Math.cos(rad);
                  var sr = Math.sin(rad);
                  vbuf[offset] = x1 * cr - y1 * sr + x;
                  vbuf[offset + 1] = x1 * sr + y1 * cr + y;
                  vbuf[offset + 2] = 0;
                  vbuf[offset + 9] = x2 * cr - y1 * sr + x;
                  vbuf[offset + 10] = x2 * sr + y1 * cr + y;
                  vbuf[offset + 11] = 0;
                  vbuf[offset + 18] = x1 * cr - y2 * sr + x;
                  vbuf[offset + 19] = x1 * sr + y2 * cr + y;
                  vbuf[offset + 20] = 0;
                  vbuf[offset + 27] = x2 * cr - y2 * sr + x;
                  vbuf[offset + 28] = x2 * sr + y2 * cr + y;
                  vbuf[offset + 29] = 0;
                } else {
                  vbuf[offset] = x - halfWidth;
                  vbuf[offset + 1] = y - halfHeight;
                  vbuf[offset + 2] = 0;
                  vbuf[offset + 9] = x + halfWidth;
                  vbuf[offset + 10] = y - halfHeight;
                  vbuf[offset + 11] = 0;
                  vbuf[offset + 18] = x - halfWidth;
                  vbuf[offset + 19] = y + halfHeight;
                  vbuf[offset + 20] = 0;
                  vbuf[offset + 27] = x + halfWidth;
                  vbuf[offset + 28] = y + halfHeight;
                  vbuf[offset + 29] = 0;
                }

                Color$1.toArray(vbuf, particle.color, offset + 5);
                Color$1.toArray(vbuf, particle.color, offset + 14);
                Color$1.toArray(vbuf, particle.color, offset + 23);
                Color$1.toArray(vbuf, particle.color, offset + 32);
              };

              _proto2.step = function step(dt) {
                var assembler = this.sys.assembler;
                var psys = this.sys;
                var node = psys.node;
                var particles = this.particles;
                dt = dt > assembler.maxParticleDeltaTime ? assembler.maxParticleDeltaTime : dt;
                node.updateWorldTransform();

                if (psys.positionType === PositionType.FREE) {
                  this._worldRotation = getWorldRotation(node);
                  var m = node.worldMatrix;
                  _pos.x = m.m12;
                  _pos.y = m.m13;
                } else if (psys.positionType === PositionType.RELATIVE) {
                  this._worldRotation = node.eulerAngles.z;
                  _pos.x = node.position.x;
                  _pos.y = node.position.y;
                } else {
                  this._worldRotation = 0;
                }

                if (this.active && psys.emissionRate) {
                  var rate = 1.0 / psys.emissionRate;
                  if (particles.length < psys.totalParticles) this.emitCounter += dt;

                  while (particles.length < psys.totalParticles && this.emitCounter > rate) {
                    this.emitParticle(_pos);
                    this.emitCounter -= rate;
                  }

                  this.elapsed += dt;

                  if (psys.duration !== -1 && psys.duration < this.elapsed) {
                    psys.stopSystem();
                  }
                }

                var renderData = this.renderData;
                var particleCount = particles.length;
                renderData.reset();
                this.requestData(particleCount * 4, particleCount * 6);

                if (particleCount > this.uvFilled) {
                  this.updateUVs();
                }

                var particleIdx = 0;

                while (particleIdx < particles.length) {
                  _tpa.x = _tpa.y = _tpb.x = _tpb.y = _tpc.x = _tpc.y = 0;
                  var particle = particles[particleIdx];
                  particle.timeToLive -= dt;

                  if (particle.timeToLive > 0) {
                    if (psys.emitterMode === EmitterMode.GRAVITY) {
                      var tmp = _tpc;
                      var radial = _tpa;
                      var tangential = _tpb;

                      if (particle.pos.x || particle.pos.y) {
                        radial.set(particle.pos);
                        radial.normalize();
                      }

                      tangential.set(radial);
                      radial.multiplyScalar(particle.radialAccel);
                      var newy = tangential.x;
                      tangential.x = -tangential.y;
                      tangential.y = newy;
                      tangential.multiplyScalar(particle.tangentialAccel);
                      tmp.set(radial);
                      tmp.add(tangential);
                      tmp.add(psys.gravity);
                      tmp.multiplyScalar(dt);
                      particle.dir.add(tmp);
                      tmp.set(particle.dir);
                      tmp.multiplyScalar(dt);
                      particle.pos.add(tmp);
                    } else {
                      particle.angle += particle.degreesPerSecond * dt;
                      particle.radius += particle.deltaRadius * dt;
                      particle.pos.x = -Math.cos(particle.angle) * particle.radius;
                      particle.pos.y = -Math.sin(particle.angle) * particle.radius;
                    }

                    particle.color.r += particle.deltaColor.r * dt;
                    particle.color.g += particle.deltaColor.g * dt;
                    particle.color.b += particle.deltaColor.b * dt;
                    particle.color.a += particle.deltaColor.a * dt;
                    particle.size += particle.deltaSize * dt;

                    if (particle.size < 0) {
                      particle.size = 0;
                    }

                    particle.rotation += particle.deltaRotation * dt;
                    var newPos = _tpa;
                    newPos.set(particle.pos);

                    if (psys.positionType !== PositionType.GROUPED) {
                      newPos.add(particle.startPos);
                    }

                    var offset = formatBytes * particleIdx * 4;
                    this.updateParticleBuffer(particle, newPos, renderData, offset);
                    ++particleIdx;
                  } else {
                    var deadParticle = particles[particleIdx];

                    if (particleIdx !== particles.length - 1) {
                      particles[particleIdx] = particles[particles.length - 1];
                    }

                    pool$2.put(deadParticle);
                    particles.length--;
                    renderData.resize(renderData.vertexCount - 4, renderData.indexCount - 6);
                  }
                }

                this.renderData.material = this.sys.getRenderMaterial(0);
                this.renderData.frame = this.sys._renderSpriteFrame;
                renderData.setRenderDrawInfoAttributes();

                if (particles.length === 0 && !this.active && !this.readyToPlay) {
                  this.finished = true;

                  psys._finishedSimulation();
                }
              };

              _proto2.requestData = function requestData(vertexCount, indexCount) {
                var offset = this.renderData.indexCount;
                this.renderData.request(vertexCount, indexCount);
                var count = this.renderData.indexCount / 6;
                var buffer = this.renderData.iData;

                for (var i = offset; i < count; i++) {
                  var vId = i * 4;
                  buffer[offset++] = vId;
                  buffer[offset++] = vId + 1;
                  buffer[offset++] = vId + 2;
                  buffer[offset++] = vId + 1;
                  buffer[offset++] = vId + 3;
                  buffer[offset++] = vId + 2;
                }
              };

              _proto2.initDrawInfo = function initDrawInfo() {
                var renderData = this.renderData;
                renderData.setRenderDrawInfoAttributes();
              };

              return Simulator;
            }();

            var _dec$1x, _class$1A, _class2$1k, _initializer$1f;
            var ccclass$o = ccclass$p,
                serializable$i = serializable$j;
            var ParticleAsset = exports('ParticleAsset', (_dec$1x = ccclass$o('cc.ParticleAsset'), _dec$1x(_class$1A = (_class2$1k = function (_Asset) {
              _inheritsLoose(ParticleAsset, _Asset);

              function ParticleAsset() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;
                _this.spriteFrame = _initializer$1f && _initializer$1f();
                return _this;
              }

              return ParticleAsset;
            }(Asset), (_initializer$1f = applyDecoratedInitializer(_class2$1k.prototype, "spriteFrame", [serializable$i], function () {
              return null;
            })), _class2$1k)) || _class$1A));
            legacyCC.ParticleAsset = ParticleAsset;

            /** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
            var window$1 = {};
            (function () {

              function i(a) {
                throw a;
              }

              var r = void 0,
                  v = !0,
                  aa = this;

              function y(a, c) {
                var b = a.split("."),
                    e = aa;
                !(b[0] in e) && e.execScript && e.execScript("var " + b[0]);

                for (var f; b.length && (f = b.shift());) {
                  !b.length && c !== r ? e[f] = c : e = e[f] ? e[f] : e[f] = {};
                }
              }
              var H = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;

              function ba(a) {
                if ("string" === typeof a) {
                  var c = a.split(""),
                      b,
                      e;
                  b = 0;

                  for (e = c.length; b < e; b++) {
                    c[b] = (c[b].charCodeAt(0) & 255) >>> 0;
                  }

                  a = c;
                }

                for (var f = 1, d = 0, g = a.length, h, m = 0; 0 < g;) {
                  h = 1024 < g ? 1024 : g;
                  g -= h;

                  do {
                    f += a[m++], d += f;
                  } while (--h);

                  f %= 65521;
                  d %= 65521;
                }

                return (d << 16 | f) >>> 0;
              }

              function J(a, c) {
                this.index = "number" === typeof c ? c : 0;
                this.i = 0;
                this.buffer = a instanceof (H ? Uint8Array : Array) ? a : new (H ? Uint8Array : Array)(32768);
                2 * this.buffer.length <= this.index && i(Error("invalid index"));
                this.buffer.length <= this.index && this.f();
              }

              J.prototype.f = function () {
                var a = this.buffer,
                    c,
                    b = a.length,
                    e = new (H ? Uint8Array : Array)(b << 1);
                if (H) e.set(a);else for (c = 0; c < b; ++c) {
                  e[c] = a[c];
                }
                return this.buffer = e;
              };

              J.prototype.d = function (a, c, b) {
                var e = this.buffer,
                    f = this.index,
                    d = this.i,
                    g = e[f],
                    h;
                b && 1 < c && (a = 8 < c ? (N[a & 255] << 24 | N[a >>> 8 & 255] << 16 | N[a >>> 16 & 255] << 8 | N[a >>> 24 & 255]) >> 32 - c : N[a] >> 8 - c);
                if (8 > c + d) g = g << c | a, d += c;else for (h = 0; h < c; ++h) {
                  g = g << 1 | a >> c - h - 1 & 1, 8 === ++d && (d = 0, e[f++] = N[g], g = 0, f === e.length && (e = this.f()));
                }
                e[f] = g;
                this.buffer = e;
                this.i = d;
                this.index = f;
              };

              J.prototype.finish = function () {
                var a = this.buffer,
                    c = this.index,
                    b;
                0 < this.i && (a[c] <<= 8 - this.i, a[c] = N[a[c]], c++);
                H ? b = a.subarray(0, c) : (a.length = c, b = a);
                return b;
              };

              var ca = new (H ? Uint8Array : Array)(256),
                  ha;

              for (ha = 0; 256 > ha; ++ha) {
                for (var R = ha, ia = R, ja = 7, R = R >>> 1; R; R >>>= 1) {
                  ia <<= 1, ia |= R & 1, --ja;
                }

                ca[ha] = (ia << ja & 255) >>> 0;
              }

              var N = ca;

              function la(a) {
                this.buffer = new (H ? Uint16Array : Array)(2 * a);
                this.length = 0;
              }

              la.prototype.getParent = function (a) {
                return 2 * ((a - 2) / 4 | 0);
              };

              la.prototype.push = function (a, c) {
                var b,
                    e,
                    f = this.buffer,
                    d;
                b = this.length;
                f[this.length++] = c;

                for (f[this.length++] = a; 0 < b;) {
                  if (e = this.getParent(b), f[b] > f[e]) d = f[b], f[b] = f[e], f[e] = d, d = f[b + 1], f[b + 1] = f[e + 1], f[e + 1] = d, b = e;else break;
                }

                return this.length;
              };

              la.prototype.pop = function () {
                var a,
                    c,
                    b = this.buffer,
                    e,
                    f,
                    d;
                c = b[0];
                a = b[1];
                this.length -= 2;
                b[0] = b[this.length];
                b[1] = b[this.length + 1];

                for (d = 0;;) {
                  f = 2 * d + 2;
                  if (f >= this.length) break;
                  f + 2 < this.length && b[f + 2] > b[f] && (f += 2);
                  if (b[f] > b[d]) e = b[d], b[d] = b[f], b[f] = e, e = b[d + 1], b[d + 1] = b[f + 1], b[f + 1] = e;else break;
                  d = f;
                }

                return {
                  index: a,
                  value: c,
                  length: this.length
                };
              };

              function S(a) {
                var c = a.length,
                    b = 0,
                    e = Number.POSITIVE_INFINITY,
                    f,
                    d,
                    g,
                    h,
                    m,
                    j,
                    s,
                    n,
                    l;

                for (n = 0; n < c; ++n) {
                  a[n] > b && (b = a[n]), a[n] < e && (e = a[n]);
                }

                f = 1 << b;
                d = new (H ? Uint32Array : Array)(f);
                g = 1;
                h = 0;

                for (m = 2; g <= b;) {
                  for (n = 0; n < c; ++n) {
                    if (a[n] === g) {
                      j = 0;
                      s = h;

                      for (l = 0; l < g; ++l) {
                        j = j << 1 | s & 1, s >>= 1;
                      }

                      for (l = j; l < f; l += m) {
                        d[l] = g << 16 | n;
                      }

                      ++h;
                    }
                  }

                  ++g;
                  h <<= 1;
                  m <<= 1;
                }

                return [d, b, e];
              }

              function ma(a, c) {
                this.h = pa;
                this.w = 0;
                this.input = a;
                this.b = 0;
                c && (c.lazy && (this.w = c.lazy), "number" === typeof c.compressionType && (this.h = c.compressionType), c.outputBuffer && (this.a = H && c.outputBuffer instanceof Array ? new Uint8Array(c.outputBuffer) : c.outputBuffer), "number" === typeof c.outputIndex && (this.b = c.outputIndex));
                this.a || (this.a = new (H ? Uint8Array : Array)(32768));
              }

              var pa = 2,
                  qa = {
                NONE: 0,
                r: 1,
                j: pa,
                N: 3
              },
                  ra = [],
                  T;

              for (T = 0; 288 > T; T++) {
                switch (v) {
                  case 143 >= T:
                    ra.push([T + 48, 8]);
                    break;

                  case 255 >= T:
                    ra.push([T - 144 + 400, 9]);
                    break;

                  case 279 >= T:
                    ra.push([T - 256 + 0, 7]);
                    break;

                  case 287 >= T:
                    ra.push([T - 280 + 192, 8]);
                    break;

                  default:
                    i("invalid literal: " + T);
                }
              }

              ma.prototype.n = function () {
                var a,
                    c,
                    b,
                    e,
                    f = this.input;

                switch (this.h) {
                  case 0:
                    b = 0;

                    for (e = f.length; b < e;) {
                      c = H ? f.subarray(b, b + 65535) : f.slice(b, b + 65535);
                      b += c.length;
                      var d = c,
                          g = b === e,
                          h = r,
                          m = r,
                          j = r,
                          s = r,
                          n = r,
                          l = this.a,
                          q = this.b;

                      if (H) {
                        for (l = new Uint8Array(this.a.buffer); l.length <= q + d.length + 5;) {
                          l = new Uint8Array(l.length << 1);
                        }

                        l.set(this.a);
                      }

                      h = g ? 1 : 0;
                      l[q++] = h | 0;
                      m = d.length;
                      j = ~m + 65536 & 65535;
                      l[q++] = m & 255;
                      l[q++] = m >>> 8 & 255;
                      l[q++] = j & 255;
                      l[q++] = j >>> 8 & 255;
                      if (H) l.set(d, q), q += d.length, l = l.subarray(0, q);else {
                        s = 0;

                        for (n = d.length; s < n; ++s) {
                          l[q++] = d[s];
                        }

                        l.length = q;
                      }
                      this.b = q;
                      this.a = l;
                    }

                    break;

                  case 1:
                    var E = new J(new Uint8Array(this.a.buffer), this.b);
                    E.d(1, 1, v);
                    E.d(1, 2, v);
                    var t = sa(this, f),
                        z,
                        K,
                        A;
                    z = 0;

                    for (K = t.length; z < K; z++) {
                      if (A = t[z], J.prototype.d.apply(E, ra[A]), 256 < A) E.d(t[++z], t[++z], v), E.d(t[++z], 5), E.d(t[++z], t[++z], v);else if (256 === A) break;
                    }

                    this.a = E.finish();
                    this.b = this.a.length;
                    break;

                  case pa:
                    var x = new J(new Uint8Array(this.a), this.b),
                        B,
                        k,
                        p,
                        D,
                        C,
                        da = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                        W,
                        Ma,
                        ea,
                        Na,
                        na,
                        va = Array(19),
                        Oa,
                        $,
                        oa,
                        F,
                        Pa;
                    B = pa;
                    x.d(1, 1, v);
                    x.d(B, 2, v);
                    k = sa(this, f);
                    W = ta(this.L, 15);
                    Ma = ua(W);
                    ea = ta(this.K, 7);
                    Na = ua(ea);

                    for (p = 286; 257 < p && 0 === W[p - 1]; p--) {
                    }

                    for (D = 30; 1 < D && 0 === ea[D - 1]; D--) {
                    }

                    var Qa = p,
                        Ra = D,
                        M = new (H ? Uint32Array : Array)(Qa + Ra),
                        u,
                        O,
                        w,
                        fa,
                        L = new (H ? Uint32Array : Array)(316),
                        I,
                        G,
                        P = new (H ? Uint8Array : Array)(19);

                    for (u = O = 0; u < Qa; u++) {
                      M[O++] = W[u];
                    }

                    for (u = 0; u < Ra; u++) {
                      M[O++] = ea[u];
                    }

                    if (!H) {
                      u = 0;

                      for (fa = P.length; u < fa; ++u) {
                        P[u] = 0;
                      }
                    }

                    u = I = 0;

                    for (fa = M.length; u < fa; u += O) {
                      for (O = 1; u + O < fa && M[u + O] === M[u]; ++O) {
                      }

                      w = O;
                      if (0 === M[u]) {
                        if (3 > w) for (; 0 < w--;) {
                          L[I++] = 0, P[0]++;
                        } else for (; 0 < w;) {
                          G = 138 > w ? w : 138, G > w - 3 && G < w && (G = w - 3), 10 >= G ? (L[I++] = 17, L[I++] = G - 3, P[17]++) : (L[I++] = 18, L[I++] = G - 11, P[18]++), w -= G;
                        }
                      } else if (L[I++] = M[u], P[M[u]]++, w--, 3 > w) for (; 0 < w--;) {
                        L[I++] = M[u], P[M[u]]++;
                      } else for (; 0 < w;) {
                        G = 6 > w ? w : 6, G > w - 3 && G < w && (G = w - 3), L[I++] = 16, L[I++] = G - 3, P[16]++, w -= G;
                      }
                    }

                    a = H ? L.subarray(0, I) : L.slice(0, I);
                    na = ta(P, 7);

                    for (F = 0; 19 > F; F++) {
                      va[F] = na[da[F]];
                    }

                    for (C = 19; 4 < C && 0 === va[C - 1]; C--) {
                    }

                    Oa = ua(na);
                    x.d(p - 257, 5, v);
                    x.d(D - 1, 5, v);
                    x.d(C - 4, 4, v);

                    for (F = 0; F < C; F++) {
                      x.d(va[F], 3, v);
                    }

                    F = 0;

                    for (Pa = a.length; F < Pa; F++) {
                      if ($ = a[F], x.d(Oa[$], na[$], v), 16 <= $) {
                        F++;

                        switch ($) {
                          case 16:
                            oa = 2;
                            break;

                          case 17:
                            oa = 3;
                            break;

                          case 18:
                            oa = 7;
                            break;

                          default:
                            i("invalid code: " + $);
                        }

                        x.d(a[F], oa, v);
                      }
                    }

                    var Sa = [Ma, W],
                        Ta = [Na, ea],
                        Q,
                        Ua,
                        ga,
                        ya,
                        Va,
                        Wa,
                        Xa,
                        Ya;
                    Va = Sa[0];
                    Wa = Sa[1];
                    Xa = Ta[0];
                    Ya = Ta[1];
                    Q = 0;

                    for (Ua = k.length; Q < Ua; ++Q) {
                      if (ga = k[Q], x.d(Va[ga], Wa[ga], v), 256 < ga) x.d(k[++Q], k[++Q], v), ya = k[++Q], x.d(Xa[ya], Ya[ya], v), x.d(k[++Q], k[++Q], v);else if (256 === ga) break;
                    }

                    this.a = x.finish();
                    this.b = this.a.length;
                    break;

                  default:
                    i("invalid compression type");
                }

                return this.a;
              };

              function wa(a, c) {
                this.length = a;
                this.G = c;
              }

              function xa() {
                var a = za;

                switch (v) {
                  case 3 === a:
                    return [257, a - 3, 0];

                  case 4 === a:
                    return [258, a - 4, 0];

                  case 5 === a:
                    return [259, a - 5, 0];

                  case 6 === a:
                    return [260, a - 6, 0];

                  case 7 === a:
                    return [261, a - 7, 0];

                  case 8 === a:
                    return [262, a - 8, 0];

                  case 9 === a:
                    return [263, a - 9, 0];

                  case 10 === a:
                    return [264, a - 10, 0];

                  case 12 >= a:
                    return [265, a - 11, 1];

                  case 14 >= a:
                    return [266, a - 13, 1];

                  case 16 >= a:
                    return [267, a - 15, 1];

                  case 18 >= a:
                    return [268, a - 17, 1];

                  case 22 >= a:
                    return [269, a - 19, 2];

                  case 26 >= a:
                    return [270, a - 23, 2];

                  case 30 >= a:
                    return [271, a - 27, 2];

                  case 34 >= a:
                    return [272, a - 31, 2];

                  case 42 >= a:
                    return [273, a - 35, 3];

                  case 50 >= a:
                    return [274, a - 43, 3];

                  case 58 >= a:
                    return [275, a - 51, 3];

                  case 66 >= a:
                    return [276, a - 59, 3];

                  case 82 >= a:
                    return [277, a - 67, 4];

                  case 98 >= a:
                    return [278, a - 83, 4];

                  case 114 >= a:
                    return [279, a - 99, 4];

                  case 130 >= a:
                    return [280, a - 115, 4];

                  case 162 >= a:
                    return [281, a - 131, 5];

                  case 194 >= a:
                    return [282, a - 163, 5];

                  case 226 >= a:
                    return [283, a - 195, 5];

                  case 257 >= a:
                    return [284, a - 227, 5];

                  case 258 === a:
                    return [285, a - 258, 0];

                  default:
                    i("invalid length: " + a);
                }
              }

              var Aa = [],
                  za,
                  Ba;

              for (za = 3; 258 >= za; za++) {
                Ba = xa(), Aa[za] = Ba[2] << 24 | Ba[1] << 16 | Ba[0];
              }

              var Ca = H ? new Uint32Array(Aa) : Aa;

              function sa(a, c) {
                function b(a, c) {
                  var b = a.G,
                      d = [],
                      e = 0,
                      f;
                  f = Ca[a.length];
                  d[e++] = f & 65535;
                  d[e++] = f >> 16 & 255;
                  d[e++] = f >> 24;
                  var g;

                  switch (v) {
                    case 1 === b:
                      g = [0, b - 1, 0];
                      break;

                    case 2 === b:
                      g = [1, b - 2, 0];
                      break;

                    case 3 === b:
                      g = [2, b - 3, 0];
                      break;

                    case 4 === b:
                      g = [3, b - 4, 0];
                      break;

                    case 6 >= b:
                      g = [4, b - 5, 1];
                      break;

                    case 8 >= b:
                      g = [5, b - 7, 1];
                      break;

                    case 12 >= b:
                      g = [6, b - 9, 2];
                      break;

                    case 16 >= b:
                      g = [7, b - 13, 2];
                      break;

                    case 24 >= b:
                      g = [8, b - 17, 3];
                      break;

                    case 32 >= b:
                      g = [9, b - 25, 3];
                      break;

                    case 48 >= b:
                      g = [10, b - 33, 4];
                      break;

                    case 64 >= b:
                      g = [11, b - 49, 4];
                      break;

                    case 96 >= b:
                      g = [12, b - 65, 5];
                      break;

                    case 128 >= b:
                      g = [13, b - 97, 5];
                      break;

                    case 192 >= b:
                      g = [14, b - 129, 6];
                      break;

                    case 256 >= b:
                      g = [15, b - 193, 6];
                      break;

                    case 384 >= b:
                      g = [16, b - 257, 7];
                      break;

                    case 512 >= b:
                      g = [17, b - 385, 7];
                      break;

                    case 768 >= b:
                      g = [18, b - 513, 8];
                      break;

                    case 1024 >= b:
                      g = [19, b - 769, 8];
                      break;

                    case 1536 >= b:
                      g = [20, b - 1025, 9];
                      break;

                    case 2048 >= b:
                      g = [21, b - 1537, 9];
                      break;

                    case 3072 >= b:
                      g = [22, b - 2049, 10];
                      break;

                    case 4096 >= b:
                      g = [23, b - 3073, 10];
                      break;

                    case 6144 >= b:
                      g = [24, b - 4097, 11];
                      break;

                    case 8192 >= b:
                      g = [25, b - 6145, 11];
                      break;

                    case 12288 >= b:
                      g = [26, b - 8193, 12];
                      break;

                    case 16384 >= b:
                      g = [27, b - 12289, 12];
                      break;

                    case 24576 >= b:
                      g = [28, b - 16385, 13];
                      break;

                    case 32768 >= b:
                      g = [29, b - 24577, 13];
                      break;

                    default:
                      i("invalid distance");
                  }

                  f = g;
                  d[e++] = f[0];
                  d[e++] = f[1];
                  d[e++] = f[2];
                  var h, j;
                  h = 0;

                  for (j = d.length; h < j; ++h) {
                    l[q++] = d[h];
                  }

                  t[d[0]]++;
                  z[d[3]]++;
                  E = a.length + c - 1;
                  n = null;
                }

                var e,
                    f,
                    d,
                    g,
                    h,
                    m = {},
                    j,
                    s,
                    n,
                    l = H ? new Uint16Array(2 * c.length) : [],
                    q = 0,
                    E = 0,
                    t = new (H ? Uint32Array : Array)(286),
                    z = new (H ? Uint32Array : Array)(30),
                    K = a.w,
                    A;

                if (!H) {
                  for (d = 0; 285 >= d;) {
                    t[d++] = 0;
                  }

                  for (d = 0; 29 >= d;) {
                    z[d++] = 0;
                  }
                }

                t[256] = 1;
                e = 0;

                for (f = c.length; e < f; ++e) {
                  d = h = 0;

                  for (g = 3; d < g && e + d !== f; ++d) {
                    h = h << 8 | c[e + d];
                  }

                  m[h] === r && (m[h] = []);
                  j = m[h];

                  if (!(0 < E--)) {
                    for (; 0 < j.length && 32768 < e - j[0];) {
                      j.shift();
                    }

                    if (e + 3 >= f) {
                      n && b(n, -1);
                      d = 0;

                      for (g = f - e; d < g; ++d) {
                        A = c[e + d], l[q++] = A, ++t[A];
                      }

                      break;
                    }

                    if (0 < j.length) {
                      var x = r,
                          B = r,
                          k = 0,
                          p = r,
                          D = r,
                          C = r,
                          da = r,
                          W = c.length,
                          D = 0,
                          da = j.length;

                      a: for (; D < da; D++) {
                        x = j[da - D - 1];
                        p = 3;

                        if (3 < k) {
                          for (C = k; 3 < C; C--) {
                            if (c[x + C - 1] !== c[e + C - 1]) continue a;
                          }

                          p = k;
                        }

                        for (; 258 > p && e + p < W && c[x + p] === c[e + p];) {
                          ++p;
                        }

                        p > k && (B = x, k = p);
                        if (258 === p) break;
                      }

                      s = new wa(k, e - B);
                      n ? n.length < s.length ? (A = c[e - 1], l[q++] = A, ++t[A], b(s, 0)) : b(n, -1) : s.length < K ? n = s : b(s, 0);
                    } else n ? b(n, -1) : (A = c[e], l[q++] = A, ++t[A]);
                  }

                  j.push(e);
                }

                l[q++] = 256;
                t[256]++;
                a.L = t;
                a.K = z;
                return H ? l.subarray(0, q) : l;
              }

              function ta(a, c) {
                function b(a) {
                  var c = z[a][K[a]];
                  c === n ? (b(a + 1), b(a + 1)) : --E[c];
                  ++K[a];
                }

                var e = a.length,
                    f = new la(572),
                    d = new (H ? Uint8Array : Array)(e),
                    g,
                    h,
                    m,
                    j,
                    s;
                if (!H) for (j = 0; j < e; j++) {
                  d[j] = 0;
                }

                for (j = 0; j < e; ++j) {
                  0 < a[j] && f.push(j, a[j]);
                }

                g = Array(f.length / 2);
                h = new (H ? Uint32Array : Array)(f.length / 2);
                if (1 === g.length) return d[f.pop().index] = 1, d;
                j = 0;

                for (s = f.length / 2; j < s; ++j) {
                  g[j] = f.pop(), h[j] = g[j].value;
                }

                var n = h.length,
                    l = new (H ? Uint16Array : Array)(c),
                    q = new (H ? Uint8Array : Array)(c),
                    E = new (H ? Uint8Array : Array)(n),
                    t = Array(c),
                    z = Array(c),
                    K = Array(c),
                    A = (1 << c) - n,
                    x = 1 << c - 1,
                    B,
                    k,
                    p,
                    D,
                    C;
                l[c - 1] = n;

                for (k = 0; k < c; ++k) {
                  A < x ? q[k] = 0 : (q[k] = 1, A -= x), A <<= 1, l[c - 2 - k] = (l[c - 1 - k] / 2 | 0) + n;
                }

                l[0] = q[0];
                t[0] = Array(l[0]);
                z[0] = Array(l[0]);

                for (k = 1; k < c; ++k) {
                  l[k] > 2 * l[k - 1] + q[k] && (l[k] = 2 * l[k - 1] + q[k]), t[k] = Array(l[k]), z[k] = Array(l[k]);
                }

                for (B = 0; B < n; ++B) {
                  E[B] = c;
                }

                for (p = 0; p < l[c - 1]; ++p) {
                  t[c - 1][p] = h[p], z[c - 1][p] = p;
                }

                for (B = 0; B < c; ++B) {
                  K[B] = 0;
                }

                1 === q[c - 1] && (--E[0], ++K[c - 1]);

                for (k = c - 2; 0 <= k; --k) {
                  D = B = 0;
                  C = K[k + 1];

                  for (p = 0; p < l[k]; p++) {
                    D = t[k + 1][C] + t[k + 1][C + 1], D > h[B] ? (t[k][p] = D, z[k][p] = n, C += 2) : (t[k][p] = h[B], z[k][p] = B, ++B);
                  }

                  K[k] = 0;
                  1 === q[k] && b(k);
                }

                m = E;
                j = 0;

                for (s = g.length; j < s; ++j) {
                  d[g[j].index] = m[j];
                }

                return d;
              }

              function ua(a) {
                var c = new (H ? Uint16Array : Array)(a.length),
                    b = [],
                    e = [],
                    f = 0,
                    d,
                    g,
                    h,
                    m;
                d = 0;

                for (g = a.length; d < g; d++) {
                  b[a[d]] = (b[a[d]] | 0) + 1;
                }

                d = 1;

                for (g = 16; d <= g; d++) {
                  e[d] = f, f += b[d] | 0, f > 1 << d && i("overcommitted"), f <<= 1;
                }

                65536 > f && i("undercommitted");
                d = 0;

                for (g = a.length; d < g; d++) {
                  f = e[a[d]];
                  e[a[d]] += 1;
                  h = c[d] = 0;

                  for (m = a[d]; h < m; h++) {
                    c[d] = c[d] << 1 | f & 1, f >>>= 1;
                  }
                }

                return c;
              }

              function Da(a, c) {
                this.input = a;
                this.a = new (H ? Uint8Array : Array)(32768);
                this.h = U.j;
                var b = {},
                    e;
                if ((c || !(c = {})) && "number" === typeof c.compressionType) this.h = c.compressionType;

                for (e in c) {
                  b[e] = c[e];
                }

                b.outputBuffer = this.a;
                this.z = new ma(this.input, b);
              }

              var U = qa;

              Da.prototype.n = function () {
                var a,
                    c,
                    b,
                    e,
                    f,
                    d,
                    g,
                    h = 0;
                g = this.a;
                a = Ea;

                switch (a) {
                  case Ea:
                    c = Math.LOG2E * Math.log(32768) - 8;
                    break;

                  default:
                    i(Error("invalid compression method"));
                }

                b = c << 4 | a;
                g[h++] = b;

                switch (a) {
                  case Ea:
                    switch (this.h) {
                      case U.NONE:
                        f = 0;
                        break;

                      case U.r:
                        f = 1;
                        break;

                      case U.j:
                        f = 2;
                        break;

                      default:
                        i(Error("unsupported compression type"));
                    }

                    break;

                  default:
                    i(Error("invalid compression method"));
                }

                e = f << 6 | 0;
                g[h++] = e | 31 - (256 * b + e) % 31;
                d = ba(this.input);
                this.z.b = h;
                g = this.z.n();
                h = g.length;
                H && (g = new Uint8Array(g.buffer), g.length <= h + 4 && (this.a = new Uint8Array(g.length + 4), this.a.set(g), g = this.a), g = g.subarray(0, h + 4));
                g[h++] = d >> 24 & 255;
                g[h++] = d >> 16 & 255;
                g[h++] = d >> 8 & 255;
                g[h++] = d & 255;
                return g;
              };

              y("Zlib.Deflate", Da);
              y("Zlib.Deflate.compress", function (a, c) {
                return new Da(a, c).n();
              });
              y("Zlib.Deflate.CompressionType", U);
              y("Zlib.Deflate.CompressionType.NONE", U.NONE);
              y("Zlib.Deflate.CompressionType.FIXED", U.r);
              y("Zlib.Deflate.CompressionType.DYNAMIC", U.j);

              function V(a, c) {
                this.k = [];
                this.l = 32768;
                this.e = this.g = this.c = this.q = 0;
                this.input = H ? new Uint8Array(a) : a;
                this.s = !1;
                this.m = Fa;
                this.B = !1;
                if (c || !(c = {})) c.index && (this.c = c.index), c.bufferSize && (this.l = c.bufferSize), c.bufferType && (this.m = c.bufferType), c.resize && (this.B = c.resize);

                switch (this.m) {
                  case Ga:
                    this.b = 32768;
                    this.a = new (H ? Uint8Array : Array)(32768 + this.l + 258);
                    break;

                  case Fa:
                    this.b = 0;
                    this.a = new (H ? Uint8Array : Array)(this.l);
                    this.f = this.J;
                    this.t = this.H;
                    this.o = this.I;
                    break;

                  default:
                    i(Error("invalid inflate mode"));
                }
              }

              var Ga = 0,
                  Fa = 1,
                  Ha = {
                D: Ga,
                C: Fa
              };

              V.prototype.p = function () {
                for (; !this.s;) {
                  var a = X(this, 3);
                  a & 1 && (this.s = v);
                  a >>>= 1;

                  switch (a) {
                    case 0:
                      var c = this.input,
                          b = this.c,
                          e = this.a,
                          f = this.b,
                          d = r,
                          g = r,
                          h = r,
                          m = e.length,
                          j = r;
                      this.e = this.g = 0;
                      d = c[b++];
                      d === r && i(Error("invalid uncompressed block header: LEN (first byte)"));
                      g = d;
                      d = c[b++];
                      d === r && i(Error("invalid uncompressed block header: LEN (second byte)"));
                      g |= d << 8;
                      d = c[b++];
                      d === r && i(Error("invalid uncompressed block header: NLEN (first byte)"));
                      h = d;
                      d = c[b++];
                      d === r && i(Error("invalid uncompressed block header: NLEN (second byte)"));
                      h |= d << 8;
                      g === ~h && i(Error("invalid uncompressed block header: length verify"));
                      b + g > c.length && i(Error("input buffer is broken"));

                      switch (this.m) {
                        case Ga:
                          for (; f + g > e.length;) {
                            j = m - f;
                            g -= j;
                            if (H) e.set(c.subarray(b, b + j), f), f += j, b += j;else for (; j--;) {
                              e[f++] = c[b++];
                            }
                            this.b = f;
                            e = this.f();
                            f = this.b;
                          }

                          break;

                        case Fa:
                          for (; f + g > e.length;) {
                            e = this.f({
                              v: 2
                            });
                          }

                          break;

                        default:
                          i(Error("invalid inflate mode"));
                      }

                      if (H) e.set(c.subarray(b, b + g), f), f += g, b += g;else for (; g--;) {
                        e[f++] = c[b++];
                      }
                      this.c = b;
                      this.b = f;
                      this.a = e;
                      break;

                    case 1:
                      this.o(Ia, Ja);
                      break;

                    case 2:
                      Ka(this);
                      break;

                    default:
                      i(Error("unknown BTYPE: " + a));
                  }
                }

                return this.t();
              };

              var La = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                  Za = H ? new Uint16Array(La) : La,
                  $a = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258],
                  ab = H ? new Uint16Array($a) : $a,
                  bb = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0],
                  cb = H ? new Uint8Array(bb) : bb,
                  db = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],
                  eb = H ? new Uint16Array(db) : db,
                  fb = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
                  gb = H ? new Uint8Array(fb) : fb,
                  hb = new (H ? Uint8Array : Array)(288),
                  Y,
                  ib;
              Y = 0;

              for (ib = hb.length; Y < ib; ++Y) {
                hb[Y] = 143 >= Y ? 8 : 255 >= Y ? 9 : 279 >= Y ? 7 : 8;
              }

              var Ia = S(hb),
                  jb = new (H ? Uint8Array : Array)(30),
                  kb,
                  lb;
              kb = 0;

              for (lb = jb.length; kb < lb; ++kb) {
                jb[kb] = 5;
              }

              var Ja = S(jb);

              function X(a, c) {
                for (var b = a.g, e = a.e, f = a.input, d = a.c, g; e < c;) {
                  g = f[d++], g === r && i(Error("input buffer is broken")), b |= g << e, e += 8;
                }

                g = b & (1 << c) - 1;
                a.g = b >>> c;
                a.e = e - c;
                a.c = d;
                return g;
              }

              function mb(a, c) {
                for (var b = a.g, e = a.e, f = a.input, d = a.c, g = c[0], h = c[1], m, j, s; e < h;) {
                  m = f[d++], m === r && i(Error("input buffer is broken")), b |= m << e, e += 8;
                }

                j = g[b & (1 << h) - 1];
                s = j >>> 16;
                a.g = b >> s;
                a.e = e - s;
                a.c = d;
                return j & 65535;
              }

              function Ka(a) {
                function c(a, b, c) {
                  var d, e, f, g;

                  for (g = 0; g < a;) {
                    switch (d = mb(this, b), d) {
                      case 16:
                        for (f = 3 + X(this, 2); f--;) {
                          c[g++] = e;
                        }

                        break;

                      case 17:
                        for (f = 3 + X(this, 3); f--;) {
                          c[g++] = 0;
                        }

                        e = 0;
                        break;

                      case 18:
                        for (f = 11 + X(this, 7); f--;) {
                          c[g++] = 0;
                        }

                        e = 0;
                        break;

                      default:
                        e = c[g++] = d;
                    }
                  }

                  return c;
                }

                var b = X(a, 5) + 257,
                    e = X(a, 5) + 1,
                    f = X(a, 4) + 4,
                    d = new (H ? Uint8Array : Array)(Za.length),
                    g,
                    h,
                    m,
                    j;

                for (j = 0; j < f; ++j) {
                  d[Za[j]] = X(a, 3);
                }

                g = S(d);
                h = new (H ? Uint8Array : Array)(b);
                m = new (H ? Uint8Array : Array)(e);
                a.o(S(c.call(a, b, g, h)), S(c.call(a, e, g, m)));
              }

              V.prototype.o = function (a, c) {
                var b = this.a,
                    e = this.b;
                this.u = a;

                for (var f = b.length - 258, d, g, h, m; 256 !== (d = mb(this, a));) {
                  if (256 > d) e >= f && (this.b = e, b = this.f(), e = this.b), b[e++] = d;else {
                    g = d - 257;
                    m = ab[g];
                    0 < cb[g] && (m += X(this, cb[g]));
                    d = mb(this, c);
                    h = eb[d];
                    0 < gb[d] && (h += X(this, gb[d]));
                    e >= f && (this.b = e, b = this.f(), e = this.b);

                    for (; m--;) {
                      b[e] = b[e++ - h];
                    }
                  }
                }

                for (; 8 <= this.e;) {
                  this.e -= 8, this.c--;
                }

                this.b = e;
              };

              V.prototype.I = function (a, c) {
                var b = this.a,
                    e = this.b;
                this.u = a;

                for (var f = b.length, d, g, h, m; 256 !== (d = mb(this, a));) {
                  if (256 > d) e >= f && (b = this.f(), f = b.length), b[e++] = d;else {
                    g = d - 257;
                    m = ab[g];
                    0 < cb[g] && (m += X(this, cb[g]));
                    d = mb(this, c);
                    h = eb[d];
                    0 < gb[d] && (h += X(this, gb[d]));
                    e + m > f && (b = this.f(), f = b.length);

                    for (; m--;) {
                      b[e] = b[e++ - h];
                    }
                  }
                }

                for (; 8 <= this.e;) {
                  this.e -= 8, this.c--;
                }

                this.b = e;
              };

              V.prototype.f = function () {
                var a = new (H ? Uint8Array : Array)(this.b - 32768),
                    c = this.b - 32768,
                    b,
                    e,
                    f = this.a;
                if (H) a.set(f.subarray(32768, a.length));else {
                  b = 0;

                  for (e = a.length; b < e; ++b) {
                    a[b] = f[b + 32768];
                  }
                }
                this.k.push(a);
                this.q += a.length;
                if (H) f.set(f.subarray(c, c + 32768));else for (b = 0; 32768 > b; ++b) {
                  f[b] = f[c + b];
                }
                this.b = 32768;
                return f;
              };

              V.prototype.J = function (a) {
                var c,
                    b = this.input.length / this.c + 1 | 0,
                    e,
                    f,
                    d,
                    g = this.input,
                    h = this.a;
                a && ("number" === typeof a.v && (b = a.v), "number" === typeof a.F && (b += a.F));
                2 > b ? (e = (g.length - this.c) / this.u[2], d = 258 * (e / 2) | 0, f = d < h.length ? h.length + d : h.length << 1) : f = h.length * b;
                H ? (c = new Uint8Array(f), c.set(h)) : c = h;
                return this.a = c;
              };

              V.prototype.t = function () {
                var a = 0,
                    c = this.a,
                    b = this.k,
                    e,
                    f = new (H ? Uint8Array : Array)(this.q + (this.b - 32768)),
                    d,
                    g,
                    h,
                    m;
                if (0 === b.length) return H ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
                d = 0;

                for (g = b.length; d < g; ++d) {
                  e = b[d];
                  h = 0;

                  for (m = e.length; h < m; ++h) {
                    f[a++] = e[h];
                  }
                }

                d = 32768;

                for (g = this.b; d < g; ++d) {
                  f[a++] = c[d];
                }

                this.k = [];
                return this.buffer = f;
              };

              V.prototype.H = function () {
                var a,
                    c = this.b;
                H ? this.B ? (a = new Uint8Array(c), a.set(this.a.subarray(0, c))) : a = this.a.subarray(0, c) : (this.a.length > c && (this.a.length = c), a = this.a);
                return this.buffer = a;
              };

              function nb(a, c) {
                var b, e;
                this.input = a;
                this.c = 0;
                if (c || !(c = {})) c.index && (this.c = c.index), c.verify && (this.M = c.verify);
                b = a[this.c++];
                e = a[this.c++];

                switch (b & 15) {
                  case Ea:
                    this.method = Ea;
                    break;

                  default:
                    i(Error("unsupported compression method"));
                }

                0 !== ((b << 8) + e) % 31 && i(Error("invalid fcheck flag:" + ((b << 8) + e) % 31));
                e & 32 && i(Error("fdict flag is not supported"));
                this.A = new V(a, {
                  index: this.c,
                  bufferSize: c.bufferSize,
                  bufferType: c.bufferType,
                  resize: c.resize
                });
              }

              nb.prototype.p = function () {
                var a = this.input,
                    c,
                    b;
                c = this.A.p();
                this.c = this.A.c;
                this.M && (b = (a[this.c++] << 24 | a[this.c++] << 16 | a[this.c++] << 8 | a[this.c++]) >>> 0, b !== ba(c) && i(Error("invalid adler-32 checksum")));
                return c;
              };

              y("Zlib.Inflate", nb);
              y("Zlib.Inflate.BufferType", Ha);
              Ha.ADAPTIVE = Ha.C;
              Ha.BLOCK = Ha.D;
              y("Zlib.Inflate.prototype.decompress", nb.prototype.p);
              var tb = new (H ? Uint8Array : Array)(288),
                  Z,
                  ub;
              Z = 0;

              for (ub = tb.length; Z < ub; ++Z) {
                tb[Z] = 143 >= Z ? 8 : 255 >= Z ? 9 : 279 >= Z ? 7 : 8;
              }

              S(tb);
              var vb = new (H ? Uint8Array : Array)(30),
                  wb,
                  xb;
              wb = 0;

              for (xb = vb.length; wb < xb; ++wb) {
                vb[wb] = 5;
              }

              S(vb);
              var Ea = 8;
            }).call(window$1);
            var _p = window$1.Zlib;
            _p.Deflate = _p["Deflate"];
            _p.Deflate.compress = _p.Deflate["compress"];
            _p.Inflate = _p["Inflate"];
            _p.Inflate.BufferType = _p.Inflate["BufferType"];
            _p.Inflate.prototype.decompress = _p.Inflate.prototype["decompress"];

            var PNGReader = function () {
              function PNGReader(data) {
                var _this = this;

                this.pos = 8;
                this.palette = [];
                this.imgData = [];
                this.text = {};
                this.width = 0;
                this.height = 0;
                this.bits = 0;
                this.colorType = 0;
                this.compressionMethod = 0;
                this.filterMethod = 0;
                this.interlaceMethod = 0;
                this.colors = 0;
                this.hasAlphaChannel = false;
                this.pixelBitlength = 0;
                this.data = data;
                this.transparency = {
                  indexed: [],
                  rgb: 0,
                  grayscale: 0
                };
                var frame;
                var i = 0;
                var _i = 0;
                var _j = 0;
                var chunkSize = 0;

                while (true) {
                  chunkSize = this.readUInt32();

                  var section = function () {
                    var _results = [];

                    for (i = _i = 0; _i < 4; i = ++_i) {
                      _results.push(String.fromCharCode(_this.data[_this.pos++]));
                    }

                    return _results;
                  }.call(this).join('');

                  switch (section) {
                    case 'IHDR':
                      this.width = this.readUInt32();
                      this.height = this.readUInt32();
                      this.bits = this.data[this.pos++];
                      this.colorType = this.data[this.pos++];
                      this.compressionMethod = this.data[this.pos++];
                      this.filterMethod = this.data[this.pos++];
                      this.interlaceMethod = this.data[this.pos++];
                      break;

                    case 'acTL':
                      this.animation = {
                        numFrames: this.readUInt32(),
                        numPlays: this.readUInt32() || Infinity,
                        frames: []
                      };
                      break;

                    case 'PLTE':
                      this.palette = this.read(chunkSize);
                      break;

                    case 'fcTL':
                      if (frame) {
                        this.animation.frames.push(frame);
                      }

                      this.pos += 4;
                      frame = {
                        width: this.readUInt32(),
                        height: this.readUInt32(),
                        xOffset: this.readUInt32(),
                        yOffset: this.readUInt32()
                      };
                      var delayNum = this.readUInt16();
                      var delayDen = this.readUInt16() || 100;
                      frame.delay = 1000 * delayNum / delayDen;
                      frame.disposeOp = this.data[this.pos++];
                      frame.blendOp = this.data[this.pos++];
                      frame.data = [];
                      break;

                    case 'IDAT':
                    case 'fdAT':
                      if (section === 'fdAT') {
                        this.pos += 4;
                        chunkSize -= 4;
                      }

                      data = (frame != null ? frame.data : void 0) || this.imgData;

                      for (i = _i = 0; chunkSize >= 0 ? _i < chunkSize : _i > chunkSize; i = chunkSize >= 0 ? ++_i : --_i) {
                        data.push(this.data[this.pos++]);
                      }

                      break;

                    case 'tRNS':
                      this.transparency = {};

                      switch (this.colorType) {
                        case 3:
                          this.transparency.indexed = this.read(chunkSize);
                          var ccshort = 255 - this.transparency.indexed.length;

                          if (ccshort > 0) {
                            for (i = _j = 0; ccshort >= 0 ? _j < ccshort : _j > ccshort; i = ccshort >= 0 ? ++_j : --_j) {
                              this.transparency.indexed.push(255);
                            }
                          }

                          break;

                        case 0:
                          this.transparency.grayscale = this.read(chunkSize)[0];
                          break;

                        case 2:
                          this.transparency.rgb = this.read(chunkSize);
                      }

                      break;

                    case 'tEXt':
                      var text = this.read(chunkSize);
                      var index = text.indexOf(0);
                      var key = String.fromCharCode.apply(String, text.slice(0, index));
                      this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
                      break;

                    case 'IEND':
                      if (frame) {
                        this.animation.frames.push(frame);
                      }

                      this.colors = function () {
                        switch (_this.colorType) {
                          case 0:
                          case 3:
                          case 4:
                            return 1;

                          case 2:
                          case 6:
                            return 3;
                        }
                      }.call(this);

                      var _ref = this.colorType;
                      this.hasAlphaChannel = _ref === 4 || _ref === 6;
                      var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
                      this.pixelBitlength = this.bits * colors;

                      this.colorSpace = function () {
                        switch (_this.colors) {
                          case 1:
                            return 'DeviceGray';

                          case 3:
                            return 'DeviceRGB';
                        }
                      }.call(this);

                      if (!(this.imgData instanceof Uint8Array)) {
                        this.imgData = new Uint8Array(this.imgData);
                      }

                      return;

                    default:
                      this.pos += chunkSize;
                  }

                  this.pos += 4;

                  if (this.pos > this.data.length) {
                    throw new Error(getError(6017));
                  }
                }
              }

              var _proto = PNGReader.prototype;

              _proto.read = function read(bytes) {
                var i = 0;
                var _i = 0;
                var _results = [];

                for (i = _i = 0; bytes >= 0 ? _i < bytes : _i > bytes; i = bytes >= 0 ? ++_i : --_i) {
                  _results.push(this.data[this.pos++]);
                }

                return _results;
              };

              _proto.readUInt32 = function readUInt32() {
                var b1 = this.data[this.pos++] << 24;
                var b2 = this.data[this.pos++] << 16;
                var b3 = this.data[this.pos++] << 8;
                var b4 = this.data[this.pos++];
                return b1 | b2 | b3 | b4;
              };

              _proto.readUInt16 = function readUInt16() {
                var b1 = this.data[this.pos++] << 8;
                var b2 = this.data[this.pos++];
                return b1 | b2;
              };

              _proto.decodePixels = function decodePixels(data) {
                if (data == null) {
                  data = this.imgData;
                }

                if (data.length === 0) {
                  return new Uint8Array(0);
                }

                var inflate = new _p.Inflate(data, {
                  index: 0,
                  verify: false
                });
                data = inflate.decompress();
                var pixelBytes = this.pixelBitlength / 8;
                var scanlineLength = pixelBytes * this.width;
                var pixels = new Uint8Array(scanlineLength * this.height);
                var length = data.length;
                var row = 0;
                var pos = 0;
                var c = 0;
                var ccbyte = 0;
                var col = 0;
                var i = 0;
                var _i = 0;
                var _j = 0;
                var _k = 0;
                var _l = 0;
                var _m = 0;
                var left = 0;
                var p = 0;
                var pa = 0;
                var paeth = 0;
                var pb = 0;
                var pc = 0;
                var upper = 0;
                var upperLeft = 0;

                while (pos < length) {
                  switch (data[pos++]) {
                    case 0:
                      for (i = _i = 0; _i < scanlineLength; i = _i += 1) {
                        pixels[c++] = data[pos++];
                      }

                      break;

                    case 1:
                      for (i = _j = 0; _j < scanlineLength; i = _j += 1) {
                        ccbyte = data[pos++];
                        left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                        pixels[c++] = (ccbyte + left) % 256;
                      }

                      break;

                    case 2:
                      for (i = _k = 0; _k < scanlineLength; i = _k += 1) {
                        ccbyte = data[pos++];
                        col = (i - i % pixelBytes) / pixelBytes;
                        upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                        pixels[c++] = (upper + ccbyte) % 256;
                      }

                      break;

                    case 3:
                      for (i = _l = 0; _l < scanlineLength; i = _l += 1) {
                        ccbyte = data[pos++];
                        col = (i - i % pixelBytes) / pixelBytes;
                        left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                        upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                        pixels[c++] = (ccbyte + Math.floor((left + upper) / 2)) % 256;
                      }

                      break;

                    case 4:
                      for (i = _m = 0; _m < scanlineLength; i = _m += 1) {
                        ccbyte = data[pos++];
                        col = (i - i % pixelBytes) / pixelBytes;
                        left = i < pixelBytes ? 0 : pixels[c - pixelBytes];

                        if (row === 0) {
                          upper = upperLeft = 0;
                        } else {
                          upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                          upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];
                        }

                        p = left + upper - upperLeft;
                        pa = Math.abs(p - left);
                        pb = Math.abs(p - upper);
                        pc = Math.abs(p - upperLeft);

                        if (pa <= pb && pa <= pc) {
                          paeth = left;
                        } else if (pb <= pc) {
                          paeth = upper;
                        } else {
                          paeth = upperLeft;
                        }

                        pixels[c++] = (ccbyte + paeth) % 256;
                      }

                      break;

                    default:
                      throw new Error(getError(6018, data[pos - 1]));
                  }

                  row++;
                }

                return pixels;
              };

              _proto.copyToImageData = function copyToImageData(imageData, pixels) {
                var alpha = this.hasAlphaChannel;
                var palette;
                var colors = this.colors;

                if (this.palette.length) {
                  palette = this._decodedPalette != null ? this._decodedPalette : this._decodedPalette = this.decodePalette();
                  colors = 4;
                  alpha = true;
                }

                var data = imageData.data || imageData;
                var length = data.length;
                var input = palette || pixels;
                var i = 0;
                var j = 0;
                var k = 0;
                var v = 0;

                if (colors === 1) {
                  while (i < length) {
                    k = palette ? pixels[i / 4] * 4 : j;
                    v = input[k++];
                    data[i++] = v;
                    data[i++] = v;
                    data[i++] = v;
                    data[i++] = alpha ? input[k++] : 255;
                    j = k;
                  }
                } else {
                  while (i < length) {
                    k = palette ? pixels[i / 4] * 4 : j;
                    data[i++] = input[k++];
                    data[i++] = input[k++];
                    data[i++] = input[k++];
                    data[i++] = alpha ? input[k++] : 255;
                    j = k;
                  }
                }
              };

              _proto.decodePalette = function decodePalette() {
                var palette = this.palette;
                var transparency = this.transparency.indexed || [];
                var ret = new Uint8Array((transparency.length || 0) + palette.length);
                var pos = 0;
                var c = 0;
                var _ref1 = 0;

                for (var i = 0, _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {
                  ret[pos++] = palette[i];
                  ret[pos++] = palette[i + 1];
                  ret[pos++] = palette[i + 2];
                  _ref1 = transparency[c++];
                  ret[pos++] = _ref1 != null ? _ref1 : 255;
                }

                return ret;
              };

              _proto.render = function render(canvas) {
                canvas.width = this.width;
                canvas.height = this.height;
                var ctx = canvas.getContext('2d');
                var data = ctx.createImageData(this.width, this.height);
                this.copyToImageData(data, this.decodePixels(null));
                return ctx.putImageData(data, 0, 0);
              };

              return PNGReader;
            }();

            var TiffReader = function () {
              function TiffReader() {
                this._littleEndian = false;
                this._tiffData = [];
                this._fileDirectories = [];
              }

              var _proto = TiffReader.prototype;

              _proto.getUint8 = function getUint8(offset) {
                return this._tiffData[offset];
              };

              _proto.getUint16 = function getUint16(offset) {
                if (this._littleEndian) return this._tiffData[offset + 1] << 8 | this._tiffData[offset];else return this._tiffData[offset] << 8 | this._tiffData[offset + 1];
              };

              _proto.getUint32 = function getUint32(offset) {
                var a = this._tiffData;
                if (this._littleEndian) return a[offset + 3] << 24 | a[offset + 2] << 16 | a[offset + 1] << 8 | a[offset];else return a[offset] << 24 | a[offset + 1] << 16 | a[offset + 2] << 8 | a[offset + 3];
              };

              _proto.checkLittleEndian = function checkLittleEndian() {
                var BOM = this.getUint16(0);

                if (BOM === 0x4949) {
                  this._littleEndian = true;
                } else if (BOM === 0x4D4D) {
                  this._littleEndian = false;
                } else {
                  console.log(BOM);
                  throw TypeError(getError(6019));
                }

                return this._littleEndian;
              };

              _proto.hasTowel = function hasTowel() {
                if (this.getUint16(2) !== 42) {
                  throw RangeError(getError(6020));
                }

                return true;
              };

              _proto.getFieldTypeName = function getFieldTypeName(fieldType) {
                var typeNames = fieldTypeNames;

                if (fieldType in typeNames) {
                  return typeNames[fieldType];
                }

                return null;
              };

              _proto.getFieldTagName = function getFieldTagName(fieldTag) {
                var tagNames = fieldTagNames;

                if (fieldTag in tagNames) {
                  return tagNames[fieldTag];
                } else {
                  logID(6021, fieldTag);
                  return "Tag" + fieldTag;
                }
              };

              _proto.getFieldTypeLength = function getFieldTypeLength(fieldTypeName) {
                if (['BYTE', 'ASCII', 'SBYTE', 'UNDEFINED'].indexOf(fieldTypeName) !== -1) {
                  return 1;
                } else if (['SHORT', 'SSHORT'].indexOf(fieldTypeName) !== -1) {
                  return 2;
                } else if (['LONG', 'SLONG', 'FLOAT'].indexOf(fieldTypeName) !== -1) {
                  return 4;
                } else if (['RATIONAL', 'SRATIONAL', 'DOUBLE'].indexOf(fieldTypeName) !== -1) {
                  return 8;
                }

                return 0;
              };

              _proto.getFieldValues = function getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset) {
                var fieldValues = [];
                var fieldTypeLength = this.getFieldTypeLength(fieldTypeName);
                var fieldValueSize = fieldTypeLength * typeCount;

                if (fieldValueSize <= 4) {
                  if (this._littleEndian === false) fieldValues.push(valueOffset >>> (4 - fieldTypeLength) * 8);else fieldValues.push(valueOffset);
                } else {
                  for (var i = 0; i < typeCount; i++) {
                    var indexOffset = fieldTypeLength * i;

                    if (fieldTypeLength >= 8) {
                      if (['RATIONAL', 'SRATIONAL'].indexOf(fieldTypeName) !== -1) {
                        fieldValues.push(this.getUint32(valueOffset + indexOffset));
                        fieldValues.push(this.getUint32(valueOffset + indexOffset + 4));
                      } else {
                        logID(8000);
                      }
                    } else {
                      fieldValues.push(this.getBytes(fieldTypeLength, valueOffset + indexOffset));
                    }
                  }
                }

                if (fieldTypeName === 'ASCII') {
                  fieldValues.forEach(function (e, i, a) {
                    a[i] = String.fromCharCode(e);
                  });
                }

                return fieldValues;
              };

              _proto.getBytes = function getBytes(numBytes, offset) {
                if (numBytes <= 0) {
                  logID(8001);
                } else if (numBytes <= 1) {
                  return this.getUint8(offset);
                } else if (numBytes <= 2) {
                  return this.getUint16(offset);
                } else if (numBytes <= 3) {
                  return this.getUint32(offset) >>> 8;
                } else if (numBytes <= 4) {
                  return this.getUint32(offset);
                } else {
                  logID(8002);
                }

                return 0;
              };

              _proto.getBits = function getBits(numBits, byteOffset, bitOffset) {
                bitOffset = bitOffset || 0;
                var extraBytes = Math.floor(bitOffset / 8);
                var newByteOffset = byteOffset + extraBytes;
                var totalBits = bitOffset + numBits;
                var shiftRight = 32 - numBits;
                var shiftLeft = 0;
                var rawBits = 0;

                if (totalBits <= 0) {
                  logID(6023);
                } else if (totalBits <= 8) {
                  shiftLeft = 24 + bitOffset;
                  rawBits = this.getUint8(newByteOffset);
                } else if (totalBits <= 16) {
                  shiftLeft = 16 + bitOffset;
                  rawBits = this.getUint16(newByteOffset);
                } else if (totalBits <= 32) {
                  shiftLeft = bitOffset;
                  rawBits = this.getUint32(newByteOffset);
                } else {
                  logID(6022);
                }

                return {
                  bits: rawBits << shiftLeft >>> shiftRight,
                  byteOffset: newByteOffset + Math.floor(totalBits / 8),
                  bitOffset: totalBits % 8
                };
              };

              _proto.parseFileDirectory = function parseFileDirectory(offset) {
                var numDirEntries = this.getUint16(offset);
                var tiffFields = [];
                var i = 0;
                var entryCount = 0;

                for (i = offset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, entryCount++) {
                  var fieldTag = this.getUint16(i);
                  var fieldType = this.getUint16(i + 2);
                  var typeCount = this.getUint32(i + 4);
                  var valueOffset = this.getUint32(i + 8);
                  var fieldTagName = this.getFieldTagName(fieldTag);
                  var fieldTypeName = this.getFieldTypeName(fieldType);
                  var fieldValues = this.getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);
                  tiffFields[fieldTagName] = {
                    type: fieldTypeName,
                    values: fieldValues
                  };
                }

                this._fileDirectories.push(tiffFields);

                var nextIFDByteOffset = this.getUint32(i);

                if (nextIFDByteOffset !== 0x00000000) {
                  this.parseFileDirectory(nextIFDByteOffset);
                }
              };

              _proto.clampColorSample = function clampColorSample(colorSample, bitsPerSample) {
                var multiplier = Math.pow(2, 8 - bitsPerSample);
                return Math.floor(colorSample * multiplier + (multiplier - 1));
              };

              _proto.parseTIFF = function parseTIFF(tiffData, canvas) {
                var _this = this;

                canvas = canvas || ccwindow.document.createElement('canvas');
                this._tiffData = tiffData;
                this._canvas = canvas;
                this.checkLittleEndian();

                if (!this.hasTowel()) {
                  return;
                }

                var firstIFDByteOffset = this.getUint32(4);
                this._fileDirectories.length = 0;
                this.parseFileDirectory(firstIFDByteOffset);
                var fileDirectory = this._fileDirectories[0];
                var imageWidth = fileDirectory.ImageWidth.values[0];
                var imageLength = fileDirectory.ImageLength.values[0];
                this._canvas.width = imageWidth;
                this._canvas.height = imageLength;
                var strips = [];
                var compression = fileDirectory.Compression ? fileDirectory.Compression.values[0] : 1;
                var samplesPerPixel = fileDirectory.SamplesPerPixel.values[0];
                var sampleProperties = [];
                var bitsPerPixel = 0;
                var hasBytesPerPixel = false;
                fileDirectory.BitsPerSample.values.forEach(function (bitsPerSample, i, bitsPerSampleValues) {
                  sampleProperties[i] = {
                    bitsPerSample: bitsPerSample,
                    hasBytesPerSample: false,
                    bytesPerSample: undefined
                  };

                  if (bitsPerSample % 8 === 0) {
                    sampleProperties[i].hasBytesPerSample = true;
                    sampleProperties[i].bytesPerSample = bitsPerSample / 8;
                  }

                  bitsPerPixel += bitsPerSample;
                }, this);
                var bytesPerPixel = 0;

                if (bitsPerPixel % 8 === 0) {
                  hasBytesPerPixel = true;
                  bytesPerPixel = bitsPerPixel / 8;
                }

                var stripOffsetValues = fileDirectory.StripOffsets.values;
                var numStripOffsetValues = stripOffsetValues.length;
                var stripByteCountValues;

                if (fileDirectory.StripByteCounts) {
                  stripByteCountValues = fileDirectory.StripByteCounts.values;
                } else {
                  logID(8003);

                  if (numStripOffsetValues === 1) {
                    stripByteCountValues = [Math.ceil(imageWidth * imageLength * bitsPerPixel / 8)];
                  } else {
                    throw Error(getError(6024));
                  }
                }

                var blockLength = 1;
                var iterations = 1;

                for (var i = 0; i < numStripOffsetValues; i++) {
                  var stripOffset = stripOffsetValues[i];
                  strips[i] = [];
                  var stripByteCount = stripByteCountValues[i];

                  for (var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {
                    switch (compression) {
                      case 1:
                        pixel = [];

                        for (var m = 0; m < samplesPerPixel; m++) {
                          var s = sampleProperties[m];

                          if (s.hasBytesPerSample) {
                            var sampleOffset = s.bytesPerSample * m;
                            pixel.push(this.getBytes(s.bytesPerSample, stripOffset + byteOffset + sampleOffset));
                          } else {
                            var sampleInfo = this.getBits(s.bitsPerSample, stripOffset + byteOffset, bitOffset);
                            pixel.push(sampleInfo.bits);
                            byteOffset = sampleInfo.byteOffset - stripOffset;
                            bitOffset = sampleInfo.bitOffset;
                            throw RangeError(getError(6025));
                          }
                        }

                        strips[i].push(pixel);

                        if (hasBytesPerPixel) {
                          jIncrement = bytesPerPixel;
                        } else {
                          jIncrement = 0;
                          throw RangeError(getError(6026));
                        }

                        break;

                      case 2:
                        break;

                      case 3:
                        break;

                      case 4:
                        break;

                      case 5:
                        break;

                      case 6:
                        break;

                      case 7:
                        break;

                      case 32773:
                        if (getHeader) {
                          getHeader = false;
                          var header = this.getUint8(stripOffset + byteOffset);

                          if (header >= 0 && header <= 127) {
                            blockLength = header + 1;
                          } else if (header >= -127 && header <= -1) {
                            iterations = -header + 1;
                          } else {
                              getHeader = true;
                            }
                        } else {
                          var currentByte = this.getUint8(stripOffset + byteOffset);

                          for (var _m = 0; _m < iterations; _m++) {
                            var _s = sampleProperties[sample];

                            if (_s.hasBytesPerSample) {
                              currentSample = currentSample << 8 * numBytes | currentByte;
                              numBytes++;

                              if (numBytes === _s.bytesPerSample) {
                                pixel.push(currentSample);
                                currentSample = numBytes = 0;
                                sample++;
                              }
                            } else {
                              throw RangeError(getError(6025));
                            }

                            if (sample === samplesPerPixel) {
                              strips[i].push(pixel);
                              pixel = [];
                              sample = 0;
                            }
                          }

                          blockLength--;

                          if (blockLength === 0) {
                            getHeader = true;
                          }
                        }

                        jIncrement = 1;
                        break;
                    }
                  }
                }

                if (canvas.getContext) {
                  var ctx = this._canvas.getContext('2d');

                  ctx.fillStyle = 'rgba(255, 255, 255, 0)';
                  var rowsPerStrip = fileDirectory.RowsPerStrip ? fileDirectory.RowsPerStrip.values[0] : imageLength;
                  var numStrips = strips.length;
                  var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;
                  var rowsInLastStrip = imageLengthModRowsPerStrip === 0 ? rowsPerStrip : imageLengthModRowsPerStrip;
                  var numRowsInStrip = rowsPerStrip;
                  var numRowsInPreviousStrip = 0;
                  var photometricInterpretation = fileDirectory.PhotometricInterpretation.values[0];
                  var extraSamplesValues = [];
                  var numExtraSamples = 0;

                  if (fileDirectory.ExtraSamples) {
                    extraSamplesValues = fileDirectory.ExtraSamples.values;
                    numExtraSamples = extraSamplesValues.length;
                  }

                  var colorMapValues = [];
                  var colorMapSampleSize = 0;

                  if (fileDirectory.ColorMap) {
                    colorMapValues = fileDirectory.ColorMap.values;
                    colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);
                  }

                  for (var _i = 0; _i < numStrips; _i++) {
                    if (_i + 1 === numStrips) {
                      numRowsInStrip = rowsInLastStrip;
                    }

                    var numPixels = strips[_i].length;
                    var yPadding = numRowsInPreviousStrip * _i;

                    for (var y = 0, j = 0; y < numRowsInStrip && j < numPixels; y++) {
                      for (var x = 0; x < imageWidth; x++, j++) {
                        var pixelSamples = strips[_i][j];
                        var red = 0;
                        var green = 0;
                        var blue = 0;
                        var opacity = 1.0;

                        if (numExtraSamples > 0) {
                          for (var k = 0; k < numExtraSamples; k++) {
                            if (extraSamplesValues[k] === 1 || extraSamplesValues[k] === 2) {
                              opacity = pixelSamples[3 + k] / 256;
                              break;
                            }
                          }
                        }

                        (function () {
                          switch (photometricInterpretation) {
                            case 0:
                              var invertValue = 0;

                              if (sampleProperties[0].hasBytesPerSample) {
                                invertValue = Math.pow(0x10, sampleProperties[0].bytesPerSample * 2);
                              }

                              pixelSamples.forEach(function (sample, index, samples) {
                                samples[index] = invertValue - sample;
                              });

                            case 1:
                              red = green = blue = _this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                              break;

                            case 2:
                              red = _this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                              green = _this.clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);
                              blue = _this.clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);
                              break;

                            case 3:
                              if (colorMapValues === undefined) {
                                throw Error(getError(6027));
                              }

                              var colorMapIndex = pixelSamples[0];
                              red = _this.clampColorSample(colorMapValues[colorMapIndex], 16);
                              green = _this.clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);
                              blue = _this.clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);
                              break;

                            default:
                              throw RangeError(getError(6028, photometricInterpretation));
                          }
                        })();

                        ctx.fillStyle = "rgba(" + red + ", " + green + ", " + blue + ", " + opacity + ")";
                        ctx.fillRect(x, yPadding + y, 1, 1);
                      }
                    }

                    numRowsInPreviousStrip = numRowsInStrip;
                  }
                }

                return this._canvas;
              };

              return TiffReader;
            }();
            var fieldTagNames = {
              0x013B: 'Artist',
              0x0102: 'BitsPerSample',
              0x0109: 'CellLength',
              0x0108: 'CellWidth',
              0x0140: 'ColorMap',
              0x0103: 'Compression',
              0x8298: 'Copyright',
              0x0132: 'DateTime',
              0x0152: 'ExtraSamples',
              0x010A: 'FillOrder',
              0x0121: 'FreeByteCounts',
              0x0120: 'FreeOffsets',
              0x0123: 'GrayResponseCurve',
              0x0122: 'GrayResponseUnit',
              0x013C: 'HostComputer',
              0x010E: 'ImageDescription',
              0x0101: 'ImageLength',
              0x0100: 'ImageWidth',
              0x010F: 'Make',
              0x0119: 'MaxSampleValue',
              0x0118: 'MinSampleValue',
              0x0110: 'Model',
              0x00FE: 'NewSubfileType',
              0x0112: 'Orientation',
              0x0106: 'PhotometricInterpretation',
              0x011C: 'PlanarConfiguration',
              0x0128: 'ResolutionUnit',
              0x0116: 'RowsPerStrip',
              0x0115: 'SamplesPerPixel',
              0x0131: 'Software',
              0x0117: 'StripByteCounts',
              0x0111: 'StripOffsets',
              0x00FF: 'SubfileType',
              0x0107: 'Threshholding',
              0x011A: 'XResolution',
              0x011B: 'YResolution',
              0x0146: 'BadFaxLines',
              0x0147: 'CleanFaxData',
              0x0157: 'ClipPath',
              0x0148: 'ConsecutiveBadFaxLines',
              0x01B1: 'Decode',
              0x01B2: 'DefaultImageColor',
              0x010D: 'DocumentName',
              0x0150: 'DotRange',
              0x0141: 'HalftoneHints',
              0x015A: 'Indexed',
              0x015B: 'JPEGTables',
              0x011D: 'PageName',
              0x0129: 'PageNumber',
              0x013D: 'Predictor',
              0x013F: 'PrimaryChromaticities',
              0x0214: 'ReferenceBlackWhite',
              0x0153: 'SampleFormat',
              0x022F: 'StripRowCounts',
              0x014A: 'SubIFDs',
              0x0124: 'T4Options',
              0x0125: 'T6Options',
              0x0145: 'TileByteCounts',
              0x0143: 'TileLength',
              0x0144: 'TileOffsets',
              0x0142: 'TileWidth',
              0x012D: 'TransferFunction',
              0x013E: 'WhitePoint',
              0x0158: 'XClipPathUnits',
              0x011E: 'XPosition',
              0x0211: 'YCbCrCoefficients',
              0x0213: 'YCbCrPositioning',
              0x0212: 'YCbCrSubSampling',
              0x0159: 'YClipPathUnits',
              0x011F: 'YPosition',
              0x9202: 'ApertureValue',
              0xA001: 'ColorSpace',
              0x9004: 'DateTimeDigitized',
              0x9003: 'DateTimeOriginal',
              0x8769: 'Exif IFD',
              0x9000: 'ExifVersion',
              0x829A: 'ExposureTime',
              0xA300: 'FileSource',
              0x9209: 'Flash',
              0xA000: 'FlashpixVersion',
              0x829D: 'FNumber',
              0xA420: 'ImageUniqueID',
              0x9208: 'LightSource',
              0x927C: 'MakerNote',
              0x9201: 'ShutterSpeedValue',
              0x9286: 'UserComment',
              0x83BB: 'IPTC',
              0x8773: 'ICC Profile',
              0x02BC: 'XMP',
              0xA480: 'GDAL_METADATA',
              0xA481: 'GDAL_NODATA',
              0x8649: 'Photoshop'
            };
            var fieldTypeNames = {
              0x0001: 'BYTE',
              0x0002: 'ASCII',
              0x0003: 'SHORT',
              0x0004: 'LONG',
              0x0005: 'RATIONAL',
              0x0006: 'SBYTE',
              0x0007: 'UNDEFINED',
              0x0008: 'SSHORT',
              0x0009: 'SLONG',
              0x000A: 'SRATIONAL',
              0x000B: 'FLOAT',
              0x000C: 'DOUBLE'
            };

            var BASE64_KEYS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            var BASE64_VALUES = new Array(123);

            for (var i$2 = 0; i$2 < 123; ++i$2) {
              BASE64_VALUES[i$2] = 64;
            }

            for (var _i = 0; _i < 64; ++_i) {
              BASE64_VALUES[BASE64_KEYS.charCodeAt(_i)] = _i;
            }

            var Base64 = {
              name: 'Jacob__Codec__Base64'
            };

            Base64.decode = function Jacob__Codec__Base64__decode(input) {
              var output = [],
                  chr1,
                  chr2,
                  chr3,
                  enc1,
                  enc2,
                  enc3,
                  enc4,
                  i = 0;
              input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

              while (i < input.length) {
                enc1 = BASE64_VALUES[input.charCodeAt(i++)];
                enc2 = BASE64_VALUES[input.charCodeAt(i++)];
                enc3 = BASE64_VALUES[input.charCodeAt(i++)];
                enc4 = BASE64_VALUES[input.charCodeAt(i++)];
                chr1 = enc1 << 2 | enc2 >> 4;
                chr2 = (enc2 & 15) << 4 | enc3 >> 2;
                chr3 = (enc3 & 3) << 6 | enc4;
                output.push(String.fromCharCode(chr1));

                if (enc3 !== 64) {
                  output.push(String.fromCharCode(chr2));
                }

                if (enc4 !== 64) {
                  output.push(String.fromCharCode(chr3));
                }
              }

              output = output.join('');
              return output;
            };

            Base64.decodeAsArray = function Jacob__Codec__Base64___decodeAsArray(input, bytes) {
              var dec = this.decode(input),
                  ar = [],
                  i,
                  j,
                  len;

              for (i = 0, len = dec.length / bytes; i < len; i++) {
                ar[i] = 0;

                for (j = bytes - 1; j >= 0; --j) {
                  ar[i] += dec.charCodeAt(i * bytes + j) << j * 8;
                }
              }

              return ar;
            };

            var GZip = function Jacob__GZip(data) {
              this.data = data;
              this.debug = false;
              this.gpflags = undefined;
              this.files = 0;
              this.unzipped = [];
              this.buf32k = new Array(32768);
              this.bIdx = 0;
              this.modeZIP = false;
              this.bytepos = 0;
              this.bb = 1;
              this.bits = 0;
              this.nameBuf = [];
              this.fileout = undefined;
              this.literalTree = new Array(GZip.LITERALS);
              this.distanceTree = new Array(32);
              this.treepos = 0;
              this.Places = null;
              this.len = 0;
              this.fpos = new Array(17);
              this.fpos[0] = 0;
              this.flens = undefined;
              this.fmax = undefined;
            };

            GZip.gunzip = function (string) {
              if (string.constructor === Array) ; else if (string.constructor === String) ;

              var gzip = new GZip(string);
              return gzip.gunzip()[0][0];
            };

            GZip.HufNode = function () {
              this.b0 = 0;
              this.b1 = 0;
              this.jump = null;
              this.jumppos = -1;
            };

            GZip.LITERALS = 288;
            GZip.NAMEMAX = 256;
            GZip.bitReverse = [0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff];
            GZip.cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
            GZip.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99];
            GZip.cpdist = [0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001];
            GZip.cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
            GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

            GZip.prototype.gunzip = function () {
              this.outputArr = [];
              this.nextFile();
              return this.unzipped;
            };

            GZip.prototype.readByte = function () {
              this.bits += 8;

              if (this.bytepos < this.data.length) {
                return this.data.charCodeAt(this.bytepos++);
              } else {
                return -1;
              }
            };

            GZip.prototype.byteAlign = function () {
              this.bb = 1;
            };

            GZip.prototype.readBit = function () {
              var carry;
              this.bits++;
              carry = this.bb & 1;
              this.bb >>= 1;

              if (this.bb === 0) {
                this.bb = this.readByte();
                carry = this.bb & 1;
                this.bb = this.bb >> 1 | 0x80;
              }

              return carry;
            };

            GZip.prototype.readBits = function (a) {
              var res = 0,
                  i = a;

              while (i--) {
                res = res << 1 | this.readBit();
              }

              if (a) res = GZip.bitReverse[res] >> 8 - a;
              return res;
            };

            GZip.prototype.flushBuffer = function () {
              this.bIdx = 0;
            };

            GZip.prototype.addBuffer = function (a) {
              this.buf32k[this.bIdx++] = a;
              this.outputArr.push(String.fromCharCode(a));
              if (this.bIdx === 0x8000) this.bIdx = 0;
            };

            GZip.prototype.IsPat = function () {
              while (1) {
                if (this.fpos[this.len] >= this.fmax) return -1;
                if (this.flens[this.fpos[this.len]] === this.len) return this.fpos[this.len]++;
                this.fpos[this.len]++;
              }
            };

            GZip.prototype.Rec = function () {
              var curplace = this.Places[this.treepos];
              var tmp;

              if (this.len === 17) {
                return -1;
              }

              this.treepos++;
              this.len++;
              tmp = this.IsPat();

              if (tmp >= 0) {
                curplace.b0 = tmp;
              } else {
                curplace.b0 = 0x8000;
                if (this.Rec()) return -1;
              }

              tmp = this.IsPat();

              if (tmp >= 0) {
                curplace.b1 = tmp;
                curplace.jump = null;
              } else {
                curplace.b1 = 0x8000;
                curplace.jump = this.Places[this.treepos];
                curplace.jumppos = this.treepos;
                if (this.Rec()) return -1;
              }

              this.len--;
              return 0;
            };

            GZip.prototype.CreateTree = function (currentTree, numval, lengths, show) {
              var i;
              this.Places = currentTree;
              this.treepos = 0;
              this.flens = lengths;
              this.fmax = numval;

              for (i = 0; i < 17; i++) {
                this.fpos[i] = 0;
              }

              this.len = 0;

              if (this.Rec()) {
                return -1;
              }

              return 0;
            };

            GZip.prototype.DecodeValue = function (currentTree) {
              var len,
                  i,
                  xtreepos = 0,
                  X = currentTree[xtreepos],
                  b;

              while (1) {
                b = this.readBit();

                if (b) {
                  if (!(X.b1 & 0x8000)) {
                    return X.b1;
                  }

                  X = X.jump;
                  len = currentTree.length;

                  for (i = 0; i < len; i++) {
                    if (currentTree[i] === X) {
                      xtreepos = i;
                      break;
                    }
                  }
                } else {
                  if (!(X.b0 & 0x8000)) {
                    return X.b0;
                  }

                  xtreepos++;
                  X = currentTree[xtreepos];
                }
              }

              return -1;
            };

            GZip.prototype.DeflateLoop = function () {
              var last, c, type, i, len;

              do {
                last = this.readBit();
                type = this.readBits(2);

                if (type === 0) {
                  var blockLen, cSum;
                  this.byteAlign();
                  blockLen = this.readByte();
                  blockLen |= this.readByte() << 8;
                  cSum = this.readByte();
                  cSum |= this.readByte() << 8;

                  if ((blockLen ^ ~cSum) & 0xffff) {
                    document.write("BlockLen checksum mismatch\n");
                  }

                  while (blockLen--) {
                    c = this.readByte();
                    this.addBuffer(c);
                  }
                } else if (type === 1) {
                  var j;

                  while (1) {
                    j = GZip.bitReverse[this.readBits(7)] >> 1;

                    if (j > 23) {
                      j = j << 1 | this.readBit();

                      if (j > 199) {
                        j -= 128;
                        j = j << 1 | this.readBit();
                      } else {
                        j -= 48;

                        if (j > 143) {
                          j = j + 136;
                        }
                      }
                    } else {
                      j += 256;
                    }

                    if (j < 256) {
                      this.addBuffer(j);
                    } else if (j === 256) {
                      break;
                    } else {
                      var len, dist;
                      j -= 256 + 1;
                      len = this.readBits(GZip.cplext[j]) + GZip.cplens[j];
                      j = GZip.bitReverse[this.readBits(5)] >> 3;

                      if (GZip.cpdext[j] > 8) {
                        dist = this.readBits(8);
                        dist |= this.readBits(GZip.cpdext[j] - 8) << 8;
                      } else {
                        dist = this.readBits(GZip.cpdext[j]);
                      }

                      dist += GZip.cpdist[j];

                      for (j = 0; j < len; j++) {
                        var c = this.buf32k[this.bIdx - dist & 0x7fff];
                        this.addBuffer(c);
                      }
                    }
                  }
                } else if (type === 2) {
                  var j, n, literalCodes, distCodes, lenCodes;
                  var ll = new Array(288 + 32);
                  literalCodes = 257 + this.readBits(5);
                  distCodes = 1 + this.readBits(5);
                  lenCodes = 4 + this.readBits(4);

                  for (j = 0; j < 19; j++) {
                    ll[j] = 0;
                  }

                  for (j = 0; j < lenCodes; j++) {
                    ll[GZip.border[j]] = this.readBits(3);
                  }

                  len = this.distanceTree.length;

                  for (i = 0; i < len; i++) {
                    this.distanceTree[i] = new GZip.HufNode();
                  }

                  if (this.CreateTree(this.distanceTree, 19, ll, 0)) {
                    this.flushBuffer();
                    return 1;
                  }

                  n = literalCodes + distCodes;
                  i = 0;

                  while (i < n) {
                    j = this.DecodeValue(this.distanceTree);

                    if (j < 16) {
                      ll[i++] = j;
                    } else if (j === 16) {
                      var l;
                      j = 3 + this.readBits(2);

                      if (i + j > n) {
                        this.flushBuffer();
                        return 1;
                      }

                      l = i ? ll[i - 1] : 0;

                      while (j--) {
                        ll[i++] = l;
                      }
                    } else {
                      if (j === 17) {
                        j = 3 + this.readBits(3);
                      } else {
                        j = 11 + this.readBits(7);
                      }

                      if (i + j > n) {
                        this.flushBuffer();
                        return 1;
                      }

                      while (j--) {
                        ll[i++] = 0;
                      }
                    }
                  }

                  len = this.literalTree.length;

                  for (i = 0; i < len; i++) {
                    this.literalTree[i] = new GZip.HufNode();
                  }

                  if (this.CreateTree(this.literalTree, literalCodes, ll, 0)) {
                    this.flushBuffer();
                    return 1;
                  }

                  len = this.literalTree.length;

                  for (i = 0; i < len; i++) {
                    this.distanceTree[i] = new GZip.HufNode();
                  }

                  var ll2 = new Array();

                  for (i = literalCodes; i < ll.length; i++) {
                    ll2[i - literalCodes] = ll[i];
                  }

                  if (this.CreateTree(this.distanceTree, distCodes, ll2, 0)) {
                    this.flushBuffer();
                    return 1;
                  }

                  while (1) {
                    j = this.DecodeValue(this.literalTree);

                    if (j >= 256) {
                      var len, dist;
                      j -= 256;

                      if (j === 0) {
                        break;
                      }

                      j--;
                      len = this.readBits(GZip.cplext[j]) + GZip.cplens[j];
                      j = this.DecodeValue(this.distanceTree);

                      if (GZip.cpdext[j] > 8) {
                        dist = this.readBits(8);
                        dist |= this.readBits(GZip.cpdext[j] - 8) << 8;
                      } else {
                        dist = this.readBits(GZip.cpdext[j]);
                      }

                      dist += GZip.cpdist[j];

                      while (len--) {
                        var c = this.buf32k[this.bIdx - dist & 0x7fff];
                        this.addBuffer(c);
                      }
                    } else {
                      this.addBuffer(j);
                    }
                  }
                }
              } while (!last);

              this.flushBuffer();
              this.byteAlign();
              return 0;
            };

            GZip.prototype.unzipFile = function (name) {
              var i;
              this.gunzip();

              for (i = 0; i < this.unzipped.length; i++) {
                if (this.unzipped[i][1] === name) {
                  return this.unzipped[i][0];
                }
              }
            };

            GZip.prototype.nextFile = function () {
              this.outputArr = [];
              this.modeZIP = false;
              var tmp = [];
              tmp[0] = this.readByte();
              tmp[1] = this.readByte();

              if (tmp[0] === 0x78 && tmp[1] === 0xda) {
                this.DeflateLoop();
                this.unzipped[this.files] = [this.outputArr.join(''), "geonext.gxt"];
                this.files++;
              }

              if (tmp[0] === 0x1f && tmp[1] === 0x8b) {
                this.skipdir();
                this.unzipped[this.files] = [this.outputArr.join(''), "file"];
                this.files++;
              }

              if (tmp[0] === 0x50 && tmp[1] === 0x4b) {
                this.modeZIP = true;
                tmp[2] = this.readByte();
                tmp[3] = this.readByte();

                if (tmp[2] === 0x03 && tmp[3] === 0x04) {
                  tmp[0] = this.readByte();
                  tmp[1] = this.readByte();
                  this.gpflags = this.readByte();
                  this.gpflags |= this.readByte() << 8;
                  var method = this.readByte();
                  method |= this.readByte() << 8;
                  this.readByte();
                  this.readByte();
                  this.readByte();
                  this.readByte();
                  var compSize = this.readByte();
                  compSize |= this.readByte() << 8;
                  compSize |= this.readByte() << 16;
                  compSize |= this.readByte() << 24;
                  var size = this.readByte();
                  size |= this.readByte() << 8;
                  size |= this.readByte() << 16;
                  size |= this.readByte() << 24;
                  var filelen = this.readByte();
                  filelen |= this.readByte() << 8;
                  var extralen = this.readByte();
                  extralen |= this.readByte() << 8;
                  i = 0;
                  this.nameBuf = [];

                  while (filelen--) {
                    var c = this.readByte();

                    if (c === "/" | c === ":") {
                      i = 0;
                    } else if (i < GZip.NAMEMAX - 1) {
                      this.nameBuf[i++] = String.fromCharCode(c);
                    }
                  }

                  if (!this.fileout) this.fileout = this.nameBuf;
                  var i = 0;

                  while (i < extralen) {
                    c = this.readByte();
                    i++;
                  }

                  if (method === 8) {
                    this.DeflateLoop();
                    this.unzipped[this.files] = [this.outputArr.join(''), this.nameBuf.join('')];
                    this.files++;
                  }

                  this.skipdir();
                }
              }
            };

            GZip.prototype.skipdir = function () {
              var tmp = [];
              var compSize, size, os, i, c;

              if (this.gpflags & 8) {
                tmp[0] = this.readByte();
                tmp[1] = this.readByte();
                tmp[2] = this.readByte();
                tmp[3] = this.readByte();
                compSize = this.readByte();
                compSize |= this.readByte() << 8;
                compSize |= this.readByte() << 16;
                compSize |= this.readByte() << 24;
                size = this.readByte();
                size |= this.readByte() << 8;
                size |= this.readByte() << 16;
                size |= this.readByte() << 24;
              }

              if (this.modeZIP) this.nextFile();
              tmp[0] = this.readByte();

              if (tmp[0] !== 8) {
                return 0;
              }

              this.gpflags = this.readByte();
              this.readByte();
              this.readByte();
              this.readByte();
              this.readByte();
              this.readByte();
              os = this.readByte();

              if (this.gpflags & 4) {
                tmp[0] = this.readByte();
                tmp[2] = this.readByte();
                this.len = tmp[0] + 256 * tmp[1];

                for (i = 0; i < this.len; i++) {
                  this.readByte();
                }
              }

              if (this.gpflags & 8) {
                i = 0;
                this.nameBuf = [];

                while (c = this.readByte()) {
                  if (c === "7" || c === ":") i = 0;
                  if (i < GZip.NAMEMAX - 1) this.nameBuf[i++] = c;
                }
              }

              if (this.gpflags & 16) {
                while (c = this.readByte()) {}
              }

              if (this.gpflags & 2) {
                this.readByte();
                this.readByte();
              }

              this.DeflateLoop();
              size = this.readByte();
              size |= this.readByte() << 8;
              size |= this.readByte() << 16;
              size |= this.readByte() << 24;
              if (this.modeZIP) this.nextFile();
            };

            var codec = {
              name: 'Jacob__Codec'
            };
            codec.Base64 = Base64;
            codec.GZip = GZip;

            codec.unzip = function () {
              return codec.GZip.gunzip.apply(codec.GZip, arguments);
            };

            codec.unzipBase64 = function () {
              var buffer = codec.Base64.decode.apply(codec.Base64, arguments);

              try {
                return codec.GZip.gunzip.call(codec.GZip, buffer);
              } catch (e) {
                return buffer.slice(7);
              }
            };

            codec.unzipBase64AsArray = function (input, bytes) {
              bytes = bytes || 1;
              var dec = this.unzipBase64(input),
                  ar = [],
                  i,
                  j,
                  len;

              for (i = 0, len = dec.length / bytes; i < len; i++) {
                ar[i] = 0;

                for (j = bytes - 1; j >= 0; --j) {
                  ar[i] += dec.charCodeAt(i * bytes + j) << j * 8;
                }
              }

              return ar;
            };

            codec.unzipAsArray = function (input, bytes) {
              bytes = bytes || 1;
              var dec = this.unzip(input),
                  ar = [],
                  i,
                  j,
                  len;

              for (i = 0, len = dec.length / bytes; i < len; i++) {
                ar[i] = 0;

                for (j = bytes - 1; j >= 0; --j) {
                  ar[i] += dec.charCodeAt(i * bytes + j) << j * 8;
                }
              }

              return ar;
            };

            var _dec$1y, _dec2$17, _dec3$O, _dec4$y, _dec5$s, _dec6$o, _class$1B, _class2$1l, _initializer$1g, _initializer2$13, _initializer3$Q, _initializer4$L, _initializer5$C, _initializer6$v, _initializer7$o, _initializer8$m, _initializer9$j, _initializer10$h, _initializer11$d, _initializer12$d, _initializer13$d, _initializer14$9, _initializer15$8, _initializer16$8, _initializer17$7, _initializer18$6, _initializer19$6, _initializer20$4, _initializer21$3, _initializer22$3, _initializer23$3, _initializer24$3, _initializer25$3, _initializer26$3, _initializer27$2, _initializer28$2, _initializer29$1, _initializer30$1, _initializer31$1, _initializer32$1, _initializer33$1, _initializer34$1, _initializer35$1, _initializer36$1, _initializer37$1, _initializer38$1, _initializer39$1, _initializer40$1, _initializer41$1, _initializer42, _initializer43, _class3$i, _temp$r;
            var ImageFormat;

            (function (ImageFormat) {
              ImageFormat[ImageFormat["JPG"] = 0] = "JPG";
              ImageFormat[ImageFormat["PNG"] = 1] = "PNG";
              ImageFormat[ImageFormat["TIFF"] = 2] = "TIFF";
              ImageFormat[ImageFormat["WEBP"] = 3] = "WEBP";
              ImageFormat[ImageFormat["PVR"] = 4] = "PVR";
              ImageFormat[ImageFormat["ETC"] = 5] = "ETC";
              ImageFormat[ImageFormat["S3TC"] = 6] = "S3TC";
              ImageFormat[ImageFormat["ATITC"] = 7] = "ATITC";
              ImageFormat[ImageFormat["TGA"] = 8] = "TGA";
              ImageFormat[ImageFormat["RAWDATA"] = 9] = "RAWDATA";
              ImageFormat[ImageFormat["UNKNOWN"] = 10] = "UNKNOWN";
            })(ImageFormat || (ImageFormat = {}));

            function getImageFormatByData(imgData) {
              if (imgData.length > 8 && imgData[0] === 0x89 && imgData[1] === 0x50 && imgData[2] === 0x4E && imgData[3] === 0x47 && imgData[4] === 0x0D && imgData[5] === 0x0A && imgData[6] === 0x1A && imgData[7] === 0x0A) {
                return ImageFormat.PNG;
              }

              if (imgData.length > 2 && (imgData[0] === 0x49 && imgData[1] === 0x49 || imgData[0] === 0x4d && imgData[1] === 0x4d || imgData[0] === 0xff && imgData[1] === 0xd8)) {
                return ImageFormat.TIFF;
              }

              return ImageFormat.UNKNOWN;
            }

            function getParticleComponents(node) {
              var parent = node.parent;
              var comp = node.getComponent(ParticleSystem2D);

              if (!parent || !comp) {
                return node.getComponentsInChildren(ParticleSystem2D);
              }

              return getParticleComponents(parent);
            }

            var ParticleSystem2D = exports('ParticleSystem2D', (_dec$1y = ccclass$p('cc.ParticleSystem2D'), _dec2$17 = type$8(ParticleAsset), _dec3$O = type$8(SpriteFrame), _dec4$y = type$8(PositionType), _dec5$s = type$8(EmitterMode), _dec6$o = formerlySerializedAs$3('preview'), _dec$1y(_class$1B = (_class2$1l = (_temp$r = _class3$i = function (_UIRenderer) {
              _inheritsLoose(ParticleSystem2D, _UIRenderer);

              function ParticleSystem2D() {
                var _this;

                _this = _UIRenderer.call(this) || this;
                _this.duration = _initializer$1g && _initializer$1g();
                _this.emissionRate = _initializer2$13 && _initializer2$13();
                _this.life = _initializer3$Q && _initializer3$Q();
                _this.lifeVar = _initializer4$L && _initializer4$L();
                _this.angle = _initializer5$C && _initializer5$C();
                _this.angleVar = _initializer6$v && _initializer6$v();
                _this.startSize = _initializer7$o && _initializer7$o();
                _this.startSizeVar = _initializer8$m && _initializer8$m();
                _this.endSize = _initializer9$j && _initializer9$j();
                _this.endSizeVar = _initializer10$h && _initializer10$h();
                _this.startSpin = _initializer11$d && _initializer11$d();
                _this.startSpinVar = _initializer12$d && _initializer12$d();
                _this.endSpin = _initializer13$d && _initializer13$d();
                _this.endSpinVar = _initializer14$9 && _initializer14$9();
                _this.sourcePos = _initializer15$8 && _initializer15$8();
                _this.posVar = _initializer16$8 && _initializer16$8();
                _this.emitterMode = _initializer17$7 && _initializer17$7();
                _this.gravity = _initializer18$6 && _initializer18$6();
                _this.speed = _initializer19$6 && _initializer19$6();
                _this.speedVar = _initializer20$4 && _initializer20$4();
                _this.tangentialAccel = _initializer21$3 && _initializer21$3();
                _this.tangentialAccelVar = _initializer22$3 && _initializer22$3();
                _this.radialAccel = _initializer23$3 && _initializer23$3();
                _this.radialAccelVar = _initializer24$3 && _initializer24$3();
                _this.rotationIsDir = _initializer25$3 && _initializer25$3();
                _this.startRadius = _initializer26$3 && _initializer26$3();
                _this.startRadiusVar = _initializer27$2 && _initializer27$2();
                _this.endRadius = _initializer28$2 && _initializer28$2();
                _this.endRadiusVar = _initializer29$1 && _initializer29$1();
                _this.rotatePerS = _initializer30$1 && _initializer30$1();
                _this.rotatePerSVar = _initializer31$1 && _initializer31$1();
                _this.aspectRatio = 1;
                _this.playOnLoad = _initializer32$1 && _initializer32$1();
                _this.autoRemoveOnFinish = _initializer33$1 && _initializer33$1();
                _this._preview = _initializer34$1 && _initializer34$1();
                _this._custom = _initializer35$1 && _initializer35$1();
                _this._file = _initializer36$1 && _initializer36$1();
                _this._spriteFrame = _initializer37$1 && _initializer37$1();
                _this._totalParticles = _initializer38$1 && _initializer38$1();
                _this._startColor = _initializer39$1 && _initializer39$1();
                _this._startColorVar = _initializer40$1 && _initializer40$1();
                _this._endColor = _initializer41$1 && _initializer41$1();
                _this._endColorVar = _initializer42 && _initializer42();
                _this._positionType = _initializer43 && _initializer43();
                _this._stopped = true;
                _this._useFile = void 0;

                _this.initProperties();

                _this._useFile = false;
                return _this;
              }

              var _proto = ParticleSystem2D.prototype;

              _proto.onEnable = function onEnable() {
                _UIRenderer.prototype.onEnable.call(this);

                this._updateMaterial();

                this._updatePositionType();
              };

              _proto.onDestroy = function onDestroy() {
                _UIRenderer.prototype.onDestroy.call(this);

                if (this.autoRemoveOnFinish) {
                  this.autoRemoveOnFinish = false;
                }

                this._simulator.uvFilled = 0;

                if (this._simulator.renderData && this._assembler) {
                  this._assembler.removeData(this._simulator.renderData);
                }
              };

              _proto.initProperties = function initProperties() {
                this._previewTimer = null;
                this._focused = false;
                this.aspectRatio = 1;
                this._simulator = new Simulator(this);
              };

              _proto.onFocusInEditor = function onFocusInEditor() {
                this._focused = true;
                var components = getParticleComponents(this.node);

                for (var i = 0; i < components.length; ++i) {
                  components[i]._startPreview();
                }
              };

              _proto.onLostFocusInEditor = function onLostFocusInEditor() {
                this._focused = false;
                var components = getParticleComponents(this.node);

                for (var i = 0; i < components.length; ++i) {
                  components[i]._stopPreview();
                }
              };

              _proto._startPreview = function _startPreview() {
                if (this._preview) {
                  this.resetSystem();
                }
              };

              _proto._stopPreview = function _stopPreview() {
                if (this._preview) {
                  this.resetSystem();
                  this.stopSystem();
                }

                if (this._previewTimer) {
                  clearInterval(this._previewTimer);
                }
              };

              _proto.__preload = function __preload() {
                _UIRenderer.prototype.__preload.call(this);

                if (this._custom && this.spriteFrame && !this._renderSpriteFrame) {
                  this._applySpriteFrame();
                } else if (this._file) {
                  if (this._custom) {
                    var missCustomTexture = !this._getTexture();

                    if (missCustomTexture) {
                      this._applyFile();
                    }
                  } else {
                    this._applyFile();
                  }
                }

                {
                  if (this.playOnLoad) {
                    this.resetSystem();
                  }
                }
              };

              _proto._flushAssembler = function _flushAssembler() {
                var assembler = ParticleSystem2D.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this._assembler = assembler;
                }

                if (this._assembler && this._assembler.createData) {
                  this._simulator.renderData = this._assembler.createData(this);

                  this._simulator.renderData.particleInitRenderDrawInfo(this.renderEntity);

                  this._simulator.initDrawInfo();
                }
              };

              _proto.lateUpdate = function lateUpdate(dt) {
                if (!this._simulator.finished) {
                  this._simulator.step(dt);
                }
              };

              _proto.addParticle = function addParticle() {};

              _proto.stopSystem = function stopSystem() {
                this._stopped = true;

                this._simulator.stop();
              };

              _proto.resetSystem = function resetSystem() {
                this._stopped = false;

                this._simulator.reset();

                this.markForUpdateRenderData();
              };

              _proto.isFull = function isFull() {
                return this.particleCount >= this.totalParticles;
              };

              _proto._applyFile = function _applyFile() {
                var file = this._file;

                if (file) {
                  if (!file) {
                    errorID(6029);
                    return;
                  }

                  if (!this.isValid) {
                    return;
                  }

                  this._plistFile = file.nativeUrl;

                  if (!this._custom) {
                    var isDiffFrame = this._spriteFrame !== file.spriteFrame;
                    if (isDiffFrame) this.spriteFrame = file.spriteFrame;

                    this._initWithDictionary(file._nativeAsset);
                  }

                  if (!this._spriteFrame) {
                    if (file.spriteFrame) {
                      this.spriteFrame = file.spriteFrame;
                    } else if (this._custom) {
                      this._initTextureWithDictionary(file._nativeAsset);
                    }
                  } else if (!this._renderSpriteFrame && this._spriteFrame) {
                    this._applySpriteFrame();
                  }
                }
              };

              _proto._initTextureWithDictionary = function _initTextureWithDictionary(dict) {
                var _this2 = this;

                if (dict.spriteFrameUuid) {
                  var spriteFrameUuid = dict.spriteFrameUuid;
                  assetManager.loadAny(spriteFrameUuid, function (err, spriteFrame) {
                    if (err) {
                      dict.spriteFrameUuid = undefined;

                      _this2._initTextureWithDictionary(dict);

                      error(err);
                    } else {
                      _this2.spriteFrame = spriteFrame;
                    }
                  });
                } else {
                  var imgPath = changeBasename(this._plistFile, dict.textureFileName || '');

                  if (dict.textureFileName) {
                    assetManager.loadRemote(imgPath, function (err, imageAsset) {
                      if (err) {
                        dict.textureFileName = undefined;

                        _this2._initTextureWithDictionary(dict);

                        error(err);
                      } else {
                        if (imageAsset) {
                          _this2.spriteFrame = SpriteFrame.createWithImage(imageAsset);
                        } else {
                          _this2.spriteFrame = SpriteFrame.createWithImage(builtinResMgr.get('white-texture'));
                        }
                      }
                    });
                  } else if (dict.textureImageData) {
                    var textureData = dict.textureImageData;

                    if (textureData && textureData.length > 0) {
                      var imgPathName = imgPath;

                      if (this.file) {
                        imgPathName += "-" + this.file.uuid;
                      }

                      var imageAsset = assetManager.assets.get(imgPathName);

                      if (!imageAsset) {
                        var buffer = codec.unzipBase64AsArray(textureData, 1);

                        if (!buffer) {
                          warnID(6030, this._file.name);
                          return false;
                        }

                        var imageFormat = getImageFormatByData(buffer);

                        if (imageFormat !== ImageFormat.TIFF && imageFormat !== ImageFormat.PNG) {
                          warnID(6031, this._file.name);
                          return false;
                        }

                        var canvasObj = ccwindow.document.createElement('canvas');

                        if (imageFormat === ImageFormat.PNG) {
                          var myPngObj = new PNGReader(buffer);
                          myPngObj.render(canvasObj);
                        } else {
                          if (!this._tiffReader) {
                            this._tiffReader = new TiffReader();
                          }

                          this._tiffReader.parseTIFF(buffer, canvasObj);
                        }

                        imageAsset = new ImageAsset(canvasObj);
                        assetManager.assets.add(imgPathName, imageAsset);
                      }

                      if (!imageAsset) {
                        warnID(6032, this._file.name);
                      }

                      if (imageAsset) {
                        this.spriteFrame = SpriteFrame.createWithImage(imageAsset);
                      } else {
                        this.spriteFrame = SpriteFrame.createWithImage(builtinResMgr.get('white-texture'));
                      }
                    } else {
                      return false;
                    }
                  }
                }

                return true;
              };

              _proto._initWithDictionary = function _initWithDictionary(dict) {
                this._useFile = true;
                this.totalParticles = parseInt(dict.maxParticles || 0);
                this.life = parseFloat(dict.particleLifespan || 0);
                this.lifeVar = parseFloat(dict.particleLifespanVariance || 0);
                var _tempEmissionRate = dict.emissionRate;

                if (_tempEmissionRate) {
                  this.emissionRate = _tempEmissionRate;
                } else {
                  this.emissionRate = Math.min(this.totalParticles / this.life, Number.MAX_VALUE);
                }

                this.duration = parseFloat(dict.duration || 0);
                this._srcBlendFactor = parseInt(dict.blendFuncSource || BlendFactor.SRC_ALPHA);
                this._dstBlendFactor = parseInt(dict.blendFuncDestination || BlendFactor.ONE_MINUS_SRC_ALPHA);
                var locStartColor = this._startColor;
                locStartColor.r = parseFloat(dict.startColorRed || 0) * 255;
                locStartColor.g = parseFloat(dict.startColorGreen || 0) * 255;
                locStartColor.b = parseFloat(dict.startColorBlue || 0) * 255;
                locStartColor.a = parseFloat(dict.startColorAlpha || 0) * 255;
                var locStartColorVar = this._startColorVar;
                locStartColorVar.r = parseFloat(dict.startColorVarianceRed || 0) * 255;
                locStartColorVar.g = parseFloat(dict.startColorVarianceGreen || 0) * 255;
                locStartColorVar.b = parseFloat(dict.startColorVarianceBlue || 0) * 255;
                locStartColorVar.a = parseFloat(dict.startColorVarianceAlpha || 0) * 255;
                var locEndColor = this._endColor;
                locEndColor.r = parseFloat(dict.finishColorRed || 0) * 255;
                locEndColor.g = parseFloat(dict.finishColorGreen || 0) * 255;
                locEndColor.b = parseFloat(dict.finishColorBlue || 0) * 255;
                locEndColor.a = parseFloat(dict.finishColorAlpha || 0) * 255;
                var locEndColorVar = this._endColorVar;
                locEndColorVar.r = parseFloat(dict.finishColorVarianceRed || 0) * 255;
                locEndColorVar.g = parseFloat(dict.finishColorVarianceGreen || 0) * 255;
                locEndColorVar.b = parseFloat(dict.finishColorVarianceBlue || 0) * 255;
                locEndColorVar.a = parseFloat(dict.finishColorVarianceAlpha || 0) * 255;
                this.startSize = parseFloat(dict.startParticleSize || 0);
                this.startSizeVar = parseFloat(dict.startParticleSizeVariance || 0);
                this.endSize = parseFloat(dict.finishParticleSize || 0);
                this.endSizeVar = parseFloat(dict.finishParticleSizeVariance || 0);
                this.positionType = parseFloat(dict.positionType !== undefined ? dict.positionType : PositionType.FREE);
                this.sourcePos.set(0, 0);
                this.posVar.set(parseFloat(dict.sourcePositionVariancex || 0), parseFloat(dict.sourcePositionVariancey || 0));
                this.angle = parseFloat(dict.angle || 0);
                this.angleVar = parseFloat(dict.angleVariance || 0);
                this.startSpin = parseFloat(dict.rotationStart || 0);
                this.startSpinVar = parseFloat(dict.rotationStartVariance || 0);
                this.endSpin = parseFloat(dict.rotationEnd || 0);
                this.endSpinVar = parseFloat(dict.rotationEndVariance || 0);
                this.emitterMode = parseInt(dict.emitterType || EmitterMode.GRAVITY);

                if (this.emitterMode === EmitterMode.GRAVITY) {
                  this.gravity.set(parseFloat(dict.gravityx || 0), parseFloat(dict.gravityy || 0));
                  this.speed = parseFloat(dict.speed || 0);
                  this.speedVar = parseFloat(dict.speedVariance || 0);
                  this.radialAccel = parseFloat(dict.radialAcceleration || 0);
                  this.radialAccelVar = parseFloat(dict.radialAccelVariance || 0);
                  this.tangentialAccel = parseFloat(dict.tangentialAcceleration || 0);
                  this.tangentialAccelVar = parseFloat(dict.tangentialAccelVariance || 0);
                  var locRotationIsDir = dict.rotationIsDir || '';

                  if (locRotationIsDir !== null) {
                    locRotationIsDir = locRotationIsDir.toString().toLowerCase();
                    this.rotationIsDir = locRotationIsDir === 'true' || locRotationIsDir === '1';
                  } else {
                    this.rotationIsDir = false;
                  }
                } else if (this.emitterMode === EmitterMode.RADIUS) {
                  this.startRadius = parseFloat(dict.maxRadius || 0);
                  this.startRadiusVar = parseFloat(dict.maxRadiusVariance || 0);
                  this.endRadius = parseFloat(dict.minRadius || 0);
                  this.endRadiusVar = parseFloat(dict.minRadiusVariance || 0);
                  this.rotatePerS = parseFloat(dict.rotatePerSecond || 0);
                  this.rotatePerSVar = parseFloat(dict.rotatePerSecondVariance || 0);
                } else {
                  warnID(6009);
                  return false;
                }

                this._initTextureWithDictionary(dict);

                return true;
              };

              _proto._syncAspect = function _syncAspect() {
                if (this._renderSpriteFrame) {
                  var frameRect = this._renderSpriteFrame.rect;
                  this.aspectRatio = frameRect.width / frameRect.height;
                }
              };

              _proto._applySpriteFrame = function _applySpriteFrame() {
                this._renderSpriteFrame = this._renderSpriteFrame || this._spriteFrame;

                if (this._renderSpriteFrame) {
                  if (this._renderSpriteFrame.texture) {
                    if (this._simulator) {
                      this._simulator.updateUVs(true);
                    }

                    this._syncAspect();

                    this._updateMaterial();

                    this._stopped = false;
                    this.markForUpdateRenderData();
                  }
                } else {
                  this.resetSystem();
                }
              };

              _proto._getTexture = function _getTexture() {
                return this._renderSpriteFrame && this._renderSpriteFrame.texture;
              };

              _proto._updateMaterial = function _updateMaterial() {
                if (this._customMaterial) {
                  this.setMaterial(this._customMaterial, 0);
                  var target = this.getRenderMaterial(0).passes[0].blendState.targets[0];
                  this._dstBlendFactor = target.blendDst;
                  this._srcBlendFactor = target.blendSrc;
                }

                var mat = this.getMaterialInstance(0);
                if (mat) mat.recompileShaders({
                  USE_LOCAL: this._positionType !== PositionType.FREE
                });

                if (mat && mat.passes.length > 0) {
                  this._updateBlendFunc();
                }
              };

              _proto._finishedSimulation = function _finishedSimulation() {

                this.resetSystem();
                this.stopSystem();
                this.markForUpdateRenderData();

                if (this.autoRemoveOnFinish && this._stopped) {
                  this.node.destroy();
                }
              };

              _proto._canRender = function _canRender() {
                return _UIRenderer.prototype._canRender.call(this) && !this._stopped && this._renderSpriteFrame !== null && this._renderSpriteFrame !== undefined;
              };

              _proto._render = function _render(render) {
                if (this._positionType === PositionType.RELATIVE) {
                  render.commitComp(this, this._simulator.renderData, this._renderSpriteFrame, this._assembler, this.node.parent);
                } else if (this.positionType === PositionType.GROUPED) {
                  render.commitComp(this, this._simulator.renderData, this._renderSpriteFrame, this._assembler, this.node);
                } else {
                  render.commitComp(this, this._simulator.renderData, this._renderSpriteFrame, this._assembler, null);
                }
              };

              _proto._updatePositionType = function _updatePositionType() {
                if (this._positionType === PositionType.RELATIVE) {
                  this._renderEntity.setRenderTransform(this.node.parent);

                  this._renderEntity.setUseLocal(true);
                } else if (this.positionType === PositionType.GROUPED) {
                  this._renderEntity.setRenderTransform(this.node);

                  this._renderEntity.setUseLocal(true);
                } else {
                  this._renderEntity.setRenderTransform(null);

                  this._renderEntity.setUseLocal(false);
                }
              };

              _createClass(ParticleSystem2D, [{
                key: "custom",
                get: function get() {
                  return this._custom;
                },
                set: function set(value) {

                  if (this._custom !== value) {
                    this._custom = value;

                    this._applyFile();

                    this._updateMaterial();
                  }
                }
              }, {
                key: "file",
                get: function get() {
                  return this._file;
                },
                set: function set(value) {
                  if (this._file !== value) {
                    this._file = value;

                    if (value) {
                      this._applyFile();
                    } else {
                      this.custom = true;
                    }
                  }
                }
              }, {
                key: "spriteFrame",
                get: function get() {
                  return this._spriteFrame;
                },
                set: function set(value) {
                  var lastSprite = this._renderSpriteFrame;

                  if (lastSprite === value) {
                    return;
                  }

                  this._renderSpriteFrame = value;

                  if (!value || value._uuid) {
                    this._spriteFrame = value;
                  }

                  this._applySpriteFrame();
                }
              }, {
                key: "particleCount",
                get: function get() {
                  return this._simulator.particles.length;
                }
              }, {
                key: "totalParticles",
                get: function get() {
                  return this._totalParticles;
                },
                set: function set(value) {
                  if (this._totalParticles === value) return;
                  this._totalParticles = value;
                }
              }, {
                key: "startColor",
                get: function get() {
                  return this._startColor;
                },
                set: function set(val) {
                  this._startColor.r = val.r;
                  this._startColor.g = val.g;
                  this._startColor.b = val.b;
                  this._startColor.a = val.a;
                }
              }, {
                key: "startColorVar",
                get: function get() {
                  return this._startColorVar;
                },
                set: function set(val) {
                  this._startColorVar.r = val.r;
                  this._startColorVar.g = val.g;
                  this._startColorVar.b = val.b;
                  this._startColorVar.a = val.a;
                }
              }, {
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(value) {}
              }, {
                key: "endColor",
                get: function get() {
                  return this._endColor;
                },
                set: function set(val) {
                  this._endColor.r = val.r;
                  this._endColor.g = val.g;
                  this._endColor.b = val.b;
                  this._endColor.a = val.a;
                }
              }, {
                key: "endColorVar",
                get: function get() {
                  return this._endColorVar;
                },
                set: function set(val) {
                  this._endColorVar.r = val.r;
                  this._endColorVar.g = val.g;
                  this._endColorVar.b = val.b;
                  this._endColorVar.a = val.a;
                }
              }, {
                key: "positionType",
                get: function get() {
                  return this._positionType;
                },
                set: function set(val) {
                  this._positionType = val;

                  this._updateMaterial();

                  this._updatePositionType();
                }
              }, {
                key: "preview",
                get: function get() {
                  return this._preview;
                },
                set: function set(val) {
                  if (val) {
                    this._startPreview();
                  } else {
                    this._stopPreview();
                  }

                  this._preview = val;
                }
              }, {
                key: "stopped",
                get: function get() {
                  return this._stopped;
                }
              }, {
                key: "active",
                get: function get() {
                  return this._simulator.active;
                }
              }, {
                key: "assembler",
                get: function get() {
                  return this._assembler;
                }
              }]);

              return ParticleSystem2D;
            }(UIRenderer), _class3$i.EmitterMode = EmitterMode, _class3$i.PositionType = PositionType, _class3$i.DURATION_INFINITY = DURATION_INFINITY, _class3$i.START_SIZE_EQUAL_TO_END_SIZE = START_SIZE_EQUAL_TO_END_SIZE, _class3$i.START_RADIUS_EQUAL_TO_END_RADIUS = START_RADIUS_EQUAL_TO_END_RADIUS, _temp$r), (_applyDecoratedDescriptor(_class2$1l.prototype, "file", [_dec2$17], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "file"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "spriteFrame", [_dec3$O], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "spriteFrame"), _class2$1l.prototype), _initializer$1g = applyDecoratedInitializer(_class2$1l.prototype, "duration", [serializable$j], function () {
              return -1;
            }), _initializer2$13 = applyDecoratedInitializer(_class2$1l.prototype, "emissionRate", [serializable$j], function () {
              return 10;
            }), _initializer3$Q = applyDecoratedInitializer(_class2$1l.prototype, "life", [serializable$j], function () {
              return 1;
            }), _initializer4$L = applyDecoratedInitializer(_class2$1l.prototype, "lifeVar", [serializable$j], function () {
              return 0;
            }), _applyDecoratedDescriptor(_class2$1l.prototype, "color", [override$1], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "color"), _class2$1l.prototype), _initializer5$C = applyDecoratedInitializer(_class2$1l.prototype, "angle", [serializable$j], function () {
              return 90;
            }), _initializer6$v = applyDecoratedInitializer(_class2$1l.prototype, "angleVar", [serializable$j], function () {
              return 20;
            }), _initializer7$o = applyDecoratedInitializer(_class2$1l.prototype, "startSize", [serializable$j], function () {
              return 50;
            }), _initializer8$m = applyDecoratedInitializer(_class2$1l.prototype, "startSizeVar", [serializable$j], function () {
              return 0;
            }), _initializer9$j = applyDecoratedInitializer(_class2$1l.prototype, "endSize", [serializable$j], function () {
              return 0;
            }), _initializer10$h = applyDecoratedInitializer(_class2$1l.prototype, "endSizeVar", [serializable$j], function () {
              return 0;
            }), _initializer11$d = applyDecoratedInitializer(_class2$1l.prototype, "startSpin", [serializable$j], function () {
              return 0;
            }), _initializer12$d = applyDecoratedInitializer(_class2$1l.prototype, "startSpinVar", [serializable$j], function () {
              return 0;
            }), _initializer13$d = applyDecoratedInitializer(_class2$1l.prototype, "endSpin", [serializable$j], function () {
              return 0;
            }), _initializer14$9 = applyDecoratedInitializer(_class2$1l.prototype, "endSpinVar", [serializable$j], function () {
              return 0;
            }), _initializer15$8 = applyDecoratedInitializer(_class2$1l.prototype, "sourcePos", [serializable$j], function () {
              return Vec2.ZERO.clone();
            }), _initializer16$8 = applyDecoratedInitializer(_class2$1l.prototype, "posVar", [serializable$j], function () {
              return Vec2.ZERO.clone();
            }), _applyDecoratedDescriptor(_class2$1l.prototype, "positionType", [_dec4$y], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "positionType"), _class2$1l.prototype), _initializer17$7 = applyDecoratedInitializer(_class2$1l.prototype, "emitterMode", [serializable$j, _dec5$s], function () {
              return EmitterMode.GRAVITY;
            }), _initializer18$6 = applyDecoratedInitializer(_class2$1l.prototype, "gravity", [serializable$j], function () {
              return Vec2.ZERO.clone();
            }), _initializer19$6 = applyDecoratedInitializer(_class2$1l.prototype, "speed", [serializable$j], function () {
              return 180;
            }), _initializer20$4 = applyDecoratedInitializer(_class2$1l.prototype, "speedVar", [serializable$j], function () {
              return 50;
            }), _initializer21$3 = applyDecoratedInitializer(_class2$1l.prototype, "tangentialAccel", [serializable$j], function () {
              return 80;
            }), _initializer22$3 = applyDecoratedInitializer(_class2$1l.prototype, "tangentialAccelVar", [serializable$j], function () {
              return 0;
            }), _initializer23$3 = applyDecoratedInitializer(_class2$1l.prototype, "radialAccel", [serializable$j], function () {
              return 0;
            }), _initializer24$3 = applyDecoratedInitializer(_class2$1l.prototype, "radialAccelVar", [serializable$j], function () {
              return 0;
            }), _initializer25$3 = applyDecoratedInitializer(_class2$1l.prototype, "rotationIsDir", [serializable$j], function () {
              return false;
            }), _initializer26$3 = applyDecoratedInitializer(_class2$1l.prototype, "startRadius", [serializable$j], function () {
              return 0;
            }), _initializer27$2 = applyDecoratedInitializer(_class2$1l.prototype, "startRadiusVar", [serializable$j], function () {
              return 0;
            }), _initializer28$2 = applyDecoratedInitializer(_class2$1l.prototype, "endRadius", [serializable$j], function () {
              return 0;
            }), _initializer29$1 = applyDecoratedInitializer(_class2$1l.prototype, "endRadiusVar", [serializable$j], function () {
              return 0;
            }), _initializer30$1 = applyDecoratedInitializer(_class2$1l.prototype, "rotatePerS", [serializable$j], function () {
              return 0;
            }), _initializer31$1 = applyDecoratedInitializer(_class2$1l.prototype, "rotatePerSVar", [serializable$j], function () {
              return 0;
            }), _initializer32$1 = applyDecoratedInitializer(_class2$1l.prototype, "playOnLoad", [serializable$j], function () {
              return true;
            }), _initializer33$1 = applyDecoratedInitializer(_class2$1l.prototype, "autoRemoveOnFinish", [serializable$j], function () {
              return false;
            }), _initializer34$1 = applyDecoratedInitializer(_class2$1l.prototype, "_preview", [_dec6$o], function () {
              return true;
            }), _initializer35$1 = applyDecoratedInitializer(_class2$1l.prototype, "_custom", [serializable$j], function () {
              return false;
            }), _initializer36$1 = applyDecoratedInitializer(_class2$1l.prototype, "_file", [serializable$j], function () {
              return null;
            }), _initializer37$1 = applyDecoratedInitializer(_class2$1l.prototype, "_spriteFrame", [serializable$j], function () {
              return null;
            }), _initializer38$1 = applyDecoratedInitializer(_class2$1l.prototype, "_totalParticles", [serializable$j], function () {
              return 150;
            }), _initializer39$1 = applyDecoratedInitializer(_class2$1l.prototype, "_startColor", [serializable$j], function () {
              return new Color$1(255, 255, 255, 255);
            }), _initializer40$1 = applyDecoratedInitializer(_class2$1l.prototype, "_startColorVar", [serializable$j], function () {
              return new Color$1(0, 0, 0, 0);
            }), _initializer41$1 = applyDecoratedInitializer(_class2$1l.prototype, "_endColor", [serializable$j], function () {
              return new Color$1(255, 255, 255, 0);
            }), _initializer42 = applyDecoratedInitializer(_class2$1l.prototype, "_endColorVar", [serializable$j], function () {
              return new Color$1(0, 0, 0, 0);
            }), _initializer43 = applyDecoratedInitializer(_class2$1l.prototype, "_positionType", [serializable$j], function () {
              return PositionType.FREE;
            })), _class2$1l)) || _class$1B));

            var _dec$1z, _dec2$18, _class$1C, _class2$1m, _initializer$1h, _initializer2$14, _initializer3$R, _initializer4$M, _initializer5$D, _initializer6$w, _class3$j, _temp$s;

            var Point$2 = function () {
              function Point(point, dir) {
                this.point = new Vec2();
                this.dir = new Vec2();
                this.distance = 0;
                this.time = 0;
                if (point) this.point.set(point);
                if (dir) this.dir.set(dir);
              }

              var _proto = Point.prototype;

              _proto.setPoint = function setPoint(x, y) {
                this.point.x = x;
                this.point.y = y;
              };

              _proto.setDir = function setDir(x, y) {
                this.dir.x = x;
                this.dir.y = y;
              };

              return Point;
            }();

            var MotionStreak = exports('MotionStreak', (_dec$1z = ccclass$p('cc.MotionStreak'), _dec2$18 = type$8(Texture2D), _dec$1z(_class$1C = (_class2$1m = (_temp$s = _class3$j = function (_UIRenderer) {
              _inheritsLoose(MotionStreak, _UIRenderer);

              function MotionStreak() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _UIRenderer.call.apply(_UIRenderer, [this].concat(args)) || this;
                _this._preview = _initializer$1h && _initializer$1h();
                _this._fadeTime = _initializer2$14 && _initializer2$14();
                _this._minSeg = _initializer3$R && _initializer3$R();
                _this._stroke = _initializer4$M && _initializer4$M();
                _this._texture = _initializer5$D && _initializer5$D();
                _this._fastMode = _initializer6$w && _initializer6$w();
                _this._points = [];
                return _this;
              }

              var _proto2 = MotionStreak.prototype;

              _proto2.onEnable = function onEnable() {
                _UIRenderer.prototype.onEnable.call(this);

                this.reset();
              };

              _proto2._flushAssembler = function _flushAssembler() {
                var assembler = MotionStreak.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this._assembler = assembler;
                }

                if (!this.renderData) {
                  if (this._assembler && this._assembler.createData) {
                    this._renderData = this._assembler.createData(this);
                    this.renderData.material = this.material;

                    this._updateColor();
                  }
                }
              };

              _proto2.onFocusInEditor = function onFocusInEditor() {
                if (this._preview) {
                  this.reset();
                }
              };

              _proto2.onLostFocusInEditor = function onLostFocusInEditor() {
                if (this._preview) {
                  this.reset();
                }
              };

              _proto2.reset = function reset() {
                this._points.length = 0;
                if (this.renderData) this.renderData.clear();
              };

              _proto2.lateUpdate = function lateUpdate(dt) {
                if (this._assembler) this._assembler.update(this, dt);
              };

              _proto2._render = function _render(render) {
                render.commitComp(this, this.renderData, this._texture, this._assembler, null);
              };

              _createClass(MotionStreak, [{
                key: "preview",
                get: function get() {
                  return this._preview;
                },
                set: function set(val) {
                  this._preview = val;
                  this.reset();
                }
              }, {
                key: "fadeTime",
                get: function get() {
                  return this._fadeTime;
                },
                set: function set(val) {
                  this._fadeTime = val;
                  this.reset();
                }
              }, {
                key: "minSeg",
                get: function get() {
                  return this._minSeg;
                },
                set: function set(val) {
                  this._minSeg = val;
                }
              }, {
                key: "stroke",
                get: function get() {
                  return this._stroke;
                },
                set: function set(val) {
                  this._stroke = val;
                }
              }, {
                key: "texture",
                get: function get() {
                  return this._texture;
                },
                set: function set(val) {
                  if (this._texture === val) return;
                  this._texture = val;
                }
              }, {
                key: "fastMode",
                get: function get() {
                  return this._fastMode;
                },
                set: function set(val) {
                  this._fastMode = val;
                }
              }, {
                key: "points",
                get: function get() {
                  return this._points;
                }
              }]);

              return MotionStreak;
            }(UIRenderer), _class3$j.Point = Point$2, _temp$s), (_applyDecoratedDescriptor(_class2$1m.prototype, "texture", [_dec2$18], Object.getOwnPropertyDescriptor(_class2$1m.prototype, "texture"), _class2$1m.prototype), _initializer$1h = applyDecoratedInitializer(_class2$1m.prototype, "_preview", [serializable$j], function () {
              return false;
            }), _initializer2$14 = applyDecoratedInitializer(_class2$1m.prototype, "_fadeTime", [serializable$j], function () {
              return 1;
            }), _initializer3$R = applyDecoratedInitializer(_class2$1m.prototype, "_minSeg", [serializable$j], function () {
              return 1;
            }), _initializer4$M = applyDecoratedInitializer(_class2$1m.prototype, "_stroke", [serializable$j], function () {
              return 64;
            }), _initializer5$D = applyDecoratedInitializer(_class2$1m.prototype, "_texture", [serializable$j], function () {
              return null;
            }), _initializer6$w = applyDecoratedInitializer(_class2$1m.prototype, "_fastMode", [serializable$j], function () {
              return false;
            })), _class2$1m)) || _class$1C));

            var _tangent = new Vec2();

            var _normal$1 = new Vec2();

            var _vec2 = new Vec2();

            var QUAD_INDICES$6;

            function normal(out, dir) {
              out.x = -dir.y;
              out.y = dir.x;
              return out;
            }

            var MotionStreakAssembler = {
              createData: function createData(comp) {
                var renderData = comp.requestRenderData();
                renderData.dataLength = 4;
                renderData.resize(16, (16 - 2) * 3);
                return renderData;
              },
              update: function update(comp, dt) {
                var stroke = comp.stroke / 2;
                var node = comp.node;
                var matrix = node.worldMatrix;
                var tx = matrix.m12;
                var ty = matrix.m13;
                var points = comp.points;
                var cur;

                if (points.length > 1) {
                  var point = points[0];
                  var difx = point.point.x - tx;
                  var dify = point.point.y - ty;

                  if (difx * difx + dify * dify < comp.minSeg) {
                    cur = point;
                  }
                }

                if (!cur) {
                  cur = new MotionStreak.Point();
                  points.unshift(cur);
                }

                cur.setPoint(tx, ty);
                cur.time = comp.fadeTime + dt;
                var vertexCount = 0;
                var indexCount = 0;

                if (points.length < 2) {
                  return;
                }

                var renderData = comp.renderData;
                this.updateRenderDataCache(comp, renderData);
                var color = comp.color;
                var cr = color.r;
                var cg = color.g;
                var cb = color.b;
                var ca = color.a;
                var prev = points[1];
                prev.distance = Vec2.subtract(_vec2, cur.point, prev.point).length();

                _vec2.normalize();

                prev.setDir(_vec2.x, _vec2.y);
                cur.setDir(_vec2.x, _vec2.y);
                renderData.dataLength = points.length * 2;
                var data = renderData.data;
                var fadeTime = comp.fadeTime;
                var findLast = false;

                for (var i = points.length - 1; i >= 0; i--) {
                  var p = points[i];
                  var _point = p.point;
                  var dir = p.dir;
                  p.time -= dt;

                  if (p.time < 0) {
                    points.splice(i, 1);
                    continue;
                  }

                  var progress = p.time / fadeTime;
                  var next = points[i - 1];

                  if (!findLast) {
                    if (!next) {
                      points.splice(i, 1);
                      continue;
                    }

                    _point.x = next.point.x - dir.x * progress;
                    _point.y = next.point.y - dir.y * progress;
                  }

                  findLast = true;
                  normal(_normal$1, dir);
                  var da = progress * ca;
                  var c = (da << 24 >>> 0) + (cb << 16) + (cg << 8) + cr;
                  var offset = vertexCount;
                  data[offset].x = _point.x + _normal$1.x * stroke;
                  data[offset].y = _point.y + _normal$1.y * stroke;
                  data[offset].u = 1;
                  data[offset].v = progress;
                  data[offset].color._val = c;
                  offset += 1;
                  data[offset].x = _point.x - _normal$1.x * stroke;
                  data[offset].y = _point.y - _normal$1.y * stroke;
                  data[offset].u = 0;
                  data[offset].v = progress;
                  data[offset].color._val = c;
                  vertexCount += 2;
                }

                indexCount = vertexCount <= 2 ? 0 : (vertexCount - 2) * 3;
                renderData.resize(vertexCount, indexCount);
              },
              updateWorldVertexAllData: function updateWorldVertexAllData(comp) {
                var renderData = comp.renderData;
                var stride = renderData.floatStride;
                var dataList = renderData.data;
                var vData = renderData.chunk.vb;

                for (var i = 0; i < dataList.length; i++) {
                  var offset = i * stride;
                  vData[offset + 0] = dataList[i].x;
                  vData[offset + 1] = dataList[i].y;
                  vData[offset + 2] = dataList[i].z;
                  vData[offset + 3] = dataList[i].u;
                  vData[offset + 4] = dataList[i].v;
                  Color$1.toArray(vData, dataList[i].color, offset + 5);
                }
              },
              createQuadIndices: function createQuadIndices(comp, indexCount) {
                var renderData = comp.renderData;
                var chunk = renderData.chunk;
                var vid = 0;
                var meshBuffer = chunk.meshBuffer;
                var indexOffset = meshBuffer.indexOffset;
                QUAD_INDICES$6 = null;
                QUAD_INDICES$6 = new Uint16Array(indexCount);

                for (var i = 0, l = indexCount; i < l; i += 2) {
                  var start = vid + i;
                  QUAD_INDICES$6[indexOffset++] = start;
                  QUAD_INDICES$6[indexOffset++] = start + 2;
                  QUAD_INDICES$6[indexOffset++] = start + 1;
                  QUAD_INDICES$6[indexOffset++] = start + 1;
                  QUAD_INDICES$6[indexOffset++] = start + 2;
                  QUAD_INDICES$6[indexOffset++] = start + 3;
                }
              },
              updateRenderDataCache: function updateRenderDataCache(comp, renderData) {
                if (renderData.passDirty) {
                  renderData.updatePass(comp);
                }

                if (renderData.nodeDirty) {
                  renderData.updateNode(comp);
                }

                if (renderData.textureDirty && comp.texture) {
                  renderData.updateTexture(comp.texture);
                  renderData.material = comp.getRenderMaterial(0);
                }

                if (renderData.hashDirty) {
                  renderData.updateHash();
                }
              },
              updateRenderData: function updateRenderData(comp) {
              },
              updateColor: function updateColor(comp) {},
              fillBuffers: function fillBuffers(comp, renderer) {
                var renderData = comp.renderData;
                var chunk = renderData.chunk;
                var dataList = renderData.data;
                var vertexCount = renderData.vertexCount;
                var indexCount = renderData.indexCount;
                var vData = chunk.vb;
                var vertexOffset = 0;

                for (var i = 0; i < vertexCount; i++) {
                  var vert = dataList[i];
                  vData[vertexOffset++] = vert.x;
                  vData[vertexOffset++] = vert.y;
                  vData[vertexOffset++] = vert.z;
                  vData[vertexOffset++] = vert.u;
                  vData[vertexOffset++] = vert.v;
                  Color$1.toArray(vData, vert.color, vertexOffset);
                  vertexOffset += 4;
                }

                var bid = chunk.bufferId;
                var vid = chunk.vertexOffset;
                var meshBuffer = chunk.meshBuffer;
                var ib = chunk.meshBuffer.iData;
                var indexOffset = meshBuffer.indexOffset;

                for (var _i = 0, l = indexCount; _i < l; _i += 2) {
                  var start = vid + _i;
                  ib[indexOffset++] = start;
                  ib[indexOffset++] = start + 2;
                  ib[indexOffset++] = start + 1;
                  ib[indexOffset++] = start + 1;
                  ib[indexOffset++] = start + 2;
                  ib[indexOffset++] = start + 3;
                }

                meshBuffer.indexOffset += renderData.indexCount;
                meshBuffer.setDirty();
              }
            };
            var MotionStreakAssemblerManager = exports('MotionStreakAssemblerManager', {
              getAssembler: function getAssembler(comp) {
                return MotionStreakAssembler;
              }
            });
            MotionStreak.Assembler = MotionStreakAssemblerManager;

            var ParticleAssembler = {
              maxParticleDeltaTime: 0,
              createData: function createData(comp) {
                return MeshRenderData.add();
              },
              removeData: function removeData(data) {
                MeshRenderData.remove(data);
              },
              updateRenderData: function updateRenderData() {},
              fillBuffers: function fillBuffers(comp, renderer) {}
            };
            var ParticleSystem2DAssembler = exports('ParticleSystem2DAssembler', {
              getAssembler: function getAssembler(comp) {
                if (!ParticleAssembler.maxParticleDeltaTime) {
                  ParticleAssembler.maxParticleDeltaTime = legacyCC.game.frameTime / 1000 * 2;
                }

                return ParticleAssembler;
              }
            });
            ParticleSystem2D.Assembler = ParticleSystem2DAssembler;

            var ERigidBodyType;

            (function (ERigidBodyType) {
              ERigidBodyType[ERigidBodyType["DYNAMIC"] = 1] = "DYNAMIC";
              ERigidBodyType[ERigidBodyType["STATIC"] = 2] = "STATIC";
              ERigidBodyType[ERigidBodyType["KINEMATIC"] = 4] = "KINEMATIC";
            })(ERigidBodyType || (ERigidBodyType = exports('ERigidBodyType', {})));

            Enum(ERigidBodyType);
            var EAxisDirection;

            (function (EAxisDirection) {
              EAxisDirection[EAxisDirection["X_AXIS"] = 0] = "X_AXIS";
              EAxisDirection[EAxisDirection["Y_AXIS"] = 1] = "Y_AXIS";
              EAxisDirection[EAxisDirection["Z_AXIS"] = 2] = "Z_AXIS";
            })(EAxisDirection || (EAxisDirection = exports('EAxisDirection', {})));

            Enum(EAxisDirection);
            var ESimplexType;

            (function (ESimplexType) {
              ESimplexType[ESimplexType["VERTEX"] = 1] = "VERTEX";
              ESimplexType[ESimplexType["LINE"] = 2] = "LINE";
              ESimplexType[ESimplexType["TRIANGLE"] = 3] = "TRIANGLE";
              ESimplexType[ESimplexType["TETRAHEDRON"] = 4] = "TETRAHEDRON";
            })(ESimplexType || (ESimplexType = {}));

            Enum(ESimplexType);
            var EColliderType;

            (function (EColliderType) {
              EColliderType[EColliderType["BOX"] = 0] = "BOX";
              EColliderType[EColliderType["SPHERE"] = 1] = "SPHERE";
              EColliderType[EColliderType["CAPSULE"] = 2] = "CAPSULE";
              EColliderType[EColliderType["CYLINDER"] = 3] = "CYLINDER";
              EColliderType[EColliderType["CONE"] = 4] = "CONE";
              EColliderType[EColliderType["MESH"] = 5] = "MESH";
              EColliderType[EColliderType["PLANE"] = 6] = "PLANE";
              EColliderType[EColliderType["SIMPLEX"] = 7] = "SIMPLEX";
              EColliderType[EColliderType["TERRAIN"] = 8] = "TERRAIN";
            })(EColliderType || (EColliderType = {}));

            Enum(EColliderType);
            var EConstraintType;

            (function (EConstraintType) {
              EConstraintType[EConstraintType["POINT_TO_POINT"] = 0] = "POINT_TO_POINT";
              EConstraintType[EConstraintType["HINGE"] = 1] = "HINGE";
              EConstraintType[EConstraintType["CONE_TWIST"] = 2] = "CONE_TWIST";
              EConstraintType[EConstraintType["FIXED"] = 3] = "FIXED";
            })(EConstraintType || (EConstraintType = {}));

            Enum(EConstraintType);
            var PhysicsGroup;

            (function (PhysicsGroup) {
              PhysicsGroup[PhysicsGroup["DEFAULT"] = 1] = "DEFAULT";
            })(PhysicsGroup || (PhysicsGroup = {}));

            Enum(PhysicsGroup);

            function updateLegacyMacro(id) {
              legacyCC._global.CC_PHYSICS_BUILTIN = id === 'builtin';
              legacyCC._global.CC_PHYSICS_CANNON = id === 'cannon.js';
              legacyCC._global.CC_PHYSICS_AMMO = id === 'bullet';
            }

            function register(id, wrapper) {
              console.info("[PHYSICS]: register " + id + ".");
              selector.backend[id] = wrapper;

              if (!selector.physicsWorld || selector.id === id) {
                updateLegacyMacro(id);
                var mutableSelector = selector;
                mutableSelector.id = id;
                mutableSelector.wrapper = wrapper;
              }
            }

            var worldInitData;

            function switchTo(id) {
              if (!selector.runInEditor) return;
              var mutableSelector = selector;

              if (selector.physicsWorld && id !== selector.id && selector.backend[id] != null) {
                selector.physicsWorld.destroy();
                console.info("[PHYSICS]: switch from " + selector.id + " to " + id + ".");
                updateLegacyMacro(id);
                mutableSelector.id = id;
                mutableSelector.wrapper = selector.backend[id];
                mutableSelector.physicsWorld = createPhysicsWorld();
              } else {
                console.info("[PHYSICS]: using " + id + ".");
                mutableSelector.physicsWorld = createPhysicsWorld();
              }

              if (worldInitData) {
                var world = mutableSelector.physicsWorld;
                world.setGravity(worldInitData.gravity);
                world.setAllowSleep(worldInitData.allowSleep);
              }
            }

            var selector = {
              id: '',
              switchTo: switchTo,
              register: register,
              wrapper: {},
              backend: {},
              physicsWorld: null,
              runInEditor: !EDITOR
            };
            function constructDefaultWorld(data) {
              if (!worldInitData) worldInitData = data;
              if (!selector.runInEditor) return;

              if (!selector.physicsWorld) {
                console.info("[PHYSICS]: using " + selector.id + ".");
                var mutableSelector = selector;
                var world = mutableSelector.physicsWorld = createPhysicsWorld();
                world.setGravity(worldInitData.gravity);
                world.setAllowSleep(worldInitData.allowSleep);
              }
            }

            var FUNC = function FUNC() {
              return 0;
            };

            var ENTIRE_WORLD = {
              impl: null,
              setGravity: FUNC,
              setAllowSleep: FUNC,
              setDefaultMaterial: FUNC,
              step: FUNC,
              syncAfterEvents: FUNC,
              syncSceneToPhysics: FUNC,
              raycast: FUNC,
              raycastClosest: FUNC,
              emitEvents: FUNC,
              destroy: FUNC
            };
            var ECheckType;

            (function (ECheckType) {
              ECheckType[ECheckType["World"] = 0] = "World";
              ECheckType[ECheckType["RigidBody"] = 1] = "RigidBody";
              ECheckType[ECheckType["BoxCollider"] = 2] = "BoxCollider";
              ECheckType[ECheckType["SphereCollider"] = 3] = "SphereCollider";
              ECheckType[ECheckType["CapsuleCollider"] = 4] = "CapsuleCollider";
              ECheckType[ECheckType["MeshCollider"] = 5] = "MeshCollider";
              ECheckType[ECheckType["CylinderCollider"] = 6] = "CylinderCollider";
              ECheckType[ECheckType["ConeCollider"] = 7] = "ConeCollider";
              ECheckType[ECheckType["TerrainCollider"] = 8] = "TerrainCollider";
              ECheckType[ECheckType["SimplexCollider"] = 9] = "SimplexCollider";
              ECheckType[ECheckType["PlaneCollider"] = 10] = "PlaneCollider";
              ECheckType[ECheckType["PointToPointConstraint"] = 11] = "PointToPointConstraint";
              ECheckType[ECheckType["HingeConstraint"] = 12] = "HingeConstraint";
              ECheckType[ECheckType["ConeTwistConstraint"] = 13] = "ConeTwistConstraint";
              ECheckType[ECheckType["FixedConstraint"] = 14] = "FixedConstraint";
            })(ECheckType || (ECheckType = {}));

            function check(obj, type) {
              if (obj == null) {
                if (selector.id) {
                  warn(selector.id + " physics does not support " + ECheckType[type]);
                } else {
                  errorID(9600);
                }

                return true;
              }

              return false;
            }

            function createPhysicsWorld() {
              if (check(selector.wrapper.PhysicsWorld, ECheckType.World)) {
                return ENTIRE_WORLD;
              }

              return new selector.wrapper.PhysicsWorld();
            }
            var ENTIRE_RIGID_BODY = {
              impl: null,
              rigidBody: null,
              isAwake: false,
              isSleepy: false,
              isSleeping: false,
              initialize: FUNC,
              onEnable: FUNC,
              onDisable: FUNC,
              onDestroy: FUNC,
              setType: FUNC,
              setMass: FUNC,
              setLinearDamping: FUNC,
              setAngularDamping: FUNC,
              useGravity: FUNC,
              setLinearFactor: FUNC,
              setAngularFactor: FUNC,
              setAllowSleep: FUNC,
              wakeUp: FUNC,
              sleep: FUNC,
              clearState: FUNC,
              clearForces: FUNC,
              clearVelocity: FUNC,
              setSleepThreshold: FUNC,
              getSleepThreshold: FUNC,
              getLinearVelocity: FUNC,
              setLinearVelocity: FUNC,
              getAngularVelocity: FUNC,
              setAngularVelocity: FUNC,
              applyForce: FUNC,
              applyLocalForce: FUNC,
              applyImpulse: FUNC,
              applyLocalImpulse: FUNC,
              applyTorque: FUNC,
              applyLocalTorque: FUNC,
              setGroup: FUNC,
              getGroup: FUNC,
              addGroup: FUNC,
              removeGroup: FUNC,
              setMask: FUNC,
              getMask: FUNC,
              addMask: FUNC,
              removeMask: FUNC,
              isUsingCCD: FUNC,
              useCCD: FUNC
            };
            function createRigidBody() {
              if (check(selector.wrapper.RigidBody, ECheckType.RigidBody)) {
                return ENTIRE_RIGID_BODY;
              }

              return new selector.wrapper.RigidBody();
            }
            var CREATE_COLLIDER_PROXY = {
              INITED: false
            };
            var ENTIRE_SHAPE = {
              impl: null,
              collider: null,
              attachedRigidBody: null,
              initialize: FUNC,
              onLoad: FUNC,
              onEnable: FUNC,
              onDisable: FUNC,
              onDestroy: FUNC,
              setGroup: FUNC,
              getGroup: FUNC,
              addGroup: FUNC,
              removeGroup: FUNC,
              setMask: FUNC,
              getMask: FUNC,
              addMask: FUNC,
              removeMask: FUNC,
              setMaterial: FUNC,
              setAsTrigger: FUNC,
              setCenter: FUNC,
              getAABB: FUNC,
              getBoundingSphere: FUNC,
              updateSize: FUNC,
              updateRadius: FUNC,
              setRadius: FUNC,
              setCylinderHeight: FUNC,
              setDirection: FUNC,
              setHeight: FUNC,
              setShapeType: FUNC,
              setVertices: FUNC,
              setMesh: FUNC,
              setTerrain: FUNC,
              setNormal: FUNC,
              setConstant: FUNC,
              updateEventListener: FUNC
            };
            function createShape(type) {
              initColliderProxy();
              return CREATE_COLLIDER_PROXY[type]();
            }

            function initColliderProxy() {
              if (CREATE_COLLIDER_PROXY.INITED) return;
              CREATE_COLLIDER_PROXY.INITED = true;

              CREATE_COLLIDER_PROXY[EColliderType.BOX] = function createBoxShape() {
                if (check(selector.wrapper.BoxShape, ECheckType.BoxCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.BoxShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.SPHERE] = function createSphereShape() {
                if (check(selector.wrapper.SphereShape, ECheckType.SphereCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.SphereShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.CAPSULE] = function createCapsuleShape() {
                if (check(selector.wrapper.CapsuleShape, ECheckType.CapsuleCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.CapsuleShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.CYLINDER] = function createCylinderShape() {
                if (check(selector.wrapper.CylinderShape, ECheckType.CylinderCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.CylinderShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.CONE] = function createConeShape() {
                if (check(selector.wrapper.ConeShape, ECheckType.ConeCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.ConeShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.MESH] = function createTrimeshShape() {
                if (check(selector.wrapper.TrimeshShape, ECheckType.MeshCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.TrimeshShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.TERRAIN] = function createTerrainShape() {
                if (check(selector.wrapper.TerrainShape, ECheckType.TerrainCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.TerrainShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.SIMPLEX] = function createSimplexShape() {
                if (check(selector.wrapper.SimplexShape, ECheckType.SimplexCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.SimplexShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.PLANE] = function createPlaneShape() {
                if (check(selector.wrapper.PlaneShape, ECheckType.PlaneCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.PlaneShape();
              };
            }

            var CREATE_CONSTRAINT_PROXY = {
              INITED: false
            };
            var ENTIRE_CONSTRAINT = {
              impl: null,
              initialize: FUNC,
              onLoad: FUNC,
              onEnable: FUNC,
              onDisable: FUNC,
              onDestroy: FUNC,
              setEnableCollision: FUNC,
              setConnectedBody: FUNC,
              setPivotA: FUNC,
              setPivotB: FUNC,
              setAxis: FUNC,
              setBreakForce: FUNC,
              setBreakTorque: FUNC
            };
            function createConstraint(type) {
              initConstraintProxy();
              return CREATE_CONSTRAINT_PROXY[type]();
            }

            function initConstraintProxy() {
              if (CREATE_CONSTRAINT_PROXY.INITED) return;
              CREATE_CONSTRAINT_PROXY.INITED = true;

              CREATE_CONSTRAINT_PROXY[EConstraintType.POINT_TO_POINT] = function createPointToPointConstraint() {
                if (check(selector.wrapper.PointToPointConstraint, ECheckType.PointToPointConstraint)) {
                  return ENTIRE_CONSTRAINT;
                }

                return new selector.wrapper.PointToPointConstraint();
              };

              CREATE_CONSTRAINT_PROXY[EConstraintType.HINGE] = function createHingeConstraint() {
                if (check(selector.wrapper.HingeConstraint, ECheckType.HingeConstraint)) {
                  return ENTIRE_CONSTRAINT;
                }

                return new selector.wrapper.HingeConstraint();
              };

              CREATE_CONSTRAINT_PROXY[EConstraintType.CONE_TWIST] = function createConeTwistConstraint() {
                if (check(selector.wrapper.ConeTwistConstraint, ECheckType.ConeTwistConstraint)) {
                  return ENTIRE_CONSTRAINT;
                }

                return new selector.wrapper.ConeTwistConstraint();
              };

              CREATE_CONSTRAINT_PROXY[EConstraintType.FIXED] = function createFixedConstraint() {
                if (check(selector.wrapper.FixedConstraint, ECheckType.FixedConstraint)) {
                  return ENTIRE_CONSTRAINT;
                }

                return new selector.wrapper.FixedConstraint();
              };
            }

            var TriggerEventObject$1 = {
              type: 'onTriggerEnter',
              selfCollider: null,
              otherCollider: null,
              impl: null
            };
            var CollisionEventObject$1 = {
              type: 'onCollisionEnter',
              selfCollider: null,
              otherCollider: null,
              contacts: [],
              impl: null
            };
            var BulletCache = function () {
              function BulletCache() {
                this.BT_TRANSFORM_0 = bt.Transform_new();
                this.BT_TRANSFORM_1 = bt.Transform_new();
                this.BT_V3_0 = bt.Vec3_new(0, 0, 0);
                this.BT_V3_1 = bt.Vec3_new(0, 0, 0);
                this.BT_V3_2 = bt.Vec3_new(0, 0, 0);
                this.BT_QUAT_0 = bt.Quat_new(0, 0, 0, 1);
              }

              BulletCache.setWrapper = function setWrapper(impl, type, wrap) {
                if (!this.ROOT[type]) this.ROOT[type] = {};
                this.ROOT[type][impl] = wrap;
              };

              BulletCache.delWrapper = function delWrapper(impl, type) {
                delete this.ROOT[type][impl];
              };

              BulletCache.getWrapper = function getWrapper(ptr, type) {
                return this.ROOT[type][ptr];
              };

              BulletCache.isNotEmptyShape = function isNotEmptyShape(ptr) {
                return ptr !== bt.EmptyShape_static();
              };

              _createClass(BulletCache, null, [{
                key: "instance",
                get: function get() {
                  if (BulletCache._instance == null) BulletCache._instance = new BulletCache();
                  return BulletCache._instance;
                }
              }]);

              return BulletCache;
            }();
            BulletCache._instance = void 0;
            BulletCache.ROOT = {};
            var CC_V3_0 = new Vec3();
            var CC_V3_1 = new Vec3();
            var CC_QUAT_0 = new Quat();
            var CC_MAT4_0 = new Mat4();
            var CC_MAT4_1 = new Mat4();
            bt.CACHE = BulletCache;

            function cocos2BulletVec3(out, v) {
              bt.Vec3_set(out, v.x, v.y, v.z);
              return out;
            }
            function bullet2CocosVec3(out, v) {
              out.x = bt.Vec3_x(v);
              out.y = bt.Vec3_y(v);
              out.z = bt.Vec3_z(v);
              return out;
            }
            function cocos2BulletQuat(out, q) {
              bt.Quat_set(out, q.x, q.y, q.z, q.w);
              return out;
            }
            function bullet2CocosQuat(out, q) {
              out.x = bt.Quat_x(q);
              out.y = bt.Quat_y(q);
              out.z = bt.Quat_z(q);
              out.w = bt.Quat_w(q);
              return out;
            }
            function cocos2BulletTriMesh(out, mesh) {
              var len = mesh.renderingSubMeshes.length;

              for (var i = 0; i < len; i++) {
                var subMesh = mesh.renderingSubMeshes[i];
                var geoInfo = subMesh.geometricInfo;

                if (geoInfo) {
                  var primitiveMode = subMesh.primitiveMode;
                  var vb = geoInfo.positions;
                  var ib = geoInfo.indices;
                  var v0 = BulletCache.instance.BT_V3_0;
                  var v1 = BulletCache.instance.BT_V3_1;
                  var v2 = BulletCache.instance.BT_V3_2;

                  if (primitiveMode === PrimitiveMode.TRIANGLE_LIST) {
                    var cnt = ib.length;

                    for (var j = 0; j < cnt; j += 3) {
                      var i0 = ib[j] * 3;
                      var i1 = ib[j + 1] * 3;
                      var i2 = ib[j + 2] * 3;
                      bt.Vec3_set(v0, vb[i0], vb[i0 + 1], vb[i0 + 2]);
                      bt.Vec3_set(v1, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                      bt.Vec3_set(v2, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                      bt.TriangleMesh_addTriangle(out, v0, v1, v2);
                    }
                  } else if (primitiveMode === PrimitiveMode.TRIANGLE_STRIP) {
                    var _cnt = ib.length - 2;

                    var rev = 0;

                    for (var _j = 0; _j < _cnt; _j += 1) {
                      var _i = ib[_j - rev] * 3;

                      var _i2 = ib[_j + rev + 1] * 3;

                      var _i3 = ib[_j + 2] * 3;

                      rev = ~rev;
                      bt.Vec3_set(v0, vb[_i], vb[_i + 1], vb[_i + 2]);
                      bt.Vec3_set(v1, vb[_i2], vb[_i2 + 1], vb[_i2 + 2]);
                      bt.Vec3_set(v2, vb[_i3], vb[_i3 + 1], vb[_i3 + 2]);
                      bt.TriangleMesh_addTriangle(out, v0, v1, v2);
                    }
                  } else if (primitiveMode === PrimitiveMode.TRIANGLE_FAN) {
                    var _cnt2 = ib.length - 1;

                    var _i4 = ib[0] * 3;

                    bt.Vec3_set(v0, vb[_i4], vb[_i4 + 1], vb[_i4 + 2]);

                    for (var _j2 = 1; _j2 < _cnt2; _j2 += 1) {
                      var _i5 = ib[_j2] * 3;

                      var _i6 = ib[_j2 + 1] * 3;

                      bt.Vec3_set(v1, vb[_i5], vb[_i5 + 1], vb[_i5 + 2]);
                      bt.Vec3_set(v2, vb[_i6], vb[_i6 + 1], vb[_i6 + 2]);
                      bt.TriangleMesh_addTriangle(out, v0, v1, v2);
                    }
                  }
                }
              }

              return out;
            }

            var _dec$1A, _class$1D, _class2$1n, _initializer$1i, _initializer2$15, _initializer3$S, _initializer4$N, _class3$k, _temp$t;
            var PhysicsMaterial = exports('PhysicsMaterial', (_dec$1A = ccclass$p('cc.PhysicsMaterial'), _dec$1A(_class$1D = (_class2$1n = (_temp$t = _class3$k = function (_Asset) {
              _inheritsLoose(PhysicsMaterial, _Asset);

              function PhysicsMaterial() {
                var _this;

                _this = _Asset.call(this) || this;
                _this.id = void 0;
                _this._friction = _initializer$1i && _initializer$1i();
                _this._rollingFriction = _initializer2$15 && _initializer2$15();
                _this._spinningFriction = _initializer3$S && _initializer3$S();
                _this._restitution = _initializer4$N && _initializer4$N();
                PhysicsMaterial.allMaterials.push(_assertThisInitialized(_this));
                _this.id = PhysicsMaterial._idCounter++;
                if (!_this._uuid) _this._uuid = "pm_" + _this.id;
                return _this;
              }

              var _proto = PhysicsMaterial.prototype;

              _proto.clone = function clone() {
                var c = new PhysicsMaterial();
                c._friction = this._friction;
                c._restitution = this._restitution;
                c._rollingFriction = this._rollingFriction;
                c._spinningFriction = this._spinningFriction;
                return c;
              };

              _proto.destroy = function destroy() {
                if (_Asset.prototype.destroy.call(this)) {
                  var idx = PhysicsMaterial.allMaterials.indexOf(this);

                  if (idx >= 0) {
                    PhysicsMaterial.allMaterials.splice(idx, 1);
                  }

                  return true;
                }

                return false;
              };

              _proto.setValues = function setValues(friction, rollingFriction, spinningFriction, restitution) {
                var emitUpdate = this._friction !== friction || this._rollingFriction !== rollingFriction || this._spinningFriction !== spinningFriction || this._restitution !== restitution;
                this._friction = friction;
                this._rollingFriction = rollingFriction;
                this._spinningFriction = spinningFriction;
                this._restitution = restitution;
                if (emitUpdate) this.emit(PhysicsMaterial.EVENT_UPDATE);
              };

              _createClass(PhysicsMaterial, [{
                key: "friction",
                get: function get() {
                  return this._friction;
                },
                set: function set(value) {
                  if (!equals$1(this._friction, value)) {
                    this._friction = value;
                    this.emit(PhysicsMaterial.EVENT_UPDATE);
                  }
                }
              }, {
                key: "rollingFriction",
                get: function get() {
                  return this._rollingFriction;
                },
                set: function set(value) {
                  if (!equals$1(this._rollingFriction, value)) {
                    this._rollingFriction = value;
                    this.emit(PhysicsMaterial.EVENT_UPDATE);
                  }
                }
              }, {
                key: "spinningFriction",
                get: function get() {
                  return this._spinningFriction;
                },
                set: function set(value) {
                  if (!equals$1(this._spinningFriction, value)) {
                    this._spinningFriction = value;
                    this.emit(PhysicsMaterial.EVENT_UPDATE);
                  }
                }
              }, {
                key: "restitution",
                get: function get() {
                  return this._restitution;
                },
                set: function set(value) {
                  if (!equals$1(this._restitution, value)) {
                    this._restitution = value;
                    this.emit(PhysicsMaterial.EVENT_UPDATE);
                  }
                }
              }]);

              return PhysicsMaterial;
            }(Asset), _class3$k.allMaterials = [], _class3$k.EVENT_UPDATE = 'event_update', _class3$k._idCounter = 0, _temp$t), (_initializer$1i = applyDecoratedInitializer(_class2$1n.prototype, "_friction", [serializable$j], function () {
              return 0.6;
            }), _initializer2$15 = applyDecoratedInitializer(_class2$1n.prototype, "_rollingFriction", [serializable$j], function () {
              return 0.0;
            }), _initializer3$S = applyDecoratedInitializer(_class2$1n.prototype, "_spinningFriction", [serializable$j], function () {
              return 0.0;
            }), _initializer4$N = applyDecoratedInitializer(_class2$1n.prototype, "_restitution", [serializable$j], function () {
              return 0.0;
            })), _class2$1n)) || _class$1D));

            var PhysicsRayResult = exports('PhysicsRayResult', function () {
              function PhysicsRayResult() {
                this._hitPoint = new Vec3();
                this._hitNormal = new Vec3();
                this._distance = 0;
                this._collider = null;
              }

              var _proto = PhysicsRayResult.prototype;

              _proto._assign = function _assign(hitPoint, distance, collider, hitNormal) {
                Vec3.copy(this._hitPoint, hitPoint);
                Vec3.copy(this._hitNormal, hitNormal);
                this._distance = distance;
                this._collider = collider;
              };

              _proto.clone = function clone() {
                var c = new PhysicsRayResult();
                Vec3.copy(c._hitPoint, this._hitPoint);
                Vec3.copy(c._hitNormal, this._hitNormal);
                c._distance = this._distance;
                c._collider = this._collider;
                return c;
              };

              _createClass(PhysicsRayResult, [{
                key: "hitPoint",
                get: function get() {
                  return this._hitPoint;
                }
              }, {
                key: "distance",
                get: function get() {
                  return this._distance;
                }
              }, {
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }, {
                key: "hitNormal",
                get: function get() {
                  return this._hitNormal;
                }
              }]);

              return PhysicsRayResult;
            }());
            var PhysicsLineStripCastResult = function (_PhysicsRayResult) {
              _inheritsLoose(PhysicsLineStripCastResult, _PhysicsRayResult);

              function PhysicsLineStripCastResult() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _PhysicsRayResult.call.apply(_PhysicsRayResult, [this].concat(args)) || this;
                _this._id = 0;
                return _this;
              }

              var _proto2 = PhysicsLineStripCastResult.prototype;

              _proto2._assign = function _assign(hitPoint, distance, collider, hitNormal, id) {
                if (id === void 0) {
                  id = 0;
                }

                _PhysicsRayResult.prototype._assign.call(this, hitPoint, distance, collider, hitNormal);

                this._id = id;
              };

              _proto2.clone = function clone() {
                var c = new PhysicsLineStripCastResult();
                Vec3.copy(c._hitPoint, this._hitPoint);
                Vec3.copy(c._hitNormal, this._hitNormal);
                c._distance = this._distance;
                c._collider = this._collider;
                c._id = this._id;
                return c;
              };

              _createClass(PhysicsLineStripCastResult, [{
                key: "id",
                get: function get() {
                  return this._id;
                }
              }]);

              return PhysicsLineStripCastResult;
            }(PhysicsRayResult);

            var CollisionMatrix = function CollisionMatrix(strategy) {
              if (strategy === 1) {
                var self = this;

                var _loop = function _loop(i) {
                  var key = "_" + (1 << i);
                  self[key] = 0;
                  self.updateArray = [];
                  Object.defineProperty(self, 1 << i, {
                    get: function get() {
                      return this[key];
                    },
                    set: function set(v) {
                      if (this[key] !== v) {
                        this[key] = v;

                        if (this.updateArray.indexOf(i) < 0) {
                          this.updateArray.push(i);
                        }
                      }
                    }
                  });
                };

                for (var i = 0; i < 32; i++) {
                  _loop(i);
                }

                this['_1'] = PhysicsGroup.DEFAULT;
              } else {
                for (var _i = 0; _i < 32; _i++) {
                  var key = 1 << _i;
                  this["" + key] = 0;
                }

                this['1'] = PhysicsGroup.DEFAULT;
              }
            };

            legacyCC.internal.PhysicsGroup = PhysicsGroup;
            var PhysicsSystem = exports('PhysicsSystem', function (_System) {
              _inheritsLoose(PhysicsSystem, _System);

              var _proto = PhysicsSystem.prototype;

              _proto.setDefaultPhysicsMaterial = function setDefaultPhysicsMaterial(material) {
                this._material = material;
                this.physicsWorld.setDefaultMaterial(this._material);

                this._material.on(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);
              };

              _proto.initDefaultMaterial = function initDefaultMaterial() {
                var _this2 = this;

                if (this._material != null) return Promise.resolve();
                var builtinMaterial = builtinResMgr.get('default-physics-material');

                if (!builtinMaterial) {
                  console.error('PhysicsSystem initDefaultMaterial() Failed to load builtinMaterial');
                  return Promise.resolve();
                }

                var userMaterial = settings.querySettings(Settings.Category.PHYSICS, 'defaultMaterial');

                if (!userMaterial) {
                  this.setDefaultPhysicsMaterial(builtinMaterial);
                  return Promise.resolve();
                } else {
                  return new Promise(function (resolve, reject) {
                    assetManager.loadAny(userMaterial, function (err, asset) {
                      return err || !(asset instanceof PhysicsMaterial) ? reject(err) : resolve(asset);
                    });
                  }).then(function (asset) {
                    _this2.setDefaultPhysicsMaterial(asset);
                  })["catch"](function (reason) {
                    warn(reason);
                    warn("Failed to load user customized default physics material: " + userMaterial + ", will fallback to built-in default physics material");

                    _this2.setDefaultPhysicsMaterial(builtinMaterial);
                  });
                }
              };

              function PhysicsSystem() {
                var _this;

                _this = _System.call(this) || this;
                _this.raycastClosestResult = new PhysicsRayResult();
                _this.raycastResults = [];
                _this.lineStripCastClosestResult = new PhysicsLineStripCastResult();
                _this.lineStripCastResults = [];
                _this.collisionMatrix = new CollisionMatrix(1);
                _this.minVolumeSize = 1e-5;
                _this.useNodeChains = false;
                _this._enable = true;
                _this._allowSleep = true;
                _this._maxSubSteps = 1;
                _this._subStepCount = 0;
                _this._fixedTimeStep = 1.0 / 60.0;
                _this._autoSimulation = true;
                _this._accumulator = 0;
                _this._sleepThreshold = 0.1;
                _this._gravity = new Vec3(0, -10, 0);
                _this.raycastOptions = {
                  group: -1,
                  mask: -1,
                  queryTrigger: true,
                  maxDistance: 10000000
                };
                _this.raycastResultPool = new RecyclePool(function () {
                  return new PhysicsRayResult();
                }, 1);
                return _this;
              }

              _proto.postUpdate = function postUpdate(deltaTime) {
                if (!this.physicsWorld) return;

                if (!this._enable) {
                  this.physicsWorld.syncSceneToPhysics();
                  return;
                }

                if (this._autoSimulation) {
                  this._subStepCount = 0;
                  this._accumulator += deltaTime;
                  director.emit(Director.EVENT_BEFORE_PHYSICS);

                  while (this._subStepCount < this._maxSubSteps) {
                    if (this._accumulator >= this._fixedTimeStep) {
                      this.physicsWorld.syncSceneToPhysics();
                      this.physicsWorld.step(this._fixedTimeStep);
                      this.physicsWorld.emitEvents();
                      this.physicsWorld.syncAfterEvents();
                      this._accumulator -= this._fixedTimeStep;
                      this._subStepCount++;
                    } else {
                      this.physicsWorld.syncSceneToPhysics();
                      break;
                    }
                  }

                  director.emit(Director.EVENT_AFTER_PHYSICS);
                }
              };

              _proto.resetConfiguration = function resetConfiguration(config) {
                var allowSleep = config ? config.allowSleep : settings.querySettings(Settings.Category.PHYSICS, 'allowSleep');
                if (typeof allowSleep === 'boolean') this._allowSleep = allowSleep;
                var fixedTimeStep = config ? config.fixedTimeStep : settings.querySettings(Settings.Category.PHYSICS, 'fixedTimeStep');
                if (typeof fixedTimeStep === 'number') this._fixedTimeStep = fixedTimeStep;
                var maxSubSteps = config ? config.maxSubSteps : settings.querySettings(Settings.Category.PHYSICS, 'maxSubSteps');
                if (typeof maxSubSteps === 'number') this._maxSubSteps = maxSubSteps;
                var sleepThreshold = config ? config.sleepThreshold : settings.querySettings(Settings.Category.PHYSICS, 'sleepThreshold');
                if (typeof sleepThreshold === 'number') this._sleepThreshold = sleepThreshold;
                var autoSimulation = config ? config.autoSimulation : settings.querySettings(Settings.Category.PHYSICS, 'autoSimulation');
                if (typeof autoSimulation === 'boolean') this.autoSimulation = autoSimulation;
                var gravity = config ? config.gravity : settings.querySettings(Settings.Category.PHYSICS, 'gravity');
                if (gravity) Vec3.copy(this._gravity, gravity);
                var collisionMatrix = config ? config.collisionMatrix : settings.querySettings(Settings.Category.PHYSICS, 'collisionMatrix');

                if (collisionMatrix) {
                  for (var i in collisionMatrix) {
                    this.collisionMatrix["" + (1 << parseInt(i))] = collisionMatrix[i];
                  }
                }

                var collisionGroups = config ? config.collisionGroups : settings.querySettings(Settings.Category.PHYSICS, 'collisionGroups');

                if (collisionGroups) {
                  var cg = collisionGroups;

                  if (cg instanceof Array) {
                    cg.forEach(function (v) {
                      PhysicsGroup[v.name] = 1 << v.index;
                    });
                    Enum.update(PhysicsGroup);
                  }
                }

                if (this.physicsWorld) {
                  this.physicsWorld.setGravity(this._gravity);
                  this.physicsWorld.setAllowSleep(this._allowSleep);
                }
              };

              _proto.resetAccumulator = function resetAccumulator(time) {
                if (time === void 0) {
                  time = 0;
                }

                this._accumulator = time;
              };

              _proto.step = function step(fixedTimeStep, deltaTime, maxSubSteps) {
                if (this.physicsWorld) this.physicsWorld.step(fixedTimeStep, deltaTime, maxSubSteps);
              };

              _proto.syncSceneToPhysics = function syncSceneToPhysics() {
                if (this.physicsWorld) this.physicsWorld.syncSceneToPhysics();
              };

              _proto.emitEvents = function emitEvents() {
                if (this.physicsWorld) this.physicsWorld.emitEvents();
              };

              _proto.raycast = function raycast(worldRay, mask, maxDistance, queryTrigger) {
                if (mask === void 0) {
                  mask = 0xffffffff;
                }

                if (maxDistance === void 0) {
                  maxDistance = 10000000;
                }

                if (queryTrigger === void 0) {
                  queryTrigger = true;
                }

                if (!this.physicsWorld) return false;
                this.raycastResultPool.reset();
                this.raycastResults.length = 0;
                this.raycastOptions.mask = mask >>> 0;
                this.raycastOptions.maxDistance = maxDistance;
                this.raycastOptions.queryTrigger = queryTrigger;
                return this.physicsWorld.raycast(worldRay, this.raycastOptions, this.raycastResultPool, this.raycastResults);
              };

              _proto.raycastClosest = function raycastClosest(worldRay, mask, maxDistance, queryTrigger) {
                if (mask === void 0) {
                  mask = 0xffffffff;
                }

                if (maxDistance === void 0) {
                  maxDistance = 10000000;
                }

                if (queryTrigger === void 0) {
                  queryTrigger = true;
                }

                if (!this.physicsWorld) return false;
                this.raycastOptions.mask = mask >>> 0;
                this.raycastOptions.maxDistance = maxDistance;
                this.raycastOptions.queryTrigger = queryTrigger;
                return this.physicsWorld.raycastClosest(worldRay, this.raycastOptions, this.raycastClosestResult);
              };

              _proto.lineStripCast = function lineStripCast(samplePointsWorldSpace, mask, maxDistance, queryTrigger) {
                if (mask === void 0) {
                  mask = 0xffffffff;
                }

                if (maxDistance === void 0) {
                  maxDistance = 10000000;
                }

                if (queryTrigger === void 0) {
                  queryTrigger = true;
                }

                if (samplePointsWorldSpace.length < 2) return false;
                this.lineStripCastResults = [];
                var distance = 0;
                var worldRay = new Ray();

                for (var i = 1; i < samplePointsWorldSpace.length; ++i) {
                  if (distance > maxDistance) break;
                  var fromPoint = samplePointsWorldSpace[i - 1];
                  var toPoint = samplePointsWorldSpace[i];
                  var direction = new Vec3();
                  Vec3.subtract(direction, toPoint, fromPoint);
                  var stepLength = Vec3.len(direction);
                  distance += stepLength;
                  Vec3.multiplyScalar(direction, direction, 1.0 / stepLength);
                  worldRay.d = direction;
                  worldRay.o = fromPoint;
                  var hit = this.raycast(worldRay, mask, stepLength, queryTrigger);

                  if (hit) {
                    for (var re = 0; re < this.raycastResults.length; re++) {
                      var result = this.raycastResults[re];

                      if (re === 0 && Vec3.equals(fromPoint, result.hitPoint)) {
                        continue;
                      }

                      var copiedResult = new PhysicsLineStripCastResult();

                      copiedResult._assign(result.hitPoint, result.distance, result.collider, result.hitNormal, i - 1);

                      this.lineStripCastResults.push(copiedResult);
                    }
                  }
                }

                return this.lineStripCastResults.length > 0;
              };

              _proto.lineStripCastClosest = function lineStripCastClosest(samplePointsWorldSpace, mask, maxDistance, queryTrigger) {
                if (mask === void 0) {
                  mask = 0xffffffff;
                }

                if (maxDistance === void 0) {
                  maxDistance = 10000000;
                }

                if (queryTrigger === void 0) {
                  queryTrigger = true;
                }

                if (samplePointsWorldSpace.length < 2) {
                  return false;
                }

                var distance = 0;
                var worldRay = new Ray();
                var hit = false;

                for (var i = 1; i < samplePointsWorldSpace.length; ++i) {
                  if (distance > maxDistance) break;
                  var fromPoint = samplePointsWorldSpace[i - 1];
                  var toPoint = samplePointsWorldSpace[i];
                  var direction = new Vec3();
                  Vec3.subtract(direction, toPoint, fromPoint);
                  var stepLength = Vec3.len(direction);
                  distance += stepLength;
                  Vec3.multiplyScalar(direction, direction, 1.0 / stepLength);
                  worldRay.d = direction;
                  worldRay.o = fromPoint;
                  hit = this.raycastClosest(worldRay, mask, stepLength, queryTrigger);

                  if (hit) {
                    var result = this.raycastClosestResult;
                    var copiedResult = new PhysicsLineStripCastResult();

                    copiedResult._assign(result.hitPoint, result.distance, result.collider, result.hitNormal, i - 1);

                    this.lineStripCastClosestResult = copiedResult;
                    break;
                  }
                }

                return hit;
              };

              _proto._updateMaterial = function _updateMaterial() {
                if (this.physicsWorld) this.physicsWorld.setDefaultMaterial(this._material);
              };

              PhysicsSystem.constructAndRegister = function constructAndRegister() {
                var _settings$querySettin;

                var enabled = (_settings$querySettin = settings.querySettings(Settings.Category.PHYSICS, 'enabled')) !== null && _settings$querySettin !== void 0 ? _settings$querySettin : true;

                if (!enabled) {
                  return;
                }

                if (!PhysicsSystem._instance) {
                  var sys = new PhysicsSystem();
                  sys.resetConfiguration();
                  constructDefaultWorld(sys);
                  PhysicsSystem._instance = sys;
                  director.registerSystem(PhysicsSystem.ID, sys, sys.priority);
                  game.onPostProjectInitDelegate.add(sys.initDefaultMaterial.bind(sys));
                }
              };

              _createClass(PhysicsSystem, [{
                key: "enable",
                get: function get() {
                  return this._enable;
                },
                set: function set(value) {
                  this._enable = value;
                }
              }, {
                key: "allowSleep",
                get: function get() {
                  return this._allowSleep;
                },
                set: function set(v) {
                  this._allowSleep = v;

                  if (this.physicsWorld) {
                    this.physicsWorld.setAllowSleep(v);
                  }
                }
              }, {
                key: "maxSubSteps",
                get: function get() {
                  return this._maxSubSteps;
                },
                set: function set(value) {
                  this._maxSubSteps = value;
                }
              }, {
                key: "fixedTimeStep",
                get: function get() {
                  return this._fixedTimeStep;
                },
                set: function set(value) {
                  this._fixedTimeStep = value;
                }
              }, {
                key: "gravity",
                get: function get() {
                  return this._gravity;
                },
                set: function set(gravity) {
                  this._gravity.set(gravity);

                  if (this.physicsWorld) {
                    this.physicsWorld.setGravity(gravity);
                  }
                }
              }, {
                key: "sleepThreshold",
                get: function get() {
                  return this._sleepThreshold;
                },
                set: function set(v) {
                  this._sleepThreshold = v;
                }
              }, {
                key: "autoSimulation",
                get: function get() {
                  return this._autoSimulation;
                },
                set: function set(value) {
                  this._autoSimulation = value;
                }
              }, {
                key: "defaultMaterial",
                get: function get() {
                  return this._material;
                }
              }, {
                key: "physicsWorld",
                get: function get() {
                  return selector.physicsWorld;
                }
              }], [{
                key: "PHYSICS_NONE",
                get: function get() {
                  return !selector.id;
                }
              }, {
                key: "PHYSICS_BUILTIN",
                get: function get() {
                  return selector.id === 'builtin';
                }
              }, {
                key: "PHYSICS_CANNON",
                get: function get() {
                  return selector.id === 'cannon.js';
                }
              }, {
                key: "PHYSICS_BULLET",
                get: function get() {
                  return selector.id === 'bullet';
                }
              }, {
                key: "PHYSICS_PHYSX",
                get: function get() {
                  return selector.id === 'physx';
                }
              }, {
                key: "PhysicsGroup",
                get: function get() {
                  return PhysicsGroup;
                }
              }, {
                key: "instance",
                get: function get() {
                  return PhysicsSystem._instance;
                }
              }]);

              return PhysicsSystem;
            }(System));
            PhysicsSystem.ID = 'PHYSICS';
            PhysicsSystem._instance = null;
            director.once(Director.EVENT_INIT, function () {
              PhysicsSystem.constructAndRegister();
            });

            var _dec$1B, _dec2$19, _dec3$P, _dec4$z, _class$1E, _class2$1o, _initializer$1j, _initializer2$16, _initializer3$T, _initializer4$O, _initializer5$E, _initializer6$x, _initializer7$p, _initializer8$n, _initializer9$k, _class3$l, _temp$u;
            var RigidBody = exports('RigidBody', (_dec$1B = ccclass$p('cc.RigidBody'), _dec2$19 = executionOrder(-1), _dec3$P = type$8(PhysicsSystem.PhysicsGroup), _dec4$z = type$8(ERigidBodyType), _dec$1B(_class$1E = disallowMultiple(_class$1E = _dec2$19(_class$1E = (_class2$1o = (_temp$u = _class3$l = function (_Component) {
              _inheritsLoose(RigidBody, _Component);

              function RigidBody() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._body = null;
                _this._group = _initializer$1j && _initializer$1j();
                _this._type = _initializer2$16 && _initializer2$16();
                _this._mass = _initializer3$T && _initializer3$T();
                _this._allowSleep = _initializer4$O && _initializer4$O();
                _this._linearDamping = _initializer5$E && _initializer5$E();
                _this._angularDamping = _initializer6$x && _initializer6$x();
                _this._useGravity = _initializer7$p && _initializer7$p();
                _this._linearFactor = _initializer8$n && _initializer8$n();
                _this._angularFactor = _initializer9$k && _initializer9$k();
                return _this;
              }

              var _proto = RigidBody.prototype;

              _proto.onLoad = function onLoad() {
                if (!selector.runInEditor) return;
                this._body = createRigidBody();

                this._body.initialize(this);
              };

              _proto.onEnable = function onEnable() {
                if (this._body) this._body.onEnable();
              };

              _proto.onDisable = function onDisable() {
                if (this._body) this._body.onDisable();
              };

              _proto.onDestroy = function onDestroy() {
                if (this._body) this._body.onDestroy();
              };

              _proto.applyForce = function applyForce(force, relativePoint) {
                if (this._isInitialized) this._body.applyForce(force, relativePoint);
              };

              _proto.applyLocalForce = function applyLocalForce(force, localPoint) {
                if (this._isInitialized) this._body.applyLocalForce(force, localPoint);
              };

              _proto.applyImpulse = function applyImpulse(impulse, relativePoint) {
                if (this._isInitialized) this._body.applyImpulse(impulse, relativePoint);
              };

              _proto.applyLocalImpulse = function applyLocalImpulse(impulse, localPoint) {
                if (this._isInitialized) this._body.applyLocalImpulse(impulse, localPoint);
              };

              _proto.applyTorque = function applyTorque(torque) {
                if (this._isInitialized) this._body.applyTorque(torque);
              };

              _proto.applyLocalTorque = function applyLocalTorque(torque) {
                if (this._isInitialized) this._body.applyLocalTorque(torque);
              };

              _proto.wakeUp = function wakeUp() {
                if (this._isInitialized) this._body.wakeUp();
              };

              _proto.sleep = function sleep() {
                if (this._isInitialized) this._body.sleep();
              };

              _proto.clearState = function clearState() {
                if (this._isInitialized) this._body.clearState();
              };

              _proto.clearForces = function clearForces() {
                if (this._isInitialized) this._body.clearForces();
              };

              _proto.clearVelocity = function clearVelocity() {
                if (this._isInitialized) this._body.clearVelocity();
              };

              _proto.getLinearVelocity = function getLinearVelocity(out) {
                if (this._isInitialized) this._body.getLinearVelocity(out);
              };

              _proto.setLinearVelocity = function setLinearVelocity(value) {
                if (this._isInitialized) this._body.setLinearVelocity(value);
              };

              _proto.getAngularVelocity = function getAngularVelocity(out) {
                if (this._isInitialized) this._body.getAngularVelocity(out);
              };

              _proto.setAngularVelocity = function setAngularVelocity(value) {
                if (this._isInitialized) this._body.setAngularVelocity(value);
              };

              _proto.getGroup = function getGroup() {
                if (this._isInitialized) return this._body.getGroup();
                return 0;
              };

              _proto.setGroup = function setGroup(v) {
                if (this._isInitialized) this._body.setGroup(v);
              };

              _proto.addGroup = function addGroup(v) {
                if (this._isInitialized) this._body.addGroup(v);
              };

              _proto.removeGroup = function removeGroup(v) {
                if (this._isInitialized) this._body.removeGroup(v);
              };

              _proto.getMask = function getMask() {
                if (this._isInitialized) return this._body.getMask();
                return 0;
              };

              _proto.setMask = function setMask(v) {
                if (this._isInitialized) this._body.setMask(v);
              };

              _proto.addMask = function addMask(v) {
                if (this._isInitialized) this._body.addMask(v);
              };

              _proto.removeMask = function removeMask(v) {
                if (this._isInitialized) this._body.removeMask(v);
              };

              _createClass(RigidBody, [{
                key: "group",
                get: function get() {
                  return this._group;
                },
                set: function set(v) {
                  if ( !Number.isInteger(Math.log2(v >>> 0))) warn('[Physics]: The group should only have one bit.');
                  this._group = v;

                  if (this._body) {
                    if (this._body.getGroup() !== v) this._body.setGroup(v);
                  }
                }
              }, {
                key: "type",
                get: function get() {
                  return this._type;
                },
                set: function set(v) {
                  if (this._type === v) return;
                  this._type = v;
                  if (this._body) this._body.setType(v);
                }
              }, {
                key: "mass",
                get: function get() {
                  return this._mass;
                },
                set: function set(value) {
                  if ( value <= 0) warn('[Physics]: The mass should be greater than zero.');
                  if (this._mass === value) return;
                  value = value <= 0 ? 0.0001 : value;
                  this._mass = value;
                  if (this._body) this._body.setMass(value);
                }
              }, {
                key: "allowSleep",
                get: function get() {
                  return this._allowSleep;
                },
                set: function set(v) {
                  this._allowSleep = v;
                  if (this._body) this._body.setAllowSleep(v);
                }
              }, {
                key: "linearDamping",
                get: function get() {
                  return this._linearDamping;
                },
                set: function set(value) {
                  if ( (value < 0 || value > 1)) warn('[Physics]: The damping should be between zero to one.');
                  this._linearDamping = value;
                  if (this._body) this._body.setLinearDamping(value);
                }
              }, {
                key: "angularDamping",
                get: function get() {
                  return this._angularDamping;
                },
                set: function set(value) {
                  if ( (value < 0 || value > 1)) warn('[Physics]: The damping should be between zero to one.');
                  this._angularDamping = value;
                  if (this._body) this._body.setAngularDamping(value);
                }
              }, {
                key: "useGravity",
                get: function get() {
                  return this._useGravity;
                },
                set: function set(value) {
                  this._useGravity = value;
                  if (this._body) this._body.useGravity(value);
                }
              }, {
                key: "linearFactor",
                get: function get() {
                  return this._linearFactor;
                },
                set: function set(value) {
                  Vec3.copy(this._linearFactor, value);

                  if (this._body) {
                    this._body.setLinearFactor(this._linearFactor);
                  }
                }
              }, {
                key: "angularFactor",
                get: function get() {
                  return this._angularFactor;
                },
                set: function set(value) {
                  Vec3.copy(this._angularFactor, value);

                  if (this._body) {
                    this._body.setAngularFactor(this._angularFactor);
                  }
                }
              }, {
                key: "sleepThreshold",
                get: function get() {
                  if (this._isInitialized) {
                    return this._body.getSleepThreshold();
                  }

                  return 0.1;
                },
                set: function set(v) {
                  if (this._isInitialized) {
                    this._body.setSleepThreshold(v);
                  }
                }
              }, {
                key: "useCCD",
                get: function get() {
                  if (this._isInitialized) {
                    return this._body.isUsingCCD();
                  }

                  return false;
                },
                set: function set(v) {
                  if (this._isInitialized) {
                    this._body.useCCD(v);
                  }
                }
              }, {
                key: "isAwake",
                get: function get() {
                  if (this._isInitialized) return this._body.isAwake;
                  return false;
                }
              }, {
                key: "isSleepy",
                get: function get() {
                  if (this._isInitialized) return this._body.isSleepy;
                  return false;
                }
              }, {
                key: "isSleeping",
                get: function get() {
                  if (this._isInitialized) return this._body.isSleeping;
                  return false;
                }
              }, {
                key: "isStatic",
                get: function get() {
                  return this._type === ERigidBodyType.STATIC;
                },
                set: function set(v) {
                  if (v && this.isStatic || !v && !this.isStatic) return;
                  this.type = v ? ERigidBodyType.STATIC : ERigidBodyType.DYNAMIC;
                }
              }, {
                key: "isDynamic",
                get: function get() {
                  return this._type === ERigidBodyType.DYNAMIC;
                },
                set: function set(v) {
                  if (v && this.isDynamic || !v && !this.isDynamic) return;
                  this.type = v ? ERigidBodyType.DYNAMIC : ERigidBodyType.KINEMATIC;
                }
              }, {
                key: "isKinematic",
                get: function get() {
                  return this._type === ERigidBodyType.KINEMATIC;
                },
                set: function set(v) {
                  if (v && this.isKinematic || !v && !this.isKinematic) return;
                  this.type = v ? ERigidBodyType.KINEMATIC : ERigidBodyType.DYNAMIC;
                }
              }, {
                key: "body",
                get: function get() {
                  return this._body;
                }
              }, {
                key: "_isInitialized",
                get: function get() {
                  var r = this._body === null;

                  if (r) {
                    error('[Physics]: This component has not been call onLoad yet, please make sure the node has been added to the scene.');
                  }

                  return !r;
                }
              }]);

              return RigidBody;
            }(Component), _class3$l.Type = ERigidBodyType, _temp$u), (_applyDecoratedDescriptor(_class2$1o.prototype, "group", [_dec3$P], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "group"), _class2$1o.prototype), _applyDecoratedDescriptor(_class2$1o.prototype, "type", [_dec4$z], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "type"), _class2$1o.prototype), _initializer$1j = applyDecoratedInitializer(_class2$1o.prototype, "_group", [serializable$j], function () {
              return PhysicsSystem.PhysicsGroup.DEFAULT;
            }), _initializer2$16 = applyDecoratedInitializer(_class2$1o.prototype, "_type", [serializable$j], function () {
              return ERigidBodyType.DYNAMIC;
            }), _initializer3$T = applyDecoratedInitializer(_class2$1o.prototype, "_mass", [serializable$j], function () {
              return 1;
            }), _initializer4$O = applyDecoratedInitializer(_class2$1o.prototype, "_allowSleep", [serializable$j], function () {
              return true;
            }), _initializer5$E = applyDecoratedInitializer(_class2$1o.prototype, "_linearDamping", [serializable$j], function () {
              return 0.1;
            }), _initializer6$x = applyDecoratedInitializer(_class2$1o.prototype, "_angularDamping", [serializable$j], function () {
              return 0.1;
            }), _initializer7$p = applyDecoratedInitializer(_class2$1o.prototype, "_useGravity", [serializable$j], function () {
              return true;
            }), _initializer8$n = applyDecoratedInitializer(_class2$1o.prototype, "_linearFactor", [serializable$j], function () {
              return new Vec3(1, 1, 1);
            }), _initializer9$k = applyDecoratedInitializer(_class2$1o.prototype, "_angularFactor", [serializable$j], function () {
              return new Vec3(1, 1, 1);
            })), _class2$1o)) || _class$1E) || _class$1E) || _class$1E));

            (function (_RigidBody) {})(RigidBody || (RigidBody = exports('RigidBody', {})));

            var _dec$1C, _dec2$1a, _dec3$Q, _dec4$A, _dec5$t, _class$1F, _class2$1p, _initializer$1k, _initializer2$17, _initializer3$U, _class3$m, _temp$v;
            var Collider = exports('Collider', (_dec$1C = ccclass$p('cc.Collider'), _dec2$1a = type$8(RigidBody), _dec3$Q = type$8(PhysicsMaterial), _dec4$A = type$8(Vec3), _dec5$t = type$8(PhysicsMaterial), _dec$1C(_class$1F = (_class2$1p = (_temp$v = _class3$m = function (_Eventify) {
              _inheritsLoose(Collider, _Eventify);

              function Collider(type) {
                var _this;

                _this = _Eventify.call(this) || this;
                _this.type = void 0;
                _this._shape = null;
                _this._aabb = null;
                _this._boundingSphere = null;
                _this._isSharedMaterial = true;
                _this._needTriggerEvent = false;
                _this._needCollisionEvent = false;
                _this._material = _initializer$1k && _initializer$1k();
                _this._isTrigger = _initializer2$17 && _initializer2$17();
                _this._center = _initializer3$U && _initializer3$U();
                _this.type = type;
                return _this;
              }

              var _proto = Collider.prototype;

              _proto.on = function on(type, callback, target, once) {
                var ret = _Eventify.prototype.on.call(this, type, callback, target, once);

                this._updateNeedEvent(type);

                return ret;
              };

              _proto.off = function off(type, callback, target) {
                _Eventify.prototype.off.call(this, type, callback, target);

                this._updateNeedEvent();
              };

              _proto.once = function once(type, callback, target) {
                var ret = _Eventify.prototype.once.call(this, type, callback, target);

                this._updateNeedEvent(type);

                return ret;
              };

              _proto.removeAll = function removeAll(typeOrTarget) {
                _Eventify.prototype.removeAll.call(this, typeOrTarget);

                this._updateNeedEvent();
              };

              _proto.getGroup = function getGroup() {
                if (this._isInitialized) {
                  return this._shape.getGroup();
                }

                return 0;
              };

              _proto.setGroup = function setGroup(v) {
                if (this._isInitialized) {
                  this._shape.setGroup(v);
                }
              };

              _proto.addGroup = function addGroup(v) {
                if (this._isInitialized) {
                  this._shape.addGroup(v);
                }
              };

              _proto.removeGroup = function removeGroup(v) {
                if (this._isInitialized) {
                  this._shape.removeGroup(v);
                }
              };

              _proto.getMask = function getMask() {
                if (this._isInitialized) {
                  return this._shape.getMask();
                }

                return 0;
              };

              _proto.setMask = function setMask(v) {
                if (this._isInitialized) {
                  this._shape.setMask(v);
                }
              };

              _proto.addMask = function addMask(v) {
                if (this._isInitialized) {
                  this._shape.addMask(v);
                }
              };

              _proto.removeMask = function removeMask(v) {
                if (this._isInitialized) {
                  this._shape.removeMask(v);
                }
              };

              _proto.onLoad = function onLoad() {
                if (!selector.runInEditor) return;
                this.sharedMaterial = this._material;
                this._shape = createShape(this.type);

                this._shape.initialize(this);

                this._shape.onLoad();
              };

              _proto.onEnable = function onEnable() {
                if (this._shape) {
                  this._shape.onEnable();
                }
              };

              _proto.onDisable = function onDisable() {
                if (this._shape) {
                  this._shape.onDisable();
                }
              };

              _proto.onDestroy = function onDestroy() {
                if (this._shape) {
                  this._needTriggerEvent = false;
                  this._needCollisionEvent = false;

                  this._shape.updateEventListener();

                  if (this._material) this._material.off(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);

                  this._shape.onDestroy();
                }

                if (this._boundingSphere) this._boundingSphere.destroy();
              };

              _proto._updateMaterial = function _updateMaterial() {
                if (this._shape) this._shape.setMaterial(this._material);
              };

              _proto._updateNeedEvent = function _updateNeedEvent(type) {
                if (this.isValid) {
                  if (type !== undefined) {
                    if (type === 'onCollisionEnter' || type === 'onCollisionStay' || type === 'onCollisionExit') {
                      this._needCollisionEvent = true;
                    }

                    if (type === 'onTriggerEnter' || type === 'onTriggerStay' || type === 'onTriggerExit') {
                      this._needTriggerEvent = true;
                    }
                  } else {
                    if (!(this.hasEventListener('onTriggerEnter') || this.hasEventListener('onTriggerStay') || this.hasEventListener('onTriggerExit'))) {
                      this._needTriggerEvent = false;
                    }

                    if (!(this.hasEventListener('onCollisionEnter') || this.hasEventListener('onCollisionStay') || this.hasEventListener('onCollisionExit'))) {
                      this._needCollisionEvent = false;
                    }
                  }

                  if (this._shape) this._shape.updateEventListener();
                }
              };

              _createClass(Collider, [{
                key: "attachedRigidBody",
                get: function get() {
                  return findAttachedBody(this.node);
                }
              }, {
                key: "sharedMaterial",
                get: function get() {
                  return this._material;
                },
                set: function set(value) {
                  {
                    this.material = value;
                  }
                }
              }, {
                key: "material",
                get: function get() {
                  if (this._isSharedMaterial && this._material) {
                    this._material.off(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);

                    this._material = this._material.clone();

                    this._material.on(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);

                    this._isSharedMaterial = false;
                  }

                  return this._material;
                },
                set: function set(value) {
                  if (this._shape) {
                    if (value && this._material) {
                      if (this._material.id !== value.id) {
                        this._material.off(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);

                        value.on(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);
                        this._isSharedMaterial = false;
                        this._material = value;
                      }
                    } else if (value && !this._material) {
                      value.on(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);
                      this._material = value;
                    } else if (!value && this._material) {
                      this._material.off(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);

                      this._material = value;
                    }

                    this._updateMaterial();
                  } else {
                    this._material = value;
                  }
                }
              }, {
                key: "isTrigger",
                get: function get() {
                  return this._isTrigger;
                },
                set: function set(value) {
                  this._isTrigger = value;

                  if (this._shape) {
                    this._shape.setAsTrigger(this._isTrigger);
                  }
                }
              }, {
                key: "center",
                get: function get() {
                  return this._center;
                },
                set: function set(value) {
                  Vec3.copy(this._center, value);

                  if (this._shape) {
                    this._shape.setCenter(this._center);
                  }
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }, {
                key: "worldBounds",
                get: function get() {
                  if (this._aabb == null) this._aabb = new AABB();
                  if (this._shape) this._shape.getAABB(this._aabb);
                  return this._aabb;
                }
              }, {
                key: "boundingSphere",
                get: function get() {
                  if (this._boundingSphere == null) this._boundingSphere = new Sphere();
                  if (this._shape) this._shape.getBoundingSphere(this._boundingSphere);
                  return this._boundingSphere;
                }
              }, {
                key: "needTriggerEvent",
                get: function get() {
                  return this._needTriggerEvent;
                }
              }, {
                key: "needCollisionEvent",
                get: function get() {
                  return this._needCollisionEvent;
                }
              }, {
                key: "_isInitialized",
                get: function get() {
                  var r = this._shape === null;

                  if (r) {
                    error('[Physics]: This component has not been call onLoad yet, please make sure the node has been added to the scene.');
                  }

                  return !r;
                }
              }]);

              return Collider;
            }(Eventify(Component)), _class3$m.Type = EColliderType, _class3$m.Axis = EAxisDirection, _temp$v), (_applyDecoratedDescriptor(_class2$1p.prototype, "attachedRigidBody", [_dec2$1a], Object.getOwnPropertyDescriptor(_class2$1p.prototype, "attachedRigidBody"), _class2$1p.prototype), _applyDecoratedDescriptor(_class2$1p.prototype, "sharedMaterial", [_dec3$Q], Object.getOwnPropertyDescriptor(_class2$1p.prototype, "sharedMaterial"), _class2$1p.prototype), _applyDecoratedDescriptor(_class2$1p.prototype, "center", [_dec4$A], Object.getOwnPropertyDescriptor(_class2$1p.prototype, "center"), _class2$1p.prototype), _initializer$1k = applyDecoratedInitializer(_class2$1p.prototype, "_material", [_dec5$t], function () {
              return null;
            }), _initializer2$17 = applyDecoratedInitializer(_class2$1p.prototype, "_isTrigger", [serializable$j], function () {
              return false;
            }), _initializer3$U = applyDecoratedInitializer(_class2$1p.prototype, "_center", [serializable$j], function () {
              return new Vec3();
            })), _class2$1p)) || _class$1F));

            (function (_Collider) {})(Collider || (Collider = exports('Collider', {})));

            function findAttachedBody(node) {
              var rb = node.getComponent(RigidBody);

              if (rb && rb.isValid) {
                return rb;
              }

              return null;
            }

            var _dec$1D, _dec2$1b, _class$1G, _class2$1q, _initializer$1l;
            var BoxCollider = exports('BoxCollider', (_dec$1D = ccclass$p('cc.BoxCollider'), _dec2$1b = type$8(Vec3), _dec$1D(_class$1G = (_class2$1q = function (_Collider) {
              _inheritsLoose(BoxCollider, _Collider);

              function BoxCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.BOX) || this;
                _this._size = _initializer$1l && _initializer$1l();
                return _this;
              }

              _createClass(BoxCollider, [{
                key: "size",
                get: function get() {
                  return this._size;
                },
                set: function set(value) {
                  if (Vec3.strictEquals(this._size, value)) return;
                  Vec3.copy(this._size, value);
                  absolute(this._size);

                  if (this._shape) {
                    this.shape.updateSize();
                  }
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }]);

              return BoxCollider;
            }(Collider), (_applyDecoratedDescriptor(_class2$1q.prototype, "size", [_dec2$1b], Object.getOwnPropertyDescriptor(_class2$1q.prototype, "size"), _class2$1q.prototype), _initializer$1l = applyDecoratedInitializer(_class2$1q.prototype, "_size", [serializable$j], function () {
              return new Vec3(1, 1, 1);
            })), _class2$1q)) || _class$1G));

            var _dec$1E, _class$1H, _class2$1r, _initializer$1m;
            var SphereCollider = exports('SphereCollider', (_dec$1E = ccclass$p('cc.SphereCollider'), _dec$1E(_class$1H = (_class2$1r = function (_Collider) {
              _inheritsLoose(SphereCollider, _Collider);

              function SphereCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.SPHERE) || this;
                _this._radius = _initializer$1m && _initializer$1m();
                return _this;
              }

              _createClass(SphereCollider, [{
                key: "radius",
                get: function get() {
                  return this._radius;
                },
                set: function set(value) {
                  if (this._radius === value) return;
                  this._radius = Math.abs(value);

                  if (this._shape) {
                    this.shape.updateRadius();
                  }
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }]);

              return SphereCollider;
            }(Collider), (_initializer$1m = applyDecoratedInitializer(_class2$1r.prototype, "_radius", [serializable$j], function () {
              return 0.5;
            })), _class2$1r)) || _class$1H));

            var _dec$1F, _dec2$1c, _class$1I, _class2$1s, _initializer$1n, _initializer2$18, _initializer3$V;
            var CapsuleCollider = exports('CapsuleCollider', (_dec$1F = ccclass$p('cc.CapsuleCollider'), _dec2$1c = type$8(EAxisDirection), _dec$1F(_class$1I = (_class2$1s = function (_Collider) {
              _inheritsLoose(CapsuleCollider, _Collider);

              function CapsuleCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.CAPSULE) || this;
                _this._radius = _initializer$1n && _initializer$1n();
                _this._cylinderHeight = _initializer2$18 && _initializer2$18();
                _this._direction = _initializer3$V && _initializer3$V();
                return _this;
              }

              var _proto = CapsuleCollider.prototype;

              _proto._getRadiusScale = function _getRadiusScale() {
                if (this.node == null) return 1;
                var ws = this.node.worldScale;
                if (this._direction === EAxisDirection.Y_AXIS) return Math.abs(absMax(ws.x, ws.z));
                if (this._direction === EAxisDirection.X_AXIS) return Math.abs(absMax(ws.y, ws.z));
                return Math.abs(absMax(ws.x, ws.y));
              };

              _proto._getHeightScale = function _getHeightScale() {
                if (this.node == null) return 1;
                var ws = this.node.worldScale;
                if (this._direction === EAxisDirection.Y_AXIS) return Math.abs(ws.y);
                if (this._direction === EAxisDirection.X_AXIS) return Math.abs(ws.x);
                return Math.abs(ws.z);
              };

              _createClass(CapsuleCollider, [{
                key: "radius",
                get: function get() {
                  return this._radius;
                },
                set: function set(value) {
                  if (this._radius === value) return;
                  this._radius = Math.abs(value);

                  if (this._shape) {
                    this.shape.setRadius(value);
                  }
                }
              }, {
                key: "cylinderHeight",
                get: function get() {
                  return this._cylinderHeight;
                },
                set: function set(value) {
                  if (this._cylinderHeight === value) return;
                  this._cylinderHeight = Math.abs(value);

                  if (this._shape) {
                    this.shape.setCylinderHeight(value);
                  }
                }
              }, {
                key: "direction",
                get: function get() {
                  return this._direction;
                },
                set: function set(value) {
                  value = Math.floor(value);
                  if (value < EAxisDirection.X_AXIS || value > EAxisDirection.Z_AXIS) return;
                  if (this._direction === value) return;
                  this._direction = value;

                  if (this._shape) {
                    this.shape.setDirection(value);
                  }
                }
              }, {
                key: "height",
                get: function get() {
                  return this._radius * 2 + this._cylinderHeight;
                },
                set: function set(value) {
                  var ch = value - this._radius * 2;
                  if (ch < 0) ch = 0;
                  this.cylinderHeight = ch;
                }
              }, {
                key: "worldHeight",
                get: function get() {
                  return this._radius * 2 * this._getRadiusScale() + this._cylinderHeight * this._getHeightScale();
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }]);

              return CapsuleCollider;
            }(Collider), (_applyDecoratedDescriptor(_class2$1s.prototype, "direction", [_dec2$1c], Object.getOwnPropertyDescriptor(_class2$1s.prototype, "direction"), _class2$1s.prototype), _initializer$1n = applyDecoratedInitializer(_class2$1s.prototype, "_radius", [serializable$j], function () {
              return 0.5;
            }), _initializer2$18 = applyDecoratedInitializer(_class2$1s.prototype, "_cylinderHeight", [serializable$j], function () {
              return 1;
            }), _initializer3$V = applyDecoratedInitializer(_class2$1s.prototype, "_direction", [serializable$j], function () {
              return EAxisDirection.Y_AXIS;
            })), _class2$1s)) || _class$1I));

            var _dec$1G, _dec2$1d, _class$1J, _class2$1t, _initializer$1o, _initializer2$19, _initializer3$W;
            var CylinderCollider = exports('CylinderCollider', (_dec$1G = ccclass$p('cc.CylinderCollider'), _dec2$1d = type$8(EAxisDirection), _dec$1G(_class$1J = (_class2$1t = function (_Collider) {
              _inheritsLoose(CylinderCollider, _Collider);

              function CylinderCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.CYLINDER) || this;
                _this._radius = _initializer$1o && _initializer$1o();
                _this._height = _initializer2$19 && _initializer2$19();
                _this._direction = _initializer3$W && _initializer3$W();
                return _this;
              }

              _createClass(CylinderCollider, [{
                key: "radius",
                get: function get() {
                  return this._radius;
                },
                set: function set(value) {
                  if (this._radius === value) return;
                  this._radius = Math.abs(value);

                  if (this._shape) {
                    this.shape.setRadius(value);
                  }
                }
              }, {
                key: "height",
                get: function get() {
                  return this._height;
                },
                set: function set(value) {
                  if (this._height === value) return;
                  this._height = Math.abs(value);

                  if (this._shape) {
                    this.shape.setHeight(value);
                  }
                }
              }, {
                key: "direction",
                get: function get() {
                  return this._direction;
                },
                set: function set(value) {
                  if (this._direction === value) return;
                  if (value < EAxisDirection.X_AXIS || value > EAxisDirection.Z_AXIS) return;
                  this._direction = value;

                  if (this._shape) {
                    this.shape.setDirection(value);
                  }
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }]);

              return CylinderCollider;
            }(Collider), (_applyDecoratedDescriptor(_class2$1t.prototype, "direction", [_dec2$1d], Object.getOwnPropertyDescriptor(_class2$1t.prototype, "direction"), _class2$1t.prototype), _initializer$1o = applyDecoratedInitializer(_class2$1t.prototype, "_radius", [serializable$j], function () {
              return 0.5;
            }), _initializer2$19 = applyDecoratedInitializer(_class2$1t.prototype, "_height", [serializable$j], function () {
              return 2;
            }), _initializer3$W = applyDecoratedInitializer(_class2$1t.prototype, "_direction", [serializable$j], function () {
              return EAxisDirection.Y_AXIS;
            })), _class2$1t)) || _class$1J));

            var _dec$1H, _dec2$1e, _class$1K, _class2$1u, _initializer$1p, _initializer2$1a, _initializer3$X;
            var ConeCollider = exports('ConeCollider', (_dec$1H = ccclass$p('cc.ConeCollider'), _dec2$1e = type$8(EAxisDirection), _dec$1H(_class$1K = (_class2$1u = function (_Collider) {
              _inheritsLoose(ConeCollider, _Collider);

              function ConeCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.CONE) || this;
                _this._radius = _initializer$1p && _initializer$1p();
                _this._height = _initializer2$1a && _initializer2$1a();
                _this._direction = _initializer3$X && _initializer3$X();
                return _this;
              }

              _createClass(ConeCollider, [{
                key: "radius",
                get: function get() {
                  return this._radius;
                },
                set: function set(value) {
                  if (this._radius === value) return;
                  this._radius = Math.abs(value);

                  if (this._shape) {
                    this.shape.setRadius(value);
                  }
                }
              }, {
                key: "height",
                get: function get() {
                  return this._height;
                },
                set: function set(value) {
                  if (this._height === value) return;
                  if (value < 0) value = 0;
                  this._height = value;

                  if (this._shape) {
                    this.shape.setHeight(value);
                  }
                }
              }, {
                key: "direction",
                get: function get() {
                  return this._direction;
                },
                set: function set(value) {
                  if (this._direction === value) return;
                  if (value < EAxisDirection.X_AXIS || value > EAxisDirection.Z_AXIS) return;
                  this._direction = value;

                  if (this._shape) {
                    this.shape.setDirection(value);
                  }
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }]);

              return ConeCollider;
            }(Collider), (_applyDecoratedDescriptor(_class2$1u.prototype, "direction", [_dec2$1e], Object.getOwnPropertyDescriptor(_class2$1u.prototype, "direction"), _class2$1u.prototype), _initializer$1p = applyDecoratedInitializer(_class2$1u.prototype, "_radius", [serializable$j], function () {
              return 0.5;
            }), _initializer2$1a = applyDecoratedInitializer(_class2$1u.prototype, "_height", [serializable$j], function () {
              return 1;
            }), _initializer3$X = applyDecoratedInitializer(_class2$1u.prototype, "_direction", [serializable$j], function () {
              return EAxisDirection.Y_AXIS;
            })), _class2$1u)) || _class$1K));

            var _dec$1I, _dec2$1f, _class$1L, _class2$1v, _initializer$1q, _initializer2$1b;
            var MeshCollider = exports('MeshCollider', (_dec$1I = ccclass$p('cc.MeshCollider'), _dec2$1f = type$8(Mesh), _dec$1I(_class$1L = (_class2$1v = function (_Collider) {
              _inheritsLoose(MeshCollider, _Collider);

              function MeshCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.MESH) || this;
                _this._mesh = _initializer$1q && _initializer$1q();
                _this._convex = _initializer2$1b && _initializer2$1b();
                return _this;
              }

              _createClass(MeshCollider, [{
                key: "mesh",
                get: function get() {
                  return this._mesh;
                },
                set: function set(value) {
                  if (this._mesh === value) return;
                  this._mesh = value;
                  if (this._shape) this.shape.setMesh(this._mesh);
                }
              }, {
                key: "convex",
                get: function get() {
                  return this._convex;
                },
                set: function set(value) {
                  if (this._convex === value) return;
                  this._convex = value;
                  if (this._shape && this._mesh) this.shape.setMesh(this._mesh);
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }]);

              return MeshCollider;
            }(Collider), (_applyDecoratedDescriptor(_class2$1v.prototype, "mesh", [_dec2$1f], Object.getOwnPropertyDescriptor(_class2$1v.prototype, "mesh"), _class2$1v.prototype), _initializer$1q = applyDecoratedInitializer(_class2$1v.prototype, "_mesh", [serializable$j], function () {
              return null;
            }), _initializer2$1b = applyDecoratedInitializer(_class2$1v.prototype, "_convex", [serializable$j], function () {
              return false;
            })), _class2$1v)) || _class$1L));

            var _dec$1J, _dec2$1g, _class$1M, _class2$1w, _initializer$1r, _initializer2$1c, _initializer3$Y, _initializer4$P;
            var ConstantForce = exports('ConstantForce', (_dec$1J = ccclass$p('cc.ConstantForce'), _dec2$1g = requireComponent(RigidBody), _dec$1J(_class$1M = _dec2$1g(_class$1M = disallowMultiple(_class$1M = (_class2$1w = function (_Component) {
              _inheritsLoose(ConstantForce, _Component);

              function ConstantForce() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._rigidBody = null;
                _this._force = _initializer$1r && _initializer$1r();
                _this._localForce = _initializer2$1c && _initializer2$1c();
                _this._torque = _initializer3$Y && _initializer3$Y();
                _this._localTorque = _initializer4$P && _initializer4$P();
                _this._mask = 0;
                return _this;
              }

              var _proto = ConstantForce.prototype;

              _proto.onLoad = function onLoad() {
                this._rigidBody = this.node.getComponent(RigidBody);

                this._maskUpdate(this._force, 1);

                this._maskUpdate(this._localForce, 2);

                this._maskUpdate(this._torque, 4);

                this._maskUpdate(this._localTorque, 8);
              };

              _proto.lateUpdate = function lateUpdate(dt) {
                {
                  if (this._rigidBody != null && this._mask !== 0) {
                    if (this._mask & 1) this._rigidBody.applyForce(this._force);
                    if (this._mask & 2) this._rigidBody.applyLocalForce(this.localForce);
                    if (this._mask & 4) this._rigidBody.applyTorque(this._torque);
                    if (this._mask & 8) this._rigidBody.applyLocalTorque(this._localTorque);
                  }
                }
              };

              _proto._maskUpdate = function _maskUpdate(t, m) {
                if (t.strictEquals(Vec3.ZERO)) {
                  this._mask &= ~m;
                } else {
                  this._mask |= m;
                }
              };

              _createClass(ConstantForce, [{
                key: "force",
                get: function get() {
                  return this._force;
                },
                set: function set(value) {
                  Vec3.copy(this._force, value);

                  this._maskUpdate(this._force, 1);
                }
              }, {
                key: "localForce",
                get: function get() {
                  return this._localForce;
                },
                set: function set(value) {
                  Vec3.copy(this._localForce, value);

                  this._maskUpdate(this.localForce, 2);
                }
              }, {
                key: "torque",
                get: function get() {
                  return this._torque;
                },
                set: function set(value) {
                  Vec3.copy(this._torque, value);

                  this._maskUpdate(this._torque, 4);
                }
              }, {
                key: "localTorque",
                get: function get() {
                  return this._localTorque;
                },
                set: function set(value) {
                  Vec3.copy(this._localTorque, value);

                  this._maskUpdate(this._localTorque, 8);
                }
              }]);

              return ConstantForce;
            }(Component), (_initializer$1r = applyDecoratedInitializer(_class2$1w.prototype, "_force", [serializable$j], function () {
              return new Vec3();
            }), _initializer2$1c = applyDecoratedInitializer(_class2$1w.prototype, "_localForce", [serializable$j], function () {
              return new Vec3();
            }), _initializer3$Y = applyDecoratedInitializer(_class2$1w.prototype, "_torque", [serializable$j], function () {
              return new Vec3();
            }), _initializer4$P = applyDecoratedInitializer(_class2$1w.prototype, "_localTorque", [serializable$j], function () {
              return new Vec3();
            })), _class2$1w)) || _class$1M) || _class$1M) || _class$1M));

            var _dec$1K, _class$1N, _class2$1x, _initializer$1s, _initializer2$1d, _initializer3$Z, _initializer4$Q, _initializer5$F, _initializer6$y, _dec2$1h, _class4$l, _dec3$R, _class6$8, _class7$6, _initializer7$q;
            var TERRAIN_MAX_LEVELS = exports('TERRAIN_MAX_LEVELS', 4);
            var TERRAIN_MAX_BLEND_LAYERS = exports('TERRAIN_MAX_BLEND_LAYERS', 4);
            var TERRAIN_MAX_LAYER_COUNT = exports('TERRAIN_MAX_LAYER_COUNT', 256);
            var TERRAIN_BLOCK_TILE_COMPLEXITY = exports('TERRAIN_BLOCK_TILE_COMPLEXITY', 32);
            var TERRAIN_BLOCK_VERTEX_COMPLEXITY = exports('TERRAIN_BLOCK_VERTEX_COMPLEXITY', 33);
            var TERRAIN_BLOCK_VERTEX_SIZE = exports('TERRAIN_BLOCK_VERTEX_SIZE', 8);
            var TERRAIN_HEIGHT_BASE = exports('TERRAIN_HEIGHT_BASE', 32768);
            var TERRAIN_HEIGHT_FACTORY = exports('TERRAIN_HEIGHT_FACTORY', 1.0 / 512.0);
            var TERRAIN_HEIGHT_FMIN = exports('TERRAIN_HEIGHT_FMIN', -TERRAIN_HEIGHT_BASE * TERRAIN_HEIGHT_FACTORY);
            var TERRAIN_HEIGHT_FMAX = exports('TERRAIN_HEIGHT_FMAX', (65535 - TERRAIN_HEIGHT_BASE) * TERRAIN_HEIGHT_FACTORY);
            var TERRAIN_NORTH_INDEX = exports('TERRAIN_NORTH_INDEX', 0);
            var TERRAIN_SOUTH_INDEX = exports('TERRAIN_SOUTH_INDEX', 1);
            var TERRAIN_WEST_INDEX = exports('TERRAIN_WEST_INDEX', 2);
            var TERRAIN_EAST_INDEX = exports('TERRAIN_EAST_INDEX', 3);
            var TERRAIN_DATA_VERSION = exports('TERRAIN_DATA_VERSION', 0x01010001);
            var TERRAIN_DATA_VERSION2 = exports('TERRAIN_DATA_VERSION2', 0x01010002);
            var TERRAIN_DATA_VERSION3 = exports('TERRAIN_DATA_VERSION3', 0x01010003);
            var TERRAIN_DATA_VERSION4 = exports('TERRAIN_DATA_VERSION4', 0x01010004);
            var TERRAIN_DATA_VERSION5 = exports('TERRAIN_DATA_VERSION5', 0x01010005);
            var TERRAIN_DATA_VERSION6 = exports('TERRAIN_DATA_VERSION6', 0x01010006);
            var TERRAIN_DATA_VERSION7 = exports('TERRAIN_DATA_VERSION7', 0x01010007);
            var TERRAIN_DATA_VERSION_DEFAULT = exports('TERRAIN_DATA_VERSION_DEFAULT', 0x01010111);

            var TerrainBuffer = function () {
              function TerrainBuffer() {
                this.length = 0;
                this.buffer = new Uint8Array(2048);
                this._buffView = new DataView(this.buffer.buffer);
                this._seekPos = 0;
              }

              var _proto = TerrainBuffer.prototype;

              _proto.reserve = function reserve(size) {
                if (this.buffer.byteLength > size) {
                  return;
                }

                var capacity = this.buffer.byteLength;

                while (capacity < size) {
                  capacity += capacity;
                }

                var temp = new Uint8Array(capacity);

                for (var i = 0; i < this.length; ++i) {
                  temp[i] = this.buffer[i];
                }

                this.buffer = temp;
                this._buffView = new DataView(this.buffer.buffer);
              };

              _proto.assign = function assign(buff) {
                this.buffer = buff;
                this.length = buff.length;
                this._seekPos = buff.byteOffset;
                this._buffView = new DataView(buff.buffer);
              };

              _proto.writeInt8 = function writeInt8(value) {
                this.reserve(this.length + 1);

                this._buffView.setInt8(this.length, value);

                this.length += 1;
              };

              _proto.writeInt16 = function writeInt16(value) {
                this.reserve(this.length + 2);

                this._buffView.setInt16(this.length, value, true);

                this.length += 2;
              };

              _proto.writeInt32 = function writeInt32(value) {
                this.reserve(this.length + 4);

                this._buffView.setInt32(this.length, value, true);

                this.length += 4;
              };

              _proto.writeIntArray = function writeIntArray(value) {
                this.reserve(this.length + 4 * value.length);

                for (var i = 0; i < value.length; ++i) {
                  this._buffView.setInt32(this.length + i * 4, value[i], true);
                }

                this.length += 4 * value.length;
              };

              _proto.writeFloat = function writeFloat(value) {
                this.reserve(this.length + 4);

                this._buffView.setFloat32(this.length, value, true);

                this.length += 4;
              };

              _proto.writeFloatArray = function writeFloatArray(value) {
                this.reserve(this.length + 4 * value.length);

                for (var i = 0; i < value.length; ++i) {
                  this._buffView.setFloat32(this.length + i * 4, value[i], true);
                }

                this.length += 4 * value.length;
              };

              _proto.writeDouble = function writeDouble(value) {
                this.reserve(this.length + 8);

                this._buffView.setFloat64(this.length, value, true);

                this.length += 8;
              };

              _proto.writeDoubleArray = function writeDoubleArray(value) {
                this.reserve(this.length + 8 * value.length);

                for (var i = 0; i < value.length; ++i) {
                  this._buffView.setFloat64(this.length + i * 8, value[i], true);
                }

                this.length += 8 * value.length;
              };

              _proto.writeString = function writeString(value) {
                this.reserve(this.length + value.length + 4);

                this._buffView.setInt32(this.length, value.length, true);

                for (var i = 0; i < value.length; ++i) {
                  this._buffView.setInt8(this.length + 4 + i, value.charCodeAt(i));
                }

                this.length += value.length + 4;
              };

              _proto.readInt8 = function readInt8() {
                var value = this._buffView.getInt8(this._seekPos);

                this._seekPos += 1;
                return value;
              };

              _proto.readInt16 = function readInt16() {
                var value = this._buffView.getInt16(this._seekPos, true);

                this._seekPos += 2;
                return value;
              };

              _proto.readInt = function readInt() {
                var value = this._buffView.getInt32(this._seekPos, true);

                this._seekPos += 4;
                return value;
              };

              _proto.readIntArray = function readIntArray(value) {
                for (var i = 0; i < value.length; ++i) {
                  value[i] = this._buffView.getInt32(this._seekPos + i * 4, true);
                }

                this._seekPos += 4 * value.length;
                return value;
              };

              _proto.readFloat = function readFloat() {
                var value = this._buffView.getFloat32(this._seekPos, true);

                this._seekPos += 4;
                return value;
              };

              _proto.readFloatArray = function readFloatArray(value) {
                for (var i = 0; i < value.length; ++i) {
                  value[i] = this._buffView.getFloat32(this._seekPos + i * 4, true);
                }

                this._seekPos += 4 * value.length;
                return value;
              };

              _proto.readDouble = function readDouble() {
                var value = this._buffView.getFloat64(this._seekPos, true);

                this._seekPos += 8;
                return value;
              };

              _proto.readDoubleArray = function readDoubleArray(value) {
                for (var i = 0; i < value.length; ++i) {
                  value[i] = this._buffView.getFloat64(this._seekPos + i * 4, true);
                }

                this._seekPos += 8 * value.length;
                return value;
              };

              _proto.readString = function readString() {
                var length = this.readInt();
                var value = '';

                for (var i = 0; i < length; ++i) {
                  value += String.fromCharCode(this.readInt8());
                }

                return value;
              };

              return TerrainBuffer;
            }();

            var TerrainLayerInfo = exports('TerrainLayerInfo', (_dec$1K = ccclass$p('cc.TerrainLayerInfo'), _dec$1K(_class$1N = (_class2$1x = function TerrainLayerInfo() {
              this.slot = _initializer$1s && _initializer$1s();
              this.tileSize = _initializer2$1d && _initializer2$1d();
              this.detailMap = _initializer3$Z && _initializer3$Z();
              this.normalMap = _initializer4$Q && _initializer4$Q();
              this.roughness = _initializer5$F && _initializer5$F();
              this.metallic = _initializer6$y && _initializer6$y();
            }, (_initializer$1s = applyDecoratedInitializer(_class2$1x.prototype, "slot", [serializable$j], function () {
              return 0;
            }), _initializer2$1d = applyDecoratedInitializer(_class2$1x.prototype, "tileSize", [serializable$j], function () {
              return 1;
            }), _initializer3$Z = applyDecoratedInitializer(_class2$1x.prototype, "detailMap", [serializable$j], function () {
              return null;
            }), _initializer4$Q = applyDecoratedInitializer(_class2$1x.prototype, "normalMap", [serializable$j], function () {
              return null;
            }), _initializer5$F = applyDecoratedInitializer(_class2$1x.prototype, "roughness", [serializable$j], function () {
              return 1;
            }), _initializer6$y = applyDecoratedInitializer(_class2$1x.prototype, "metallic", [serializable$j], function () {
              return 0;
            })), _class2$1x)) || _class$1N));
            var TerrainLayerBinaryInfo = exports('TerrainLayerBinaryInfo', (_dec2$1h = ccclass$p('cc.TerrainLayerBinaryInfo'), _dec2$1h(_class4$l = function TerrainLayerBinaryInfo() {
              this.slot = 0;
              this.tileSize = 1;
              this.roughness = 1;
              this.metallic = 0;
              this.detailMapId = '';
              this.normalMapId = '';
            }) || _class4$l));
            var TerrainAsset = exports('TerrainAsset', (_dec3$R = ccclass$p('cc.TerrainAsset'), _dec3$R(_class6$8 = (_class7$6 = function (_Asset) {
              _inheritsLoose(TerrainAsset, _Asset);

              function TerrainAsset() {
                var _this;

                _this = _Asset.call(this) || this;
                _this._version = 0;
                _this._data = null;
                _this._tileSize = 1;
                _this._blockCount = [1, 1];
                _this._weightMapSize = 128;
                _this._lightMapSize = 128;
                _this._heights = new Uint16Array();
                _this._normals = new Float32Array();
                _this._weights = new Uint8Array();
                _this._layerBuffer = [-1, -1, -1, -1];
                _this._layerBinaryInfos = [];
                _this._layerInfos = _initializer7$q && _initializer7$q();
                return _this;
              }

              var _proto2 = TerrainAsset.prototype;

              _proto2.getLayer = function getLayer(xBlock, yBlock, layerId) {
                var blockId = yBlock * this.blockCount[0] + xBlock;
                var index = blockId * 4 + layerId;

                if (xBlock < this.blockCount[0] && yBlock < this.blockCount[1] && index < this._layerBuffer.length) {
                  return this._layerBuffer[index];
                }

                return -1;
              };

              _proto2.getHeight = function getHeight(i, j) {
                var vertexCountX = this._blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY + 1;
                return (this._heights[j * vertexCountX + i] - TERRAIN_HEIGHT_BASE) * TERRAIN_HEIGHT_FACTORY;
              };

              _proto2.getVertexCountI = function getVertexCountI() {
                if (this._blockCount.length < 1) return 0;
                return this._blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY + 1;
              };

              _proto2.getVertexCountJ = function getVertexCountJ() {
                if (this._blockCount.length < 2) return 0;
                return this._blockCount[1] * TERRAIN_BLOCK_TILE_COMPLEXITY + 1;
              };

              _proto2._setNativeData = function _setNativeData(_nativeData) {
                this._data = _nativeData;
              };

              _proto2._loadNativeData = function _loadNativeData(_nativeData) {
                if (!_nativeData || _nativeData.length === 0) {
                  return false;
                }

                var stream = new TerrainBuffer();
                stream.assign(_nativeData);
                this._version = stream.readInt();

                if (this._version === TERRAIN_DATA_VERSION_DEFAULT) {
                  return true;
                }

                if (this._version !== TERRAIN_DATA_VERSION && this._version !== TERRAIN_DATA_VERSION2 && this._version !== TERRAIN_DATA_VERSION3 && this._version !== TERRAIN_DATA_VERSION4 && this._version !== TERRAIN_DATA_VERSION5 && this._version !== TERRAIN_DATA_VERSION6 && this._version !== TERRAIN_DATA_VERSION7) {
                  return false;
                }

                if (this._version >= TERRAIN_DATA_VERSION7) {
                  this.tileSize = stream.readDouble();
                } else {
                  this.tileSize = stream.readFloat();
                }

                this.tileSize = Math.floor(this.tileSize * 100) / 100.0;
                stream.readIntArray(this._blockCount);
                this.weightMapSize = stream.readInt16();
                this.lightMapSize = stream.readInt16();
                var heightBufferSize = stream.readInt();
                this.heights = new Uint16Array(heightBufferSize);

                for (var i = 0; i < this.heights.length; ++i) {
                  this.heights[i] = stream.readInt16();
                }

                if (this._version >= TERRAIN_DATA_VERSION6) {
                  var normalBufferSize = stream.readInt();
                  this.normals = new Float32Array(normalBufferSize);

                  for (var _i = 0; _i < this.normals.length; ++_i) {
                    this.normals[_i] = stream.readFloat();
                  }
                }

                var WeightBufferSize = stream.readInt();
                this.weights = new Uint8Array(WeightBufferSize);

                for (var _i2 = 0; _i2 < this.weights.length; ++_i2) {
                  this.weights[_i2] = stream.readInt8();
                }

                if (this._version >= TERRAIN_DATA_VERSION2) {
                  var layerBufferSize = stream.readInt();
                  this.layerBuffer = new Array(layerBufferSize);

                  for (var _i3 = 0; _i3 < this.layerBuffer.length; ++_i3) {
                    this.layerBuffer[_i3] = stream.readInt16();
                  }
                }

                if (this._version >= TERRAIN_DATA_VERSION3) {
                  var layerInfoSize = stream.readInt();
                  this._layerBinaryInfos = new Array(layerInfoSize);

                  for (var _i4 = 0; _i4 < this._layerBinaryInfos.length; ++_i4) {
                    this._layerBinaryInfos[_i4] = new TerrainLayerBinaryInfo();
                    this._layerBinaryInfos[_i4].slot = stream.readInt();

                    if (this._version >= TERRAIN_DATA_VERSION7) {
                      this._layerBinaryInfos[_i4].tileSize = stream.readDouble();
                    } else {
                      this._layerBinaryInfos[_i4].tileSize = stream.readFloat();
                    }

                    this._layerBinaryInfos[_i4].detailMapId = stream.readString();

                    if (this._version >= TERRAIN_DATA_VERSION4) {
                      this._layerBinaryInfos[_i4].normalMapId = stream.readString();

                      if (this._version >= TERRAIN_DATA_VERSION7) {
                        this._layerBinaryInfos[_i4].roughness = stream.readDouble();
                        this._layerBinaryInfos[_i4].metallic = stream.readDouble();
                      } else {
                        this._layerBinaryInfos[_i4].roughness = stream.readFloat();
                        this._layerBinaryInfos[_i4].metallic = stream.readFloat();
                      }
                    }
                  }
                }

                return true;
              };

              _proto2._exportNativeData = function _exportNativeData() {
                var stream = new TerrainBuffer();
                stream.writeInt32(TERRAIN_DATA_VERSION7);
                stream.writeDouble(this.tileSize);
                stream.writeIntArray(this._blockCount);
                stream.writeInt16(this.weightMapSize);
                stream.writeInt16(this.lightMapSize);
                stream.writeInt32(this.heights.length);

                for (var i = 0; i < this.heights.length; ++i) {
                  stream.writeInt16(this.heights[i]);
                }

                stream.writeInt32(this.normals.length);

                for (var _i5 = 0; _i5 < this.normals.length; ++_i5) {
                  stream.writeFloat(this.normals[_i5]);
                }

                stream.writeInt32(this.weights.length);

                for (var _i6 = 0; _i6 < this.weights.length; ++_i6) {
                  stream.writeInt8(this.weights[_i6]);
                }

                stream.writeInt32(this.layerBuffer.length);

                for (var _i7 = 0; _i7 < this.layerBuffer.length; ++_i7) {
                  stream.writeInt16(this.layerBuffer[_i7]);
                }

                var layerBinaryInfos = [];
                layerBinaryInfos.length = this.layerInfos.length;

                for (var _i8 = 0; _i8 < layerBinaryInfos.length; ++_i8) {
                  var layer = this.layerInfos[_i8];
                  var binaryLayer = new TerrainLayerBinaryInfo();
                  binaryLayer.slot = _i8;
                  binaryLayer.tileSize = layer.tileSize;
                  binaryLayer.detailMapId = layer.detailMap ? layer.detailMap._uuid : '';
                  binaryLayer.normalMapId = layer.normalMap ? layer.normalMap._uuid : '';
                  binaryLayer.metallic = layer.metallic;
                  binaryLayer.roughness = layer.roughness;
                  layerBinaryInfos[_i8] = binaryLayer;
                }

                stream.writeInt32(layerBinaryInfos.length);

                for (var _i9 = 0; _i9 < layerBinaryInfos.length; ++_i9) {
                  stream.writeInt32(layerBinaryInfos[_i9].slot);
                  stream.writeDouble(layerBinaryInfos[_i9].tileSize);
                  stream.writeString(layerBinaryInfos[_i9].detailMapId);
                  stream.writeString(layerBinaryInfos[_i9].normalMapId);
                  stream.writeDouble(layerBinaryInfos[_i9].roughness);
                  stream.writeDouble(layerBinaryInfos[_i9].metallic);
                }

                return stream.buffer;
              };

              _proto2._exportDefaultNativeData = function _exportDefaultNativeData() {
                var stream = new TerrainBuffer();
                stream.writeInt32(TERRAIN_DATA_VERSION_DEFAULT);
                return stream.buffer;
              };

              _createClass(TerrainAsset, [{
                key: "_nativeAsset",
                get: function get() {
                  return this._data.buffer;
                },
                set: function set(value) {
                  if (this._data && this._data.byteLength === value.byteLength) {
                    this._data.set(new Uint8Array(value));
                  } else {
                    this._data = new Uint8Array(value);
                  }

                  this._loadNativeData(this._data);
                }
              }, {
                key: "version",
                get: function get() {
                  return this._version;
                }
              }, {
                key: "tileSize",
                get: function get() {
                  return this._tileSize;
                },
                set: function set(value) {
                  this._tileSize = value;
                }
              }, {
                key: "blockCount",
                get: function get() {
                  return this._blockCount;
                },
                set: function set(value) {
                  this._blockCount = value;
                }
              }, {
                key: "lightMapSize",
                get: function get() {
                  return this._lightMapSize;
                },
                set: function set(value) {
                  this._lightMapSize = value;
                }
              }, {
                key: "weightMapSize",
                get: function get() {
                  return this._weightMapSize;
                },
                set: function set(value) {
                  this._weightMapSize = value;
                }
              }, {
                key: "heights",
                get: function get() {
                  return this._heights;
                },
                set: function set(value) {
                  this._heights = value;
                }
              }, {
                key: "normals",
                get: function get() {
                  return this._normals;
                },
                set: function set(value) {
                  this._normals = value;
                }
              }, {
                key: "weights",
                get: function get() {
                  return this._weights;
                },
                set: function set(value) {
                  this._weights = value;
                }
              }, {
                key: "layerBuffer",
                get: function get() {
                  return this._layerBuffer;
                },
                set: function set(value) {
                  this._layerBuffer = value;
                }
              }, {
                key: "layerInfos",
                get: function get() {
                  return this._layerInfos;
                },
                set: function set(value) {
                  this._layerInfos = value;
                }
              }, {
                key: "layerBinaryInfos",
                get: function get() {
                  return this._layerBinaryInfos;
                }
              }]);

              return TerrainAsset;
            }(Asset), (_initializer7$q = applyDecoratedInitializer(_class7$6.prototype, "_layerInfos", [serializable$j], function () {
              return [];
            })), _class7$6)) || _class6$8));

            var _dec$1L, _dec2$1i, _class$1O, _class2$1y, _initializer$1t;
            var TerrainCollider = exports('TerrainCollider', (_dec$1L = ccclass$p('cc.TerrainCollider'), _dec2$1i = type$8(TerrainAsset), _dec$1L(_class$1O = (_class2$1y = function (_Collider) {
              _inheritsLoose(TerrainCollider, _Collider);

              function TerrainCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.TERRAIN) || this;
                _this._terrain = _initializer$1t && _initializer$1t();
                return _this;
              }

              _createClass(TerrainCollider, [{
                key: "terrain",
                get: function get() {
                  return this._terrain;
                },
                set: function set(value) {
                  this._terrain = value;
                  if (this._shape) this.shape.setTerrain(this._terrain);
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }]);

              return TerrainCollider;
            }(Collider), (_applyDecoratedDescriptor(_class2$1y.prototype, "terrain", [_dec2$1i], Object.getOwnPropertyDescriptor(_class2$1y.prototype, "terrain"), _class2$1y.prototype), _initializer$1t = applyDecoratedInitializer(_class2$1y.prototype, "_terrain", [serializable$j], function () {
              return null;
            })), _class2$1y)) || _class$1O));

            var _dec$1M, _dec2$1j, _class$1P, _class2$1z, _initializer$1u, _initializer2$1e, _class3$n, _temp$w;
            var SimplexCollider = exports('SimplexCollider', (_dec$1M = ccclass$p('cc.SimplexCollider'), _dec2$1j = type$8(ESimplexType), _dec$1M(_class$1P = (_class2$1z = (_temp$w = _class3$n = function (_Collider) {
              _inheritsLoose(SimplexCollider, _Collider);

              function SimplexCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.SIMPLEX) || this;
                _this._shapeType = _initializer$1u && _initializer$1u();
                _this._vertices = _initializer2$1e && _initializer2$1e();
                return _this;
              }

              var _proto = SimplexCollider.prototype;

              _proto.updateVertices = function updateVertices() {
                if (this._shape) {
                  this.shape.setVertices(this._vertices);
                }
              };

              _createClass(SimplexCollider, [{
                key: "shapeType",
                get: function get() {
                  return this._shapeType;
                },
                set: function set(v) {
                  this._shapeType = v;

                  if (this._shape) {
                    this.shape.setShapeType(v);
                  }
                }
              }, {
                key: "vertex0",
                get: function get() {
                  return this._vertices[0];
                },
                set: function set(v) {
                  Vec3.copy(this._vertices[0], v);
                  this.updateVertices();
                }
              }, {
                key: "vertex1",
                get: function get() {
                  return this._vertices[1];
                },
                set: function set(v) {
                  Vec3.copy(this._vertices[1], v);
                  this.updateVertices();
                }
              }, {
                key: "vertex2",
                get: function get() {
                  return this._vertices[2];
                },
                set: function set(v) {
                  Vec3.copy(this._vertices[2], v);
                  this.updateVertices();
                }
              }, {
                key: "vertex3",
                get: function get() {
                  return this._vertices[3];
                },
                set: function set(v) {
                  Vec3.copy(this._vertices[3], v);
                  this.updateVertices();
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }, {
                key: "vertices",
                get: function get() {
                  return this._vertices;
                }
              }]);

              return SimplexCollider;
            }(Collider), _class3$n.ESimplexType = ESimplexType, _temp$w), (_applyDecoratedDescriptor(_class2$1z.prototype, "shapeType", [_dec2$1j], Object.getOwnPropertyDescriptor(_class2$1z.prototype, "shapeType"), _class2$1z.prototype), _initializer$1u = applyDecoratedInitializer(_class2$1z.prototype, "_shapeType", [serializable$j], function () {
              return ESimplexType.TETRAHEDRON;
            }), _initializer2$1e = applyDecoratedInitializer(_class2$1z.prototype, "_vertices", [serializable$j], function () {
              return [new Vec3(0, 0, 0), new Vec3(0, 0, 1), new Vec3(1, 0, 0), new Vec3(0, 1, 0)];
            })), _class2$1z)) || _class$1P));

            (function (_SimplexCollider) {})(SimplexCollider || (SimplexCollider = exports('SimplexCollider', {})));

            var _dec$1N, _dec2$1k, _class$1Q, _class2$1A, _initializer$1v, _initializer2$1f;
            var PlaneCollider = exports('PlaneCollider', (_dec$1N = ccclass$p('cc.PlaneCollider'), _dec2$1k = type$8(Vec3), _dec$1N(_class$1Q = (_class2$1A = function (_Collider) {
              _inheritsLoose(PlaneCollider, _Collider);

              function PlaneCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.PLANE) || this;
                _this._normal = _initializer$1v && _initializer$1v();
                _this._constant = _initializer2$1f && _initializer2$1f();
                return _this;
              }

              _createClass(PlaneCollider, [{
                key: "normal",
                get: function get() {
                  return this._normal;
                },
                set: function set(value) {
                  if (Vec3.strictEquals(this._normal, value)) return;
                  Vec3.copy(this._normal, value);

                  if (this._shape) {
                    this.shape.setNormal(this._normal);
                  }
                }
              }, {
                key: "constant",
                get: function get() {
                  return this._constant;
                },
                set: function set(v) {
                  if (this._constant === v) return;
                  this._constant = v;

                  if (this._shape) {
                    this.shape.setConstant(this._constant);
                  }
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }]);

              return PlaneCollider;
            }(Collider), (_applyDecoratedDescriptor(_class2$1A.prototype, "normal", [_dec2$1k], Object.getOwnPropertyDescriptor(_class2$1A.prototype, "normal"), _class2$1A.prototype), _initializer$1v = applyDecoratedInitializer(_class2$1A.prototype, "_normal", [serializable$j], function () {
              return new Vec3(0, 1, 0);
            }), _initializer2$1f = applyDecoratedInitializer(_class2$1A.prototype, "_constant", [serializable$j], function () {
              return 0;
            })), _class2$1A)) || _class$1Q));

            var _dec$1O, _dec2$1l, _dec3$S, _dec4$B, _dec5$u, _class$1R, _class2$1B, _initializer$1w, _initializer2$1g, _class3$o, _temp$x;
            var Constraint$1 = exports('Constraint', (_dec$1O = ccclass$p('cc.Constraint'), _dec2$1l = requireComponent(RigidBody), _dec3$S = type$8(RigidBody), _dec4$B = type$8(RigidBody), _dec5$u = type$8(RigidBody), _dec$1O(_class$1R = _dec2$1l(_class$1R = (_class2$1B = (_temp$x = _class3$o = function (_Eventify) {
              _inheritsLoose(Constraint, _Eventify);

              function Constraint(type) {
                var _this;

                _this = _Eventify.call(this) || this;
                _this.TYPE = void 0;
                _this._enableCollision = _initializer$1w && _initializer$1w();
                _this._connectedBody = _initializer2$1g && _initializer2$1g();
                _this._constraint = null;
                _this.TYPE = type;
                return _this;
              }

              var _proto = Constraint.prototype;

              _proto.onLoad = function onLoad() {
                if (!selector.runInEditor) return;
                this._constraint = createConstraint(this.TYPE);

                this._constraint.initialize(this);
              };

              _proto.onEnable = function onEnable() {
                if (this._constraint) {
                  this._constraint.onEnable();
                }
              };

              _proto.onDisable = function onDisable() {
                if (this._constraint) {
                  this._constraint.onDisable();
                }
              };

              _proto.onDestroy = function onDestroy() {
                if (this._constraint) {
                  this._constraint.onDestroy();
                }
              };

              _createClass(Constraint, [{
                key: "attachedBody",
                get: function get() {
                  return this.getComponent(RigidBody);
                }
              }, {
                key: "connectedBody",
                get: function get() {
                  return this._connectedBody;
                },
                set: function set(v) {
                  this._connectedBody = v;

                  {
                    if (this._constraint) this._constraint.setConnectedBody(v);
                  }
                }
              }, {
                key: "enableCollision",
                get: function get() {
                  return this._enableCollision;
                },
                set: function set(v) {
                  this._enableCollision = v;

                  {
                    if (this._constraint) this._constraint.setEnableCollision(v);
                  }
                }
              }]);

              return Constraint;
            }(Eventify(Component)), _class3$o.Type = EConstraintType, _temp$x), (_applyDecoratedDescriptor(_class2$1B.prototype, "attachedBody", [_dec3$S], Object.getOwnPropertyDescriptor(_class2$1B.prototype, "attachedBody"), _class2$1B.prototype), _applyDecoratedDescriptor(_class2$1B.prototype, "connectedBody", [_dec4$B], Object.getOwnPropertyDescriptor(_class2$1B.prototype, "connectedBody"), _class2$1B.prototype), _initializer$1w = applyDecoratedInitializer(_class2$1B.prototype, "_enableCollision", [serializable$j], function () {
              return true;
            }), _initializer2$1g = applyDecoratedInitializer(_class2$1B.prototype, "_connectedBody", [_dec5$u], function () {
              return null;
            })), _class2$1B)) || _class$1R) || _class$1R));

            (function (_Constraint) {})(Constraint$1 || (Constraint$1 = exports('Constraint', {})));

            var _dec$1P, _dec2$1m, _dec3$T, _dec4$C, _dec5$v, _dec6$p, _dec7$j, _class$1S, _class2$1C, _initializer$1x, _initializer2$1h, _initializer3$_;
            var HingeConstraint = exports('HingeConstraint', (_dec$1P = ccclass$p('cc.HingeConstraint'), _dec2$1m = type$8(Vec3), _dec3$T = type$8(Vec3), _dec4$C = type$8(Vec3), _dec5$v = formerlySerializedAs$3('axisA'), _dec6$p = formerlySerializedAs$3('pivotA'), _dec7$j = formerlySerializedAs$3('pivotB'), _dec$1P(_class$1S = (_class2$1C = function (_Constraint) {
              _inheritsLoose(HingeConstraint, _Constraint);

              function HingeConstraint() {
                var _this;

                _this = _Constraint.call(this, EConstraintType.HINGE) || this;
                _this._axis = _initializer$1x && _initializer$1x();
                _this._pivotA = _initializer2$1h && _initializer2$1h();
                _this._pivotB = _initializer3$_ && _initializer3$_();
                return _this;
              }

              _createClass(HingeConstraint, [{
                key: "pivotA",
                get: function get() {
                  return this._pivotA;
                },
                set: function set(v) {
                  Vec3.copy(this._pivotA, v);

                  {
                    this.constraint.setPivotA(this._pivotA);
                  }
                }
              }, {
                key: "pivotB",
                get: function get() {
                  return this._pivotB;
                },
                set: function set(v) {
                  Vec3.copy(this._pivotB, v);

                  {
                    this.constraint.setPivotB(this._pivotB);
                  }
                }
              }, {
                key: "axis",
                get: function get() {
                  return this._axis;
                },
                set: function set(v) {
                  Vec3.copy(this._axis, v);

                  {
                    this.constraint.setAxis(this._axis);
                  }
                }
              }, {
                key: "constraint",
                get: function get() {
                  return this._constraint;
                }
              }]);

              return HingeConstraint;
            }(Constraint$1), (_applyDecoratedDescriptor(_class2$1C.prototype, "pivotA", [_dec2$1m], Object.getOwnPropertyDescriptor(_class2$1C.prototype, "pivotA"), _class2$1C.prototype), _applyDecoratedDescriptor(_class2$1C.prototype, "pivotB", [_dec3$T], Object.getOwnPropertyDescriptor(_class2$1C.prototype, "pivotB"), _class2$1C.prototype), _applyDecoratedDescriptor(_class2$1C.prototype, "axis", [_dec4$C], Object.getOwnPropertyDescriptor(_class2$1C.prototype, "axis"), _class2$1C.prototype), _initializer$1x = applyDecoratedInitializer(_class2$1C.prototype, "_axis", [serializable$j, _dec5$v], function () {
              return new Vec3();
            }), _initializer2$1h = applyDecoratedInitializer(_class2$1C.prototype, "_pivotA", [serializable$j, _dec6$p], function () {
              return new Vec3();
            }), _initializer3$_ = applyDecoratedInitializer(_class2$1C.prototype, "_pivotB", [serializable$j, _dec7$j], function () {
              return new Vec3();
            })), _class2$1C)) || _class$1S));

            var _dec$1Q, _dec2$1n, _dec3$U, _dec4$D, _dec5$w, _class$1T, _class2$1D, _initializer$1y, _initializer2$1i;
            var FixedConstraint = (_dec$1Q = ccclass$p('cc.FixedConstraint'), _dec2$1n = type$8(CCFloat), _dec3$U = type$8(CCFloat), _dec4$D = formerlySerializedAs$3('breakForce'), _dec5$w = formerlySerializedAs$3('breakTorque'), _dec$1Q(_class$1T = (_class2$1D = function (_Constraint) {
              _inheritsLoose(FixedConstraint, _Constraint);

              function FixedConstraint() {
                var _this;

                _this = _Constraint.call(this, EConstraintType.FIXED) || this;
                _this._breakForce = _initializer$1y && _initializer$1y();
                _this._breakTorque = _initializer2$1i && _initializer2$1i();
                return _this;
              }

              _createClass(FixedConstraint, [{
                key: "breakForce",
                get: function get() {
                  return this._breakForce;
                },
                set: function set(v) {
                  this._breakForce = v;

                  {
                    this.constraint.setBreakForce(v);
                  }
                }
              }, {
                key: "breakTorque",
                get: function get() {
                  return this._breakTorque;
                },
                set: function set(v) {
                  this._breakTorque = v;

                  {
                    this.constraint.setBreakTorque(v);
                  }
                }
              }, {
                key: "constraint",
                get: function get() {
                  return this._constraint;
                }
              }]);

              return FixedConstraint;
            }(Constraint$1), (_applyDecoratedDescriptor(_class2$1D.prototype, "breakForce", [_dec2$1n], Object.getOwnPropertyDescriptor(_class2$1D.prototype, "breakForce"), _class2$1D.prototype), _applyDecoratedDescriptor(_class2$1D.prototype, "breakTorque", [_dec3$U], Object.getOwnPropertyDescriptor(_class2$1D.prototype, "breakTorque"), _class2$1D.prototype), _initializer$1y = applyDecoratedInitializer(_class2$1D.prototype, "_breakForce", [serializable$j, _dec4$D], function () {
              return 1e8;
            }), _initializer2$1i = applyDecoratedInitializer(_class2$1D.prototype, "_breakTorque", [serializable$j, _dec5$w], function () {
              return 1e8;
            })), _class2$1D)) || _class$1T);

            var _dec$1R, _dec2$1o, _dec3$V, _class$1U, _class2$1E, _initializer$1z, _initializer2$1j;
            var PointToPointConstraint = exports('PointToPointConstraint', (_dec$1R = ccclass$p('cc.PointToPointConstraint'), _dec2$1o = type$8(Vec3), _dec3$V = type$8(Vec3), _dec$1R(_class$1U = (_class2$1E = function (_Constraint) {
              _inheritsLoose(PointToPointConstraint, _Constraint);

              function PointToPointConstraint() {
                var _this;

                _this = _Constraint.call(this, EConstraintType.POINT_TO_POINT) || this;
                _this._pivotA = _initializer$1z && _initializer$1z();
                _this._pivotB = _initializer2$1j && _initializer2$1j();
                return _this;
              }

              _createClass(PointToPointConstraint, [{
                key: "pivotA",
                get: function get() {
                  return this._pivotA;
                },
                set: function set(v) {
                  Vec3.copy(this._pivotA, v);

                  {
                    this.constraint.setPivotA(this._pivotA);
                  }
                }
              }, {
                key: "pivotB",
                get: function get() {
                  return this._pivotB;
                },
                set: function set(v) {
                  Vec3.copy(this._pivotB, v);

                  {
                    this.constraint.setPivotB(this._pivotB);
                  }
                }
              }, {
                key: "constraint",
                get: function get() {
                  return this._constraint;
                }
              }]);

              return PointToPointConstraint;
            }(Constraint$1), (_applyDecoratedDescriptor(_class2$1E.prototype, "pivotA", [_dec2$1o], Object.getOwnPropertyDescriptor(_class2$1E.prototype, "pivotA"), _class2$1E.prototype), _applyDecoratedDescriptor(_class2$1E.prototype, "pivotB", [_dec3$V], Object.getOwnPropertyDescriptor(_class2$1E.prototype, "pivotB"), _class2$1E.prototype), _initializer$1z = applyDecoratedInitializer(_class2$1E.prototype, "_pivotA", [serializable$j], function () {
              return new Vec3();
            }), _initializer2$1j = applyDecoratedInitializer(_class2$1E.prototype, "_pivotB", [serializable$j], function () {
              return new Vec3();
            })), _class2$1E)) || _class$1U));

            legacyCC.PhysicsSystem = PhysicsSystem;
            legacyCC.PhysicsMaterial = PhysicsMaterial;
            legacyCC.PhysicsRayResult = PhysicsRayResult;
            legacyCC.ConstantForce = ConstantForce;

            var physics = /*#__PURE__*/Object.freeze({
                __proto__: null,
                PhysicsSystem: PhysicsSystem,
                PhysicsRayResult: PhysicsRayResult,
                get Collider () { return Collider; },
                BoxCollider: BoxCollider,
                SphereCollider: SphereCollider,
                CapsuleCollider: CapsuleCollider,
                MeshCollider: MeshCollider,
                CylinderCollider: CylinderCollider,
                ConeCollider: ConeCollider,
                TerrainCollider: TerrainCollider,
                get SimplexCollider () { return SimplexCollider; },
                PlaneCollider: PlaneCollider,
                get Constraint () { return Constraint$1; },
                HingeConstraint: HingeConstraint,
                FixedConstraint: FixedConstraint,
                PointToPointConstraint: PointToPointConstraint,
                get RigidBody () { return RigidBody; },
                PhysicsMaterial: PhysicsMaterial,
                ConstantForce: ConstantForce,
                selector: selector,
                utils: util,
                get ERigidBodyType () { return ERigidBodyType; },
                get EAxisDirection () { return EAxisDirection; },
                get ESimplexType () { return ESimplexType; },
                get EColliderType () { return EColliderType; },
                get EConstraintType () { return EConstraintType; },
                get PhysicsGroup () { return PhysicsGroup; }
            });
            exports('physics', physics);

            legacyCC.physics = physics;

            var EBtSharedBodyDirty;

            (function (EBtSharedBodyDirty) {
              EBtSharedBodyDirty[EBtSharedBodyDirty["BODY_RE_ADD"] = 1] = "BODY_RE_ADD";
              EBtSharedBodyDirty[EBtSharedBodyDirty["GHOST_RE_ADD"] = 2] = "GHOST_RE_ADD";
            })(EBtSharedBodyDirty || (EBtSharedBodyDirty = {}));

            var btCollisionFlags;

            (function (btCollisionFlags) {
              btCollisionFlags[btCollisionFlags["CF_STATIC_OBJECT"] = 1] = "CF_STATIC_OBJECT";
              btCollisionFlags[btCollisionFlags["CF_KINEMATIC_OBJECT"] = 2] = "CF_KINEMATIC_OBJECT";
              btCollisionFlags[btCollisionFlags["CF_NO_CONTACT_RESPONSE"] = 4] = "CF_NO_CONTACT_RESPONSE";
              btCollisionFlags[btCollisionFlags["CF_CUSTOM_MATERIAL_CALLBACK"] = 8] = "CF_CUSTOM_MATERIAL_CALLBACK";
              btCollisionFlags[btCollisionFlags["CF_CHARACTER_OBJECT"] = 16] = "CF_CHARACTER_OBJECT";
              btCollisionFlags[btCollisionFlags["CF_DISABLE_VISUALIZE_OBJECT"] = 32] = "CF_DISABLE_VISUALIZE_OBJECT";
              btCollisionFlags[btCollisionFlags["CF_DISABLE_SPU_COLLISION_PROCESSING"] = 64] = "CF_DISABLE_SPU_COLLISION_PROCESSING";
            })(btCollisionFlags || (btCollisionFlags = {}));

            var btCollisionObjectTypes;

            (function (btCollisionObjectTypes) {
              btCollisionObjectTypes[btCollisionObjectTypes["CO_COLLISION_OBJECT"] = 1] = "CO_COLLISION_OBJECT";
              btCollisionObjectTypes[btCollisionObjectTypes["CO_RIGID_BODY"] = 2] = "CO_RIGID_BODY";
              btCollisionObjectTypes[btCollisionObjectTypes["CO_GHOST_OBJECT"] = 4] = "CO_GHOST_OBJECT";
              btCollisionObjectTypes[btCollisionObjectTypes["CO_SOFT_BODY"] = 8] = "CO_SOFT_BODY";
              btCollisionObjectTypes[btCollisionObjectTypes["CO_HF_FLUID"] = 16] = "CO_HF_FLUID";
              btCollisionObjectTypes[btCollisionObjectTypes["CO_USER_TYPE"] = 32] = "CO_USER_TYPE";
              btCollisionObjectTypes[btCollisionObjectTypes["CO_FEATHERSTONE_LINK"] = 64] = "CO_FEATHERSTONE_LINK";
            })(btCollisionObjectTypes || (btCollisionObjectTypes = {}));

            var btCollisionObjectStates;

            (function (btCollisionObjectStates) {
              btCollisionObjectStates[btCollisionObjectStates["ACTIVE_TAG"] = 1] = "ACTIVE_TAG";
              btCollisionObjectStates[btCollisionObjectStates["ISLAND_SLEEPING"] = 2] = "ISLAND_SLEEPING";
              btCollisionObjectStates[btCollisionObjectStates["WANTS_DEACTIVATION"] = 3] = "WANTS_DEACTIVATION";
              btCollisionObjectStates[btCollisionObjectStates["DISABLE_DEACTIVATION"] = 4] = "DISABLE_DEACTIVATION";
              btCollisionObjectStates[btCollisionObjectStates["DISABLE_SIMULATION"] = 5] = "DISABLE_SIMULATION";
            })(btCollisionObjectStates || (btCollisionObjectStates = {}));

            var btRigidBodyFlags;

            (function (btRigidBodyFlags) {
              btRigidBodyFlags[btRigidBodyFlags["BT_DISABLE_WORLD_GRAVITY"] = 1] = "BT_DISABLE_WORLD_GRAVITY";
              btRigidBodyFlags[btRigidBodyFlags["BT_ENABLE_GYROPSCOPIC_FORCE"] = 2] = "BT_ENABLE_GYROPSCOPIC_FORCE";
            })(btRigidBodyFlags || (btRigidBodyFlags = {}));

            var v3_0 = CC_V3_0;
            var v3_1$4 = CC_V3_1;
            var BulletRigidBody = function () {
              var _proto = BulletRigidBody.prototype;

              _proto.setMass = function setMass(value) {
                if (!this._rigidBody.isDynamic) return;
                bt.RigidBody_setMass(this.impl, value);

                this._wakeUpIfSleep();

                this._sharedBody.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
              };

              _proto.setType = function setType(v) {
                this._sharedBody.setType(v);
              };

              _proto.setLinearDamping = function setLinearDamping(value) {
                bt.RigidBody_setDamping(this.impl, this._rigidBody.linearDamping, this._rigidBody.angularDamping);
              };

              _proto.setAngularDamping = function setAngularDamping(value) {
                bt.RigidBody_setDamping(this.impl, this._rigidBody.linearDamping, this._rigidBody.angularDamping);
              };

              _proto.useGravity = function useGravity(value) {
                if (!this._rigidBody.isDynamic) return;
                var m_rigidBodyFlag = bt.RigidBody_getFlags(this.impl);

                if (value) {
                  m_rigidBodyFlag &= ~btRigidBodyFlags.BT_DISABLE_WORLD_GRAVITY;
                } else {
                  bt.RigidBody_setGravity(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, Vec3.ZERO));
                  m_rigidBodyFlag |= btRigidBodyFlags.BT_DISABLE_WORLD_GRAVITY;
                }

                bt.RigidBody_setFlags(this.impl, m_rigidBodyFlag);

                this._wakeUpIfSleep();

                this._sharedBody.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
              };

              _proto.useCCD = function useCCD(value) {
                bt.CollisionObject_setCcdMotionThreshold(this.impl, value ? 0.01 : 0);
                bt.CollisionObject_setCcdSweptSphereRadius(this.impl, value ? 0.1 : 0);
                this._isUsingCCD = value;
              };

              _proto.isUsingCCD = function isUsingCCD() {
                return this._isUsingCCD;
              };

              _proto.setLinearFactor = function setLinearFactor(v) {
                bt.RigidBody_setLinearFactor(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v));

                this._wakeUpIfSleep();
              };

              _proto.setAngularFactor = function setAngularFactor(v) {
                bt.RigidBody_setAngularFactor(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v));

                this._wakeUpIfSleep();
              };

              _proto.setAllowSleep = function setAllowSleep(v) {
                if (!this._rigidBody.isDynamic) return;

                if (v) {
                  bt.CollisionObject_forceActivationState(this.impl, btCollisionObjectStates.ACTIVE_TAG);
                } else {
                  bt.CollisionObject_forceActivationState(this.impl, btCollisionObjectStates.DISABLE_DEACTIVATION);
                }

                this._wakeUpIfSleep();
              };

              function BulletRigidBody() {
                this.id = void 0;
                this._isEnabled = false;
                this._isUsingCCD = false;
                this.id = BulletRigidBody.idCounter++;
              }

              _proto.clearState = function clearState() {
                bt.RigidBody_clearState(this.impl);
              };

              _proto.clearVelocity = function clearVelocity() {
                this.setLinearVelocity(Vec3.ZERO);
                this.setAngularVelocity(Vec3.ZERO);
              };

              _proto.clearForces = function clearForces() {
                bt.RigidBody_clearForces(this.impl);
              };

              _proto.initialize = function initialize(com) {
                this._rigidBody = com;
                this._sharedBody = PhysicsSystem.instance.physicsWorld.getSharedBody(this._rigidBody.node, this);
                this._sharedBody.reference = true;
              };

              _proto.onEnable = function onEnable() {
                this._isEnabled = true;
                this.setMass(this._rigidBody.mass);
                this.setAllowSleep(this._rigidBody.allowSleep);
                this.setLinearDamping(this._rigidBody.linearDamping);
                this.setAngularDamping(this._rigidBody.angularDamping);
                this.setLinearFactor(this._rigidBody.linearFactor);
                this.setAngularFactor(this._rigidBody.angularFactor);
                this.useGravity(this._rigidBody.useGravity);
                this._sharedBody.bodyEnabled = true;
              };

              _proto.onDisable = function onDisable() {
                this._isEnabled = false;
                this._sharedBody.bodyEnabled = false;
              };

              _proto.onDestroy = function onDestroy() {
                this._sharedBody.reference = false;
                this._rigidBody = null;
                this._sharedBody = null;
              };

              _proto.wakeUp = function wakeUp(force) {
                if (force === void 0) {
                  force = true;
                }

                bt.CollisionObject_activate(this.impl, force);
              };

              _proto.sleep = function sleep() {
                var state = bt.CollisionObject_getActivationState(this.impl);

                if (state !== btCollisionObjectStates.DISABLE_DEACTIVATION && state !== btCollisionObjectStates.DISABLE_SIMULATION) {
                  bt.CollisionObject_forceActivationState(this.impl, btCollisionObjectStates.ISLAND_SLEEPING);
                }
              };

              _proto.setSleepThreshold = function setSleepThreshold(v) {
                this._wakeUpIfSleep();

                bt.RigidBody_setSleepingThresholds(this.impl, v, v);
              };

              _proto.getSleepThreshold = function getSleepThreshold() {
                return bt.RigidBody_getLinearSleepingThreshold(this.impl);
              };

              _proto.getLinearVelocity = function getLinearVelocity(out) {
                return bullet2CocosVec3(out, bt.RigidBody_getLinearVelocity(this.impl));
              };

              _proto.setLinearVelocity = function setLinearVelocity(value) {
                this._wakeUpIfSleep();

                cocos2BulletVec3(bt.RigidBody_getLinearVelocity(this.impl), value);
              };

              _proto.getAngularVelocity = function getAngularVelocity(out) {
                return bullet2CocosVec3(out, bt.RigidBody_getAngularVelocity(this.impl));
              };

              _proto.setAngularVelocity = function setAngularVelocity(value) {
                this._wakeUpIfSleep();

                cocos2BulletVec3(bt.RigidBody_getAngularVelocity(this.impl), value);
              };

              _proto.applyLocalForce = function applyLocalForce(force, rel_pos) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                var quat = this._sharedBody.node.worldRotation;
                var v = Vec3.transformQuat(v3_0, force, quat);
                var rp = rel_pos ? Vec3.transformQuat(v3_1$4, rel_pos, quat) : Vec3.ZERO;
                bt.RigidBody_applyForce(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v), cocos2BulletVec3(BulletCache.instance.BT_V3_1, rp));
              };

              _proto.applyLocalTorque = function applyLocalTorque(torque) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                Vec3.transformQuat(v3_0, torque, this._sharedBody.node.worldRotation);
                bt.RigidBody_applyTorque(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v3_0));
              };

              _proto.applyLocalImpulse = function applyLocalImpulse(impulse, rel_pos) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                var quat = this._sharedBody.node.worldRotation;
                var v = Vec3.transformQuat(v3_0, impulse, quat);
                var rp = rel_pos ? Vec3.transformQuat(v3_1$4, rel_pos, quat) : Vec3.ZERO;
                bt.RigidBody_applyImpulse(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v), cocos2BulletVec3(BulletCache.instance.BT_V3_1, rp));
              };

              _proto.applyForce = function applyForce(force, rel_pos) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                var rp = rel_pos || Vec3.ZERO;
                bt.RigidBody_applyForce(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, force), cocos2BulletVec3(BulletCache.instance.BT_V3_1, rp));
              };

              _proto.applyTorque = function applyTorque(torque) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                bt.RigidBody_applyTorque(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, torque));
              };

              _proto.applyImpulse = function applyImpulse(impulse, rel_pos) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                var rp = rel_pos || Vec3.ZERO;
                bt.RigidBody_applyImpulse(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, impulse), cocos2BulletVec3(BulletCache.instance.BT_V3_1, rp));
              };

              _proto.getGroup = function getGroup() {
                return this._sharedBody.collisionFilterGroup;
              };

              _proto.setGroup = function setGroup(v) {
                this._sharedBody.collisionFilterGroup = v;
              };

              _proto.addGroup = function addGroup(v) {
                this._sharedBody.collisionFilterGroup |= v;
              };

              _proto.removeGroup = function removeGroup(v) {
                this._sharedBody.collisionFilterGroup &= ~v;
              };

              _proto.getMask = function getMask() {
                return this._sharedBody.collisionFilterMask;
              };

              _proto.setMask = function setMask(v) {
                this._sharedBody.collisionFilterMask = v;
              };

              _proto.addMask = function addMask(v) {
                this._sharedBody.collisionFilterMask |= v;
              };

              _proto.removeMask = function removeMask(v) {
                this._sharedBody.collisionFilterMask &= ~v;
              };

              _proto._wakeUpIfSleep = function _wakeUpIfSleep() {
                if (!this.isAwake) {
                  bt.CollisionObject_activate(this.impl, true);
                }
              };

              _createClass(BulletRigidBody, [{
                key: "isAwake",
                get: function get() {
                  var state = bt.CollisionObject_getActivationState(this.impl);
                  return state === btCollisionObjectStates.ACTIVE_TAG || state === btCollisionObjectStates.DISABLE_DEACTIVATION;
                }
              }, {
                key: "isSleepy",
                get: function get() {
                  var state = bt.CollisionObject_getActivationState(this.impl);
                  return state === btCollisionObjectStates.WANTS_DEACTIVATION;
                }
              }, {
                key: "isSleeping",
                get: function get() {
                  var state = bt.CollisionObject_getActivationState(this.impl);
                  return state === btCollisionObjectStates.ISLAND_SLEEPING;
                }
              }, {
                key: "impl",
                get: function get() {
                  return this._sharedBody.body;
                }
              }, {
                key: "rigidBody",
                get: function get() {
                  return this._rigidBody;
                }
              }, {
                key: "sharedBody",
                get: function get() {
                  return this._sharedBody;
                }
              }, {
                key: "isEnabled",
                get: function get() {
                  return this._isEnabled;
                }
              }]);

              return BulletRigidBody;
            }();
            BulletRigidBody.idCounter = 0;

            var v3_0$1 = CC_V3_0;
            var quat_0 = CC_QUAT_0;
            var IDCounter = 0;
            var BulletSharedBody = function () {
              BulletSharedBody.getSharedBody = function getSharedBody(node, wrappedWorld, wrappedBody) {
                var key = node.uuid;
                var newSB;

                if (BulletSharedBody.sharedBodesMap.has(key)) {
                  newSB = BulletSharedBody.sharedBodesMap.get(key);
                } else {
                  newSB = new BulletSharedBody(node, wrappedWorld);
                  var g = PhysicsGroup.DEFAULT;
                  var m = PhysicsSystem.instance.collisionMatrix[g];
                  newSB._collisionFilterGroup = g;
                  newSB._collisionFilterMask = m;
                  BulletSharedBody.sharedBodesMap.set(node.uuid, newSB);
                }

                if (wrappedBody) {
                  newSB._wrappedBody = wrappedBody;
                  var _g = wrappedBody.rigidBody.group;
                  var _m = PhysicsSystem.instance.collisionMatrix[_g];
                  newSB._collisionFilterGroup = _g;
                  newSB._collisionFilterMask = _m;
                }

                return newSB;
              };

              function BulletSharedBody(node, wrappedWorld) {
                this.id = void 0;
                this.node = void 0;
                this.wrappedWorld = void 0;
                this.wrappedJoints0 = [];
                this.wrappedJoints1 = [];
                this.dirty = 0;
                this._collisionFilterGroup = PhysicsSystem.PhysicsGroup.DEFAULT;
                this._collisionFilterMask = -1;
                this.ref = 0;
                this.bodyIndex = -1;
                this.ghostIndex = -1;
                this._wrappedBody = null;
                this.id = BulletSharedBody.idCounter++;
                this.wrappedWorld = wrappedWorld;
                this.node = node;
              }

              var _proto = BulletSharedBody.prototype;

              _proto._instantiateBodyStruct = function _instantiateBodyStruct() {
                if (this._bodyStruct) return;
                var mass = 0;

                if (this._wrappedBody && this._wrappedBody.rigidBody.enabled && this._wrappedBody.rigidBody.isDynamic) {
                  mass = this._wrappedBody.rigidBody.mass;
                }

                var trans = BulletCache.instance.BT_TRANSFORM_0;
                var quat = BulletCache.instance.BT_QUAT_0;
                cocos2BulletVec3(bt.Transform_getOrigin(trans), this.node.worldPosition);
                cocos2BulletQuat(quat, this.node.worldRotation);
                bt.Transform_setRotation(trans, quat);
                var motionState = bt.ccMotionState_new(this.id, trans);
                var body = bt.RigidBody_new(mass, motionState);
                var sleepTd = PhysicsSystem.instance.sleepThreshold;
                bt.RigidBody_setSleepingThresholds(body, sleepTd, sleepTd);
                this._bodyStruct = {
                  id: IDCounter++,
                  body: body,
                  motionState: motionState,
                  compound: bt.ccCompoundShape_new(),
                  wrappedShapes: [],
                  useCompound: false
                };
                BulletCache.setWrapper(this.id, bt.BODY_CACHE_NAME, this);
                if (this._ghostStruct) bt.CollisionObject_setIgnoreCollisionCheck(this.ghost, this.body, true);
                if (this._wrappedBody) this.setBodyType(this._wrappedBody.rigidBody.type);
              };

              _proto._instantiateGhostStruct = function _instantiateGhostStruct() {
                if (this._ghostStruct) return;
                var ghost = bt.CollisionObject_new();
                var ghostShape = bt.ccCompoundShape_new();
                bt.CollisionObject_setCollisionShape(ghost, ghostShape);
                bt.CollisionObject_setCollisionFlags(ghost, btCollisionFlags.CF_STATIC_OBJECT | btCollisionFlags.CF_NO_CONTACT_RESPONSE);
                this._ghostStruct = {
                  id: IDCounter++,
                  ghost: ghost,
                  compound: ghostShape,
                  wrappedShapes: []
                };
                if (this._bodyStruct) bt.CollisionObject_setIgnoreCollisionCheck(this.body, this.ghost, true);
                if (this._wrappedBody) this.setGhostType(this._wrappedBody.rigidBody.type);
              };

              _proto.setType = function setType(v) {
                this.setBodyType(v);
                this.setGhostType(v);
              };

              _proto.setBodyType = function setBodyType(v) {
                if (this._bodyStruct && this._wrappedBody) {
                  var body = this._bodyStruct.body;
                  var wrap = this._wrappedBody;
                  var com = wrap.rigidBody;
                  var m_bcf = bt.CollisionObject_getCollisionFlags(body);
                  var localInertia = BulletCache.instance.BT_V3_0;

                  switch (v) {
                    case ERigidBodyType.DYNAMIC:
                      m_bcf &= ~btCollisionFlags.CF_KINEMATIC_OBJECT;
                      m_bcf &= ~btCollisionFlags.CF_STATIC_OBJECT;
                      bt.CollisionObject_setCollisionFlags(body, m_bcf);
                      wrap.setMass(com.mass);
                      wrap.useGravity(com.useGravity);
                      wrap.setAllowSleep(com.allowSleep);
                      break;

                    case ERigidBodyType.KINEMATIC:
                      bt.Vec3_set(localInertia, 0, 0, 0);
                      bt.RigidBody_setMassProps(body, 0, localInertia);
                      m_bcf |= btCollisionFlags.CF_KINEMATIC_OBJECT;
                      m_bcf &= ~btCollisionFlags.CF_STATIC_OBJECT;
                      bt.CollisionObject_setCollisionFlags(body, m_bcf);
                      bt.CollisionObject_forceActivationState(body, btCollisionObjectStates.DISABLE_DEACTIVATION);
                      break;

                    case ERigidBodyType.STATIC:
                    default:
                      bt.Vec3_set(localInertia, 0, 0, 0);
                      bt.RigidBody_setMassProps(body, 0, localInertia);
                      m_bcf |= btCollisionFlags.CF_STATIC_OBJECT;
                      m_bcf &= ~btCollisionFlags.CF_KINEMATIC_OBJECT;
                      bt.CollisionObject_setCollisionFlags(body, m_bcf);
                      bt.CollisionObject_forceActivationState(body, btCollisionObjectStates.ISLAND_SLEEPING);
                      break;
                  }

                  this.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
                }
              };

              _proto.setGhostType = function setGhostType(v) {
                if (this._ghostStruct) {
                  var ghost = this._ghostStruct.ghost;
                  var m_gcf = bt.CollisionObject_getCollisionFlags(ghost);

                  switch (v) {
                    case ERigidBodyType.DYNAMIC:
                    case ERigidBodyType.KINEMATIC:
                      m_gcf &= ~btCollisionFlags.CF_STATIC_OBJECT;
                      m_gcf |= btCollisionFlags.CF_KINEMATIC_OBJECT;
                      bt.CollisionObject_setCollisionFlags(ghost, m_gcf);
                      bt.CollisionObject_forceActivationState(ghost, btCollisionObjectStates.DISABLE_DEACTIVATION);
                      break;

                    case ERigidBodyType.STATIC:
                    default:
                      m_gcf &= ~btCollisionFlags.CF_KINEMATIC_OBJECT;
                      m_gcf |= btCollisionFlags.CF_STATIC_OBJECT;
                      bt.CollisionObject_setCollisionFlags(ghost, m_gcf);
                      bt.CollisionObject_forceActivationState(ghost, btCollisionObjectStates.ISLAND_SLEEPING);
                      break;
                  }

                  this.dirty |= EBtSharedBodyDirty.GHOST_RE_ADD;
                }
              };

              _proto.addShape = function addShape(v, isTrigger) {
                function switchShape(that, shape) {
                  bt.CollisionObject_setCollisionShape(that.body, shape);
                  that.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;

                  if (that._wrappedBody && that._wrappedBody.isEnabled) {
                    that._wrappedBody.setMass(that._wrappedBody.rigidBody.mass);
                  }
                }

                if (isTrigger) {
                  var index = this.ghostStruct.wrappedShapes.indexOf(v);

                  if (index < 0) {
                    this.ghostStruct.wrappedShapes.push(v);
                    v.setCompound(this.ghostCompoundShape);
                    this.ghostEnabled = true;
                  }
                } else {
                  var _index = this.bodyStruct.wrappedShapes.indexOf(v);

                  if (_index < 0) {
                    this.bodyStruct.wrappedShapes.push(v);

                    if (this.bodyStruct.useCompound) {
                      v.setCompound(this.bodyCompoundShape);
                    } else {
                      var l = this.bodyStruct.wrappedShapes.length;

                      if (l === 1 && !v.needCompound()) {
                        switchShape(this, v.impl);
                      } else {
                        this.bodyStruct.useCompound = true;

                        for (var i = 0; i < l; i++) {
                          var childShape = this.bodyStruct.wrappedShapes[i];
                          childShape.setCompound(this.bodyCompoundShape);
                        }

                        switchShape(this, this.bodyStruct.compound);
                      }
                    }

                    this.bodyEnabled = true;
                  }
                }
              };

              _proto.removeShape = function removeShape(v, isTrigger) {
                if (isTrigger) {
                  var index = this.ghostStruct.wrappedShapes.indexOf(v);

                  if (index >= 0) {
                    fastRemoveAt(this.ghostStruct.wrappedShapes, index);
                    v.setCompound(0);
                    this.ghostEnabled = false;
                  }
                } else {
                  var _index2 = this.bodyStruct.wrappedShapes.indexOf(v);

                  if (_index2 >= 0) {
                    if (this.bodyStruct.useCompound) {
                      v.setCompound(0);
                    } else {
                      bt.CollisionObject_setCollisionShape(this.body, bt.EmptyShape_static());
                    }

                    bt.CollisionObject_activate(this.body, true);
                    this.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
                    fastRemoveAt(this.bodyStruct.wrappedShapes, _index2);
                    this.bodyEnabled = false;
                  }
                }
              };

              _proto.addJoint = function addJoint(v, type) {
                if (type) {
                  var i = this.wrappedJoints1.indexOf(v);
                  if (i < 0) this.wrappedJoints1.push(v);
                } else {
                  var _i = this.wrappedJoints0.indexOf(v);

                  if (_i < 0) this.wrappedJoints0.push(v);
                }
              };

              _proto.removeJoint = function removeJoint(v, type) {
                if (type) {
                  var i = this.wrappedJoints1.indexOf(v);
                  if (i >= 0) fastRemoveAt(this.wrappedJoints1, i);
                } else {
                  var _i2 = this.wrappedJoints0.indexOf(v);

                  if (_i2 >= 0) fastRemoveAt(this.wrappedJoints0, _i2);
                }
              };

              _proto.updateDirty = function updateDirty() {
                if (this.dirty) {
                  if (this.bodyIndex >= 0 && this.dirty & EBtSharedBodyDirty.BODY_RE_ADD) this.updateBodyByReAdd();
                  if (this.ghostIndex >= 0 && this.dirty & EBtSharedBodyDirty.GHOST_RE_ADD) this.updateGhostByReAdd();
                  this.dirty = 0;
                }
              };

              _proto.syncSceneToPhysics = function syncSceneToPhysics() {
                if (this.node.hasChangedFlags) {
                  var bt_quat = BulletCache.instance.BT_QUAT_0;
                  var bt_transform = bt.CollisionObject_getWorldTransform(this.body);
                  cocos2BulletQuat(bt_quat, this.node.worldRotation);
                  cocos2BulletVec3(bt.Transform_getOrigin(bt_transform), this.node.worldPosition);
                  bt.Transform_setRotation(bt_transform, bt_quat);

                  if (this.node.hasChangedFlags & TransformBit.SCALE) {
                    this.syncBodyScale();
                  }

                  if (bt.CollisionObject_isKinematicObject(this.body)) {
                    var ms = bt.RigidBody_getMotionState(this.body);
                    if (ms) bt.MotionState_setWorldTransform(ms, bt_transform);
                  } else if (this.isBodySleeping()) bt.CollisionObject_activate(this.body);
                }
              };

              _proto.syncPhysicsToScene = function syncPhysicsToScene() {
                if (bt.CollisionObject_isStaticOrKinematicObject(this.body)) return;
                this.syncPhysicsToGraphics();
              };

              _proto.syncPhysicsToGraphics = function syncPhysicsToGraphics() {
                if (this.isBodySleeping()) return;
                var bt_quat = BulletCache.instance.BT_QUAT_0;
                var bt_transform = BulletCache.instance.BT_TRANSFORM_0;
                bt.MotionState_getWorldTransform(bt.RigidBody_getMotionState(this.body), bt_transform);
                bt.Transform_getRotation(bt_transform, bt_quat);
                this.node.worldRotation = bullet2CocosQuat(quat_0, bt_quat);
                this.node.worldPosition = bullet2CocosVec3(v3_0$1, bt.Transform_getOrigin(bt_transform));

                if (this._ghostStruct) {
                  var bt_transform1 = bt.CollisionObject_getWorldTransform(this.ghost);
                  cocos2BulletVec3(bt.Transform_getOrigin(bt_transform1), this.node.worldPosition);
                  cocos2BulletQuat(bt_quat, this.node.worldRotation);
                  bt.Transform_setRotation(bt_transform1, bt_quat);
                }
              };

              _proto.syncSceneToGhost = function syncSceneToGhost() {
                if (this.node.hasChangedFlags) {
                  var bt_quat = BulletCache.instance.BT_QUAT_0;
                  var bt_transform = bt.CollisionObject_getWorldTransform(this.ghost);
                  cocos2BulletVec3(bt.Transform_getOrigin(bt_transform), this.node.worldPosition);
                  cocos2BulletQuat(bt_quat, this.node.worldRotation);
                  bt.Transform_setRotation(bt_transform, bt_quat);
                  if (this.node.hasChangedFlags & TransformBit.SCALE) this.syncGhostScale();
                  bt.CollisionObject_activate(this.ghost);
                }
              };

              _proto.syncInitialBody = function syncInitialBody() {
                var bt_quat = BulletCache.instance.BT_QUAT_0;
                var bt_transform = bt.CollisionObject_getWorldTransform(this.body);
                cocos2BulletVec3(bt.Transform_getOrigin(bt_transform), this.node.worldPosition);
                cocos2BulletQuat(bt_quat, this.node.worldRotation);
                bt.Transform_setRotation(bt_transform, bt_quat);
                this.syncBodyScale();
                bt.CollisionObject_activate(this.body);
              };

              _proto.syncInitialGhost = function syncInitialGhost() {
                var bt_quat = BulletCache.instance.BT_QUAT_0;
                var bt_transform = bt.CollisionObject_getWorldTransform(this.ghost);
                cocos2BulletVec3(bt.Transform_getOrigin(bt_transform), this.node.worldPosition);
                cocos2BulletQuat(bt_quat, this.node.worldRotation);
                bt.Transform_setRotation(bt_transform, bt_quat);
                this.syncGhostScale();
                bt.CollisionObject_activate(this.body);
              };

              _proto.syncBodyScale = function syncBodyScale() {
                for (var i = 0; i < this.bodyStruct.wrappedShapes.length; i++) {
                  this.bodyStruct.wrappedShapes[i].updateScale();
                }

                for (var _i3 = 0; _i3 < this.wrappedJoints0.length; _i3++) {
                  this.wrappedJoints0[_i3].updateScale0();
                }

                for (var _i4 = 0; _i4 < this.wrappedJoints1.length; _i4++) {
                  this.wrappedJoints1[_i4].updateScale1();
                }
              };

              _proto.syncGhostScale = function syncGhostScale() {
                for (var i = 0; i < this.ghostStruct.wrappedShapes.length; i++) {
                  this.ghostStruct.wrappedShapes[i].updateScale();
                }
              };

              _proto.updateBodyByReAdd = function updateBodyByReAdd() {
                if (this.bodyIndex >= 0) {
                  this.wrappedWorld.removeSharedBody(this);
                  this.bodyIndex = this.wrappedWorld.bodies.length;
                  this.wrappedWorld.addSharedBody(this);
                }
              };

              _proto.updateGhostByReAdd = function updateGhostByReAdd() {
                if (this.ghostIndex >= 0) {
                  this.wrappedWorld.removeGhostObject(this);
                  this.ghostIndex = this.wrappedWorld.ghosts.length;
                  this.wrappedWorld.addGhostObject(this);
                }
              };

              _proto.destroy = function destroy() {
                BulletSharedBody.sharedBodesMap["delete"](this.node.uuid);
                this.node = null;
                this.wrappedWorld = null;

                if (this._bodyStruct) {
                  var bodyStruct = this._bodyStruct;
                  BulletCache.delWrapper(bodyStruct.body, bt.BODY_CACHE_NAME);

                  bt._safe_delete(bodyStruct.motionState, EBulletType.EBulletTypeMotionState);

                  bt._safe_delete(bodyStruct.compound, EBulletType.EBulletTypeCollisionShape);

                  bt._safe_delete(bodyStruct.body, EBulletType.EBulletTypeCollisionObject);

                  this._bodyStruct = null;
                }

                if (this._ghostStruct) {
                  var ghostStruct = this._ghostStruct;

                  bt._safe_delete(ghostStruct.compound, EBulletType.EBulletTypeCollisionShape);

                  bt._safe_delete(ghostStruct.ghost, EBulletType.EBulletTypeCollisionObject);

                  this._ghostStruct = null;
                }
              };

              _proto.isBodySleeping = function isBodySleeping() {
                return bt.CollisionObject_getActivationState(this.body) === btCollisionObjectStates.ISLAND_SLEEPING;
              };

              _createClass(BulletSharedBody, [{
                key: "wrappedBody",
                get: function get() {
                  return this._wrappedBody;
                }
              }, {
                key: "bodyCompoundShape",
                get: function get() {
                  return this.bodyStruct.compound;
                }
              }, {
                key: "ghostCompoundShape",
                get: function get() {
                  return this.ghostStruct.compound;
                }
              }, {
                key: "body",
                get: function get() {
                  return this.bodyStruct.body;
                }
              }, {
                key: "ghost",
                get: function get() {
                  return this.ghostStruct.ghost;
                }
              }, {
                key: "collisionFilterGroup",
                get: function get() {
                  return this._collisionFilterGroup;
                },
                set: function set(v) {
                  if (v !== this._collisionFilterGroup) {
                    this._collisionFilterGroup = v;
                    this.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
                    this.dirty |= EBtSharedBodyDirty.GHOST_RE_ADD;
                  }
                }
              }, {
                key: "collisionFilterMask",
                get: function get() {
                  return this._collisionFilterMask;
                },
                set: function set(v) {
                  if (v !== this._collisionFilterMask) {
                    this._collisionFilterMask = v;
                    this.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
                    this.dirty |= EBtSharedBodyDirty.GHOST_RE_ADD;
                  }
                }
              }, {
                key: "bodyStruct",
                get: function get() {
                  this._instantiateBodyStruct();

                  return this._bodyStruct;
                }
              }, {
                key: "ghostStruct",
                get: function get() {
                  this._instantiateGhostStruct();

                  return this._ghostStruct;
                }
              }, {
                key: "bodyEnabled",
                set: function set(v) {
                  if (v) {
                    if (this.bodyIndex < 0) {
                      if (this.bodyStruct.wrappedShapes.length === 0) {
                        if (!this.wrappedBody) return;
                        if (!this.wrappedBody.rigidBody.isDynamic) return;
                      }

                      this.bodyIndex = this.wrappedWorld.bodies.length;
                      this.wrappedWorld.addSharedBody(this);
                      this.syncInitialBody();
                    }
                  } else if (this.bodyIndex >= 0) {
                    var isRemoveBody = this.bodyStruct.wrappedShapes.length === 0 && this.wrappedBody == null || this.bodyStruct.wrappedShapes.length === 0 && this.wrappedBody != null && !this.wrappedBody.isEnabled || this.bodyStruct.wrappedShapes.length === 0 && this.wrappedBody != null && !this.wrappedBody.rigidBody.enabledInHierarchy;

                    if (isRemoveBody) {
                      bt.RigidBody_clearState(this.body);
                      this.bodyIndex = -1;
                      this.wrappedWorld.removeSharedBody(this);
                    }
                  }
                }
              }, {
                key: "ghostEnabled",
                set: function set(v) {
                  if (v) {
                    if (this.ghostIndex < 0 && this.ghostStruct.wrappedShapes.length > 0) {
                      this.ghostIndex = 1;
                      this.wrappedWorld.addGhostObject(this);
                      this.syncInitialGhost();
                    }
                  } else if (this.ghostIndex >= 0) {
                    var isRemoveGhost = this.ghostStruct.wrappedShapes.length === 0 && this.ghost;

                    if (isRemoveGhost) {
                      this.ghostIndex = -1;
                      this.wrappedWorld.removeGhostObject(this);
                    }
                  }
                }
              }, {
                key: "reference",
                set: function set(v) {
                  v ? this.ref++ : this.ref--;

                  if (this.ref === 0) {
                    this.destroy();
                  }
                }
              }]);

              return BulletSharedBody;
            }();
            BulletSharedBody.idCounter = 0;
            BulletSharedBody.sharedBodesMap = new Map();

            var v3_0$2 = CC_V3_0;
            var ccMaterialBooks = {};
            var BulletShape = function () {
              function BulletShape() {
                this.id = BulletShape.idCounter++;
                this._isEnabled = false;
                this._isTrigger = false;
                this._isInitialized = false;
                this._impl = 0;
                this._compound = 0;
                this.quat = bt.Quat_new(0, 0, 0, 1);
                this.transform = bt.Transform_new();
              }

              var _proto = BulletShape.prototype;

              _proto.updateEventListener = function updateEventListener() {
                this._sharedBody.wrappedWorld.updateNeedEmitEvents(this.collider.needCollisionEvent || this.collider.needTriggerEvent);
              };

              _proto.setMaterial = function setMaterial(v) {
                var v1 = v == null ? PhysicsSystem.instance.defaultMaterial : v;

                if (!this._isTrigger && this._isEnabled) {
                  if (this._compound) {
                    if (!ccMaterialBooks[v1._uuid]) ccMaterialBooks[v1._uuid] = bt.ccMaterial_new();
                    var mat = ccMaterialBooks[v1._uuid];
                    bt.ccMaterial_set(mat, v1.restitution, v1.friction, v1.rollingFriction, v1.spinningFriction);
                    bt.CollisionShape_setMaterial(this._impl, mat);
                  } else {
                    bt.CollisionObject_setMaterial(this._sharedBody.body, v1.restitution, v1.friction, v1.rollingFriction, v1.spinningFriction);
                  }
                }
              };

              _proto.setCenter = function setCenter(v) {
                Vec3.copy(v3_0$2, v);
                v3_0$2.multiply(this._collider.node.worldScale);
                cocos2BulletVec3(bt.Transform_getOrigin(this.transform), v3_0$2);
                this.updateCompoundTransform();
              };

              _proto.setAsTrigger = function setAsTrigger(v) {
                if (this._isTrigger === v) return;

                if (this._isEnabled) {
                  this._sharedBody.removeShape(this, !v);

                  this._sharedBody.addShape(this, v);
                }

                this._isTrigger = v;
              };

              _proto.getAABB = function getAABB(v) {
                var bt_transform = BulletCache.instance.BT_TRANSFORM_0;
                bt.Transform_setIdentity(bt_transform);
                bt.Transform_setRotation(bt_transform, cocos2BulletQuat(BulletCache.instance.BT_QUAT_0, this._collider.node.worldRotation));
                var MIN = BulletCache.instance.BT_V3_0;
                var MAX = BulletCache.instance.BT_V3_1;
                bt.CollisionShape_getAabb(this._impl, bt_transform, MIN, MAX);
                v.halfExtents.x = (bt.Vec3_x(MAX) - bt.Vec3_x(MIN)) / 2;
                v.halfExtents.y = (bt.Vec3_y(MAX) - bt.Vec3_y(MIN)) / 2;
                v.halfExtents.z = (bt.Vec3_z(MAX) - bt.Vec3_z(MIN)) / 2;
                Vec3.add(v.center, this._collider.node.worldPosition, this._collider.center);
              };

              _proto.getBoundingSphere = function getBoundingSphere(v) {
                v.radius = bt.CollisionShape_getLocalBoundingSphere(this._impl);
                Vec3.add(v.center, this._collider.node.worldPosition, this._collider.center);
              };

              _proto.initialize = function initialize(com) {
                this._collider = com;
                this._isInitialized = true;
                this._sharedBody = PhysicsSystem.instance.physicsWorld.getSharedBody(this._collider.node);
                this._sharedBody.reference = true;
                this.onComponentSet();
                this.setWrapper();
              };

              _proto.setWrapper = function setWrapper() {
                if (BulletCache.isNotEmptyShape(this._impl)) {
                  bt.CollisionShape_setUserPointer(this._impl, this._impl);
                  BulletCache.setWrapper(this._impl, BulletShape.TYPE, this);
                }
              };

              _proto.onLoad = function onLoad() {
                this.setCenter(this._collider.center);
                this.setAsTrigger(this._collider.isTrigger);
              };

              _proto.onEnable = function onEnable() {
                this._isEnabled = true;

                this._sharedBody.addShape(this, this._isTrigger);

                this.setMaterial(this.collider.sharedMaterial);
              };

              _proto.onDisable = function onDisable() {
                this._isEnabled = false;

                this._sharedBody.removeShape(this, this._isTrigger);
              };

              _proto.onDestroy = function onDestroy() {
                this._sharedBody.reference = false;
                this._collider = null;

                bt._safe_delete(this.quat, EBulletType.EBulletTypeQuat);

                bt._safe_delete(this.transform, EBulletType.EBulletTypeTransform);

                if (this._compound) bt._safe_delete(this._compound, EBulletType.EBulletTypeCollisionShape);

                if (BulletCache.isNotEmptyShape(this._impl)) {
                  bt._safe_delete(this._impl, EBulletType.EBulletTypeCollisionShape);

                  BulletCache.delWrapper(this._impl, BulletShape.TYPE);
                }
              };

              _proto.updateByReAdd = function updateByReAdd() {
                if (this._isEnabled) {
                  this._sharedBody.removeShape(this, this._isTrigger);

                  this._sharedBody.addShape(this, this._isTrigger);
                }
              };

              _proto.getGroup = function getGroup() {
                return this._sharedBody.collisionFilterGroup;
              };

              _proto.setGroup = function setGroup(v) {
                this._sharedBody.collisionFilterGroup = v;
              };

              _proto.addGroup = function addGroup(v) {
                this._sharedBody.collisionFilterGroup |= v;
              };

              _proto.removeGroup = function removeGroup(v) {
                this._sharedBody.collisionFilterGroup &= ~v;
              };

              _proto.getMask = function getMask() {
                return this._sharedBody.collisionFilterMask;
              };

              _proto.setMask = function setMask(v) {
                this._sharedBody.collisionFilterMask = v;
              };

              _proto.addMask = function addMask(v) {
                this._sharedBody.collisionFilterMask |= v;
              };

              _proto.removeMask = function removeMask(v) {
                this._sharedBody.collisionFilterMask &= ~v;
              };

              _proto.setCompound = function setCompound(compound) {
                if (this._compound) bt.CompoundShape_removeChildShape(this._compound, this._impl);
                if (compound) bt.CompoundShape_addChildShape(compound, this.transform, this._impl);
                this._compound = compound;
              };

              _proto.updateScale = function updateScale() {
                this.setCenter(this._collider.center);
              };

              _proto.updateCompoundTransform = function updateCompoundTransform() {
                if (this._compound) {
                  bt.CompoundShape_updateChildTransform(this._compound, this._impl, this.transform, true);
                } else if (this._isEnabled && !this._isTrigger) {
                  if (this._sharedBody && !this._sharedBody.bodyStruct.useCompound) {
                    this._sharedBody.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
                  }
                }
              };

              _proto.needCompound = function needCompound() {
                if (this._collider.type === EColliderType.TERRAIN) {
                  return true;
                }

                if (this._collider.center.equals(Vec3.ZERO)) {
                  return false;
                }

                return true;
              };

              _createClass(BulletShape, [{
                key: "attachedRigidBody",
                get: function get() {
                  if (this._sharedBody.wrappedBody) return this._sharedBody.wrappedBody.rigidBody;
                  return null;
                }
              }, {
                key: "impl",
                get: function get() {
                  return this._impl;
                }
              }, {
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }, {
                key: "sharedBody",
                get: function get() {
                  return this._sharedBody;
                }
              }]);

              return BulletShape;
            }();
            BulletShape.TYPE = 'shape';
            BulletShape.idCounter = 0;

            var ArrayCollisionMatrix = function () {
              function ArrayCollisionMatrix() {
                this.matrix = [];
              }

              var _proto = ArrayCollisionMatrix.prototype;

              _proto.get = function get(i, j) {
                if (j > i) {
                  var temp = j;
                  j = i;
                  i = temp;
                }

                return this.matrix[(i * (i + 1) >> 1) + j - 1];
              };

              _proto.set = function set(i, j, value) {
                if (j > i) {
                  var temp = j;
                  j = i;
                  i = temp;
                }

                this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
              };

              _proto.reset = function reset() {
                this.matrix.length = 0;
              };

              _proto.setNumObjects = function setNumObjects(n) {
                this.matrix.length = n * (n - 1) >> 1;
              };

              return ArrayCollisionMatrix;
            }();

            var TupleDictionary = function () {
              function TupleDictionary() {
                this.data = void 0;
                this.data = {
                  keys: []
                };
              }

              var _proto = TupleDictionary.prototype;

              _proto.get = function get(i, j) {
                if (i > j) {
                  var temp = j;
                  j = i;
                  i = temp;
                }

                return this.data[i + "-" + j];
              };

              _proto.set = function set(i, j, value) {
                if (i > j) {
                  var temp = j;
                  j = i;
                  i = temp;
                }

                var key = i + "-" + j;

                if (value == null) {
                  var idx = this.data.keys.indexOf(key);

                  if (idx !== -1) {
                    this.data.keys.splice(idx, 1);
                    delete this.data[key];
                    return value;
                  }
                }

                if (!this.get(i, j)) {
                  this.data.keys.push(key);
                }

                this.data[key] = value;
                return this.data[key];
              };

              _proto.reset = function reset() {
                this.data = {
                  keys: []
                };
              };

              _proto.getLength = function getLength() {
                return this.data.keys.length;
              };

              _proto.getKeyByIndex = function getKeyByIndex(index) {
                return this.data.keys[index];
              };

              _proto.getDataByKey = function getDataByKey(Key) {
                return this.data[Key];
              };

              return TupleDictionary;
            }();

            var BulletContactData = function () {
              function BulletContactData(event) {
                this.impl = 0;
                this.event = void 0;
                this.event = event;
              }

              var _proto = BulletContactData.prototype;

              _proto.getLocalPointOnA = function getLocalPointOnA(out) {
                if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_localPointA(this.impl));
              };

              _proto.getLocalPointOnB = function getLocalPointOnB(out) {
                if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_localPointB(this.impl));
              };

              _proto.getWorldPointOnA = function getWorldPointOnA(out) {
                if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_positionWorldOnA(this.impl));
              };

              _proto.getWorldPointOnB = function getWorldPointOnB(out) {
                if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_positionWorldOnB(this.impl));
              };

              _proto.getLocalNormalOnA = function getLocalNormalOnA(out) {
                if (this.impl) {
                  var bt_rot = BulletCache.instance.BT_QUAT_0;
                  var body = bt.PersistentManifold_getBody0(this.event.impl);
                  var trans = bt.CollisionObject_getWorldTransform(body);
                  bt.Transform_getRotation(trans, bt_rot);
                  var inv_rot = CC_QUAT_0;
                  bullet2CocosQuat(inv_rot, bt_rot);
                  Quat.conjugate(inv_rot, inv_rot);
                  bullet2CocosVec3(out, bt.ManifoldPoint_get_m_normalWorldOnB(this.impl));
                  if (!this.isBodyA) Vec3.negate(out, out);
                  Vec3.transformQuat(out, out, inv_rot);
                }
              };

              _proto.getLocalNormalOnB = function getLocalNormalOnB(out) {
                if (this.impl) {
                  var bt_rot = BulletCache.instance.BT_QUAT_0;
                  var body = bt.PersistentManifold_getBody1(this.event.impl);
                  var trans = bt.CollisionObject_getWorldTransform(body);
                  bt.Transform_getRotation(trans, bt_rot);
                  var inv_rot = CC_QUAT_0;
                  bullet2CocosQuat(inv_rot, bt_rot);
                  Quat.conjugate(inv_rot, inv_rot);
                  bullet2CocosVec3(out, bt.ManifoldPoint_get_m_normalWorldOnB(this.impl));
                  Vec3.transformQuat(out, out, inv_rot);
                }
              };

              _proto.getWorldNormalOnA = function getWorldNormalOnA(out) {
                if (this.impl) {
                  bullet2CocosVec3(out, bt.ManifoldPoint_get_m_normalWorldOnB(this.impl));
                  if (!this.isBodyA) Vec3.negate(out, out);
                }
              };

              _proto.getWorldNormalOnB = function getWorldNormalOnB(out) {
                if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_normalWorldOnB(this.impl));
              };

              _createClass(BulletContactData, [{
                key: "isBodyA",
                get: function get() {
                  var sb = this.event.selfCollider.shape.sharedBody.body;
                  return sb === bt.PersistentManifold_getBody0(this.event.impl);
                }
              }]);

              return BulletContactData;
            }();

            var contactsPool = [];
            var v3_0$3 = CC_V3_0;
            var v3_1$5 = CC_V3_1;
            var BulletWorld = function () {
              var _proto = BulletWorld.prototype;

              _proto.setDefaultMaterial = function setDefaultMaterial(v) {};

              _proto.setAllowSleep = function setAllowSleep(v) {
                bt.ccDiscreteDynamicsWorld_setAllowSleep(this._world, v);
              };

              _proto.setGravity = function setGravity(gravity) {
                bt.DynamicsWorld_setGravity(this._world, cocos2BulletVec3(BulletCache.instance.BT_V3_0, gravity));
              };

              _proto.updateNeedEmitEvents = function updateNeedEmitEvents(v) {
                if (!this.ghosts) return;

                if (v) {
                  this._needEmitEvents = true;
                } else {
                  this._needEmitEvents = false;

                  for (var i = 0; i < this.ghosts.length; i++) {
                    var ghost = this.ghosts[i];
                    var shapes = ghost.ghostStruct.wrappedShapes;

                    for (var j = 0; j < shapes.length; j++) {
                      var collider = shapes[j].collider;

                      if (collider.needCollisionEvent || collider.needTriggerEvent) {
                        this._needEmitEvents = true;
                        return;
                      }
                    }
                  }

                  for (var _i = 0; _i < this.bodies.length; _i++) {
                    var body = this.bodies[_i];
                    var _shapes = body.bodyStruct.wrappedShapes;

                    for (var _j = 0; _j < _shapes.length; _j++) {
                      var _collider = _shapes[_j].collider;

                      if (_collider.needCollisionEvent || _collider.needTriggerEvent) {
                        this._needEmitEvents = true;
                        return;
                      }
                    }
                  }
                }
              };

              function BulletWorld() {
                this._world = void 0;
                this._broadphase = void 0;
                this._solver = void 0;
                this._dispatcher = void 0;
                this._needEmitEvents = false;
                this._needSyncAfterEvents = false;
                this.bodies = [];
                this.ghosts = [];
                this.constraints = [];
                this.triggerArrayMat = new ArrayCollisionMatrix();
                this.collisionArrayMat = new ArrayCollisionMatrix();
                this.contactsDic = new TupleDictionary();
                this.oldContactsDic = new TupleDictionary();
                this._broadphase = bt.DbvtBroadphase_new();
                this._dispatcher = bt.CollisionDispatcher_new();
                this._solver = bt.SequentialImpulseConstraintSolver_new();
                this._world = bt.ccDiscreteDynamicsWorld_new(this._dispatcher, this._broadphase, this._solver);
              }

              _proto.destroy = function destroy() {
                if (this.constraints.length || this.bodies.length) error('You should destroy all physics component first.');

                bt._safe_delete(this._world, EBulletType.EBulletTypeCollisionWorld);

                bt._safe_delete(this._broadphase, EBulletType.EBulletTypeDbvtBroadPhase);

                bt._safe_delete(this._dispatcher, EBulletType.EBulletTypeCollisionDispatcher);

                bt._safe_delete(this._solver, EBulletType.EBulletTypeSequentialImpulseConstraintSolver);

                this.bodies = null;
                this.ghosts = null;
                this.constraints = null;
                this.triggerArrayMat = null;
                this.collisionArrayMat = null;
                this.contactsDic = null;
                this.oldContactsDic = null;
                contactsPool.length = 0;
              };

              _proto.step = function step(deltaTime, timeSinceLastCalled, maxSubStep) {
                if (maxSubStep === void 0) {
                  maxSubStep = 0;
                }

                if (!this.bodies.length && !this.ghosts.length) return;
                if (timeSinceLastCalled === undefined) timeSinceLastCalled = deltaTime;
                bt.DynamicsWorld_stepSimulation(this._world, timeSinceLastCalled, maxSubStep, deltaTime);
              };

              _proto.syncSceneToPhysics = function syncSceneToPhysics() {
                for (var i = this.ghosts.length - 1; i >= 0; i--) {
                  var ghost = this.ghosts[i];
                  ghost.updateDirty();
                  ghost.syncSceneToGhost();
                }

                for (var _i2 = this.bodies.length - 1; _i2 >= 0; _i2--) {
                  var body = this.bodies[_i2];
                  body.updateDirty();
                  body.syncSceneToPhysics();
                }
              };

              _proto.syncAfterEvents = function syncAfterEvents() {
                if (!this._needSyncAfterEvents) return;
                this.syncSceneToPhysics();
              };

              _proto.raycast = function raycast(worldRay, options, pool, results) {
                worldRay.computeHit(v3_0$3, options.maxDistance);
                var to = cocos2BulletVec3(BulletCache.instance.BT_V3_0, v3_0$3);
                var from = cocos2BulletVec3(BulletCache.instance.BT_V3_1, worldRay.o);
                var allHitsCB = bt.ccAllRayCallback_static();
                bt.ccAllRayCallback_reset(allHitsCB, from, to, options.mask, options.queryTrigger);
                bt.ccAllRayCallback_setFlags(allHitsCB, EBulletTriangleRaycastFlag.UseSubSimplexConvexCastRaytest);
                bt.CollisionWorld_rayTest(this._world, from, to, allHitsCB);

                if (bt.RayCallback_hasHit(allHitsCB)) {
                  var posArray = bt.ccAllRayCallback_getHitPointWorld(allHitsCB);
                  var normalArray = bt.ccAllRayCallback_getHitNormalWorld(allHitsCB);
                  var ptrArray = bt.ccAllRayCallback_getCollisionShapePtrs(allHitsCB);

                  for (var i = 0, n = bt.int_array_size(ptrArray); i < n; i++) {
                    bullet2CocosVec3(v3_0$3, bt.Vec3_array_at(posArray, i));
                    bullet2CocosVec3(v3_1$5, bt.Vec3_array_at(normalArray, i));
                    var shape = BulletCache.getWrapper(bt.int_array_at(ptrArray, i), BulletShape.TYPE);
                    var r = pool.add();
                    results.push(r);

                    r._assign(v3_0$3, Vec3.distance(worldRay.o, v3_0$3), shape.collider, v3_1$5);
                  }

                  return true;
                }

                return false;
              };

              _proto.raycastClosest = function raycastClosest(worldRay, options, result) {
                worldRay.computeHit(v3_0$3, options.maxDistance);
                var to = cocos2BulletVec3(BulletCache.instance.BT_V3_0, v3_0$3);
                var from = cocos2BulletVec3(BulletCache.instance.BT_V3_1, worldRay.o);
                var closeHitCB = bt.ccClosestRayCallback_static();
                bt.ccClosestRayCallback_reset(closeHitCB, from, to, options.mask, options.queryTrigger);
                bt.ccClosestRayCallback_setFlags(closeHitCB, EBulletTriangleRaycastFlag.UseSubSimplexConvexCastRaytest);
                bt.CollisionWorld_rayTest(this._world, from, to, closeHitCB);

                if (bt.RayCallback_hasHit(closeHitCB)) {
                  bullet2CocosVec3(v3_0$3, bt.ccClosestRayCallback_getHitPointWorld(closeHitCB));
                  bullet2CocosVec3(v3_1$5, bt.ccClosestRayCallback_getHitNormalWorld(closeHitCB));
                  var shape = BulletCache.getWrapper(bt.ccClosestRayCallback_getCollisionShapePtr(closeHitCB), BulletShape.TYPE);

                  result._assign(v3_0$3, Vec3.distance(worldRay.o, v3_0$3), shape.collider, v3_1$5);

                  return true;
                }

                return false;
              };

              _proto.getSharedBody = function getSharedBody(node, wrappedBody) {
                return BulletSharedBody.getSharedBody(node, this, wrappedBody);
              };

              _proto.addSharedBody = function addSharedBody(sharedBody) {
                var i = this.bodies.indexOf(sharedBody);

                if (i < 0) {
                  this.bodies.push(sharedBody);
                  bt.DynamicsWorld_addRigidBody(this._world, sharedBody.body, sharedBody.collisionFilterGroup, sharedBody.collisionFilterMask);
                }
              };

              _proto.removeSharedBody = function removeSharedBody(sharedBody) {
                var i = this.bodies.indexOf(sharedBody);

                if (i >= 0) {
                  fastRemoveAt(this.bodies, i);
                  bt.DynamicsWorld_removeRigidBody(this._world, sharedBody.body);
                }
              };

              _proto.addGhostObject = function addGhostObject(sharedBody) {
                var i = this.ghosts.indexOf(sharedBody);

                if (i < 0) {
                  this.ghosts.push(sharedBody);
                  bt.CollisionWorld_addCollisionObject(this._world, sharedBody.ghost, sharedBody.collisionFilterGroup, sharedBody.collisionFilterMask);
                }
              };

              _proto.removeGhostObject = function removeGhostObject(sharedBody) {
                var i = this.ghosts.indexOf(sharedBody);

                if (i >= 0) {
                  fastRemoveAt(this.ghosts, i);
                  bt.CollisionWorld_removeCollisionObject(this._world, sharedBody.ghost);
                }
              };

              _proto.addConstraint = function addConstraint(constraint) {
                var i = this.constraints.indexOf(constraint);

                if (i < 0) {
                  this.constraints.push(constraint);
                  bt.DynamicsWorld_addConstraint(this.impl, constraint.impl, !constraint.constraint.enableCollision);
                  constraint.index = i;
                }
              };

              _proto.removeConstraint = function removeConstraint(constraint) {
                var i = this.constraints.indexOf(constraint);

                if (i >= 0) {
                  this.constraints.splice(i, 1);
                  bt.DynamicsWorld_removeConstraint(this.impl, constraint.impl);
                  constraint.index = -1;
                }
              };

              _proto.emitEvents = function emitEvents() {
                this._needSyncAfterEvents = false;
                if (!this._needEmitEvents) return;
                this.gatherConatactData();
                var dicL = this.contactsDic.getLength();

                while (dicL--) {
                  contactsPool.push.apply(contactsPool, CollisionEventObject$1.contacts);
                  CollisionEventObject$1.contacts.length = 0;
                  var key = this.contactsDic.getKeyByIndex(dicL);
                  var data = this.contactsDic.getDataByKey(key);
                  var shape0 = data.shape0;
                  var shape1 = data.shape1;
                  this.oldContactsDic.set(shape0.id, shape1.id, data);
                  var collider0 = shape0.collider;
                  var collider1 = shape1.collider;

                  if (collider0 && collider1) {
                    var isTrigger = collider0.isTrigger || collider1.isTrigger;

                    if (isTrigger) {
                      if (this.triggerArrayMat.get(shape0.id, shape1.id)) {
                        TriggerEventObject$1.type = 'onTriggerStay';
                      } else {
                        TriggerEventObject$1.type = 'onTriggerEnter';
                        this.triggerArrayMat.set(shape0.id, shape1.id, true);
                      }

                      TriggerEventObject$1.impl = data.impl;
                      TriggerEventObject$1.selfCollider = collider0;
                      TriggerEventObject$1.otherCollider = collider1;
                      collider0.emit(TriggerEventObject$1.type, TriggerEventObject$1);
                      TriggerEventObject$1.selfCollider = collider1;
                      TriggerEventObject$1.otherCollider = collider0;
                      collider1.emit(TriggerEventObject$1.type, TriggerEventObject$1);
                      this._needSyncAfterEvents = true;
                    } else {
                      var body0 = collider0.attachedRigidBody;
                      var body1 = collider1.attachedRigidBody;

                      if (body0 && body1) {
                        if (body0.isSleeping && body1.isSleeping) continue;
                      } else if (!body0 && body1) {
                        if (body1.isSleeping) continue;
                      } else if (!body1 && body0) {
                        if (body0.isSleeping) continue;
                      }

                      if (this.collisionArrayMat.get(shape0.id, shape1.id)) {
                        CollisionEventObject$1.type = 'onCollisionStay';
                      } else {
                        CollisionEventObject$1.type = 'onCollisionEnter';
                        this.collisionArrayMat.set(shape0.id, shape1.id, true);
                      }

                      for (var i = 0; i < data.contacts.length; i++) {
                        var cq = data.contacts[i];

                        if (contactsPool.length > 0) {
                          var c = contactsPool.pop();
                          c.impl = cq;
                          CollisionEventObject$1.contacts.push(c);
                        } else {
                          var _c = new BulletContactData(CollisionEventObject$1);

                          _c.impl = cq;
                          CollisionEventObject$1.contacts.push(_c);
                        }
                      }

                      CollisionEventObject$1.impl = data.impl;
                      CollisionEventObject$1.selfCollider = collider0;
                      CollisionEventObject$1.otherCollider = collider1;
                      collider0.emit(CollisionEventObject$1.type, CollisionEventObject$1);
                      CollisionEventObject$1.selfCollider = collider1;
                      CollisionEventObject$1.otherCollider = collider0;
                      collider1.emit(CollisionEventObject$1.type, CollisionEventObject$1);
                      this._needSyncAfterEvents = true;
                    }

                    if (this.oldContactsDic.get(shape0.id, shape1.id) == null) {
                      this.oldContactsDic.set(shape0.id, shape1.id, data);
                    }
                  }
                }

                var oldDicL = this.oldContactsDic.getLength();

                while (oldDicL--) {
                  var _key = this.oldContactsDic.getKeyByIndex(oldDicL);

                  var _data = this.oldContactsDic.getDataByKey(_key);

                  var _shape = _data.shape0;
                  var _shape2 = _data.shape1;
                  var _collider2 = _shape.collider;
                  var _collider3 = _shape2.collider;

                  if (_collider2 && _collider3) {
                    var _isTrigger = _collider2.isTrigger || _collider3.isTrigger;

                    if (this.contactsDic.getDataByKey(_key) == null) {
                      if (_isTrigger) {
                        if (this.triggerArrayMat.get(_shape.id, _shape2.id)) {
                          TriggerEventObject$1.type = 'onTriggerExit';
                          TriggerEventObject$1.selfCollider = _collider2;
                          TriggerEventObject$1.otherCollider = _collider3;

                          _collider2.emit(TriggerEventObject$1.type, TriggerEventObject$1);

                          TriggerEventObject$1.selfCollider = _collider3;
                          TriggerEventObject$1.otherCollider = _collider2;

                          _collider3.emit(TriggerEventObject$1.type, TriggerEventObject$1);

                          this.triggerArrayMat.set(_shape.id, _shape2.id, false);
                          this.oldContactsDic.set(_shape.id, _shape2.id, null);
                          this._needSyncAfterEvents = true;
                        }
                      } else if (this.collisionArrayMat.get(_shape.id, _shape2.id)) {
                        contactsPool.push.apply(contactsPool, CollisionEventObject$1.contacts);
                        CollisionEventObject$1.contacts.length = 0;
                        CollisionEventObject$1.type = 'onCollisionExit';
                        CollisionEventObject$1.selfCollider = _collider2;
                        CollisionEventObject$1.otherCollider = _collider3;

                        _collider2.emit(CollisionEventObject$1.type, CollisionEventObject$1);

                        CollisionEventObject$1.selfCollider = _collider3;
                        CollisionEventObject$1.otherCollider = _collider2;

                        _collider3.emit(CollisionEventObject$1.type, CollisionEventObject$1);

                        this.collisionArrayMat.set(_shape.id, _shape2.id, false);
                        this.oldContactsDic.set(_shape.id, _shape2.id, null);
                        this._needSyncAfterEvents = true;
                      }
                    }
                  }
                }

                this.contactsDic.reset();
              };

              _proto.gatherConatactData = function gatherConatactData() {
                var numManifolds = bt.Dispatcher_getNumManifolds(this._dispatcher);

                for (var i = 0; i < numManifolds; i++) {
                  var manifold = bt.Dispatcher_getManifoldByIndexInternal(this._dispatcher, i);
                  var numContacts = bt.PersistentManifold_getNumContacts(manifold);

                  for (var j = 0; j < numContacts; j++) {
                    var manifoldPoint = bt.PersistentManifold_getContactPoint(manifold, j);
                    var s0 = bt.ManifoldPoint_getShape0(manifoldPoint);
                    var s1 = bt.ManifoldPoint_getShape1(manifoldPoint);
                    var shape0 = BulletCache.getWrapper(s0, BulletShape.TYPE);
                    var shape1 = BulletCache.getWrapper(s1, BulletShape.TYPE);

                    if (shape0.collider.needTriggerEvent || shape1.collider.needTriggerEvent || shape0.collider.needCollisionEvent || shape1.collider.needCollisionEvent) {
                      var item = this.contactsDic.get(shape0.id, shape1.id);

                      if (!item) {
                        item = this.contactsDic.set(shape0.id, shape1.id, {
                          shape0: shape0,
                          shape1: shape1,
                          contacts: [],
                          impl: manifold
                        });
                      }

                      item.contacts.push(manifoldPoint);
                    }
                  }
                }
              };

              _createClass(BulletWorld, [{
                key: "impl",
                get: function get() {
                  return this._world;
                }
              }]);

              return BulletWorld;
            }();

            var BulletBoxShape = function (_BulletShape) {
              _inheritsLoose(BulletBoxShape, _BulletShape);

              function BulletBoxShape() {
                return _BulletShape.apply(this, arguments) || this;
              }

              var _proto = BulletBoxShape.prototype;

              _proto.updateSize = function updateSize() {
                var hf = BulletCache.instance.BT_V3_0;
                cocos2BulletVec3(hf, this.getMinUnscaledHalfExtents(VEC3_0));
                bt.BoxShape_setUnscaledHalfExtents(this.impl, hf);
                this.updateCompoundTransform();
              };

              _proto.onComponentSet = function onComponentSet() {
                var hf = BulletCache.instance.BT_V3_0;
                cocos2BulletVec3(hf, this.getMinUnscaledHalfExtents(VEC3_0));
                this._impl = bt.BoxShape_new(hf);
                this.updateScale();
              };

              _proto.updateScale = function updateScale() {
                _BulletShape.prototype.updateScale.call(this);

                var bt_v3 = BulletCache.instance.BT_V3_0;
                bt.CollisionShape_setLocalScaling(this._impl, cocos2BulletVec3(bt_v3, this.getMinScale(VEC3_0)));
                this.updateCompoundTransform();
              };

              _proto.getMinUnscaledHalfExtents = function getMinUnscaledHalfExtents(out) {
                var size = this.collider.size;
                var ws = absolute(VEC3_0.set(this._collider.node.worldScale));
                var minVolumeSize = PhysicsSystem.instance.minVolumeSize;
                var halfSizeX = size.x / 2;
                var halfSizeY = size.y / 2;
                var halfSizeZ = size.z / 2;
                var halfX = halfSizeX * ws.x < minVolumeSize ? minVolumeSize / ws.x : halfSizeX;
                var halfY = halfSizeY * ws.y < minVolumeSize ? minVolumeSize / ws.y : halfSizeY;
                var halfZ = halfSizeZ * ws.z < minVolumeSize ? minVolumeSize / ws.z : halfSizeZ;
                out.set(halfX, halfY, halfZ);
                return out;
              };

              _proto.getMinScale = function getMinScale(out) {
                var size = this.collider.size;
                var ws = absolute(VEC3_0.set(this._collider.node.worldScale));
                var minVolumeSize = PhysicsSystem.instance.minVolumeSize;
                var halfSizeX = size.x / 2;
                var halfSizeY = size.y / 2;
                var halfSizeZ = size.z / 2;
                var scaleX = halfSizeX * ws.x < minVolumeSize ? minVolumeSize / halfSizeX : ws.x;
                var scaleY = halfSizeY * ws.y < minVolumeSize ? minVolumeSize / halfSizeY : ws.y;
                var scaleZ = halfSizeZ * ws.z < minVolumeSize ? minVolumeSize / halfSizeZ : ws.z;
                out.set(scaleX, scaleY, scaleZ);
                return out;
              };

              _createClass(BulletBoxShape, [{
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }]);

              return BulletBoxShape;
            }(BulletShape);

            var BulletSphereShape = function (_BulletShape) {
              _inheritsLoose(BulletSphereShape, _BulletShape);

              function BulletSphereShape() {
                return _BulletShape.apply(this, arguments) || this;
              }

              var _proto = BulletSphereShape.prototype;

              _proto.updateRadius = function updateRadius() {
                bt.SphereShape_setUnscaledRadius(this.impl, this.getMinUnscaledRadius());
                this.updateCompoundTransform();
              };

              _proto.onComponentSet = function onComponentSet() {
                this._impl = bt.SphereShape_new(this.getMinUnscaledRadius());
                this.updateScale();
              };

              _proto.updateScale = function updateScale() {
                _BulletShape.prototype.updateScale.call(this);

                var scale = this.getMinScale();
                CC_V3_0.set(scale, scale, scale);
                var bt_v3 = BulletCache.instance.BT_V3_0;
                bt.CollisionShape_setLocalScaling(this._impl, cocos2BulletVec3(bt_v3, CC_V3_0));
                this.updateCompoundTransform();
              };

              _proto.getMinUnscaledRadius = function getMinUnscaledRadius() {
                var radius = this.collider.radius;
                var ws = Math.abs(absMaxComponent(this._collider.node.worldScale));
                var minVolumeSize = PhysicsSystem.instance.minVolumeSize;
                return ws * radius < minVolumeSize ? minVolumeSize / ws : radius;
              };

              _proto.getMinScale = function getMinScale() {
                var radius = this.collider.radius;
                var ws = Math.abs(absMaxComponent(this._collider.node.worldScale));
                var minVolumeSize = PhysicsSystem.instance.minVolumeSize;
                return ws * radius < minVolumeSize ? minVolumeSize / radius : ws;
              };

              _createClass(BulletSphereShape, [{
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }]);

              return BulletSphereShape;
            }(BulletShape);

            var BulletCapsuleShape = function (_BulletShape) {
              _inheritsLoose(BulletCapsuleShape, _BulletShape);

              function BulletCapsuleShape() {
                return _BulletShape.apply(this, arguments) || this;
              }

              var _proto = BulletCapsuleShape.prototype;

              _proto.setCylinderHeight = function setCylinderHeight(v) {
                this.updateProperties(this.collider.radius, this.collider.cylinderHeight, this.collider.direction, this._collider.node.worldScale);
              };

              _proto.setDirection = function setDirection(v) {
                this.updateProperties(this.collider.radius, this.collider.cylinderHeight, this.collider.direction, this._collider.node.worldScale);
              };

              _proto.setRadius = function setRadius(v) {
                this.updateProperties(this.collider.radius, this.collider.cylinderHeight, this.collider.direction, this._collider.node.worldScale);
              };

              _proto.onComponentSet = function onComponentSet() {
                this._impl = bt.CapsuleShape_new(0.5, 1);
                this.setRadius(this.collider.radius);
              };

              _proto.updateScale = function updateScale() {
                _BulletShape.prototype.updateScale.call(this);

                this.setRadius(this.collider.radius);
              };

              _proto.updateProperties = function updateProperties(radius, height, direction, scale) {
                var ws = scale;
                var upAxis = direction;
                var wr;
                var halfH;

                if (upAxis === 1) {
                  wr = radius * Math.abs(absMax(ws.x, ws.z));
                  halfH = height / 2 * Math.abs(ws.y);
                } else if (upAxis === 0) {
                  wr = radius * Math.abs(absMax(ws.y, ws.z));
                  halfH = height / 2 * Math.abs(ws.x);
                } else {
                  wr = radius * Math.abs(absMax(ws.x, ws.y));
                  halfH = height / 2 * Math.abs(ws.z);
                }

                bt.CapsuleShape_updateProp(this._impl, wr, halfH, upAxis);
                this.updateCompoundTransform();
              };

              _createClass(BulletCapsuleShape, [{
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }]);

              return BulletCapsuleShape;
            }(BulletShape);

            var BulletBvhTriangleMeshShape = function () {
              BulletBvhTriangleMeshShape.getBulletBvhTriangleMeshShape = function getBulletBvhTriangleMeshShape(key, mesh) {
                var newBulletBvhTriangleMeshShape;

                if (BulletBvhTriangleMeshShape.BulletBvhTriangleMeshShapeMap.has(key)) {
                  newBulletBvhTriangleMeshShape = BulletBvhTriangleMeshShape.BulletBvhTriangleMeshShapeMap.get(key);
                  newBulletBvhTriangleMeshShape.reference = true;
                } else {
                  newBulletBvhTriangleMeshShape = new BulletBvhTriangleMeshShape(key, mesh);
                  BulletBvhTriangleMeshShape.BulletBvhTriangleMeshShapeMap.set(key, newBulletBvhTriangleMeshShape);
                }

                return newBulletBvhTriangleMeshShape;
              };

              function BulletBvhTriangleMeshShape(key, mesh) {
                this.key = void 0;
                this.ref = 0;
                this.bulletBvhTriangleMeshShapePtr = void 0;
                this.btTriangleMeshPtr = 0;
                this.reference = true;
                this.key = key;
                this.btTriangleMeshPtr = bt.TriangleMesh_new();
                cocos2BulletTriMesh(this.btTriangleMeshPtr, mesh);
                this.bulletBvhTriangleMeshShapePtr = bt.BvhTriangleMeshShape_new(this.btTriangleMeshPtr, true, true);
              }

              var _proto = BulletBvhTriangleMeshShape.prototype;

              _proto.destroy = function destroy() {
                if (this.bulletBvhTriangleMeshShapePtr) {
                  bt._safe_delete(EBulletType.EBulletTypeCollisionShape, this.bulletBvhTriangleMeshShapePtr);
                }

                if (this.btTriangleMeshPtr) {
                  bt._safe_delete(EBulletType.EBulletTypeTriangleMesh, this.btTriangleMeshPtr);
                }

                BulletBvhTriangleMeshShape.BulletBvhTriangleMeshShapeMap["delete"](this.key);
              };

              _createClass(BulletBvhTriangleMeshShape, [{
                key: "reference",
                set: function set(v) {
                  v ? this.ref++ : this.ref--;

                  if (this.ref === 0) {
                    this.destroy();
                  }
                }
              }]);

              return BulletBvhTriangleMeshShape;
            }();
            BulletBvhTriangleMeshShape.BulletBvhTriangleMeshShapeMap = new Map();

            var BulletTrimeshShape = function (_BulletShape) {
              _inheritsLoose(BulletTrimeshShape, _BulletShape);

              function BulletTrimeshShape() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _BulletShape.call.apply(_BulletShape, [this].concat(args)) || this;
                _this.btBVHMeshShape = void 0;
                _this.refBtTriangleMesh = 0;
                return _this;
              }

              var _proto = BulletTrimeshShape.prototype;

              _proto.setMesh = function setMesh(v) {
                if (!this._isInitialized) return;

                if (this._impl && BulletCache.isNotEmptyShape(this._impl)) {
                  warnID(9620);
                } else {
                  var mesh = v;

                  if (mesh && mesh.renderingSubMeshes.length > 0) {
                    if (this.collider.convex) {
                      var btTriangleMesh = this._getBtTriangleMesh(mesh);

                      this._impl = bt.ConvexTriangleMeshShape_new(btTriangleMesh);
                    } else {
                      this.btBVHMeshShape = BulletBvhTriangleMeshShape.getBulletBvhTriangleMeshShape(mesh.hash, mesh);
                      this._impl = bt.ScaledBvhTriangleMeshShape_new(this.btBVHMeshShape.bulletBvhTriangleMeshShapePtr, 1, 1, 1);
                    }

                    var bt_v3 = BulletCache.instance.BT_V3_0;
                    cocos2BulletVec3(bt_v3, this._collider.node.worldScale);
                    bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
                    bt.CollisionShape_setMargin(this._impl, 0.01);
                    this.setCompound(this._compound);
                    this.updateByReAdd();
                    this.setWrapper();
                  } else {
                    this._impl = bt.EmptyShape_static();
                  }
                }
              };

              _proto.onComponentSet = function onComponentSet() {
                this.setMesh(this.collider.mesh);
              };

              _proto.onDestroy = function onDestroy() {
                if (this.collider.convex) {
                  if (this.refBtTriangleMesh) {
                    bt._safe_delete(this.refBtTriangleMesh, EBulletType.EBulletTypeTriangleMesh);
                  }
                } else if (this.btBVHMeshShape) {
                  this.btBVHMeshShape.reference = false;
                }

                _BulletShape.prototype.onDestroy.call(this);
              };

              _proto.updateScale = function updateScale() {
                _BulletShape.prototype.updateScale.call(this);

                var bt_v3 = BulletCache.instance.BT_V3_0;
                cocos2BulletVec3(bt_v3, this._collider.node.worldScale);
                bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
                this.updateCompoundTransform();
              };

              _proto._getBtTriangleMesh = function _getBtTriangleMesh(mesh) {
                this.refBtTriangleMesh = bt.TriangleMesh_new();
                cocos2BulletTriMesh(this.refBtTriangleMesh, mesh);
                return this.refBtTriangleMesh;
              };

              _createClass(BulletTrimeshShape, [{
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }]);

              return BulletTrimeshShape;
            }(BulletShape);

            var BulletCylinderShape = function (_BulletShape) {
              _inheritsLoose(BulletCylinderShape, _BulletShape);

              function BulletCylinderShape() {
                return _BulletShape.apply(this, arguments) || this;
              }

              var _proto = BulletCylinderShape.prototype;

              _proto.setHeight = function setHeight(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              };

              _proto.setDirection = function setDirection(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              };

              _proto.setRadius = function setRadius(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              };

              _proto.onComponentSet = function onComponentSet() {
                var bt_v3 = BulletCache.instance.BT_V3_0;
                bt.Vec3_set(bt_v3, 0.5, 1, 0.5);
                this._impl = bt.CylinderShape_new(bt_v3);
                this.setRadius(this.collider.radius);
              };

              _proto.updateScale = function updateScale() {
                _BulletShape.prototype.updateScale.call(this);

                this.setRadius(this.collider.radius);
              };

              _proto.updateProperties = function updateProperties(radius, height, direction, scale) {
                var ws = scale;
                var upAxis = direction;
                var wr;
                var wh;

                if (upAxis === 1) {
                  wh = height * Math.abs(ws.y);
                  wr = radius * Math.abs(absMax(ws.x, ws.z));
                } else if (upAxis === 0) {
                  wh = height * Math.abs(ws.x);
                  wr = radius * Math.abs(absMax(ws.y, ws.z));
                } else {
                  wh = height * Math.abs(ws.z);
                  wr = radius * Math.abs(absMax(ws.x, ws.y));
                }

                bt.CylinderShape_updateProp(this._impl, wr, wh / 2, upAxis);
                this.updateCompoundTransform();
              };

              _createClass(BulletCylinderShape, [{
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }]);

              return BulletCylinderShape;
            }(BulletShape);

            var BulletConeShape = function (_BulletShape) {
              _inheritsLoose(BulletConeShape, _BulletShape);

              function BulletConeShape() {
                return _BulletShape.apply(this, arguments) || this;
              }

              var _proto = BulletConeShape.prototype;

              _proto.setHeight = function setHeight(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              };

              _proto.setDirection = function setDirection(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              };

              _proto.setRadius = function setRadius(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              };

              _proto.onComponentSet = function onComponentSet() {
                this._impl = bt.ConeShape_new(0.5, 1);
                this.setRadius(this.collider.radius);
              };

              _proto.updateScale = function updateScale() {
                _BulletShape.prototype.updateScale.call(this);

                this.setRadius(this.collider.radius);
              };

              _proto.updateProperties = function updateProperties(radius, height, direction, scale) {
                var ws = scale;
                var upAxis = direction;
                var wr;
                var wh;

                if (upAxis === 1) {
                  wh = height * Math.abs(ws.y);
                  wr = radius * Math.abs(absMax(ws.x, ws.z));
                } else if (upAxis === 0) {
                  wh = height * Math.abs(ws.x);
                  wr = radius * Math.abs(absMax(ws.y, ws.z));
                } else {
                  wh = height * Math.abs(ws.z);
                  wr = radius * Math.abs(absMax(ws.x, ws.y));
                }

                bt.ConeShape_setRadius(this._impl, wr);
                bt.ConeShape_setHeight(this._impl, wh);
                bt.ConeShape_setConeUpIndex(this._impl, upAxis);
                var bt_v3 = BulletCache.instance.BT_V3_0;
                bt.Vec3_set(bt_v3, 1, 1, 1);
                bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
                this.updateCompoundTransform();
              };

              _createClass(BulletConeShape, [{
                key: "impl",
                get: function get() {
                  return this._impl;
                }
              }, {
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }]);

              return BulletConeShape;
            }(BulletShape);

            var BulletTerrainShape = function (_BulletShape) {
              _inheritsLoose(BulletTerrainShape, _BulletShape);

              function BulletTerrainShape() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _BulletShape.call.apply(_BulletShape, [this].concat(args)) || this;
                _this._bufPtr = 0;
                _this._tileSize = 0;
                _this._localOffset = new Vec3();
                return _this;
              }

              var _proto = BulletTerrainShape.prototype;

              _proto.setTerrain = function setTerrain(v) {
                if (!this._isInitialized) return;

                if (this._impl && BulletCache.isNotEmptyShape(this._impl)) {
                  warn('[Physics][Bullet]: change the terrain asset after initialization is not support.');
                } else {
                  var terrain = v;

                  if (terrain) {
                    this._tileSize = terrain.tileSize;
                    var sizeI = terrain.getVertexCountI();
                    var sizeJ = terrain.getVertexCountJ();
                    this._bufPtr = bt._malloc(4 * sizeI * sizeJ);
                    var offset = 0;
                    var min = Number.MAX_SAFE_INTEGER;
                    var max = Number.MIN_SAFE_INTEGER;

                    for (var j = 0; j < sizeJ; j++) {
                      for (var i = 0; i < sizeI; i++) {
                        var _v = terrain.getHeight(i, j);

                        bt._write_f32(this._bufPtr + offset, _v);

                        if (min > _v) min = _v;
                        if (_v > max) max = _v;
                        offset += 4;
                      }
                    }

                    max += 0.01;
                    min -= 0.01;

                    this._localOffset.set((sizeI - 1) / 2 * this._tileSize, (max + min) / 2, (sizeJ - 1) / 2 * this._tileSize);

                    this._impl = bt.TerrainShape_new(sizeI, sizeJ, this._bufPtr, 1, min, max);
                    var bt_v3 = BulletCache.instance.BT_V3_0;
                    bt.Vec3_set(bt_v3, this._tileSize, 1, this._tileSize);
                    bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
                    this.setCompound(this._compound);
                    this.updateByReAdd();
                    this.setWrapper();
                  } else {
                    this._impl = bt.EmptyShape_static();
                  }
                }
              };

              _proto.onComponentSet = function onComponentSet() {
                this.setTerrain(this.collider.terrain);
              };

              _proto.onDestroy = function onDestroy() {
                if (this._bufPtr) bt._free(this._bufPtr);

                _BulletShape.prototype.onDestroy.call(this);
              };

              _proto.setCenter = function setCenter(v) {
                Vec3.copy(CC_V3_0, v);
                CC_V3_0.add(this._localOffset);
                cocos2BulletVec3(bt.Transform_getOrigin(this.transform), CC_V3_0);
                this.updateCompoundTransform();
              };

              _createClass(BulletTerrainShape, [{
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }]);

              return BulletTerrainShape;
            }(BulletShape);

            var BulletSimplexShape = function (_BulletShape) {
              _inheritsLoose(BulletSimplexShape, _BulletShape);

              function BulletSimplexShape() {
                return _BulletShape.apply(this, arguments) || this;
              }

              var _proto = BulletSimplexShape.prototype;

              _proto.setShapeType = function setShapeType(v) {};

              _proto.setVertices = function setVertices(v) {};

              _proto.onComponentSet = function onComponentSet() {
                this._impl = bt.SimplexShape_new();
                var length = this.collider.shapeType;
                var vertices = this.collider.vertices;
                var bt_v3 = BulletCache.instance.BT_V3_0;

                for (var i = 0; i < length; i++) {
                  bt.SimplexShape_addVertex(this._impl, cocos2BulletVec3(bt_v3, vertices[i]));
                }

                bt.CollisionShape_setLocalScaling(this._impl, cocos2BulletVec3(bt_v3, this._collider.node.worldScale));
              };

              _proto.onLoad = function onLoad() {
                _BulletShape.prototype.onLoad.call(this);

                this.collider.updateVertices();
              };

              _proto.updateScale = function updateScale() {
                _BulletShape.prototype.updateScale.call(this);

                var bt_v3 = BulletCache.instance.BT_V3_0;
                bt.CollisionShape_setLocalScaling(this._impl, cocos2BulletVec3(bt_v3, this._collider.node.worldScale));
              };

              _createClass(BulletSimplexShape, [{
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }]);

              return BulletSimplexShape;
            }(BulletShape);

            var BulletPlaneShape = function (_BulletShape) {
              _inheritsLoose(BulletPlaneShape, _BulletShape);

              function BulletPlaneShape() {
                return _BulletShape.apply(this, arguments) || this;
              }

              var _proto = BulletPlaneShape.prototype;

              _proto.setNormal = function setNormal(v) {
                cocos2BulletVec3(bt.StaticPlaneShape_getPlaneNormal(this.impl), v);
                this.updateCompoundTransform();
              };

              _proto.setConstant = function setConstant(v) {
                bt.StaticPlaneShape_setPlaneConstant(this.impl, v);
                this.updateCompoundTransform();
              };

              _proto.updateScale = function updateScale() {
                _BulletShape.prototype.updateScale.call(this);

                var bt_v3 = BulletCache.instance.BT_V3_0;
                cocos2BulletVec3(bt_v3, this._collider.node.worldScale);
                bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
                this.updateCompoundTransform();
              };

              _proto.onComponentSet = function onComponentSet() {
                var normal = BulletCache.instance.BT_V3_0;
                cocos2BulletVec3(normal, this.collider.normal);
                this._impl = bt.StaticPlaneShape_new(normal, this.collider.constant);
                this.updateScale();
              };

              _createClass(BulletPlaneShape, [{
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }]);

              return BulletPlaneShape;
            }(BulletShape);

            var BulletConstraint = function () {
              function BulletConstraint() {
                this.dirty = 0;
                this.index = -1;
                this._impl = 0;
                this._collided = false;
              }

              var _proto = BulletConstraint.prototype;

              _proto.setConnectedBody = function setConnectedBody(v) {};

              _proto.setEnableCollision = function setEnableCollision(v) {
                if (this._collided !== v) {
                  this._collided = v;
                  this.updateByReAdd();
                }
              };

              _proto.updateByReAdd = function updateByReAdd() {
                if (this._rigidBody && this.index >= 0) {
                  var sb = this._rigidBody.body.sharedBody;
                  sb.wrappedWorld.removeConstraint(this);
                  sb.wrappedWorld.addConstraint(this);
                }
              };

              _proto.initialize = function initialize(v) {
                this._com = v;
                this._rigidBody = v.attachedBody;
                this._collided = v.enableCollision;
                this.onComponentSet();
              };

              _proto.onEnable = function onEnable() {
                var sb = this._rigidBody.body.sharedBody;
                sb.wrappedWorld.addConstraint(this);
                sb.addJoint(this, 0);
                var connect = this.constraint.connectedBody;

                if (connect) {
                  var sb2 = connect.body.sharedBody;
                  sb2.addJoint(this, 1);
                }
              };

              _proto.onDisable = function onDisable() {
                var sb = this._rigidBody.body.sharedBody;
                sb.wrappedWorld.removeConstraint(this);
                sb.removeJoint(this, 0);
                var connect = this.constraint.connectedBody;

                if (connect) {
                  var sb2 = connect.body.sharedBody;
                  sb2.removeJoint(this, 1);
                }
              };

              _proto.onDestroy = function onDestroy() {
                bt._safe_delete(this._impl, EBulletType.EBulletTypeTypedConstraint);

                this._com = null;
                this._rigidBody = null;
              };

              _createClass(BulletConstraint, [{
                key: "impl",
                get: function get() {
                  return this._impl;
                }
              }, {
                key: "constraint",
                get: function get() {
                  return this._com;
                }
              }]);

              return BulletConstraint;
            }();

            var BulletP2PConstraint = function (_BulletConstraint) {
              _inheritsLoose(BulletP2PConstraint, _BulletConstraint);

              function BulletP2PConstraint() {
                return _BulletConstraint.apply(this, arguments) || this;
              }

              var _proto = BulletP2PConstraint.prototype;

              _proto.setPivotA = function setPivotA(v) {
                var cs = this.constraint;
                var pivotA = BulletCache.instance.BT_V3_0;
                Vec3.multiply(CC_V3_0, cs.node.worldScale, cs.pivotA);
                cocos2BulletVec3(pivotA, CC_V3_0);
                bt.P2PConstraint_setPivotA(this._impl, pivotA);
                if (!cs.connectedBody) this.setPivotB(cs.pivotB);
              };

              _proto.setPivotB = function setPivotB(v) {
                var cs = this.constraint;
                var node = this._rigidBody.node;
                var pivotB = BulletCache.instance.BT_V3_0;
                var cb = cs.connectedBody;

                if (cb) {
                  Vec3.multiply(CC_V3_0, cb.node.worldScale, cs.pivotB);
                  cocos2BulletVec3(pivotB, CC_V3_0);
                } else {
                  Vec3.multiply(CC_V3_0, node.worldScale, cs.pivotA);
                  Vec3.add(CC_V3_0, CC_V3_0, node.worldPosition);
                  Vec3.add(CC_V3_0, CC_V3_0, cs.pivotB);
                  cocos2BulletVec3(pivotB, CC_V3_0);
                }

                bt.P2PConstraint_setPivotB(this._impl, pivotB);
              };

              _proto.onComponentSet = function onComponentSet() {
                var cb = this.constraint.connectedBody;
                var bodyA = this._rigidBody.body.impl;
                var bodyB = cb ? cb.body.impl : bt.TypedConstraint_getFixedBody();
                var pivotA = BulletCache.instance.BT_V3_0;
                var pivotB = BulletCache.instance.BT_V3_1;
                this._impl = bt.P2PConstraint_new(bodyA, bodyB, pivotA, pivotB);
                this.setPivotA(this.constraint.pivotA);
                this.setPivotB(this.constraint.pivotB);
              };

              _proto.updateScale0 = function updateScale0() {
                this.setPivotA(this.constraint.pivotA);
              };

              _proto.updateScale1 = function updateScale1() {
                this.setPivotB(this.constraint.pivotB);
              };

              _createClass(BulletP2PConstraint, [{
                key: "constraint",
                get: function get() {
                  return this._com;
                }
              }]);

              return BulletP2PConstraint;
            }(BulletConstraint);

            var BulletFixedConstraint = function (_BulletConstraint) {
              _inheritsLoose(BulletFixedConstraint, _BulletConstraint);

              function BulletFixedConstraint() {
                return _BulletConstraint.apply(this, arguments) || this;
              }

              var _proto = BulletFixedConstraint.prototype;

              _proto.setBreakForce = function setBreakForce(v) {
                bt.TypedConstraint_setMaxImpulseThreshold(this._impl, v);
              };

              _proto.setBreakTorque = function setBreakTorque(v) {};

              _proto.onComponentSet = function onComponentSet() {
                var cb = this.constraint.connectedBody;
                var bodyA = this._rigidBody.body.sharedBody;
                var bodyB = cb ? cb.body.sharedBody : PhysicsSystem.instance.physicsWorld.getSharedBody(bodyA.node);
                var trans0 = BulletCache.instance.BT_TRANSFORM_0;
                var trans1 = BulletCache.instance.BT_TRANSFORM_1;
                this._impl = bt.FixedConstraint_new(bodyA.body, bodyB.body, trans0, trans1);
                this.setBreakForce(this.constraint.breakForce);
                this.setBreakTorque(this.constraint.breakTorque);
                this.updateFrames();
              };

              _proto.updateFrames = function updateFrames() {
                var cb = this.constraint.connectedBody;
                var bodyA = this._rigidBody.body.sharedBody;
                var bodyB = cb ? cb.body.sharedBody : PhysicsSystem.instance.physicsWorld.getSharedBody(bodyA.node);
                var pos = CC_V3_0;
                var rot = CC_QUAT_0;
                var trans0 = BulletCache.instance.BT_TRANSFORM_0;
                var trans1 = BulletCache.instance.BT_TRANSFORM_1;
                var quat = BulletCache.instance.BT_QUAT_0;
                var trans = CC_MAT4_0;
                Mat4.fromRT(trans, bodyA.node.worldRotation, bodyA.node.worldPosition);
                Mat4.invert(trans, trans);
                Mat4.getRotation(rot, trans);
                Mat4.getTranslation(pos, trans);
                cocos2BulletVec3(bt.Transform_getOrigin(trans0), pos);
                cocos2BulletQuat(quat, rot);
                bt.Transform_setRotation(trans0, quat);
                Mat4.fromRT(trans, bodyB.node.worldRotation, bodyB.node.worldPosition);
                Mat4.invert(trans, trans);
                Mat4.getRotation(rot, trans);
                Mat4.getTranslation(pos, trans);
                cocos2BulletVec3(bt.Transform_getOrigin(trans1), pos);
                cocos2BulletQuat(quat, rot);
                bt.Transform_setRotation(trans1, quat);
                bt.FixedConstraint_setFrames(this._impl, trans0, trans1);
              };

              _proto.updateScale0 = function updateScale0() {
                this.updateFrames();
              };

              _proto.updateScale1 = function updateScale1() {
                this.updateFrames();
              };

              _createClass(BulletFixedConstraint, [{
                key: "constraint",
                get: function get() {
                  return this._com;
                }
              }]);

              return BulletFixedConstraint;
            }(BulletConstraint);

            var BulletHingeConstraint = function (_BulletConstraint) {
              _inheritsLoose(BulletHingeConstraint, _BulletConstraint);

              function BulletHingeConstraint() {
                return _BulletConstraint.apply(this, arguments) || this;
              }

              var _proto = BulletHingeConstraint.prototype;

              _proto.setPivotA = function setPivotA(v) {
                this.updateFrames();
              };

              _proto.setPivotB = function setPivotB(v) {
                this.updateFrames();
              };

              _proto.setAxis = function setAxis(v) {
                this.updateFrames();
              };

              _proto.onComponentSet = function onComponentSet() {
                var cb = this.constraint.connectedBody;
                var bodyA = this._rigidBody.body.impl;
                var bodyB = cb ? cb.body.impl : bt.TypedConstraint_getFixedBody();
                var trans0 = BulletCache.instance.BT_TRANSFORM_0;
                var trans1 = BulletCache.instance.BT_TRANSFORM_1;
                this._impl = bt.HingeConstraint_new(bodyA, bodyB, trans0, trans1);
                this.updateFrames();
              };

              _proto.updateFrames = function updateFrames() {
                var cs = this.constraint;
                var node = cs.node;
                var v3_0 = CC_V3_0;
                var rot_0 = CC_QUAT_0;
                var trans0 = BulletCache.instance.BT_TRANSFORM_0;
                Vec3.multiply(v3_0, node.worldScale, cs.pivotA);
                cocos2BulletVec3(bt.Transform_getOrigin(trans0), v3_0);
                var quat = BulletCache.instance.BT_QUAT_0;
                Quat.rotationTo(rot_0, Vec3.UNIT_Z, cs.axis);
                cocos2BulletQuat(quat, rot_0);
                bt.Transform_setRotation(trans0, quat);
                var trans1 = BulletCache.instance.BT_TRANSFORM_1;
                var cb = this.constraint.connectedBody;

                if (cb) {
                  Vec3.multiply(v3_0, cb.node.worldScale, cs.pivotB);
                } else {
                  Vec3.multiply(v3_0, node.worldScale, cs.pivotA);
                  Vec3.add(v3_0, v3_0, node.worldPosition);
                  Vec3.add(v3_0, v3_0, cs.pivotB);
                  Quat.multiply(rot_0, rot_0, node.worldRotation);
                }

                cocos2BulletVec3(bt.Transform_getOrigin(trans1), v3_0);
                cocos2BulletQuat(quat, rot_0);
                bt.Transform_setRotation(trans1, quat);
                bt.HingeConstraint_setFrames(this._impl, trans0, trans1);
              };

              _proto.updateScale0 = function updateScale0() {
                this.updateFrames();
              };

              _proto.updateScale1 = function updateScale1() {
                this.updateFrames();
              };

              _createClass(BulletHingeConstraint, [{
                key: "constraint",
                get: function get() {
                  return this._com;
                }
              }]);

              return BulletHingeConstraint;
            }(BulletConstraint);

            game.once(Game.EVENT_PRE_SUBSYSTEM_INIT, function () {
              selector.register('bullet', {
                PhysicsWorld: BulletWorld,
                RigidBody: BulletRigidBody,
                BoxShape: BulletBoxShape,
                SphereShape: BulletSphereShape,
                CapsuleShape: BulletCapsuleShape,
                TrimeshShape: BulletTrimeshShape,
                CylinderShape: BulletCylinderShape,
                ConeShape: BulletConeShape,
                TerrainShape: BulletTerrainShape,
                SimplexShape: BulletSimplexShape,
                PlaneShape: BulletPlaneShape,
                PointToPointConstraint: BulletP2PConstraint,
                HingeConstraint: BulletHingeConstraint,
                FixedConstraint: BulletFixedConstraint
              });
            });

            var _dec$1S, _dec2$1p, _class$1V, _class2$1F, _initializer$1A, _initializer2$1k, _class3$p, _temp$y;
            var PrimitiveType;

            (function (PrimitiveType) {
              PrimitiveType[PrimitiveType["BOX"] = 0] = "BOX";
              PrimitiveType[PrimitiveType["SPHERE"] = 1] = "SPHERE";
              PrimitiveType[PrimitiveType["CYLINDER"] = 2] = "CYLINDER";
              PrimitiveType[PrimitiveType["CONE"] = 3] = "CONE";
              PrimitiveType[PrimitiveType["CAPSULE"] = 4] = "CAPSULE";
              PrimitiveType[PrimitiveType["TORUS"] = 5] = "TORUS";
              PrimitiveType[PrimitiveType["PLANE"] = 6] = "PLANE";
              PrimitiveType[PrimitiveType["QUAD"] = 7] = "QUAD";
            })(PrimitiveType || (PrimitiveType = {}));

            ccenum(PrimitiveType);
            var Primitive = exports('Primitive', (_dec$1S = ccclass$p('cc.Primitive'), _dec2$1p = type$8(PrimitiveType), _dec$1S(_class$1V = (_class2$1F = (_temp$y = _class3$p = function (_Mesh) {
              _inheritsLoose(Primitive, _Mesh);

              function Primitive(type) {
                var _this;

                if (type === void 0) {
                  type = PrimitiveType.BOX;
                }

                _this = _Mesh.call(this) || this;
                _this.type = _initializer$1A && _initializer$1A();
                _this.info = _initializer2$1k && _initializer2$1k();
                _this.type = type;
                return _this;
              }

              var _proto = Primitive.prototype;

              _proto.onLoaded = function onLoaded() {
                _createMesh(primitives[PrimitiveType[this.type].toLowerCase()](this.info), this);
              };

              return Primitive;
            }(Mesh), _class3$p.PrimitiveType = PrimitiveType, _temp$y), (_initializer$1A = applyDecoratedInitializer(_class2$1F.prototype, "type", [_dec2$1p], function () {
              return PrimitiveType.BOX;
            }), _initializer2$1k = applyDecoratedInitializer(_class2$1F.prototype, "info", [serializable$j], function () {
              return {};
            })), _class2$1F)) || _class$1V));
            legacyCC.Primitive = Primitive;

            legacyCC.primitives = primitives;

            var Counter = function () {
              function Counter(id, opts, now) {
                this._opts = void 0;
                this._total = 0;
                this._value = 0;
                this._averageValue = 0;
                this._accumValue = 0;
                this._accumSamples = 0;
                this._id = id;
                this._opts = opts;
                this._accumStart = now;
              }

              var _proto = Counter.prototype;

              _proto.sample = function sample(now) {
                this._average(this._value, now);
              };

              _proto.human = function human() {
                var _this$_opts = this._opts,
                    average = _this$_opts.average,
                    isInteger = _this$_opts.isInteger;
                var v = average ? this._averageValue : this._value;
                return isInteger ? Math.round(v) : Math.round(v * 100) / 100;
              };

              _proto.alarm = function alarm() {
                return this._opts.below && this._value < this._opts.below || this._opts.over && this._value > this._opts.over;
              };

              _proto._average = function _average(v, now) {
                if (now === void 0) {
                  now = 0;
                }

                if (this._opts.average) {
                  this._accumValue += v;
                  ++this._accumSamples;
                  var t = now;

                  if (t - this._accumStart >= this._opts.average) {
                    this._averageValue = this._accumValue / this._accumSamples;
                    this._accumValue = 0;
                    this._accumStart = t;
                    this._accumSamples = 0;
                  }
                }
              };

              _createClass(Counter, [{
                key: "value",
                get: function get() {
                  return this._value;
                },
                set: function set(val) {
                  this._value = val;
                }
              }]);

              return Counter;
            }();

            var _dec$1T, _class$1W;
            var PerfCounter = (_dec$1T = ccclass$p('cc.PerfCounter'), _dec$1T(_class$1W = function (_Counter) {
              _inheritsLoose(PerfCounter, _Counter);

              function PerfCounter(id, opts, now) {
                var _this;

                _this = _Counter.call(this, id, opts, now) || this;
                _this._time = now;
                return _this;
              }

              var _proto = PerfCounter.prototype;

              _proto.start = function start(now) {
                if (now === void 0) {
                  now = 0;
                }

                this._time = now;
              };

              _proto.end = function end(now) {
                if (now === void 0) {
                  now = 0;
                }

                this._value = now - this._time;

                this._average(this._value);
              };

              _proto.tick = function tick() {
                this.end();
                this.start();
              };

              _proto.frame = function frame(now) {
                var t = now;
                var e = t - this._time;
                this._total++;
                var avg = this._opts.average || 1000;

                if (e > avg) {
                  this._value = this._total * 1000 / e;
                  this._total = 0;
                  this._time = t;

                  this._average(this._value);
                }
              };

              return PerfCounter;
            }(Counter)) || _class$1W);

            var _characters = '0123456789. ';
            var _average = 500;
            var _string2offset = {
              0: 0,
              1: 1,
              2: 2,
              3: 3,
              4: 4,
              5: 5,
              6: 6,
              7: 7,
              8: 8,
              9: 9,
              '.': 10
            };
            var _profileInfo = {
              fps: {
                desc: "Framerate (FPS)",
                below: 30,
                average: _average,
                isInteger: true
              },
              draws: {
                desc: 'Draw call',
                isInteger: true
              },
              frame: {
                desc: 'Frame time (ms)',
                min: 0,
                max: 50,
                average: _average
              },
              instances: {
                desc: 'Instance Count',
                isInteger: true
              },
              tricount: {
                desc: 'Triangle',
                isInteger: true
              },
              logic: {
                desc: 'Game Logic (ms)',
                min: 0,
                max: 50,
                average: _average,
                color: '#080'
              },
              physics: {
                desc: 'Physics (ms)',
                min: 0,
                max: 50,
                average: _average
              },
              render: {
                desc: 'Renderer (ms)',
                min: 0,
                max: 50,
                average: _average,
                color: '#f90'
              },
              present: {
                desc: 'Present (ms)',
                min: 0,
                max: 50,
                average: _average,
                color: '#f90'
              },
              textureMemory: {
                desc: 'GFX Texture Mem(M)'
              },
              bufferMemory: {
                desc: 'GFX Buffer Mem(M)'
              }
            };
            var _constants = {
              fontSize: 23,
              quadHeight: 0.4,
              segmentsPerLine: 8,
              textureWidth: 280,
              textureHeight: 280
            };
            var Profiler = exports('Profiler', function (_System) {
              _inheritsLoose(Profiler, _System);

              function Profiler() {
                var _this;

                _this = _System.call(this) || this;
                _this._stats = null;
                _this._showFPS = false;
                _this._rootNode = null;
                _this._device = null;
                _this._swapchain = null;
                _this._meshRenderer = null;
                _this._canvas = null;
                _this._ctx = null;
                _this._texture = null;
                _this._region = new BufferTextureCopy();
                _this._canvasArr = [];
                _this._regionArr = [_this._region];
                _this.digitsData = null;
                _this.offsetData = null;
                _this.pass = null;
                _this._canvasDone = false;
                _this._statsDone = false;
                _this._inited = false;
                _this._lineHeight = _constants.textureHeight / (Object.keys(_profileInfo).length + 1);
                _this._wordHeight = 0;
                _this._eachNumWidth = 0;
                _this._totalLines = 0;
                _this.lastTime = 0;

                {
                  _this._canvas = ccwindow.document.createElement('canvas');
                  _this._ctx = _this._canvas.getContext('2d');

                  _this._canvasArr.push(_this._canvas);
                }

                return _this;
              }

              var _proto = Profiler.prototype;

              _proto.init = function init() {
                var showFPS = !!settings.querySettings(Settings.Category.PROFILING, 'showFPS');

                if (showFPS) {
                  this.showStats();
                } else {
                  this.hideStats();
                }
              };

              _proto.isShowingStats = function isShowingStats() {
                return this._showFPS;
              };

              _proto.hideStats = function hideStats() {
                if (this._showFPS) {
                  if (this._rootNode) {
                    this._rootNode.active = false;
                  }

                  legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_AFTER_RENDER, this.afterRender, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_AFTER_DRAW, this.afterPresent, this);
                  this._showFPS = false;
                  director.root.pipeline.profiler = null;
                  legacyCC.game.config.showFPS = false;
                }
              };

              _proto.showStats = function showStats() {
                if (!this._showFPS) {
                  if (!this._device) {
                    var root = legacyCC.director.root;
                    this._device = deviceManager.gfxDevice;
                    this._swapchain = root.mainWindow.swapchain;
                  }

                  this.generateCanvas();
                  this.generateStats();
                  legacyCC.game.once(legacyCC.Game.EVENT_ENGINE_INITED, this.generateNode, this);
                  legacyCC.game.on(legacyCC.Game.EVENT_RESTART, this.generateNode, this);

                  if (this._rootNode) {
                    this._rootNode.active = true;
                  }

                  legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this);
                  legacyCC.director.on(legacyCC.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this);
                  legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this);
                  legacyCC.director.on(legacyCC.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this);
                  legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this);
                  legacyCC.director.on(legacyCC.Director.EVENT_AFTER_RENDER, this.afterRender, this);
                  legacyCC.director.on(legacyCC.Director.EVENT_AFTER_DRAW, this.afterPresent, this);
                  this._showFPS = true;
                  this._canvasDone = true;
                  this._statsDone = true;
                  legacyCC.game.config.showFPS = true;
                }
              };

              _proto.generateCanvas = function generateCanvas() {
                if (this._canvasDone) {
                  return;
                }

                var textureWidth = _constants.textureWidth,
                    textureHeight = _constants.textureHeight;

                if (!this._ctx || !this._canvas) {
                  return;
                }

                this._canvas.width = textureWidth;
                this._canvas.height = textureHeight;
                this._canvas.style.width = "" + this._canvas.width;
                this._canvas.style.height = "" + this._canvas.height;
                this._ctx.font = _constants.fontSize + "px Arial";
                this._ctx.textBaseline = 'top';
                this._ctx.fillStyle = '#fff';
                this._texture = this._device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, textureWidth, textureHeight));
                this._region.texExtent.width = textureWidth;
                this._region.texExtent.height = textureHeight;
              };

              _proto.generateStats = function generateStats() {
                if (this._statsDone || !this._ctx || !this._canvas) {
                  return;
                }

                this._stats = null;
                var now = performance.now();
                this._ctx.textAlign = 'left';
                var i = 0;

                for (var id in _profileInfo) {
                  var element = _profileInfo[id];

                  this._ctx.fillText(element.desc, 0, i * this._lineHeight);

                  element.counter = new PerfCounter(id, element, now);
                  i++;
                }

                this._totalLines = i;
                this._wordHeight = this._totalLines * this._lineHeight / this._canvas.height;

                for (var j = 0; j < _characters.length; ++j) {
                  var offset = this._ctx.measureText(_characters[j]).width;

                  this._eachNumWidth = Math.max(this._eachNumWidth, offset);
                }

                for (var _j = 0; _j < _characters.length; ++_j) {
                  this._ctx.fillText(_characters[_j], _j * this._eachNumWidth, this._totalLines * this._lineHeight);
                }

                this._eachNumWidth /= this._canvas.width;
                this._stats = _profileInfo;
                this._canvasArr[0] = this._canvas;

                this._device.copyTexImagesToTexture(this._canvasArr, this._texture, this._regionArr);
              };

              _proto.generateNode = function generateNode() {
                if (this._rootNode && this._rootNode.isValid) {
                  return;
                }

                this._rootNode = new Node('PROFILER_NODE');
                this._rootNode._objFlags = legacyCC.Object.Flags.DontSave | legacyCC.Object.Flags.HideInHierarchy;
                legacyCC.game.addPersistRootNode(this._rootNode);
                var managerNode = new Node('Profiler_Root');
                managerNode.parent = this._rootNode;
                var height = _constants.quadHeight;
                var rowHeight = height / this._totalLines;
                var lWidth = height / this._wordHeight;
                var scale = rowHeight / _constants.fontSize;
                var columnWidth = this._eachNumWidth * this._canvas.width * scale;
                var vertexPos = [0, height, 0, lWidth, height, 0, lWidth, 0, 0, 0, 0, 0];
                var vertexindices = [0, 2, 1, 0, 3, 2];
                var vertexUV = [0, 0, -1, 0, 1, 0, -1, 0, 1, this._wordHeight, -1, 0, 0, this._wordHeight, -1, 0];
                var offset = 0;

                for (var i = 0; i < this._totalLines; i++) {
                  for (var j = 0; j < _constants.segmentsPerLine; j++) {
                    vertexPos.push(lWidth + j * columnWidth, height - i * rowHeight, 0);
                    vertexPos.push(lWidth + (j + 1) * columnWidth, height - i * rowHeight, 0);
                    vertexPos.push(lWidth + (j + 1) * columnWidth, height - (i + 1) * rowHeight, 0);
                    vertexPos.push(lWidth + j * columnWidth, height - (i + 1) * rowHeight, 0);
                    offset = (i * _constants.segmentsPerLine + j + 1) * 4;
                    vertexindices.push(0 + offset, 2 + offset, 1 + offset, 0 + offset, 3 + offset, 2 + offset);
                    var idx = i * _constants.segmentsPerLine + j;
                    var z = Math.floor(idx / 4);
                    var w = idx - z * 4;
                    vertexUV.push(0, this._wordHeight, z, w);
                    vertexUV.push(this._eachNumWidth, this._wordHeight, z, w);
                    vertexUV.push(this._eachNumWidth, 1, z, w);
                    vertexUV.push(0, 1, z, w);
                  }
                }

                this._meshRenderer = managerNode.addComponent(MeshRenderer);
                this._meshRenderer.mesh = _createMesh({
                  positions: vertexPos,
                  indices: vertexindices,
                  colors: vertexUV
                });

                var _material = new Material();

                _material.initialize({
                  effectName: 'util/profiler'
                });

                var pass = this.pass = _material.passes[0];
                var hTexture = pass.getBinding('mainTexture');
                var bDigits = pass.getBinding('digits');
                var bOffset = pass.getBinding('offset');
                pass.bindTexture(hTexture, this._texture);
                this.digitsData = pass.blocks[bDigits];
                this.offsetData = pass.blocks[bOffset];
                this.offsetData[3] = -1;
                this._meshRenderer.material = _material;
                this._meshRenderer.node.layer = Layers.Enum.PROFILER;
                this._inited = true;
              };

              _proto.beforeUpdate = function beforeUpdate() {
                if (!this._stats) {
                  return;
                }

                var now = performance.now();

                this._stats.frame.counter.start(now);

                this._stats.logic.counter.start(now);
              };

              _proto.afterUpdate = function afterUpdate() {
                if (!this._stats) {
                  return;
                }

                var now = performance.now();

                if (legacyCC.director.isPaused()) {
                  this._stats.frame.counter.start(now);
                } else {
                  this._stats.logic.counter.end(now);
                }
              };

              _proto.beforePhysics = function beforePhysics() {
                if (!this._stats) {
                  return;
                }

                var now = performance.now();

                this._stats.physics.counter.start(now);
              };

              _proto.afterPhysics = function afterPhysics() {
                if (!this._stats) {
                  return;
                }

                var now = performance.now();

                this._stats.physics.counter.end(now);
              };

              _proto.beforeDraw = function beforeDraw() {
                if (!this._stats || !this._inited) {
                  return;
                }

                var surfaceTransform = this._swapchain.surfaceTransform;
                var clipSpaceSignY = this._device.capabilities.clipSpaceSignY;

                if (surfaceTransform !== this.offsetData[3]) {
                  var preTransform = preTransforms[surfaceTransform];
                  var x = -0.9;
                  var y = -0.9 * clipSpaceSignY;

                  if (sys.isXR) {
                    x = -0.5;
                    y = -0.5 * clipSpaceSignY;
                  }

                  this.offsetData[0] = x * preTransform[0] + y * preTransform[2];
                  this.offsetData[1] = x * preTransform[1] + y * preTransform[3];
                  this.offsetData[2] = this._eachNumWidth;
                  this.offsetData[3] = surfaceTransform;
                }

                this.pass._rootBufferDirty = true;

                if (this._meshRenderer.model) {
                  director.root.pipeline.profiler = this._meshRenderer.model;
                } else {
                  director.root.pipeline.profiler = null;
                }

                var now = performance.now();

                this._stats.render.counter.start(now);
              };

              _proto.afterRender = function afterRender() {
                if (!this._stats || !this._inited) {
                  return;
                }

                var now = performance.now();

                this._stats.render.counter.end(now);

                this._stats.present.counter.start(now);
              };

              _proto.afterPresent = function afterPresent() {
                if (!this._stats || !this._inited) {
                  return;
                }

                var now = performance.now();

                this._stats.frame.counter.end(now);

                this._stats.fps.counter.frame(now);

                this._stats.present.counter.end(now);

                if (now - this.lastTime < _average) {
                  return;
                }

                this.lastTime = now;
                var device = this._device;
                this._stats.draws.counter.value = device.numDrawCalls;
                this._stats.instances.counter.value = device.numInstances;
                this._stats.bufferMemory.counter.value = device.memoryStatus.bufferSize / (1024 * 1024);
                this._stats.textureMemory.counter.value = device.memoryStatus.textureSize / (1024 * 1024);
                this._stats.tricount.counter.value = device.numTris;
                var i = 0;
                var view = this.digitsData;

                for (var id in this._stats) {
                  var stat = this._stats[id];
                  stat.counter.sample(now);
                  var result = stat.counter.human().toString();

                  for (var j = _constants.segmentsPerLine - 1; j >= 0; j--) {
                    var index = i * _constants.segmentsPerLine + j;
                    var character = result[result.length - (_constants.segmentsPerLine - j)];
                    var offset = _string2offset[character];

                    if (offset === undefined) {
                      offset = 11;
                    }

                    view[index] = offset;
                  }

                  i++;
                }
              };

              return Profiler;
            }(System));
            var profiler = exports('profiler', new Profiler());
            director.registerSystem('profiler', profiler, 0);
            legacyCC.profiler = profiler;

            var DataPoolManager = function () {
              function DataPoolManager(device) {
                this.jointTexturePool = void 0;
                this.jointAnimationInfo = void 0;
                this.jointTexturePool = new JointTexturePool(device);
                this.jointAnimationInfo = new JointAnimationInfo(device);
              }

              var _proto = DataPoolManager.prototype;

              _proto.releaseSkeleton = function releaseSkeleton(skeleton) {
                this.jointTexturePool.releaseSkeleton(skeleton);
              };

              _proto.releaseAnimationClip = function releaseAnimationClip(clip) {
                this.jointTexturePool.releaseAnimationClip(clip);
              };

              _proto.clear = function clear() {
                this.jointTexturePool.clear();
                this.jointAnimationInfo.clear();
              };

              return DataPoolManager;
            }();
            legacyCC.internal.DataPoolManager = DataPoolManager;

            var m4_1$5 = new Mat4();
            var m4_2$1 = new Mat4();
            var SkeletalAnimationState = exports('SkeletalAnimationState', function (_AnimationState) {
              _inheritsLoose(SkeletalAnimationState, _AnimationState);

              function SkeletalAnimationState(clip, name) {
                var _this;

                if (name === void 0) {
                  name = '';
                }

                _this = _AnimationState.call(this, clip, name) || this;
                _this._frames = 1;
                _this._bakedDuration = 0;
                _this._animInfo = null;
                _this._sockets = [];
                _this._animInfoMgr = void 0;
                _this._parent = null;
                _this._curvesInited = false;
                _this._animInfoMgr = legacyCC.director.root.dataPoolManager.jointAnimationInfo;
                return _this;
              }

              var _proto = SkeletalAnimationState.prototype;

              _proto.initialize = function initialize(root) {
                if (this._curveLoaded) {
                  return;
                }

                this._parent = root.getComponent('cc.SkeletalAnimation');
                var baked = this._parent.useBakedAnimation;
                this._doNotCreateEval = baked;

                _AnimationState.prototype.initialize.call(this, root);

                this._curvesInited = !baked;

                var _SkelAnimDataHub$getO = SkelAnimDataHub.getOrExtract(this.clip),
                    frames = _SkelAnimDataHub$getO.frames,
                    samples = _SkelAnimDataHub$getO.samples;

                this._frames = frames - 1;
                this._animInfo = this._animInfoMgr.getData(root.uuid);
                this._bakedDuration = this._frames / samples;
                this.setUseBaked(baked);
              };

              _proto.onPlay = function onPlay() {
                var _this2 = this;

                _AnimationState.prototype.onPlay.call(this);

                var baked = this._parent.useBakedAnimation;

                if (baked) {
                  this._animInfoMgr.switchClip(this._animInfo, this.clip);

                  var users = this._parent.getUsers();

                  users.forEach(function (user) {
                    user.uploadAnimation(_this2.clip);
                  });
                }
              };

              _proto.setUseBaked = function setUseBaked(useBaked) {
                if (useBaked) {
                  this._sampleCurves = this._sampleCurvesBaked;
                  this.duration = this._bakedDuration;
                } else {
                  this._sampleCurves = _AnimationState.prototype._sampleCurves;
                  this.duration = this.clip.duration;

                  if (!this._curvesInited) {
                    this._curveLoaded = false;

                    _AnimationState.prototype.initialize.call(this, this._targetNode);

                    this._curvesInited = true;
                  }
                }
              };

              _proto.rebuildSocketCurves = function rebuildSocketCurves(sockets) {
                this._sockets.length = 0;

                if (!this._targetNode) {
                  return;
                }

                var root = this._targetNode;

                for (var i = 0; i < sockets.length; ++i) {
                  var socket = sockets[i];
                  var targetNode = root.getChildByPath(socket.path);

                  if (!socket.target) {
                    continue;
                  }

                  var clipData = SkelAnimDataHub.getOrExtract(this.clip);
                  var animPath = socket.path;
                  var source = clipData.joints[animPath];
                  var animNode = targetNode;
                  var downstream = void 0;

                  while (!source) {
                    var idx = animPath.lastIndexOf('/');
                    animPath = animPath.substring(0, idx);
                    source = clipData.joints[animPath];

                    if (animNode) {
                      if (!downstream) {
                        downstream = Mat4.identity(m4_2$1);
                      }

                      Mat4.fromRTS(m4_1$5, animNode.rotation, animNode.position, animNode.scale);
                      Mat4.multiply(downstream, m4_1$5, downstream);
                      animNode = animNode.parent;
                    }

                    if (idx < 0) {
                      break;
                    }
                  }

                  var curveData = source && source.transforms;
                  var frames = clipData.frames;
                  var transforms = [];

                  for (var f = 0; f < frames; f++) {
                    var mat = void 0;

                    if (curveData && downstream) {
                      mat = Mat4.multiply(m4_1$5, curveData[f], downstream);
                    } else if (curveData) {
                      mat = curveData[f];
                    } else if (downstream) {
                      mat = downstream;
                    } else {
                      mat = new Mat4();
                    }

                    var tfm = {
                      pos: new Vec3(),
                      rot: new Quat(),
                      scale: new Vec3()
                    };
                    Mat4.toRTS(mat, tfm.rot, tfm.pos, tfm.scale);
                    transforms.push(tfm);
                  }

                  this._sockets.push({
                    target: socket.target,
                    frames: transforms
                  });
                }
              };

              _proto._sampleCurvesBaked = function _sampleCurvesBaked(time) {
                var ratio = time / this.duration;
                var info = this._animInfo;
                var clip = this.clip;

                if (info.currentClip !== clip) {
                  this._animInfoMgr.switchClip(this._animInfo, clip);

                  var users = this._parent.getUsers();

                  users.forEach(function (user) {
                    user.uploadAnimation(clip);
                  });
                  info.data[0] = -1;
                }

                var curFrame = ratio * this._frames + 0.5 | 0;

                if (curFrame === info.data[0]) {
                  return;
                }

                info.data[0] = curFrame;
                info.dirty = true;

                for (var i = 0; i < this._sockets.length; ++i) {
                  var _this$_sockets$i = this._sockets[i],
                      target = _this$_sockets$i.target,
                      frames = _this$_sockets$i.frames;
                  var _frames$curFrame = frames[curFrame],
                      pos = _frames$curFrame.pos,
                      rot = _frames$curFrame.rot,
                      scale = _frames$curFrame.scale;
                  target.setRTS(rot, pos, scale);
                }
              };

              return SkeletalAnimationState;
            }(AnimationState));

            var _dec$1U, _dec2$1q, _class$1X, _class2$1G, _initializer$1B, _initializer2$1l, _dec3$W, _dec4$E, _dec5$x, _dec6$q, _class4$m, _class5$k, _initializer3$$, _initializer4$R, _class6$9, _temp$z;
            var Socket = exports('Socket', (_dec$1U = ccclass$p('cc.SkeletalAnimation.Socket'), _dec2$1q = type$8(Node), _dec$1U(_class$1X = (_class2$1G = function Socket(path, target) {
              if (path === void 0) {
                path = '';
              }

              if (target === void 0) {
                target = null;
              }

              this.path = _initializer$1B && _initializer$1B();
              this.target = _initializer2$1l && _initializer2$1l();
              this.path = path;
              this.target = target;
            }, (_initializer$1B = applyDecoratedInitializer(_class2$1G.prototype, "path", [serializable$j], function () {
              return '';
            }), _initializer2$1l = applyDecoratedInitializer(_class2$1G.prototype, "target", [_dec2$1q], function () {
              return null;
            })), _class2$1G)) || _class$1X));
            setClassAlias(Socket, 'cc.SkeletalAnimationComponent.Socket');
            var m4_1$6 = new Mat4();
            var m4_2$2 = new Mat4();

            function collectRecursively(node, prefix, out) {
              if (prefix === void 0) {
                prefix = '';
              }

              if (out === void 0) {
                out = [];
              }

              for (var i = 0; i < node.children.length; i++) {
                var child = node.children[i];

                if (!child) {
                  continue;
                }

                var path = prefix ? prefix + "/" + child.name : child.name;
                out.push(path);
                collectRecursively(child, path, out);
              }

              return out;
            }

            var SkeletalAnimation = exports('SkeletalAnimation', (_dec3$W = ccclass$p('cc.SkeletalAnimation'), _dec4$E = executionOrder(99), _dec5$x = type$8([Socket]), _dec6$q = type$8([Socket]), _dec3$W(_class4$m = _dec4$E(_class4$m = (_class5$k = (_temp$z = _class6$9 = function (_Animation) {
              _inheritsLoose(SkeletalAnimation, _Animation);

              function SkeletalAnimation() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Animation.call.apply(_Animation, [this].concat(args)) || this;
                _this._useBakedAnimation = _initializer3$$ && _initializer3$$();
                _this._sockets = _initializer4$R && _initializer4$R();
                _this._users = new Set();
                _this._currentBakedState = null;
                return _this;
              }

              var _proto = SkeletalAnimation.prototype;

              _proto.onLoad = function onLoad() {
                _Animation.prototype.onLoad.call(this);

                var comps = this.node.getComponentsInChildren(SkinnedMeshRenderer);

                for (var i = 0; i < comps.length; ++i) {
                  var comp = comps[i];

                  if (comp.skinningRoot === this.node) {
                    this.notifySkinnedMeshAdded(comp);
                  }
                }
              };

              _proto.onDestroy = function onDestroy() {
                _Animation.prototype.onDestroy.call(this);

                legacyCC.director.root.dataPoolManager.jointAnimationInfo.destroy(this.node.uuid);
                getGlobalAnimationManager().removeSockets(this.node, this._sockets);

                this._removeAllUsers();
              };

              _proto.onEnable = function onEnable() {
                var _this$_currentBakedSt;

                _Animation.prototype.onEnable.call(this);

                (_this$_currentBakedSt = this._currentBakedState) === null || _this$_currentBakedSt === void 0 ? void 0 : _this$_currentBakedSt.resume();
              };

              _proto.onDisable = function onDisable() {
                var _this$_currentBakedSt2;

                _Animation.prototype.onDisable.call(this);

                (_this$_currentBakedSt2 = this._currentBakedState) === null || _this$_currentBakedSt2 === void 0 ? void 0 : _this$_currentBakedSt2.pause();
              };

              _proto.start = function start() {
                this.sockets = this._sockets;
                this.useBakedAnimation = this._useBakedAnimation;

                _Animation.prototype.start.call(this);
              };

              _proto.pause = function pause() {
                if (!this._useBakedAnimation) {
                  _Animation.prototype.pause.call(this);
                } else {
                  var _this$_currentBakedSt3;

                  (_this$_currentBakedSt3 = this._currentBakedState) === null || _this$_currentBakedSt3 === void 0 ? void 0 : _this$_currentBakedSt3.pause();
                }
              };

              _proto.resume = function resume() {
                if (!this._useBakedAnimation) {
                  _Animation.prototype.resume.call(this);
                } else {
                  var _this$_currentBakedSt4;

                  (_this$_currentBakedSt4 = this._currentBakedState) === null || _this$_currentBakedSt4 === void 0 ? void 0 : _this$_currentBakedSt4.resume();
                }
              };

              _proto.stop = function stop() {
                if (!this._useBakedAnimation) {
                  _Animation.prototype.stop.call(this);
                } else if (this._currentBakedState) {
                  this._currentBakedState.stop();

                  this._currentBakedState = null;
                }
              };

              _proto.querySockets = function querySockets() {
                var animPaths = this._defaultClip && Object.keys(SkelAnimDataHub.getOrExtract(this._defaultClip).joints).sort().reduce(function (acc, cur) {
                  return cur.startsWith(acc[acc.length - 1] + "/") ? acc : (acc.push(cur), acc);
                }, []) || [];

                if (!animPaths.length) {
                  return ['please specify a valid default animation clip first'];
                }

                var out = [];

                for (var i = 0; i < animPaths.length; i++) {
                  var path = animPaths[i];
                  var node = this.node.getChildByPath(path);

                  if (!node) {
                    continue;
                  }

                  out.push(path);
                  collectRecursively(node, path, out);
                }

                return out;
              };

              _proto.rebuildSocketAnimations = function rebuildSocketAnimations() {
                for (var _iterator = _createForOfIteratorHelperLoose(this._sockets), _step; !(_step = _iterator()).done;) {
                  var socket = _step.value;
                  var joint = this.node.getChildByPath(socket.path);
                  var target = socket.target;

                  if (joint && target) {
                    target.name = socket.path.substring(socket.path.lastIndexOf('/') + 1) + " Socket";
                    target.parent = this.node;
                    getWorldTransformUntilRoot(joint, this.node, m4_1$6);
                    Mat4.fromRTS(m4_2$2, target.rotation, target.position, target.scale);

                    if (!Mat4.equals(m4_2$2, m4_1$6)) {
                      target.matrix = m4_1$6;
                    }
                  }
                }

                for (var _i = 0, _Object$keys = Object.keys(this._nameToState); _i < _Object$keys.length; _i++) {
                  var stateName = _Object$keys[_i];
                  var state = this._nameToState[stateName];
                  state.rebuildSocketCurves(this._sockets);
                }
              };

              _proto.createSocket = function createSocket(path) {
                var socket = this._sockets.find(function (s) {
                  return s.path === path;
                });

                if (socket) {
                  return socket.target;
                }

                var joint = this.node.getChildByPath(path);

                if (!joint) {
                  console.warn('illegal socket path');
                  return null;
                }

                var target = new Node();
                target.parent = this.node;

                this._sockets.push(new Socket(path, target));

                this.rebuildSocketAnimations();
                return target;
              };

              _proto.notifySkinnedMeshAdded = function notifySkinnedMeshAdded(skinnedMeshRenderer) {
                var useBakedAnimation = this._useBakedAnimation;
                var formerBound = skinnedMeshRenderer.associatedAnimation;

                if (formerBound) {
                  formerBound._users["delete"](skinnedMeshRenderer);
                }

                skinnedMeshRenderer.associatedAnimation = this;
                skinnedMeshRenderer.setUseBakedAnimation(useBakedAnimation, true);

                if (useBakedAnimation) {
                  var playingState = this._currentBakedState;

                  if (playingState) {
                    skinnedMeshRenderer.uploadAnimation(playingState.clip);
                  }
                }

                this._users.add(skinnedMeshRenderer);
              };

              _proto.notifySkinnedMeshRemoved = function notifySkinnedMeshRemoved(skinnedMeshRenderer) {
                assertIsTrue(skinnedMeshRenderer.associatedAnimation === this || skinnedMeshRenderer.associatedAnimation === null);
                skinnedMeshRenderer.setUseBakedAnimation(false);
                skinnedMeshRenderer.associatedAnimation = null;

                this._users["delete"](skinnedMeshRenderer);
              };

              _proto.getUsers = function getUsers() {
                return this._users;
              };

              _proto._createState = function _createState(clip, name) {
                return new SkeletalAnimationState(clip, name);
              };

              _proto._doCreateState = function _doCreateState(clip, name) {
                var state = _Animation.prototype._doCreateState.call(this, clip, name);

                state.rebuildSocketCurves(this._sockets);
                return state;
              };

              _proto.doPlayOrCrossFade = function doPlayOrCrossFade(state, duration) {
                if (this._useBakedAnimation) {
                  if (this._currentBakedState) {
                    this._currentBakedState.stop();
                  }

                  var skeletalAnimationState = state;
                  this._currentBakedState = skeletalAnimationState;
                  skeletalAnimationState.play();
                } else {
                  _Animation.prototype.doPlayOrCrossFade.call(this, state, duration);
                }
              };

              _proto._removeAllUsers = function _removeAllUsers() {
                var _this2 = this;

                Array.from(this._users).forEach(function (user) {
                  _this2.notifySkinnedMeshRemoved(user);
                });
              };

              _createClass(SkeletalAnimation, [{
                key: "sockets",
                get: function get() {
                  return this._sockets;
                },
                set: function set(val) {
                  if (!this._useBakedAnimation) {
                    var animMgr = getGlobalAnimationManager();
                    animMgr.removeSockets(this.node, this._sockets);
                    animMgr.addSockets(this.node, val);
                  }

                  this._sockets = val;
                  this.rebuildSocketAnimations();
                }
              }, {
                key: "useBakedAnimation",
                get: function get() {
                  return this._useBakedAnimation;
                },
                set: function set(val) {
                  this._useBakedAnimation = val;

                  for (var stateName in this._nameToState) {
                    var state = this._nameToState[stateName];
                    state.setUseBaked(val);
                  }

                  this._users.forEach(function (user) {
                    user.setUseBakedAnimation(val);
                  });

                  if (this._useBakedAnimation) {
                    getGlobalAnimationManager().removeSockets(this.node, this._sockets);
                  } else {
                    getGlobalAnimationManager().addSockets(this.node, this._sockets);
                    this._currentBakedState = null;
                  }
                }
              }]);

              return SkeletalAnimation;
            }(Animation), _class6$9.Socket = Socket, _temp$z), (_applyDecoratedDescriptor(_class5$k.prototype, "sockets", [_dec5$x], Object.getOwnPropertyDescriptor(_class5$k.prototype, "sockets"), _class5$k.prototype), _initializer3$$ = applyDecoratedInitializer(_class5$k.prototype, "_useBakedAnimation", [serializable$j], function () {
              return true;
            }), _initializer4$R = applyDecoratedInitializer(_class5$k.prototype, "_sockets", [_dec6$q], function () {
              return [];
            })), _class5$k)) || _class4$m) || _class4$m));

            var HeightField = exports('HeightField', function () {
              function HeightField(w, h) {
                this.data = new Uint16Array();
                this.w = 0;
                this.h = 0;
                this.w = w;
                this.h = h;
                this.data = new Uint16Array(w * h);

                for (var i = 0; i < w * h; ++i) {
                  this.data[i] = 0;
                }
              }

              var _proto = HeightField.prototype;

              _proto.set = function set(i, j, value) {
                this.data[j * this.w + i] = value;
              };

              _proto.get = function get(i, j) {
                return this.data[j * this.w + i];
              };

              _proto.getClamp = function getClamp(i, j) {
                i = clamp$1(i, 0, this.w - 1);
                j = clamp$1(j, 0, this.h - 1);
                return this.get(i, j);
              };

              _proto.getAt = function getAt(x, y) {
                var fx = x;
                var fy = y;
                var ix0 = Math.floor(fx);
                var iz0 = Math.floor(fy);
                var ix1 = ix0 + 1;
                var iz1 = iz0 + 1;
                var dx = fx - ix0;
                var dz = fy - iz0;
                ix0 = clamp$1(ix0, 0, this.w - 1);
                iz0 = clamp$1(iz0, 0, this.h - 1);
                ix1 = clamp$1(ix1, 0, this.w - 1);
                iz1 = clamp$1(iz1, 0, this.h - 1);
                var a = this.get(ix0, iz0);
                var b = this.get(ix1, iz0);
                var c = this.get(ix0, iz1);
                var d = this.get(ix1, iz1);
                var m = (b + c) * 0.5;

                if (dx + dz <= 1.0) {
                  d = m + (m - a);
                } else {
                  a = m + (m - d);
                }

                var h1 = a * (1.0 - dx) + b * dx;
                var h2 = c * (1.0 - dx) + d * dx;
                var h = h1 * (1.0 - dz) + h2 * dz;
                return h;
              };

              return HeightField;
            }());

            var TERRAIN_LOD_VERTS = 33;
            var TERRAIN_LOD_TILES = 32;
            var TERRAIN_LOD_LEVELS = 4;
            var TERRAIN_LOD_NORTH_INDEX = 0;
            var TERRAIN_LOD_SOUTH_INDEX = 1;
            var TERRAIN_LOD_WEST_INDEX = 2;
            var TERRAIN_LOD_EAST_INDEX = 3;
            var TERRAIN_LOD_MAX_DISTANCE = 100000000000000.0;
            var TerrainLodKey = function () {
              function TerrainLodKey() {
                this.level = 0;
                this.north = 0;
                this.south = 0;
                this.west = 0;
                this.east = 0;
              }

              var _proto = TerrainLodKey.prototype;

              _proto.equals = function equals(rk) {
                return this.level === rk.level && this.north === rk.north && this.south === rk.south && this.west === rk.west && this.east === rk.east;
              };

              return TerrainLodKey;
            }();
            var TerrainIndexPool = function TerrainIndexPool() {
              this.size = 0;
              this.indices = null;
            };
            var TerrainIndexData = function TerrainIndexData() {
              this.key = new TerrainLodKey();
              this.start = 0;
              this.size = 0;
              this.buffer = null;
              this.primCount = 0;
            };
            var TerrainLod = function () {
              TerrainLod.mapIndex = function mapIndex(i, j, k) {
                return i * (TERRAIN_LOD_LEVELS * TERRAIN_LOD_LEVELS) + j * TERRAIN_LOD_LEVELS + k;
              };

              function TerrainLod() {
                this._bodyIndexPool = void 0;
                this._connecterIndexPool = void 0;
                this._indexMap = [];
                this._indexBuffer = new Uint16Array();
                this._bodyIndexPool = new Array(TERRAIN_LOD_LEVELS);

                for (var i = 0; i < TERRAIN_LOD_LEVELS; ++i) {
                  this._bodyIndexPool[i] = new TerrainIndexPool();
                }

                this._connecterIndexPool = new Array(TERRAIN_LOD_LEVELS * TERRAIN_LOD_LEVELS * 4);

                for (var _i = 0; _i < TERRAIN_LOD_LEVELS; ++_i) {
                  for (var j = 0; j < TERRAIN_LOD_LEVELS; ++j) {
                    for (var k = 0; k < 4; ++k) {
                      this._connecterIndexPool[TerrainLod.mapIndex(_i, j, k)] = new TerrainIndexPool();
                    }
                  }
                }

                for (var _i2 = 0; _i2 < TERRAIN_LOD_LEVELS; ++_i2) {
                  this._genBodyIndex(_i2);
                }

                for (var _i3 = 0; _i3 < TERRAIN_LOD_LEVELS; ++_i3) {
                  for (var _j = 0; _j < TERRAIN_LOD_LEVELS; ++_j) {
                    this._genConnecterIndexNorth(_i3, _j);

                    this._genConnecterIndexSouth(_i3, _j);

                    this._genConnecterIndexWest(_i3, _j);

                    this._genConnecterIndexEast(_i3, _j);
                  }
                }

                var levels = TERRAIN_LOD_LEVELS;

                for (var l = 0; l < levels; ++l) {
                  for (var n = 0; n < levels; ++n) {
                    if (n < l) {
                      continue;
                    }

                    for (var s = 0; s < levels; ++s) {
                      if (s < l) {
                        continue;
                      }

                      for (var w = 0; w < levels; ++w) {
                        if (w < l) {
                          continue;
                        }

                        for (var e = 0; e < levels; ++e) {
                          if (e < l) {
                            continue;
                          }

                          var _k = new TerrainLodKey();

                          _k.level = l;
                          _k.north = n;
                          _k.south = s;
                          _k.west = w;
                          _k.east = e;

                          this._genIndexData(_k);
                        }
                      }
                    }
                  }
                }
              }

              var _proto2 = TerrainLod.prototype;

              _proto2.getIndexData = function getIndexData(k) {
                for (var i = 0; i < this._indexMap.length; ++i) {
                  if (this._indexMap[i].key.equals(k)) {
                    return this._indexMap[i];
                  }
                }

                return null;
              };

              _proto2._genBodyIndex = function _genBodyIndex(level) {
                var step = 1 << level;
                var tiles = TERRAIN_LOD_TILES >> level;
                var start = 0;

                if (level < TERRAIN_LOD_LEVELS - 1) {
                  tiles -= 2;
                  start = step * TERRAIN_LOD_VERTS + step;
                }

                if (tiles === 0 || tiles === 0) {
                  return;
                }

                var count = tiles * tiles * 6;
                this._bodyIndexPool[level].indices = new Uint16Array(count);
                var index = 0;
                var indices = new Uint16Array(count);
                var row_c = start;
                var row_n = row_c + TERRAIN_LOD_VERTS * step;

                for (var y = 0; y < tiles; ++y) {
                  for (var x = 0; x < tiles; ++x) {
                    indices[index++] = row_n + x * step;
                    indices[index++] = row_n + (x + 1) * step;
                    indices[index++] = row_c + x * step;
                    indices[index++] = row_n + (x + 1) * step;
                    indices[index++] = row_c + (x + 1) * step;
                    indices[index++] = row_c + x * step;
                  }

                  row_c += TERRAIN_LOD_VERTS * step;
                  row_n += TERRAIN_LOD_VERTS * step;
                }

                this._bodyIndexPool[level].size = index;
                this._bodyIndexPool[level].indices = indices;
              };

              _proto2._genConnecterIndexNorth = function _genConnecterIndexNorth(level, connecter) {
                var connecterIndex = TerrainLod.mapIndex(level, connecter, TERRAIN_LOD_NORTH_INDEX);

                if (connecter < level || level === TERRAIN_LOD_LEVELS - 1) {
                  this._connecterIndexPool[connecterIndex].size = 0;
                  this._connecterIndexPool[connecterIndex].indices = null;
                  return;
                }

                var self_step = 1 << level;
                var neighbor_step = 1 << connecter;
                var self_tile = TERRAIN_LOD_TILES >> level;
                var count = self_tile * 2 + 2;
                var index = 0;
                var indices = new Uint16Array(count);
                indices[index++] = 0;
                indices[index++] = 0;

                for (var i = 1; i < self_tile; ++i) {
                  var x1 = i * self_step;
                  var y1 = self_step;
                  var x0 = x1 / neighbor_step * neighbor_step;
                  var y0 = y1 - self_step;
                  var index0 = y1 * TERRAIN_LOD_VERTS + x1;
                  var index1 = y0 * TERRAIN_LOD_VERTS + x0;
                  indices[index++] = index0;
                  indices[index++] = index1;
                }

                indices[index++] = TERRAIN_LOD_VERTS - 1;
                indices[index++] = TERRAIN_LOD_VERTS - 1;
                this._connecterIndexPool[connecterIndex].size = index;
                this._connecterIndexPool[connecterIndex].indices = indices;
              };

              _proto2._genConnecterIndexSouth = function _genConnecterIndexSouth(level, connecter) {
                var connecterIndex = TerrainLod.mapIndex(level, connecter, TERRAIN_LOD_SOUTH_INDEX);

                if (connecter < level || level === TERRAIN_LOD_LEVELS - 1) {
                  this._connecterIndexPool[connecterIndex].size = 0;
                  this._connecterIndexPool[connecterIndex].indices = null;
                  return;
                }

                var self_step = 1 << level;
                var neighbor_step = 1 << connecter;
                var self_tile = TERRAIN_LOD_TILES >> level;
                var count = self_tile * 2 + 2;
                var index = 0;
                var indices = new Uint16Array(count);
                indices[index++] = TERRAIN_LOD_TILES * TERRAIN_LOD_VERTS;
                indices[index++] = TERRAIN_LOD_TILES * TERRAIN_LOD_VERTS;

                for (var i = 1; i < self_tile; ++i) {
                  var x0 = i * self_step;
                  var y0 = TERRAIN_LOD_VERTS - 1 - self_step;
                  var x1 = x0 / neighbor_step * neighbor_step;
                  var y1 = y0 + self_step;
                  var index0 = y1 * TERRAIN_LOD_VERTS + x1;
                  var index1 = y0 * TERRAIN_LOD_VERTS + x0;
                  indices[index++] = index0;
                  indices[index++] = index1;
                }

                indices[index++] = TERRAIN_LOD_VERTS * TERRAIN_LOD_VERTS - 1;
                indices[index++] = TERRAIN_LOD_VERTS * TERRAIN_LOD_VERTS - 1;
                this._connecterIndexPool[connecterIndex].size = index;
                this._connecterIndexPool[connecterIndex].indices = indices;
              };

              _proto2._genConnecterIndexWest = function _genConnecterIndexWest(level, connecter) {
                var connecterIndex = TerrainLod.mapIndex(level, connecter, TERRAIN_LOD_WEST_INDEX);

                if (connecter < level || level === TERRAIN_LOD_LEVELS - 1) {
                  this._connecterIndexPool[connecterIndex].size = 0;
                  this._connecterIndexPool[connecterIndex].indices = null;
                  return;
                }

                var self_step = 1 << level;
                var neighbor_step = 1 << connecter;
                var self_tile = TERRAIN_LOD_TILES >> level;
                var count = self_tile * 2 + 2;
                var index = 0;
                var indices = new Uint16Array(count);
                indices[index++] = 0;
                indices[index++] = 0;

                for (var i = 1; i < self_tile; ++i) {
                  var x0 = 0;
                  var y0 = i * self_step / neighbor_step * neighbor_step;
                  var x1 = self_step;
                  var y1 = i * self_step;
                  var index0 = y0 * TERRAIN_LOD_VERTS + x0;
                  var index1 = y1 * TERRAIN_LOD_VERTS + x1;
                  indices[index++] = index0;
                  indices[index++] = index1;
                }

                indices[index++] = TERRAIN_LOD_TILES * TERRAIN_LOD_VERTS;
                indices[index++] = TERRAIN_LOD_TILES * TERRAIN_LOD_VERTS;
                this._connecterIndexPool[connecterIndex].size = index;
                this._connecterIndexPool[connecterIndex].indices = indices;
              };

              _proto2._genConnecterIndexEast = function _genConnecterIndexEast(level, connecter) {
                var connecterIndex = TerrainLod.mapIndex(level, connecter, TERRAIN_LOD_EAST_INDEX);

                if (connecter < level || level === TERRAIN_LOD_LEVELS - 1) {
                  this._connecterIndexPool[connecterIndex].size = 0;
                  this._connecterIndexPool[connecterIndex].indices = null;
                  return;
                }

                var self_step = 1 << level;
                var neighbor_step = 1 << connecter;
                var self_tile = TERRAIN_LOD_TILES >> level;
                var count = self_tile * 2 + 2;
                var index = 0;
                var indices = new Uint16Array(count);
                indices[index++] = TERRAIN_LOD_VERTS - 1;
                indices[index++] = TERRAIN_LOD_VERTS - 1;

                for (var i = 1; i < self_tile; ++i) {
                  var x0 = TERRAIN_LOD_VERTS - 1 - self_step;
                  var y0 = i * self_step;
                  var x1 = TERRAIN_LOD_VERTS - 1;
                  var y1 = i * self_step / neighbor_step * neighbor_step;
                  var index0 = y0 * TERRAIN_LOD_VERTS + x0;
                  var index1 = y1 * TERRAIN_LOD_VERTS + x1;
                  indices[index++] = index0;
                  indices[index++] = index1;
                }

                indices[index++] = TERRAIN_LOD_VERTS * TERRAIN_LOD_VERTS - 1;
                indices[index++] = TERRAIN_LOD_VERTS * TERRAIN_LOD_VERTS - 1;
                this._connecterIndexPool[connecterIndex].size = index;
                this._connecterIndexPool[connecterIndex].indices = indices;
              };

              _proto2._getConnenterIndex = function _getConnenterIndex(i, j, k) {
                return this._connecterIndexPool[TerrainLod.mapIndex(i, j, k)];
              };

              _proto2._genIndexData = function _genIndexData(k) {
                var data = this.getIndexData(k);

                if (data != null) {
                  return data;
                }

                var body = this._bodyIndexPool[k.level];

                var north = this._getConnenterIndex(k.level, k.north, TERRAIN_LOD_NORTH_INDEX);

                var south = this._getConnenterIndex(k.level, k.south, TERRAIN_LOD_SOUTH_INDEX);

                var west = this._getConnenterIndex(k.level, k.west, TERRAIN_LOD_WEST_INDEX);

                var east = this._getConnenterIndex(k.level, k.east, TERRAIN_LOD_EAST_INDEX);

                data = new TerrainIndexData();
                data.size = 0;
                data.primCount = 0;

                if (body.indices != null) {
                  data.size += body.size;
                }

                if (north.indices) {
                  data.size += (north.size - 2) * 3;
                }

                if (south.indices) {
                  data.size += (south.size - 2) * 3;
                }

                if (west.indices) {
                  data.size += (west.size - 2) * 3;
                }

                if (east.indices) {
                  data.size += (east.size - 2) * 3;
                }

                if (data.size === 0) {
                  return null;
                }

                var index = 0;
                data.buffer = new Uint16Array(data.size);
                data.key.level = k.level;
                data.key.east = k.east;
                data.key.west = k.west;
                data.key.north = k.north;
                data.key.south = k.south;

                if (body.indices) {
                  for (var i = 0; i < body.size; ++i) {
                    data.buffer[index++] = body.indices[i];
                  }
                }

                if (north.indices) {
                  for (var _i4 = 0; _i4 < north.size - 2; _i4 += 2) {
                    var a = north.indices[_i4 + 0];
                    var b = north.indices[_i4 + 1];
                    var c = north.indices[_i4 + 2];
                    var d = north.indices[_i4 + 3];
                    data.buffer[index++] = a;
                    data.buffer[index++] = c;
                    data.buffer[index++] = b;
                    data.buffer[index++] = c;
                    data.buffer[index++] = d;
                    data.buffer[index++] = b;
                  }
                }

                if (south.indices) {
                  for (var _i5 = 0; _i5 < south.size - 2; _i5 += 2) {
                    var _a = south.indices[_i5 + 0];
                    var _b = south.indices[_i5 + 1];
                    var _c = south.indices[_i5 + 2];
                    var _d = south.indices[_i5 + 3];
                    data.buffer[index++] = _a;
                    data.buffer[index++] = _c;
                    data.buffer[index++] = _b;
                    data.buffer[index++] = _c;
                    data.buffer[index++] = _d;
                    data.buffer[index++] = _b;
                  }
                }

                if (west.indices) {
                  for (var _i6 = 0; _i6 < west.size - 2; _i6 += 2) {
                    var _a2 = west.indices[_i6 + 0];
                    var _b2 = west.indices[_i6 + 1];
                    var _c2 = west.indices[_i6 + 2];
                    var _d2 = west.indices[_i6 + 3];
                    data.buffer[index++] = _a2;
                    data.buffer[index++] = _c2;
                    data.buffer[index++] = _b2;
                    data.buffer[index++] = _c2;
                    data.buffer[index++] = _d2;
                    data.buffer[index++] = _b2;
                  }
                }

                if (east.indices) {
                  for (var _i7 = 0; _i7 < east.size - 2; _i7 += 2) {
                    var _a3 = east.indices[_i7 + 0];
                    var _b3 = east.indices[_i7 + 1];
                    var _c3 = east.indices[_i7 + 2];
                    var _d3 = east.indices[_i7 + 3];
                    data.buffer[index++] = _a3;
                    data.buffer[index++] = _c3;
                    data.buffer[index++] = _b3;
                    data.buffer[index++] = _c3;
                    data.buffer[index++] = _d3;
                    data.buffer[index++] = _b3;
                  }
                }

                data.primCount = index / 3;
                data.start = this._indexBuffer.length;

                this._indexMap.push(data);

                var temp = new Uint16Array(data.start + data.size);
                temp.set(this._indexBuffer, 0);
                temp.set(data.buffer, data.start);
                this._indexBuffer = temp;
                return data;
              };

              return TerrainLod;
            }();

            var _dec$1V, _class$1Y, _class2$1H, _initializer$1C, _initializer2$1m, _initializer3$10, _initializer4$S, _dec2$1r, _class4$n, _class5$l, _initializer5$G, _initializer6$z, _initializer7$r, _initializer8$o, _initializer9$l, _dec3$X, _class7$7, _class8$6, _initializer10$i, _initializer11$e, _initializer12$e, _initializer13$e, _initializer14$a, _dec4$F, _dec5$y, _dec6$r, _dec7$k, _dec8$e, _dec9$c, _dec10$6, _dec11$4, _class10$2, _class11$4, _initializer15$9, _initializer16$9, _initializer17$8, _initializer18$7, _initializer19$7, _initializer20$5, _initializer21$4, _initializer22$4;
            var TERRAIN_EFFECT_UUID = '1d08ef62-a503-4ce2-8b9a-46c90873f7d3';
            var TerrainInfo = exports('TerrainInfo', (_dec$1V = ccclass$p('cc.TerrainInfo'), _dec$1V(_class$1Y = (_class2$1H = function () {
              function TerrainInfo() {
                this.tileSize = _initializer$1C && _initializer$1C();
                this.blockCount = _initializer2$1m && _initializer2$1m();
                this.weightMapSize = _initializer3$10 && _initializer3$10();
                this.lightMapSize = _initializer4$S && _initializer4$S();
              }

              _createClass(TerrainInfo, [{
                key: "size",
                get: function get() {
                  var sz = new Size$1(0, 0);
                  sz.width = this.blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY * this.tileSize;
                  sz.height = this.blockCount[1] * TERRAIN_BLOCK_TILE_COMPLEXITY * this.tileSize;
                  return sz;
                }
              }, {
                key: "tileCount",
                get: function get() {
                  var _tileCount = [0, 0];
                  _tileCount[0] = this.blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY;
                  _tileCount[1] = this.blockCount[1] * TERRAIN_BLOCK_TILE_COMPLEXITY;
                  return _tileCount;
                }
              }, {
                key: "vertexCount",
                get: function get() {
                  var _vertexCount = this.tileCount;
                  _vertexCount[0] += 1;
                  _vertexCount[1] += 1;
                  return _vertexCount;
                }
              }]);

              return TerrainInfo;
            }(), (_initializer$1C = applyDecoratedInitializer(_class2$1H.prototype, "tileSize", [serializable$j], function () {
              return 1;
            }), _initializer2$1m = applyDecoratedInitializer(_class2$1H.prototype, "blockCount", [serializable$j], function () {
              return [1, 1];
            }), _initializer3$10 = applyDecoratedInitializer(_class2$1H.prototype, "weightMapSize", [serializable$j], function () {
              return 128;
            }), _initializer4$S = applyDecoratedInitializer(_class2$1H.prototype, "lightMapSize", [serializable$j], function () {
              return 128;
            })), _class2$1H)) || _class$1Y));
            var TerrainLayer = exports('TerrainLayer', (_dec2$1r = ccclass$p('cc.TerrainLayer'), _dec2$1r(_class4$n = (_class5$l = function TerrainLayer() {
              this.detailMap = _initializer5$G && _initializer5$G();
              this.normalMap = _initializer6$z && _initializer6$z();
              this.tileSize = _initializer7$r && _initializer7$r();
              this.metallic = _initializer8$o && _initializer8$o();
              this.roughness = _initializer9$l && _initializer9$l();
            }, (_initializer5$G = applyDecoratedInitializer(_class5$l.prototype, "detailMap", [serializable$j], function () {
              return null;
            }), _initializer6$z = applyDecoratedInitializer(_class5$l.prototype, "normalMap", [serializable$j], function () {
              return null;
            }), _initializer7$r = applyDecoratedInitializer(_class5$l.prototype, "tileSize", [serializable$j], function () {
              return 1;
            }), _initializer8$o = applyDecoratedInitializer(_class5$l.prototype, "metallic", [serializable$j], function () {
              return 0;
            }), _initializer9$l = applyDecoratedInitializer(_class5$l.prototype, "roughness", [serializable$j], function () {
              return 1;
            })), _class5$l)) || _class4$n));

            var TerrainRenderable = function (_ModelRenderer) {
              _inheritsLoose(TerrainRenderable, _ModelRenderer);

              function TerrainRenderable() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _ModelRenderer.call.apply(_ModelRenderer, [this].concat(args)) || this;
                _this._model = null;
                _this._meshData = null;
                _this._brushPass = null;
                _this._brushMaterial = null;
                _this._currentMaterial = null;
                _this._currentMaterialLayers = 0;
                _this._lightmap = null;
                return _this;
              }

              var _proto = TerrainRenderable.prototype;

              _proto.destroy = function destroy() {
                if (this._model != null) {
                  legacyCC.director.root.destroyModel(this._model);
                  this._model = null;
                }

                return _ModelRenderer.prototype.destroy.call(this);
              };

              _proto._destroyModel = function _destroyModel() {
                if (this._model != null) {
                  legacyCC.director.root.destroyModel(this._model);
                  this._model = null;
                }

                if (this._meshData != null) {
                  this._meshData.destroy();

                  this._meshData = null;
                }
              };

              _proto._invalidMaterial = function _invalidMaterial() {
                if (this._currentMaterial == null) {
                  return;
                }

                this._clearMaterials();

                this._brushPass = null;
                this._currentMaterial = null;

                if (this._model != null) {
                  this._model.enabled = false;
                }
              };

              _proto._updateMaterial = function _updateMaterial(block, init) {
                if (this._meshData == null || this._model == null) {
                  return false;
                }

                var nLayers = block.getMaxLayer();

                if (this._currentMaterial == null || nLayers !== this._currentMaterialLayers) {
                  this._currentMaterial = new Material();

                  this._currentMaterial.initialize({
                    effectAsset: block.getTerrain().getEffectAsset(),
                    defines: block._getMaterialDefines(nLayers)
                  });

                  if (this._brushMaterial !== null) {
                    var brushMaterialInstance = new Material();
                    brushMaterialInstance.copy(this._brushMaterial);
                    this._brushPass = null;

                    if (brushMaterialInstance.passes !== null && brushMaterialInstance.passes.length > 0) {
                      this._brushPass = brushMaterialInstance.passes[0];
                      var passes = this._currentMaterial.passes;
                      passes.push(this._brushPass);
                      brushMaterialInstance.passes.pop();
                    }
                  }

                  if (init) {
                    this._model.initSubModel(0, this._meshData, this._currentMaterial);
                  }

                  this.setMaterial(this._currentMaterial, 0);
                  this._currentMaterialLayers = nLayers;
                  this._model.enabled = true;
                  this._model.receiveShadow = block.getTerrain().receiveShadow;
                  return true;
                }

                return false;
              };

              _proto._updateLightingmap = function _updateLightingmap(texture, uvParam) {
                if (this._model == null) {
                  return;
                }

                this._lightmap = texture;

                this._updateReceiveDirLight();

                this._model.updateLightingmap(texture, uvParam);
              };

              _proto._onMaterialModified = function _onMaterialModified(idx, mtl) {
                if (this._model == null) {
                  return;
                }

                this._onRebuildPSO(idx, mtl || this._getBuiltinMaterial());
              };

              _proto._onRebuildPSO = function _onRebuildPSO(idx, material) {
                if (this._model) {
                  this._model.setSubModelMaterial(idx, material);
                }
              };

              _proto._clearMaterials = function _clearMaterials() {
                if (this._model == null) {
                  return;
                }

                this._onMaterialModified(0, null);
              };

              _proto._onUpdateReceiveDirLight = function _onUpdateReceiveDirLight(visibility, forceClose) {
                if (forceClose === void 0) {
                  forceClose = false;
                }

                if (!this._model) {
                  return;
                }

                if (forceClose) {
                  this._model.receiveDirLight = false;
                  return;
                }

                if (this.node && (visibility & this.node.layer) === this.node.layer || visibility & this._model.visFlags) {
                  this._model.receiveDirLight = true;
                } else {
                  this._model.receiveDirLight = false;
                }
              };

              _proto._updateReceiveDirLight = function _updateReceiveDirLight() {
                var scene = this.node.scene;

                if (!scene || !scene.renderScene) {
                  return;
                }

                var mainLight = scene.renderScene.mainLight;

                if (!mainLight) {
                  return;
                }

                var visibility = mainLight.visibility;

                if (!mainLight.node) {
                  return;
                }

                if (mainLight.node.mobility === MobilityMode.Static && this._lightmap) {
                  this._onUpdateReceiveDirLight(visibility, true);
                } else {
                  this._onUpdateReceiveDirLight(visibility);
                }
              };

              _proto._getBuiltinMaterial = function _getBuiltinMaterial() {
                return builtinResMgr.get('missing-material');
              };

              return TerrainRenderable;
            }(ModelRenderer);

            var TerrainBlockLightmapInfo = exports('TerrainBlockLightmapInfo', (_dec3$X = ccclass$p('cc.TerrainBlockLightmapInfo'), _dec3$X(_class7$7 = (_class8$6 = function TerrainBlockLightmapInfo() {
              this.texture = _initializer10$i && _initializer10$i();
              this.UOff = _initializer11$e && _initializer11$e();
              this.VOff = _initializer12$e && _initializer12$e();
              this.UScale = _initializer13$e && _initializer13$e();
              this.VScale = _initializer14$a && _initializer14$a();
            }, (_initializer10$i = applyDecoratedInitializer(_class8$6.prototype, "texture", [serializable$j], function () {
              return null;
            }), _initializer11$e = applyDecoratedInitializer(_class8$6.prototype, "UOff", [serializable$j], function () {
              return 0;
            }), _initializer12$e = applyDecoratedInitializer(_class8$6.prototype, "VOff", [serializable$j], function () {
              return 0;
            }), _initializer13$e = applyDecoratedInitializer(_class8$6.prototype, "UScale", [serializable$j], function () {
              return 0;
            }), _initializer14$a = applyDecoratedInitializer(_class8$6.prototype, "VScale", [serializable$j], function () {
              return 0;
            })), _class8$6)) || _class7$7));
            var TerrainBlock = exports('TerrainBlock', function () {
              function TerrainBlock(t, i, j) {
                this._terrain = void 0;
                this._node = void 0;
                this._renderable = void 0;
                this._index = [1, 1];
                this._weightMap = null;
                this._lightmapInfo = null;
                this._lodLevel = 0;
                this._lodKey = new TerrainLodKey();
                this._errorMetrics = [0, 0, 0, 0];
                this._LevelDistances = [TERRAIN_LOD_MAX_DISTANCE, TERRAIN_LOD_MAX_DISTANCE, TERRAIN_LOD_MAX_DISTANCE, TERRAIN_LOD_MAX_DISTANCE];
                this._bbMin = new Vec3();
                this._bbMax = new Vec3();
                this._terrain = t;
                this._index[0] = i;
                this._index[1] = j;
                this._lightmapInfo = t._getLightmapInfo(i, j);
                this._node = new Node('TerrainBlock');

                this._node.setParent(this._terrain.node);

                this._node.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;
                this._node.layer = this._terrain.node.layer;
                this._renderable = this._node.addComponent(TerrainRenderable);
              }

              var _proto2 = TerrainBlock.prototype;

              _proto2.build = function build() {
                var gfxDevice = director.root.device;
                var vertexData = new Float32Array(TERRAIN_BLOCK_VERTEX_SIZE * TERRAIN_BLOCK_VERTEX_COMPLEXITY * TERRAIN_BLOCK_VERTEX_COMPLEXITY);

                this._buildVertexData(vertexData);

                var vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, TERRAIN_BLOCK_VERTEX_SIZE * Float32Array.BYTES_PER_ELEMENT * TERRAIN_BLOCK_VERTEX_COMPLEXITY * TERRAIN_BLOCK_VERTEX_COMPLEXITY, TERRAIN_BLOCK_VERTEX_SIZE * Float32Array.BYTES_PER_ELEMENT));
                vertexBuffer.update(vertexData);

                this._buildBoundingBox();

                var gfxAttributes = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F)];
                this._renderable._meshData = new RenderingSubMesh([vertexBuffer], gfxAttributes, PrimitiveMode.TRIANGLE_LIST, this._terrain._getSharedIndexBuffer(), null, false);
                this._renderable._model = legacyCC.director.root.createModel(Model);

                this._renderable._model.createBoundingShape(this._bbMin, this._bbMax);

                this._renderable._model.node = this._renderable._model.transform = this._node;

                if (this._renderable.node.scene != null) {
                  this.visible = true;
                }

                this._updateWeightMap();

                this._updateMaterial(true);

                if (this._terrain.lodEnable) {
                  this._updateLodBuffer(vertexData);

                  this._updateIndexBuffer();
                }
              };

              _proto2.rebuild = function rebuild() {
                this._updateHeight();

                this._updateWeightMap();

                this._renderable._invalidMaterial();

                this._updateMaterial(false);
              };

              _proto2.destroy = function destroy() {
                this.visible = false;

                this._renderable._destroyModel();

                if (this._node != null && this._node.isValid) {
                  this._node.destroy();
                }

                if (this._weightMap != null) {
                  this._weightMap.destroy();
                }
              };

              _proto2.update = function update() {
                this._updateMaterial(false);

                if (this.lightmap !== this._renderable._lightmap) {
                  this._renderable._updateLightingmap(this.lightmap, this.lightmapUVParam);
                }

                var useNormalMap = this._terrain.useNormalMap;
                var usePBR = this._terrain.usePBR;

                var getDetailTex = function getDetailTex(layer) {
                  return layer !== null ? layer.detailMap : null;
                };

                var getNormalTex = function getNormalTex(layer) {
                  var normalTex = layer !== null ? layer.normalMap : null;

                  if (normalTex === null) {
                    normalTex = legacyCC.builtinResMgr.get('normal-texture');
                  }

                  return normalTex;
                };

                var mtl = this._renderable._currentMaterial;

                if (mtl !== null) {
                  var nlayers = this.getMaxLayer();
                  var uvScale = new Vec4(1, 1, 1, 1);
                  var roughness = new Vec4(1, 1, 1, 1);
                  var metallic = new Vec4(0, 0, 0, 0);

                  if (nlayers === 0) {
                    if (this.layers[0] !== -1) {
                      var l0 = this._terrain.getLayer(this.layers[0]);

                      if (l0 !== null) {
                        uvScale.x = 1.0 / l0.tileSize;
                        roughness.x = l0.roughness;
                        metallic.x = l0.metallic;
                      }

                      mtl.setProperty('detailMap0', getDetailTex(l0));

                      if (useNormalMap) {
                        mtl.setProperty('normalMap0', getNormalTex(l0));
                      }
                    } else {
                      mtl.setProperty('detailMap0', legacyCC.builtinResMgr.get('default-texture'));

                      if (useNormalMap) {
                        mtl.setProperty('normalMap0', legacyCC.builtinResMgr.get('normal-texture'));
                      }
                    }
                  } else if (nlayers === 1) {
                    var _l = this._terrain.getLayer(this.layers[0]);

                    var l1 = this._terrain.getLayer(this.layers[1]);

                    if (_l !== null) {
                      uvScale.x = 1.0 / _l.tileSize;
                      roughness.x = _l.roughness;
                      metallic.x = _l.metallic;
                    }

                    if (l1 !== null) {
                      uvScale.y = 1.0 / l1.tileSize;
                      roughness.y = l1.roughness;
                      metallic.y = l1.metallic;
                    }

                    mtl.setProperty('weightMap', this._weightMap);
                    mtl.setProperty('detailMap0', getDetailTex(_l));
                    mtl.setProperty('detailMap1', getDetailTex(l1));

                    if (useNormalMap) {
                      mtl.setProperty('normalMap0', getNormalTex(_l));
                      mtl.setProperty('normalMap1', getNormalTex(l1));
                    }
                  } else if (nlayers === 2) {
                    var _l2 = this._terrain.getLayer(this.layers[0]);

                    var _l3 = this._terrain.getLayer(this.layers[1]);

                    var l2 = this._terrain.getLayer(this.layers[2]);

                    if (_l2 !== null) {
                      uvScale.x = 1.0 / _l2.tileSize;
                      roughness.x = _l2.roughness;
                      metallic.x = _l2.metallic;
                    }

                    if (_l3 !== null) {
                      uvScale.y = 1.0 / _l3.tileSize;
                      roughness.y = _l3.roughness;
                      metallic.y = _l3.metallic;
                    }

                    if (l2 !== null) {
                      uvScale.z = 1.0 / l2.tileSize;
                      roughness.z = l2.roughness;
                      metallic.z = l2.metallic;
                    }

                    mtl.setProperty('weightMap', this._weightMap);
                    mtl.setProperty('detailMap0', getDetailTex(_l2));
                    mtl.setProperty('detailMap1', getDetailTex(_l3));
                    mtl.setProperty('detailMap2', getDetailTex(l2));

                    if (useNormalMap) {
                      mtl.setProperty('normalMap0', getNormalTex(_l2));
                      mtl.setProperty('normalMap1', getNormalTex(_l3));
                      mtl.setProperty('normalMap2', getNormalTex(l2));
                    }
                  } else if (nlayers === 3) {
                    var _l4 = this._terrain.getLayer(this.layers[0]);

                    var _l5 = this._terrain.getLayer(this.layers[1]);

                    var _l6 = this._terrain.getLayer(this.layers[2]);

                    var l3 = this._terrain.getLayer(this.layers[3]);

                    if (_l4 !== null) {
                      uvScale.x = 1.0 / _l4.tileSize;
                      roughness.x = _l4.roughness;
                      metallic.x = _l4.metallic;
                    }

                    if (_l5 !== null) {
                      uvScale.y = 1.0 / _l5.tileSize;
                      roughness.y = _l5.roughness;
                      metallic.y = _l5.metallic;
                    }

                    if (_l6 !== null) {
                      uvScale.z = 1.0 / _l6.tileSize;
                      roughness.z = _l6.roughness;
                      metallic.z = _l6.metallic;
                    }

                    if (l3 !== null) {
                      uvScale.w = 1.0 / l3.tileSize;
                      roughness.w = l3.roughness;
                      metallic.w = l3.metallic;
                    }

                    mtl.setProperty('weightMap', this._weightMap);
                    mtl.setProperty('detailMap0', getDetailTex(_l4));
                    mtl.setProperty('detailMap1', getDetailTex(_l5));
                    mtl.setProperty('detailMap2', getDetailTex(_l6));
                    mtl.setProperty('detailMap3', getDetailTex(l3));

                    if (useNormalMap) {
                      mtl.setProperty('normalMap0', getNormalTex(_l4));
                      mtl.setProperty('normalMap1', getNormalTex(_l5));
                      mtl.setProperty('normalMap2', getNormalTex(_l6));
                      mtl.setProperty('normalMap3', getNormalTex(l3));
                    }
                  }

                  mtl.setProperty('UVScale', uvScale);

                  if (usePBR) {
                    mtl.setProperty('roughness', roughness);
                    mtl.setProperty('metallic', metallic);
                  }
                }
              };

              _proto2._buildLodInfo = function _buildLodInfo() {
                var vertexData = new Float32Array(TERRAIN_BLOCK_VERTEX_SIZE * TERRAIN_BLOCK_VERTEX_COMPLEXITY * TERRAIN_BLOCK_VERTEX_COMPLEXITY);

                this._buildVertexData(vertexData);

                this._updateLodBuffer(vertexData);

                this._updateIndexBuffer();
              };

              _proto2._updateLevel = function _updateLevel(camPos) {
                var maxLevel = TERRAIN_LOD_LEVELS - 1;
                var bbMin = new Vec3();
                var bbMax = new Vec3();
                Vec3.add(bbMin, this._bbMin, this._terrain.node.getWorldPosition());
                Vec3.add(bbMax, this._bbMax, this._terrain.node.getWorldPosition());
                var d1 = Vec3.distance(bbMin, camPos);
                var d2 = Vec3.distance(bbMax, camPos);
                var d = Math.min(d1, d2);
                d -= this._terrain.LodBias;
                this._lodLevel = 0;

                while (this._lodLevel < maxLevel) {
                  var ld1 = this._LevelDistances[this._lodLevel + 1];

                  if (d <= ld1) {
                    break;
                  }

                  ++this._lodLevel;
                }
              };

              _proto2.setBrushMaterial = function setBrushMaterial(mtl) {
                if (this._renderable._brushMaterial !== mtl) {
                  this._renderable._invalidMaterial();

                  this._renderable._brushMaterial = mtl;
                }
              };

              _proto2._getBrushMaterial = function _getBrushMaterial() {
                return this._renderable ? this._renderable._brushMaterial : null;
              };

              _proto2._getBrushPass = function _getBrushPass() {
                return this._renderable ? this._renderable._brushPass : null;
              };

              _proto2.getTerrain = function getTerrain() {
                return this._terrain;
              };

              _proto2.getIndex = function getIndex() {
                return this._index;
              };

              _proto2.getRect = function getRect() {
                var rect = new Rect$1();
                rect.x = this._index[0] * TERRAIN_BLOCK_TILE_COMPLEXITY;
                rect.y = this._index[1] * TERRAIN_BLOCK_TILE_COMPLEXITY;
                rect.width = TERRAIN_BLOCK_TILE_COMPLEXITY;
                rect.height = TERRAIN_BLOCK_TILE_COMPLEXITY;
                return rect;
              };

              _proto2.setLayer = function setLayer(index, layerId) {
                if (this.layers[index] !== layerId) {
                  this._terrain.setBlockLayer(this._index[0], this._index[1], index, layerId);

                  this._renderable._invalidMaterial();

                  this._updateMaterial(false);
                }
              };

              _proto2.getLayer = function getLayer(index) {
                return this.layers[index];
              };

              _proto2.getMaxLayer = function getMaxLayer() {
                if (this.layers[3] >= 0) {
                  return 3;
                }

                if (this.layers[2] >= 0) {
                  return 2;
                }

                if (this.layers[1] >= 0) {
                  return 1;
                }

                return 0;
              };

              _proto2._getMaterialDefines = function _getMaterialDefines(nlayers) {
                var lightmapMacroValue = 1;

                if (this._terrain.node && this._terrain.node.scene) {
                  if (this._terrain.node.scene.globals.bakedWithStationaryMainLight) {
                    lightmapMacroValue = 2;
                  }
                }

                return {
                  LAYERS: nlayers + 1,
                  CC_USE_LIGHTMAP: this.lightmap !== null ? lightmapMacroValue : 0,
                  USE_NORMALMAP: this._terrain.useNormalMap ? 1 : 0,
                  USE_PBR: this._terrain.usePBR ? 1 : 0
                };
              };

              _proto2._invalidMaterial = function _invalidMaterial() {
                this._renderable._invalidMaterial();
              };

              _proto2._updateMaterial = function _updateMaterial(init) {
                if (this._renderable._updateMaterial(this, init)) {
                  if (this.lightmap !== null) {
                    this.lightmap.setWrapMode(WrapMode$1.CLAMP_TO_BORDER, WrapMode$1.CLAMP_TO_BORDER);
                  }

                  this._renderable._updateLightingmap(this.lightmap, this.lightmapUVParam);
                }
              };

              _proto2._updateHeight = function _updateHeight() {
                if (this._renderable._meshData == null) {
                  return;
                }

                var vertexData = new Float32Array(TERRAIN_BLOCK_VERTEX_SIZE * TERRAIN_BLOCK_VERTEX_COMPLEXITY * TERRAIN_BLOCK_VERTEX_COMPLEXITY);

                this._buildVertexData(vertexData);

                this._renderable._meshData.vertexBuffers[0].update(vertexData);

                this._buildBoundingBox();

                this._renderable._model.createBoundingShape(this._bbMin, this._bbMax);

                this._renderable._model.updateWorldBound();

                this._updateLodBuffer(vertexData);

                this._updateIndexBuffer();
              };

              _proto2._updateWeightMap = function _updateWeightMap() {
                var nlayers = this.getMaxLayer();

                if (nlayers === 0) {
                  if (this._weightMap != null) {
                    this._weightMap.destroy();

                    this._weightMap = null;
                  }

                  return;
                }

                if (this._weightMap == null) {
                  this._weightMap = new Texture2D();

                  this._weightMap.create(this._terrain.weightMapSize, this._terrain.weightMapSize, PixelFormat.RGBA8888);

                  this._weightMap.setFilters(Filter$1.LINEAR, Filter$1.LINEAR);

                  this._weightMap.setWrapMode(WrapMode$1.CLAMP_TO_EDGE, WrapMode$1.CLAMP_TO_EDGE);
                }

                var weightData = new Uint8Array(this._terrain.weightMapSize * this._terrain.weightMapSize * 4);
                var weightIndex = 0;

                for (var j = 0; j < this._terrain.weightMapSize; ++j) {
                  for (var i = 0; i < this._terrain.weightMapSize; ++i) {
                    var x = this._index[0] * this._terrain.weightMapSize + i;
                    var y = this._index[1] * this._terrain.weightMapSize + j;

                    var w = this._terrain.getWeight(x, y);

                    weightData[weightIndex * 4 + 0] = Math.floor(w.x * 255);
                    weightData[weightIndex * 4 + 1] = Math.floor(w.y * 255);
                    weightData[weightIndex * 4 + 2] = Math.floor(w.z * 255);
                    weightData[weightIndex * 4 + 3] = Math.floor(w.w * 255);
                    weightIndex += 1;
                  }
                }

                this._weightMap.uploadData(weightData);
              };

              _proto2._updateLightmap = function _updateLightmap(info) {
                this._lightmapInfo = info;

                this._invalidMaterial();
              };

              _proto2._updateLod = function _updateLod() {
                var key = new TerrainLodKey();
                key.level = this._lodLevel;
                key.north = this._lodLevel;
                key.south = this._lodLevel;
                key.west = this._lodLevel;
                key.east = this._lodLevel;

                if (this._index[0] > 0) {
                  var n = this.getTerrain().getBlock(this._index[0] - 1, this._index[1]);
                  key.west = n._lodLevel;

                  if (key.west < this._lodLevel) {
                    key.west = this._lodLevel;
                  }
                }

                if (this._index[0] < this._terrain.info.blockCount[0] - 1) {
                  var _n = this.getTerrain().getBlock(this._index[0] + 1, this._index[1]);

                  key.east = _n._lodLevel;

                  if (key.east < this._lodLevel) {
                    key.east = this._lodLevel;
                  }
                }

                if (this._index[1] > 0) {
                  var _n2 = this.getTerrain().getBlock(this._index[0], this._index[1] - 1);

                  key.north = _n2._lodLevel;

                  if (key.north < this._lodLevel) {
                    key.north = this._lodLevel;
                  }
                }

                if (this._index[1] < this._terrain.info.blockCount[1] - 1) {
                  var _n3 = this.getTerrain().getBlock(this._index[0], this._index[1] + 1);

                  key.south = _n3._lodLevel;

                  if (key.south < this._lodLevel) {
                    key.south = this._lodLevel;
                  }
                }

                if (this._lodKey.equals(key)) {
                  return;
                }

                this._lodKey = key;

                this._updateIndexBuffer();
              };

              _proto2._resetLod = function _resetLod() {
                var key = new TerrainLodKey();
                key.level = 0;
                key.north = 0;
                key.south = 0;
                key.west = 0;
                key.east = 0;

                if (this._lodKey.equals(key)) {
                  return;
                }

                this._lodKey = key;

                this._updateIndexBuffer();
              };

              _proto2._updateIndexBuffer = function _updateIndexBuffer() {
                if (this._renderable._meshData === null) {
                  return;
                }

                if (this._renderable._model === null) {
                  return;
                }

                if (this._renderable._model.subModels.length === 0) {
                  return;
                }

                var indexData = this._terrain._getIndexData(this._lodKey);

                if (indexData === null) {
                  return;
                }

                var model = this._renderable._model.subModels[0];
                model.inputAssembler.firstIndex = indexData.start;
                model.inputAssembler.indexCount = indexData.size;
              };

              _proto2._getHeight = function _getHeight(x, y, verts) {
                var idx = TERRAIN_BLOCK_VERTEX_COMPLEXITY * y + x;
                return verts[idx * TERRAIN_BLOCK_VERTEX_SIZE + 1];
              };

              _proto2._updateLodBuffer = function _updateLodBuffer(vertecs) {
                this._lodLevel = 0;
                this._lodKey = new TerrainLodKey();

                this._calcErrorMetrics(vertecs);

                this._calcLevelDistances(vertecs);
              };

              _proto2._calcErrorMetrics = function _calcErrorMetrics(vertecs) {
                this._errorMetrics[0] = 0;

                for (var i = 1; i < TERRAIN_LOD_LEVELS; ++i) {
                  this._errorMetrics[i] = this._calcErrorMetric(i, vertecs);
                }

                for (var _i2 = 2; _i2 < TERRAIN_LOD_LEVELS; ++_i2) {
                  this._errorMetrics[_i2] = Math.max(this._errorMetrics[_i2], this._errorMetrics[_i2 - 1]);
                }
              };

              _proto2._calcErrorMetric = function _calcErrorMetric(level, vertecs) {
                var err = 0.0;
                var step = 1 << level;
                var xSectionVerts = TERRAIN_BLOCK_VERTEX_COMPLEXITY;
                var ySectionVerts = TERRAIN_BLOCK_VERTEX_COMPLEXITY;
                var xSides = xSectionVerts - 1 >> level;
                var ySides = ySectionVerts - 1 >> level;

                for (var y = 0; y < ySectionVerts; y += step) {
                  for (var x = 0; x < xSides; ++x) {
                    var x0 = x * step;
                    var x1 = x0 + step;
                    var xm = (x1 + x0) / 2;

                    var h0 = this._getHeight(x0, y, vertecs);

                    var h1 = this._getHeight(x1, y, vertecs);

                    var hm = this._getHeight(xm, y, vertecs);

                    var hmi = (h0 + h1) / 2;
                    var delta = Math.abs(hm - hmi);
                    err = Math.max(err, delta);
                  }
                }

                for (var _x2 = 0; _x2 < xSectionVerts; _x2 += step) {
                  for (var _y2 = 0; _y2 < ySides; ++_y2) {
                    var y0 = _y2 * step;
                    var y1 = y0 + step;
                    var ym = (y0 + y1) / 2;

                    var _h = this._getHeight(_x2, y0, vertecs);

                    var _h2 = this._getHeight(_x2, y1, vertecs);

                    var _hm = this._getHeight(_x2, ym, vertecs);

                    var _hmi = (_h + _h2) / 2;

                    var _delta = Math.abs(_hm - _hmi);

                    err = Math.max(err, _delta);
                  }
                }

                for (var _y3 = 0; _y3 < ySides; ++_y3) {
                  var _y4 = _y3 * step;

                  var _y5 = _y4 + step;

                  var _ym = (_y4 + _y5) / 2;

                  for (var _x3 = 0; _x3 < xSides; ++_x3) {
                    var _x4 = _x3 * step;

                    var _x5 = _x4 + step;

                    var _xm = (_x4 + _x5) / 2;

                    var _h3 = this._getHeight(_x4, _y4, vertecs);

                    var _h4 = this._getHeight(_x5, _y5, vertecs);

                    var _hm2 = this._getHeight(_xm, _ym, vertecs);

                    var _hmi2 = (_h3 + _h4) / 2;

                    var _delta2 = Math.abs(_hm2 - _hmi2);

                    err = Math.max(err, _delta2);
                  }
                }

                return err;
              };

              _proto2._calcLevelDistances = function _calcLevelDistances(vertecs) {
                var pixelerr = 4;
                var resolution = 768;
                var c = 1.0 / (2 * pixelerr / resolution);

                for (var i = 1; i < TERRAIN_LOD_LEVELS; ++i) {
                  var e = this._errorMetrics[i];
                  var d = e * c;
                  this._LevelDistances[i] = d;
                }
              };

              _proto2._buildVertexData = function _buildVertexData(vertexData) {
                var index = 0;

                for (var j = 0; j < TERRAIN_BLOCK_VERTEX_COMPLEXITY; ++j) {
                  for (var i = 0; i < TERRAIN_BLOCK_VERTEX_COMPLEXITY; ++i) {
                    var x = this._index[0] * TERRAIN_BLOCK_TILE_COMPLEXITY + i;
                    var y = this._index[1] * TERRAIN_BLOCK_TILE_COMPLEXITY + j;

                    var position = this._terrain.getPosition(x, y);

                    var normal = this._terrain.getNormal(x, y);

                    var uv = new Vec2(i / TERRAIN_BLOCK_TILE_COMPLEXITY, j / TERRAIN_BLOCK_TILE_COMPLEXITY);
                    vertexData[index++] = position.x;
                    vertexData[index++] = position.y;
                    vertexData[index++] = position.z;
                    vertexData[index++] = normal.x;
                    vertexData[index++] = normal.y;
                    vertexData[index++] = normal.z;
                    vertexData[index++] = uv.x;
                    vertexData[index++] = uv.y;
                  }
                }
              };

              _proto2._buildBoundingBox = function _buildBoundingBox() {
                this._bbMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);

                this._bbMax.set(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);

                for (var j = 0; j < TERRAIN_BLOCK_VERTEX_COMPLEXITY; ++j) {
                  for (var i = 0; i < TERRAIN_BLOCK_VERTEX_COMPLEXITY; ++i) {
                    var x = this._index[0] * TERRAIN_BLOCK_TILE_COMPLEXITY + i;
                    var y = this._index[1] * TERRAIN_BLOCK_TILE_COMPLEXITY + j;

                    var position = this._terrain.getPosition(x, y);

                    Vec3.min(this._bbMin, this._bbMin, position);
                    Vec3.max(this._bbMax, this._bbMax, position);
                  }
                }
              };

              _createClass(TerrainBlock, [{
                key: "valid",
                get: function get() {
                  if (this._terrain === null) {
                    return false;
                  }

                  var blocks = this._terrain.getBlocks();

                  for (var i = 0; i < blocks.length; ++i) {
                    if (blocks[i] === this) {
                      return true;
                    }
                  }

                  return false;
                }
              }, {
                key: "material",
                get: function get() {
                  return this._renderable ? this._renderable._currentMaterial : null;
                }
              }, {
                key: "layers",
                get: function get() {
                  return this._terrain.getBlockLayers(this._index[0], this._index[1]);
                }
              }, {
                key: "weightmap",
                get: function get() {
                  return this._weightMap;
                }
              }, {
                key: "lightmap",
                get: function get() {
                  return this._lightmapInfo ? this._lightmapInfo.texture : null;
                }
              }, {
                key: "lightmapUVParam",
                get: function get() {
                  if (this._lightmapInfo != null) {
                    return new Vec4(this._lightmapInfo.UOff, this._lightmapInfo.VOff, this._lightmapInfo.UScale, this._lightmapInfo.VScale);
                  }

                  return new Vec4(0, 0, 0, 0);
                }
              }, {
                key: "visible",
                get: function get() {
                  if (this._renderable._model !== null) {
                    return this._renderable._model.scene !== null;
                  }

                  return false;
                },
                set: function set(val) {
                  if (this._renderable._model !== null) {
                    if (val) {
                      if (this._terrain.node != null && this._terrain.node.scene != null && this._terrain.node.scene.renderScene != null && this._renderable._model.scene == null) {
                        this._terrain.node.scene.renderScene.addModel(this._renderable._model);
                      }
                    } else if (this._renderable._model.scene !== null) {
                      this._renderable._model.scene.removeModel(this._renderable._model);
                    }
                  }
                }
              }]);

              return TerrainBlock;
            }());
            var Terrain = exports('Terrain', (_dec4$F = ccclass$p('cc.Terrain'), _dec5$y = type$8(TerrainAsset), _dec6$r = type$8(EffectAsset), _dec7$k = type$8(TerrainBlockLightmapInfo), _dec8$e = type$8(CCFloat), _dec9$c = type$8(TerrainAsset), _dec10$6 = type$8(EffectAsset), _dec11$4 = type$8(TerrainInfo), _dec4$F(_class10$2 = disallowMultiple(_class10$2 = (_class11$4 = function (_Component) {
              _inheritsLoose(Terrain, _Component);

              function Terrain() {
                var _this2;

                _this2 = _Component.call(this) || this;
                _this2.__asset = _initializer15$9 && _initializer15$9();
                _this2._effectAsset = _initializer16$9 && _initializer16$9();
                _this2._lightmapInfos = _initializer17$8 && _initializer17$8();
                _this2._receiveShadow = _initializer18$7 && _initializer18$7();
                _this2._useNormalmap = _initializer19$7 && _initializer19$7();
                _this2._usePBR = _initializer20$5 && _initializer20$5();
                _this2._lodEnable = _initializer21$4 && _initializer21$4();
                _this2._lodBias = _initializer22$4 && _initializer22$4();
                _this2._buitinAsset = null;
                _this2._tileSize = 1;
                _this2._blockCount = [1, 1];
                _this2._weightMapSize = 128;
                _this2._lightMapSize = 128;
                _this2._heights = new Uint16Array();
                _this2._weights = new Uint8Array();
                _this2._normals = new Float32Array();
                _this2._layerList = [];
                _this2._layerBuffer = [];
                _this2._blocks = [];
                _this2._lod = null;
                _this2._sharedIndexBuffer = null;
                _this2._sharedLodIndexBuffer = null;

                for (var i = 0; i < TERRAIN_MAX_LAYER_COUNT; ++i) {
                  _this2._layerList.push(null);
                }

                return _this2;
              }

              var _proto3 = Terrain.prototype;

              _proto3.build = function build(info) {
                this._tileSize = info.tileSize;
                this._blockCount[0] = info.blockCount[0];
                this._blockCount[1] = info.blockCount[1];
                this._weightMapSize = info.weightMapSize;
                this._lightMapSize = info.lightMapSize;
                return this._buildImp();
              };

              _proto3.rebuild = function rebuild(info) {
                for (var i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i].destroy();
                }

                this._blocks = [];

                this._resetLightmap(false);

                this._rebuildLayerBuffer(info);

                var heightsChanged = this._rebuildHeights(info);

                this._rebuildWeights(info);

                this._tileSize = info.tileSize;
                this._blockCount[0] = info.blockCount[0];
                this._blockCount[1] = info.blockCount[1];
                this._weightMapSize = info.weightMapSize;
                this._lightMapSize = info.lightMapSize;

                if (heightsChanged) {
                  this._normals = new Float32Array(this.heights.length * 3);

                  this._buildNormals();
                }

                for (var j = 0; j < this._blockCount[1]; ++j) {
                  for (var _i3 = 0; _i3 < this._blockCount[0]; ++_i3) {
                    this._blocks.push(new TerrainBlock(this, _i3, j));
                  }
                }

                for (var _i4 = 0; _i4 < this._blocks.length; ++_i4) {
                  this._blocks[_i4].build();
                }
              };

              _proto3.importHeightField = function importHeightField(hf, heightScale) {
                var index = 0;

                for (var j = 0; j < this.vertexCount[1]; ++j) {
                  for (var i = 0; i < this.vertexCount[0]; ++i) {
                    var u = i / this.tileCount[0];
                    var v = j / this.tileCount[1];
                    var h = hf.getAt(u * hf.w, v * hf.h) * heightScale;
                    this._heights[index++] = h;
                  }
                }

                this._buildNormals();

                for (var _i5 = 0; _i5 < this._blocks.length; ++_i5) {
                  this._blocks[_i5]._updateHeight();
                }
              };

              _proto3.exportHeightField = function exportHeightField(hf, heightScale) {
                var index = 0;

                for (var j = 0; j < hf.h; ++j) {
                  for (var i = 0; i < hf.w; ++i) {
                    var u = i / (hf.w - 1);
                    var v = j / (hf.h - 1);
                    var x = u * this.size.width;
                    var y = v * this.size.height;
                    var h = this.getHeightAt(x, y);

                    if (h != null) {
                      hf.data[index++] = h * heightScale;
                    }
                  }
                }
              };

              _proto3.exportAsset = function exportAsset() {
                var asset = new TerrainAsset();
                asset.tileSize = this.tileSize;
                asset.blockCount = this.blockCount;
                asset.lightMapSize = this.lightMapSize;
                asset.weightMapSize = this.weightMapSize;
                asset.heights = this.heights;
                asset.weights = this.weights;
                asset.layerBuffer = new Array(this._blocks.length * 4);

                for (var i = 0; i < this._blocks.length; ++i) {
                  asset.layerBuffer[i * 4 + 0] = this._blocks[i].layers[0];
                  asset.layerBuffer[i * 4 + 1] = this._blocks[i].layers[1];
                  asset.layerBuffer[i * 4 + 2] = this._blocks[i].layers[2];
                  asset.layerBuffer[i * 4 + 3] = this._blocks[i].layers[3];
                }

                this.exportLayerListToAsset(asset);
                return asset;
              };

              _proto3.exportLayerListToAsset = function exportLayerListToAsset(asset) {
                asset.layerInfos.length = 0;

                for (var i = 0; i < this._layerList.length; ++i) {
                  var temp = this._layerList[i];

                  if (temp && temp.detailMap && isValid(temp.detailMap)) {
                    var layer = new TerrainLayerInfo();
                    layer.slot = i;
                    layer.tileSize = temp.tileSize;
                    layer.detailMap = temp.detailMap;
                    layer.normalMap = temp.normalMap;
                    layer.metallic = temp.metallic;
                    layer.roughness = temp.roughness;
                    asset.layerInfos.push(layer);
                  }
                }
              };

              _proto3.getEffectAsset = function getEffectAsset() {
                if (this._effectAsset === null) {
                  return legacyCC.EffectAsset.get(TERRAIN_EFFECT_UUID);
                }

                return this._effectAsset;
              };

              _proto3.onEnable = function onEnable() {
                if (this._blocks.length === 0) {
                  this._buildImp();
                }

                for (var i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i].visible = true;
                }

                legacyCC.director.root.pipelineEvent.on(PipelineEventType.RENDER_CAMERA_BEGIN, this.onUpdateFromCamera, this);
              };

              _proto3.onDisable = function onDisable() {
                legacyCC.director.root.pipelineEvent.off(PipelineEventType.RENDER_CAMERA_BEGIN, this.onUpdateFromCamera, this);

                for (var i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i].visible = false;
                }
              };

              _proto3.onDestroy = function onDestroy() {
                for (var i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i].destroy();
                }

                this._blocks = [];

                for (var _i6 = 0; _i6 < this._layerList.length; ++_i6) {
                  this._layerList[_i6] = null;
                }

                if (this._sharedIndexBuffer != null) {
                  this._sharedIndexBuffer.destroy();
                }

                if (this._sharedLodIndexBuffer != null) {
                  this._sharedLodIndexBuffer.destroy();
                }
              };

              _proto3.onRestore = function onRestore() {
                this.onEnable();

                this._buildImp(true);
              };

              _proto3.update = function update(deltaTime) {
                for (var i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i].update();
                }
              };

              _proto3.onUpdateFromCamera = function onUpdateFromCamera(cam) {
                if (!this.lodEnable || this._sharedLodIndexBuffer == null) {
                  return;
                }

                if (cam.scene !== this._getRenderScene()) {
                  return;
                }

                for (var i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i]._updateLevel(cam.position);
                }

                for (var _i7 = 0; _i7 < this._blocks.length; ++_i7) {
                  this._blocks[_i7]._updateLod();
                }
              };

              _proto3.addLayer = function addLayer(layer) {
                for (var i = 0; i < this._layerList.length; ++i) {
                  var _this$_layerList$i;

                  if (this._layerList[i] === null || this._layerList[i] && ((_this$_layerList$i = this._layerList[i]) === null || _this$_layerList$i === void 0 ? void 0 : _this$_layerList$i.detailMap) === null) {
                    this._layerList[i] = layer;

                    if (this._asset) {
                      this.exportLayerListToAsset(this._asset);
                    }

                    return i;
                  }
                }

                return -1;
              };

              _proto3.setLayer = function setLayer(i, layer) {
                this._layerList[i] = layer;

                if (this._asset) {
                  this.exportLayerListToAsset(this._asset);
                }
              };

              _proto3.removeLayer = function removeLayer(id) {
                this._layerList[id] = null;

                if (this._asset) {
                  this.exportLayerListToAsset(this._asset);
                }
              };

              _proto3.getLayer = function getLayer(id) {
                if (id === -1) {
                  return null;
                }

                return this._layerList[id];
              };

              _proto3.getPosition = function getPosition(i, j) {
                var x = i * this._tileSize;
                var z = j * this._tileSize;
                var y = this.getHeight(i, j);
                return new Vec3(x, y, z);
              };

              _proto3.getHeightField = function getHeightField() {
                return this._heights;
              };

              _proto3.setHeight = function setHeight(i, j, h) {
                h = clamp$1(h, TERRAIN_HEIGHT_FMIN, TERRAIN_HEIGHT_FMAX);
                this._heights[j * this.vertexCount[0] + i] = TERRAIN_HEIGHT_BASE + h / TERRAIN_HEIGHT_FACTORY;
              };

              _proto3.getHeight = function getHeight(i, j) {
                return (this._heights[j * this.vertexCount[0] + i] - TERRAIN_HEIGHT_BASE) * TERRAIN_HEIGHT_FACTORY;
              };

              _proto3.getHeightClamp = function getHeightClamp(i, j) {
                i = clamp$1(i, 0, this.vertexCount[0] - 1);
                j = clamp$1(j, 0, this.vertexCount[1] - 1);
                return this.getHeight(i, j);
              };

              _proto3.getHeightAt = function getHeightAt(x, y) {
                var fx = x / this.tileSize;
                var fy = y / this.tileSize;
                var ix0 = Math.floor(fx);
                var iz0 = Math.floor(fy);
                var ix1 = ix0 + 1;
                var iz1 = iz0 + 1;
                var dx = fx - ix0;
                var dz = fy - iz0;

                if (ix0 < 0 || ix0 > this.vertexCount[0] - 1 || iz0 < 0 || iz0 > this.vertexCount[1] - 1) {
                  return null;
                }

                ix0 = clamp$1(ix0, 0, this.vertexCount[0] - 1);
                iz0 = clamp$1(iz0, 0, this.vertexCount[1] - 1);
                ix1 = clamp$1(ix1, 0, this.vertexCount[0] - 1);
                iz1 = clamp$1(iz1, 0, this.vertexCount[1] - 1);
                var a = this.getHeight(ix0, iz0);
                var b = this.getHeight(ix1, iz0);
                var c = this.getHeight(ix0, iz1);
                var d = this.getHeight(ix1, iz1);
                var m = (b + c) * 0.5;

                if (dx + dz <= 1.0) {
                  d = m + (m - a);
                } else {
                  a = m + (m - d);
                }

                var h1 = a * (1.0 - dx) + b * dx;
                var h2 = c * (1.0 - dx) + d * dx;
                var h = h1 * (1.0 - dz) + h2 * dz;
                return h;
              };

              _proto3._setNormal = function _setNormal(i, j, n) {
                var index = j * this.vertexCount[0] + i;
                this._normals[index * 3 + 0] = n.x;
                this._normals[index * 3 + 1] = n.y;
                this._normals[index * 3 + 2] = n.z;
              };

              _proto3.getNormal = function getNormal(i, j) {
                var index = j * this.vertexCount[0] + i;
                var n = new Vec3();
                n.x = this._normals[index * 3 + 0];
                n.y = this._normals[index * 3 + 1];
                n.z = this._normals[index * 3 + 2];
                return n;
              };

              _proto3.getNormalAt = function getNormalAt(x, y) {
                var fx = x / this.tileSize;
                var fy = y / this.tileSize;
                var ix0 = Math.floor(fx);
                var iz0 = Math.floor(fy);
                var ix1 = ix0 + 1;
                var iz1 = iz0 + 1;
                var dx = fx - ix0;
                var dz = fy - iz0;

                if (ix0 < 0 || ix0 > this.vertexCount[0] - 1 || iz0 < 0 || iz0 > this.vertexCount[1] - 1) {
                  return null;
                }

                ix0 = clamp$1(ix0, 0, this.vertexCount[0] - 1);
                iz0 = clamp$1(iz0, 0, this.vertexCount[1] - 1);
                ix1 = clamp$1(ix1, 0, this.vertexCount[0] - 1);
                iz1 = clamp$1(iz1, 0, this.vertexCount[1] - 1);
                var a = this.getNormal(ix0, iz0);
                var b = this.getNormal(ix1, iz0);
                var c = this.getNormal(ix0, iz1);
                var d = this.getNormal(ix1, iz1);
                var m = new Vec3();
                Vec3.add(m, b, c).multiplyScalar(0.5);

                if (dx + dz <= 1.0) {
                  d.set(m);
                  d.subtract(a);
                  d.add(m);
                } else {
                  a.set(m);
                  a.subtract(d);
                  a.add(m);
                }

                var n1 = new Vec3();
                var n2 = new Vec3();
                var n = new Vec3();
                Vec3.lerp(n1, a, b, dx);
                Vec3.lerp(n2, c, d, dx);
                Vec3.lerp(n, n1, n2, dz);
                return n;
              };

              _proto3.setWeight = function setWeight(i, j, w) {
                var index = j * this._weightMapSize * this._blockCount[0] + i;
                this._weights[index * 4 + 0] = w.x * 255;
                this._weights[index * 4 + 1] = w.y * 255;
                this._weights[index * 4 + 2] = w.z * 255;
                this._weights[index * 4 + 3] = w.w * 255;
              };

              _proto3.getWeight = function getWeight(i, j) {
                var index = j * this._weightMapSize * this._blockCount[0] + i;
                var w = new Vec4();
                w.x = this._weights[index * 4 + 0] / 255.0;
                w.y = this._weights[index * 4 + 1] / 255.0;
                w.z = this._weights[index * 4 + 2] / 255.0;
                w.w = this._weights[index * 4 + 3] / 255.0;
                return w;
              };

              _proto3.getWeightAt = function getWeightAt(x, y) {
                var uWeigthComplexity = this.weightMapSize * this.blockCount[0];
                var vWeigthComplexity = this.weightMapSize * this.blockCount[1];

                if (uWeigthComplexity === 0 || vWeigthComplexity === 0) {
                  return null;
                }

                var fx = x / uWeigthComplexity;
                var fy = y / vWeigthComplexity;
                var ix0 = Math.floor(fx);
                var iz0 = Math.floor(fy);
                var ix1 = ix0 + 1;
                var iz1 = iz0 + 1;
                var dx = fx - ix0;
                var dz = fy - iz0;

                if (ix0 < 0 || ix0 > uWeigthComplexity - 1 || iz0 < 0 || iz0 > vWeigthComplexity - 1) {
                  return null;
                }

                ix0 = clamp$1(ix0, 0, uWeigthComplexity - 1);
                iz0 = clamp$1(iz0, 0, vWeigthComplexity - 1);
                ix1 = clamp$1(ix1, 0, uWeigthComplexity - 1);
                iz1 = clamp$1(iz1, 0, vWeigthComplexity - 1);
                var a = this.getWeight(ix0, iz0);
                var b = this.getWeight(ix1, iz0);
                var c = this.getWeight(ix0, iz1);
                var d = this.getWeight(ix1, iz1);
                var m = new Vec4();
                Vec4.add(m, b, c).multiplyScalar(0.5);

                if (dx + dz <= 1.0) {
                  d = new Vec4();
                  Vec4.subtract(d, m, a).add(m);
                } else {
                  a = new Vec4();
                  Vec4.subtract(a, m, d).add(m);
                }

                var n1 = new Vec4();
                var n2 = new Vec4();
                var n = new Vec4();
                Vec4.lerp(n1, a, b, dx);
                Vec4.lerp(n2, c, d, dx);
                Vec4.lerp(n, n1, n2, dz);
                return n;
              };

              _proto3.getMaxWeightLayerAt = function getMaxWeightLayerAt(x, y) {
                var uWeigthComplexity = this.weightMapSize * this.blockCount[0];
                var vWeigthComplexity = this.weightMapSize * this.blockCount[1];

                if (uWeigthComplexity === 0 || vWeigthComplexity === 0) {
                  return null;
                }

                var fx = x / uWeigthComplexity;
                var fy = y / vWeigthComplexity;
                var ix0 = Math.floor(fx);
                var iz0 = Math.floor(fy);

                if (ix0 < 0 || ix0 > uWeigthComplexity - 1 || iz0 < 0 || iz0 > vWeigthComplexity - 1) {
                  return null;
                }

                var w = this.getWeight(ix0, iz0);
                var bx = Math.floor(x / this.weightMapSize);
                var by = Math.floor(y / this.weightMapSize);
                var block = this.getBlock(bx, by);
                var i = 0;

                if (w.y > w[i] && block.getLayer(1) !== -1) {
                  i = 1;
                }

                if (w.y > w[i] && block.getLayer(2) !== -1) {
                  i = 2;
                }

                if (w.z > w[i] && block.getLayer(3) !== -1) {
                  i = 3;
                }

                i = block.getLayer(i);
                return this.getLayer(i);
              };

              _proto3.getBlockLayers = function getBlockLayers(i, j) {
                var layerIndex = (j * this._blockCount[0] + i) * TERRAIN_MAX_BLEND_LAYERS;
                return [this._layerBuffer[layerIndex], this._layerBuffer[layerIndex + 1], this._layerBuffer[layerIndex + 2], this._layerBuffer[layerIndex + 3]];
              };

              _proto3.getBlockLayer = function getBlockLayer(i, j, index) {
                var layerIndex = (j * this._blockCount[0] + i) * TERRAIN_MAX_BLEND_LAYERS;
                return this._layerBuffer[layerIndex + index];
              };

              _proto3.setBlockLayer = function setBlockLayer(i, j, index, layerId) {
                var layerIndex = (j * this._blockCount[0] + i) * TERRAIN_MAX_BLEND_LAYERS;
                this._layerBuffer[layerIndex + index] = layerId;
              };

              _proto3.getBlock = function getBlock(i, j) {
                return this._blocks[j * this._blockCount[0] + i];
              };

              _proto3.getBlocks = function getBlocks() {
                return this._blocks;
              };

              _proto3.rayCheck = function rayCheck(start, dir, step, worldSpace) {
                if (worldSpace === void 0) {
                  worldSpace = true;
                }

                var MAX_COUNT = 2000;
                var trace = start;

                if (worldSpace) {
                  Vec3.subtract(trace, start, this.node.getWorldPosition());
                }

                var delta = new Vec3();
                delta.set(dir);
                delta.multiplyScalar(step);
                var position = null;

                if (dir.equals(new Vec3(0, 1, 0))) {
                  var y = this.getHeightAt(trace.x, trace.z);

                  if (y != null && trace.y <= y) {
                    position = new Vec3(trace.x, y, trace.z);
                  }
                } else if (dir.equals(new Vec3(0, -1, 0))) {
                  var _y6 = this.getHeightAt(trace.x, trace.z);

                  if (_y6 != null && trace.y >= _y6) {
                    position = new Vec3(trace.x, _y6, trace.z);
                  }
                } else {
                  var i = 0;

                  while (i++ < MAX_COUNT) {
                    var _y7 = this.getHeightAt(trace.x, trace.z);

                    if (_y7 != null && trace.y <= _y7) {
                      break;
                    }

                    trace.add(dir);
                  }

                  while (i++ < MAX_COUNT) {
                    var _y8 = this.getHeightAt(trace.x, trace.z);

                    if (_y8 != null && trace.y <= _y8) {
                      position = new Vec3(trace.x, _y8, trace.z);
                      break;
                    }

                    trace.add(delta);
                  }
                }

                return position;
              };

              _proto3._createSharedIndexBuffer = function _createSharedIndexBuffer() {
                var gfxDevice = deviceManager.gfxDevice;

                if (this._lod !== null) {
                  var gfxBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, Uint16Array.BYTES_PER_ELEMENT * this._lod._indexBuffer.length, Uint16Array.BYTES_PER_ELEMENT));
                  gfxBuffer.update(this._lod._indexBuffer);
                  return gfxBuffer;
                } else {
                  var indexData = new Uint16Array(TERRAIN_BLOCK_TILE_COMPLEXITY * TERRAIN_BLOCK_TILE_COMPLEXITY * 6);
                  var index = 0;

                  for (var j = 0; j < TERRAIN_BLOCK_TILE_COMPLEXITY; ++j) {
                    for (var i = 0; i < TERRAIN_BLOCK_TILE_COMPLEXITY; ++i) {
                      var a = j * TERRAIN_BLOCK_VERTEX_COMPLEXITY + i;
                      var b = j * TERRAIN_BLOCK_VERTEX_COMPLEXITY + i + 1;
                      var c = (j + 1) * TERRAIN_BLOCK_VERTEX_COMPLEXITY + i;
                      var d = (j + 1) * TERRAIN_BLOCK_VERTEX_COMPLEXITY + i + 1;
                      indexData[index++] = a;
                      indexData[index++] = c;
                      indexData[index++] = b;
                      indexData[index++] = b;
                      indexData[index++] = c;
                      indexData[index++] = d;
                    }
                  }

                  var _gfxBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, Uint16Array.BYTES_PER_ELEMENT * indexData.length, Uint16Array.BYTES_PER_ELEMENT));

                  _gfxBuffer.update(indexData);

                  return _gfxBuffer;
                }
              };

              _proto3._getSharedIndexBuffer = function _getSharedIndexBuffer() {
                if (this._sharedLodIndexBuffer !== null) {
                  return this._sharedLodIndexBuffer;
                }

                if (this._sharedIndexBuffer !== null) {
                  return this._sharedIndexBuffer;
                }

                if (this.lodEnable && this._lod === null) {
                  this._lod = new TerrainLod();
                }

                if (this._lod !== null) {
                  this._sharedLodIndexBuffer = this._createSharedIndexBuffer();
                  return this._sharedLodIndexBuffer;
                } else {
                  this._sharedIndexBuffer = this._createSharedIndexBuffer();
                  return this._sharedIndexBuffer;
                }
              };

              _proto3._getIndexData = function _getIndexData(key) {
                if (this._sharedLodIndexBuffer !== null && this._lod !== null) {
                  return this._lod.getIndexData(key);
                }

                return null;
              };

              _proto3._resetLightmap = function _resetLightmap(enble) {
                this._lightmapInfos.length = 0;

                if (enble) {
                  for (var i = 0; i < this._blockCount[0] * this._blockCount[1]; ++i) {
                    this._lightmapInfos.push(new TerrainBlockLightmapInfo());
                  }
                }
              };

              _proto3._updateLightmap = function _updateLightmap(blockId, tex, uOff, vOff, uScale, vScale) {
                if (tex) {
                  if (this._lightmapInfos.length == 0) {
                    for (var i = 0; i < this._blockCount[0] * this._blockCount[1]; ++i) {
                      this._lightmapInfos.push(new TerrainBlockLightmapInfo());
                    }
                  }
                } else if (this._lightmapInfos.length == 0) {
                  return;
                }

                this._lightmapInfos[blockId].texture = tex;
                this._lightmapInfos[blockId].UOff = uOff;
                this._lightmapInfos[blockId].VOff = vOff;
                this._lightmapInfos[blockId].UScale = uScale;
                this._lightmapInfos[blockId].VScale = vScale;

                this._blocks[blockId]._updateLightmap(this._lightmapInfos[blockId]);
              };

              _proto3._getLightmapInfo = function _getLightmapInfo(i, j) {
                var index = j * this._blockCount[0] + i;
                return index < this._lightmapInfos.length ? this._lightmapInfos[index] : null;
              };

              _proto3._calcNormal = function _calcNormal(x, z) {
                var flip = 1;
                var here = this.getPosition(x, z);
                var right;
                var up;

                if (x < this.vertexCount[0] - 1) {
                  right = this.getPosition(x + 1, z);
                } else {
                  flip *= -1;
                  right = this.getPosition(x - 1, z);
                }

                if (z < this.vertexCount[1] - 1) {
                  up = this.getPosition(x, z + 1);
                } else {
                  flip *= -1;
                  up = this.getPosition(x, z - 1);
                }

                right.subtract(here);
                up.subtract(here);
                var normal = new Vec3();
                normal.set(up);
                normal.cross(right);
                normal.multiplyScalar(flip);
                normal.normalize();
                return normal;
              };

              _proto3._buildNormals = function _buildNormals() {
                var index = 0;

                for (var y = 0; y < this.vertexCount[1]; ++y) {
                  for (var x = 0; x < this.vertexCount[0]; ++x) {
                    var n = this._calcNormal(x, y);

                    this._normals[index * 3 + 0] = n.x;
                    this._normals[index * 3 + 1] = n.y;
                    this._normals[index * 3 + 2] = n.z;
                    index += 1;
                  }
                }
              };

              _proto3._buildImp = function _buildImp(restore) {
                var _this3 = this;

                if (restore === void 0) {
                  restore = false;
                }

                if (this.valid) {
                  return;
                }

                var terrainAsset = this.__asset;

                if (this._buitinAsset !== terrainAsset) {
                  this._buitinAsset = terrainAsset;
                }

                if (!restore && terrainAsset !== null) {
                  this._tileSize = terrainAsset.tileSize;
                  this._blockCount = terrainAsset.blockCount;
                  this._weightMapSize = terrainAsset.weightMapSize;
                  this._lightMapSize = terrainAsset.lightMapSize;
                  this._heights = terrainAsset.heights;
                  this._normals = terrainAsset.normals;
                  this._weights = terrainAsset.weights;
                  this._layerBuffer = terrainAsset.layerBuffer;

                  for (var i = 0; i < this._layerList.length; ++i) {
                    this._layerList[i] = null;
                  }

                  if (terrainAsset.version < TERRAIN_DATA_VERSION5) {
                    var _loop = function _loop(_i8) {
                      var layer = new TerrainLayer();
                      var layerInfo = terrainAsset.layerBinaryInfos[_i8];
                      layer.tileSize = layerInfo.tileSize;
                      legacyCC.assetManager.loadAny(layerInfo.detailMapId, function (err, asset) {
                        layer.detailMap = asset;
                      });

                      if (layerInfo.normalMapId !== '') {
                        legacyCC.assetManager.loadAny(layerInfo.normalMapId, function (err, asset) {
                          layer.normalMap = asset;
                        });
                      }

                      layer.roughness = layerInfo.roughness;
                      layer.metallic = layerInfo.metallic;
                      _this3._layerList[layerInfo.slot] = layer;
                    };

                    for (var _i8 = 0; _i8 < terrainAsset.layerBinaryInfos.length; ++_i8) {
                      _loop(_i8);
                    }
                  } else {
                    for (var _i9 = 0; _i9 < terrainAsset.layerInfos.length; ++_i9) {
                      var layer = new TerrainLayer();
                      var layerInfo = terrainAsset.layerInfos[_i9];
                      layer.tileSize = layerInfo.tileSize;
                      layer.detailMap = layerInfo.detailMap;
                      layer.normalMap = layerInfo.normalMap;
                      layer.roughness = layerInfo.roughness;
                      layer.metallic = layerInfo.metallic;
                      this._layerList[layerInfo.slot] = layer;
                    }
                  }
                }

                if (this._blockCount[0] === 0 || this._blockCount[1] === 0) {
                  return;
                }

                var vertexCount = this.vertexCount[0] * this.vertexCount[1];

                if (this._heights === null || this._heights.length !== vertexCount) {
                  this._heights = new Uint16Array(vertexCount);
                  this._normals = new Float32Array(vertexCount * 3);

                  for (var _i10 = 0; _i10 < vertexCount; ++_i10) {
                    this._heights[_i10] = TERRAIN_HEIGHT_BASE;
                    this._normals[_i10 * 3 + 0] = 0;
                    this._normals[_i10 * 3 + 1] = 1;
                    this._normals[_i10 * 3 + 2] = 0;
                  }
                }

                if (this._normals === null || this._normals.length !== vertexCount * 3) {
                  this._normals = new Float32Array(vertexCount * 3);

                  this._buildNormals();
                }

                var layerBufferSize = this.blockCount[0] * this.blockCount[1] * TERRAIN_MAX_BLEND_LAYERS;

                if (this._layerBuffer === null || this._layerBuffer.length !== layerBufferSize) {
                  this._layerBuffer = new Array(layerBufferSize);

                  for (var _i11 = 0; _i11 < layerBufferSize; ++_i11) {
                    this._layerBuffer[_i11] = -1;
                  }
                }

                var weightMapComplexityU = this._weightMapSize * this._blockCount[0];
                var weightMapComplexityV = this._weightMapSize * this._blockCount[1];

                if (this._weights.length !== weightMapComplexityU * weightMapComplexityV * 4) {
                  this._weights = new Uint8Array(weightMapComplexityU * weightMapComplexityV * 4);

                  for (var _i12 = 0; _i12 < weightMapComplexityU * weightMapComplexityV; ++_i12) {
                    this._weights[_i12 * 4 + 0] = 255;
                    this._weights[_i12 * 4 + 1] = 0;
                    this._weights[_i12 * 4 + 2] = 0;
                    this._weights[_i12 * 4 + 3] = 0;
                  }
                }

                for (var j = 0; j < this._blockCount[1]; ++j) {
                  for (var _i13 = 0; _i13 < this._blockCount[0]; ++_i13) {
                    this._blocks.push(new TerrainBlock(this, _i13, j));
                  }
                }

                for (var _i14 = 0; _i14 < this._blocks.length; ++_i14) {
                  this._blocks[_i14].build();
                }
              };

              _proto3._rebuildHeights = function _rebuildHeights(info) {
                if (this.vertexCount[0] === info.vertexCount[0] && this.vertexCount[1] === info.vertexCount[1]) {
                  return false;
                }

                var heights = new Uint16Array(info.vertexCount[0] * info.vertexCount[1]);

                for (var i = 0; i < heights.length; ++i) {
                  heights[i] = TERRAIN_HEIGHT_BASE;
                }

                var w = Math.min(this.vertexCount[0], info.vertexCount[0]);
                var h = Math.min(this.vertexCount[1], info.vertexCount[1]);

                for (var j = 0; j < h; ++j) {
                  for (var _i15 = 0; _i15 < w; ++_i15) {
                    var index0 = j * info.vertexCount[0] + _i15;
                    var index1 = j * this.vertexCount[0] + _i15;
                    heights[index0] = this._heights[index1];
                  }
                }

                this._heights = heights;
                return true;
              };

              _proto3._rebuildLayerBuffer = function _rebuildLayerBuffer(info) {
                if (this.blockCount[0] === info.blockCount[0] && this.blockCount[1] === info.blockCount[1]) {
                  return false;
                }

                var layerBuffer = [];
                layerBuffer.length = info.blockCount[0] * info.blockCount[1] * TERRAIN_MAX_BLEND_LAYERS;

                for (var i = 0; i < layerBuffer.length; ++i) {
                  layerBuffer[i] = -1;
                }

                var w = Math.min(this.blockCount[0], info.blockCount[0]);
                var h = Math.min(this.blockCount[1], info.blockCount[1]);

                for (var j = 0; j < h; ++j) {
                  for (var _i16 = 0; _i16 < w; ++_i16) {
                    var index0 = j * info.blockCount[0] + _i16;
                    var index1 = j * this.blockCount[0] + _i16;

                    for (var l = 0; l < TERRAIN_MAX_BLEND_LAYERS; ++l) {
                      layerBuffer[index0 * TERRAIN_MAX_BLEND_LAYERS + l] = this._layerBuffer[index1 * TERRAIN_MAX_BLEND_LAYERS + l];
                    }
                  }
                }

                this._layerBuffer = layerBuffer;
                return true;
              };

              _proto3._rebuildWeights = function _rebuildWeights(info) {
                var _this4 = this;

                var oldWeightMapSize = this._weightMapSize;
                var oldWeightMapComplexityU = this._weightMapSize * this._blockCount[0];
                var oldWeightMapComplexityV = this._weightMapSize * this._blockCount[1];
                var weightMapComplexityU = info.weightMapSize * info.blockCount[0];
                var weightMapComplexityV = info.weightMapSize * info.blockCount[1];

                if (weightMapComplexityU === oldWeightMapComplexityU && weightMapComplexityV === oldWeightMapComplexityV) {
                  return false;
                }

                var weights = new Uint8Array(weightMapComplexityU * weightMapComplexityV * 4);

                for (var i = 0; i < weightMapComplexityU * weightMapComplexityV; ++i) {
                  weights[i * 4 + 0] = 255;
                  weights[i * 4 + 1] = 0;
                  weights[i * 4 + 2] = 0;
                  weights[i * 4 + 3] = 0;
                }

                var w = Math.min(info.blockCount[0], this._blockCount[0]);
                var h = Math.min(info.blockCount[1], this._blockCount[1]);

                var getOldWeight = function getOldWeight(_i, _j, _weights) {
                  var index = _j * oldWeightMapComplexityU + _i;
                  var weight = new Vec4();
                  weight.x = _weights[index * 4 + 0] / 255.0;
                  weight.y = _weights[index * 4 + 1] / 255.0;
                  weight.z = _weights[index * 4 + 2] / 255.0;
                  weight.w = _weights[index * 4 + 3] / 255.0;
                  return weight;
                };

                var sampleOldWeight = function sampleOldWeight(_x, _y, _xOff, _yOff, _weights) {
                  var ix0 = Math.floor(_x);
                  var iz0 = Math.floor(_y);
                  var ix1 = Math.min(ix0 + 1, oldWeightMapSize - 1);
                  var iz1 = Math.min(iz0 + 1, oldWeightMapSize - 1);
                  var dx = _x - ix0;
                  var dz = _y - iz0;
                  var a = getOldWeight(ix0 + _xOff, iz0 + _yOff, _this4._weights);
                  var b = getOldWeight(ix1 + _xOff, iz0 + _yOff, _this4._weights);
                  var c = getOldWeight(ix0 + _xOff, iz1 + _yOff, _this4._weights);
                  var d = getOldWeight(ix1 + _xOff, iz1 + _yOff, _this4._weights);
                  var m = new Vec4();
                  Vec4.add(m, b, c).multiplyScalar(0.5);

                  if (dx + dz <= 1.0) {
                    d.set(m);
                    d.subtract(a);
                    d.add(m);
                  } else {
                    a.set(m);
                    a.subtract(d);
                    a.add(m);
                  }

                  var n1 = new Vec4();
                  var n2 = new Vec4();
                  var n = new Vec4();
                  Vec4.lerp(n1, a, b, dx);
                  Vec4.lerp(n2, c, d, dx);
                  Vec4.lerp(n, n1, n2, dz);
                  return n;
                };

                for (var j = 0; j < h; ++j) {
                  for (var _i17 = 0; _i17 < w; ++_i17) {
                    var uOff = _i17 * oldWeightMapSize;
                    var vOff = j * oldWeightMapSize;

                    for (var v = 0; v < info.weightMapSize; ++v) {
                      for (var u = 0; u < info.weightMapSize; ++u) {
                        var _w = void 0;

                        if (info.weightMapSize === oldWeightMapSize) {
                          _w = getOldWeight(u + uOff, v + vOff, this._weights);
                        } else {
                          var x = u / (info.weightMapSize - 1) * (oldWeightMapSize - 1);
                          var y = v / (info.weightMapSize - 1) * (oldWeightMapSize - 1);
                          _w = sampleOldWeight(x, y, uOff, vOff, this._weights);
                        }

                        var du = _i17 * info.weightMapSize + u;
                        var dv = j * info.weightMapSize + v;
                        var index = dv * weightMapComplexityU + du;
                        weights[index * 4 + 0] = _w.x * 255;
                        weights[index * 4 + 1] = _w.y * 255;
                        weights[index * 4 + 2] = _w.z * 255;
                        weights[index * 4 + 3] = _w.w * 255;
                      }
                    }
                  }
                }

                this._weights = weights;
                return true;
              };

              _createClass(Terrain, [{
                key: "_asset",
                get: function get() {
                  return this.__asset;
                },
                set: function set(value) {
                  this.__asset = value;

                  if (this._buitinAsset !== this.__asset) {
                    this._buitinAsset = this.__asset;

                    for (var i = 0; i < this._blocks.length; ++i) {
                      this._blocks[i].destroy();
                    }

                    this._blocks = [];

                    if (this.__asset === null) {
                      this._effectAsset = null;
                      this._lightmapInfos = [];
                      this._receiveShadow = false;
                      this._useNormalmap = false;
                      this._usePBR = false;
                      this._tileSize = 1;
                      this._blockCount = [1, 1];
                      this._weightMapSize = 128;
                      this._lightMapSize = 128;
                      this._heights = new Uint16Array();
                      this._weights = new Uint8Array();
                      this._normals = new Float32Array();
                      this._layerBuffer = [];
                      this._blocks = [];
                      this._layerList = [];

                      for (var _i18 = 0; _i18 < TERRAIN_MAX_LAYER_COUNT; ++_i18) {
                        this._layerList.push(null);
                      }
                    }

                    if (deviceManager.gfxDevice) {
                      this._buildImp();
                    }
                  }
                }
              }, {
                key: "effectAsset",
                get: function get() {
                  return this._effectAsset;
                },
                set: function set(value) {
                  if (this._effectAsset === value) {
                    return;
                  }

                  this._effectAsset = value;

                  for (var i = 0; i < this._blocks.length; ++i) {
                    this._blocks[i]._invalidMaterial();
                  }
                }
              }, {
                key: "receiveShadow",
                get: function get() {
                  return this._receiveShadow;
                },
                set: function set(val) {
                  this._receiveShadow = val;

                  for (var i = 0; i < this._blocks.length; i++) {
                    this._blocks[i]._invalidMaterial();
                  }
                }
              }, {
                key: "useNormalMap",
                get: function get() {
                  return this._useNormalmap;
                },
                set: function set(val) {
                  this._useNormalmap = val;

                  for (var i = 0; i < this._blocks.length; i++) {
                    this._blocks[i]._invalidMaterial();
                  }
                }
              }, {
                key: "usePBR",
                get: function get() {
                  return this._usePBR;
                },
                set: function set(val) {
                  this._usePBR = val;

                  for (var i = 0; i < this._blocks.length; i++) {
                    this._blocks[i]._invalidMaterial();
                  }
                }
              }, {
                key: "lodEnable",
                get: function get() {
                  return this._lodEnable;
                },
                set: function set(val) {
                  this._lodEnable = val;

                  if (this._lodEnable && this._lod === null) {
                    this._lod = new TerrainLod();

                    if (this._sharedLodIndexBuffer === null) {
                      this._sharedLodIndexBuffer = this._createSharedIndexBuffer();
                    }

                    for (var i = 0; i < this._blocks.length; ++i) {
                      this._blocks[i].destroy();
                    }

                    this._blocks = [];

                    for (var j = 0; j < this._blockCount[1]; ++j) {
                      for (var _i19 = 0; _i19 < this._blockCount[0]; ++_i19) {
                        this._blocks.push(new TerrainBlock(this, _i19, j));
                      }
                    }

                    for (var _i20 = 0; _i20 < this._blocks.length; ++_i20) {
                      this._blocks[_i20].build();
                    }
                  }

                  if (!this._lodEnable) {
                    for (var _i21 = 0; _i21 < this._blocks.length; _i21++) {
                      this._blocks[_i21]._resetLod();
                    }
                  }
                }
              }, {
                key: "LodBias",
                get: function get() {
                  return this._lodBias;
                },
                set: function set(val) {
                  this._lodBias = val;
                }
              }, {
                key: "size",
                get: function get() {
                  var sz = new Size$1(0, 0);
                  sz.width = this.blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY * this.tileSize;
                  sz.height = this.blockCount[1] * TERRAIN_BLOCK_TILE_COMPLEXITY * this.tileSize;
                  return sz;
                }
              }, {
                key: "tileSize",
                get: function get() {
                  return this._tileSize;
                }
              }, {
                key: "tileCount",
                get: function get() {
                  return [this.blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY, this.blockCount[1] * TERRAIN_BLOCK_TILE_COMPLEXITY];
                }
              }, {
                key: "vertexCount",
                get: function get() {
                  var _vertexCount = this.tileCount;
                  _vertexCount[0] += 1;
                  _vertexCount[1] += 1;
                  return _vertexCount;
                }
              }, {
                key: "blockCount",
                get: function get() {
                  return this._blockCount;
                }
              }, {
                key: "lightMapSize",
                get: function get() {
                  return this._lightMapSize;
                }
              }, {
                key: "weightMapSize",
                get: function get() {
                  return this._weightMapSize;
                }
              }, {
                key: "heights",
                get: function get() {
                  return this._heights;
                }
              }, {
                key: "weights",
                get: function get() {
                  return this._weights;
                }
              }, {
                key: "valid",
                get: function get() {
                  return this._blocks.length > 0;
                }
              }, {
                key: "info",
                get: function get() {
                  var ti = new TerrainInfo();
                  ti.tileSize = this.tileSize;
                  ti.blockCount[0] = this.blockCount[0];
                  ti.blockCount[1] = this.blockCount[1];
                  ti.weightMapSize = this.weightMapSize;
                  ti.lightMapSize = this.lightMapSize;
                  return ti;
                }
              }]);

              return Terrain;
            }(Component), (_initializer15$9 = applyDecoratedInitializer(_class11$4.prototype, "__asset", [_dec5$y, serializable$j], function () {
              return null;
            }), _initializer16$9 = applyDecoratedInitializer(_class11$4.prototype, "_effectAsset", [_dec6$r, serializable$j], function () {
              return null;
            }), _initializer17$8 = applyDecoratedInitializer(_class11$4.prototype, "_lightmapInfos", [_dec7$k, serializable$j], function () {
              return [];
            }), _initializer18$7 = applyDecoratedInitializer(_class11$4.prototype, "_receiveShadow", [serializable$j], function () {
              return false;
            }), _initializer19$7 = applyDecoratedInitializer(_class11$4.prototype, "_useNormalmap", [serializable$j], function () {
              return false;
            }), _initializer20$5 = applyDecoratedInitializer(_class11$4.prototype, "_usePBR", [serializable$j], function () {
              return false;
            }), _initializer21$4 = applyDecoratedInitializer(_class11$4.prototype, "_lodEnable", [serializable$j], function () {
              return false;
            }), _initializer22$4 = applyDecoratedInitializer(_class11$4.prototype, "_lodBias", [_dec8$e, serializable$j], function () {
              return 0;
            }), _applyDecoratedDescriptor(_class11$4.prototype, "_asset", [_dec9$c], Object.getOwnPropertyDescriptor(_class11$4.prototype, "_asset"), _class11$4.prototype), _applyDecoratedDescriptor(_class11$4.prototype, "effectAsset", [_dec10$6], Object.getOwnPropertyDescriptor(_class11$4.prototype, "effectAsset"), _class11$4.prototype), _applyDecoratedDescriptor(_class11$4.prototype, "info", [_dec11$4], Object.getOwnPropertyDescriptor(_class11$4.prototype, "info"), _class11$4.prototype)), _class11$4)) || _class10$2) || _class10$2));

            var Action = function () {
              function Action() {
                this.originalTarget = null;
                this.target = null;
                this.tag = Action.TAG_INVALID;
              }

              var _proto = Action.prototype;

              _proto.clone = function clone() {
                var action = new Action();
                action.originalTarget = null;
                action.target = null;
                action.tag = this.tag;
                return action;
              };

              _proto.isDone = function isDone() {
                return true;
              };

              _proto.startWithTarget = function startWithTarget(target) {
                this.originalTarget = target;
                this.target = target;
              };

              _proto.stop = function stop() {
                this.target = null;
              };

              _proto.step = function step(dt) {
                logID(1006);
              };

              _proto.update = function update(dt) {
                logID(1007);
              };

              _proto.getTarget = function getTarget() {
                return this.target;
              };

              _proto.setTarget = function setTarget(target) {
                this.target = target;
              };

              _proto.getOriginalTarget = function getOriginalTarget() {
                return this.originalTarget;
              };

              _proto.setOriginalTarget = function setOriginalTarget(originalTarget) {
                this.originalTarget = originalTarget;
              };

              _proto.getTag = function getTag() {
                return this.tag;
              };

              _proto.setTag = function setTag(tag) {
                this.tag = tag;
              };

              _proto.reverse = function reverse() {
                logID(1008);
                return null;
              };

              _proto.retain = function retain() {};

              _proto.release = function release() {};

              return Action;
            }();
            Action.TAG_INVALID = -1;
            var FiniteTimeAction = function (_Action) {
              _inheritsLoose(FiniteTimeAction, _Action);

              function FiniteTimeAction() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Action.call.apply(_Action, [this].concat(args)) || this;
                _this._duration = 0;
                _this._timesForRepeat = 1;
                return _this;
              }

              var _proto2 = FiniteTimeAction.prototype;

              _proto2.getDuration = function getDuration() {
                return this._duration * (this._timesForRepeat || 1);
              };

              _proto2.setDuration = function setDuration(duration) {
                this._duration = duration;
              };

              _proto2.clone = function clone() {
                return new FiniteTimeAction();
              };

              return FiniteTimeAction;
            }(Action);
            var Speed = function (_Action2) {
              _inheritsLoose(Speed, _Action2);

              function Speed(action, speed) {
                var _this2;

                if (speed === void 0) {
                  speed = 1;
                }

                _this2 = _Action2.call(this) || this;
                _this2._speed = 0;
                _this2._innerAction = null;
                action && _this2.initWithAction(action, speed);
                return _this2;
              }

              var _proto3 = Speed.prototype;

              _proto3.getSpeed = function getSpeed() {
                return this._speed;
              };

              _proto3.setSpeed = function setSpeed(speed) {
                this._speed = speed;
              };

              _proto3.initWithAction = function initWithAction(action, speed) {
                if (!action) {
                  errorID(1021);
                  return false;
                }

                this._innerAction = action;
                this._speed = speed;
                return true;
              };

              _proto3.clone = function clone() {
                var action = new Speed();
                action.initWithAction(this._innerAction.clone(), this._speed);
                return action;
              };

              _proto3.startWithTarget = function startWithTarget(target) {
                Action.prototype.startWithTarget.call(this, target);

                this._innerAction.startWithTarget(target);
              };

              _proto3.stop = function stop() {
                this._innerAction.stop();

                Action.prototype.stop.call(this);
              };

              _proto3.step = function step(dt) {
                this._innerAction.step(dt * this._speed);
              };

              _proto3.isDone = function isDone() {
                return this._innerAction.isDone();
              };

              _proto3.reverse = function reverse() {
                return new Speed(this._innerAction.reverse(), this._speed);
              };

              _proto3.setInnerAction = function setInnerAction(action) {
                if (this._innerAction !== action) {
                  this._innerAction = action;
                }
              };

              _proto3.getInnerAction = function getInnerAction() {
                return this._innerAction;
              };

              return Speed;
            }(Action);

            var ID_COUNTER = 0;

            var HashElement = function HashElement() {
              this.actions = [];
              this.target = null;
              this.actionIndex = 0;
              this.currentAction = null;
              this.paused = false;
              this.lock = false;
            };

            var ActionManager = function () {
              function ActionManager() {
                this._hashTargets = new Map();
                this._arrayTargets = [];
                this._elementPool = [];
              }

              var _proto = ActionManager.prototype;

              _proto._searchElementByTarget = function _searchElementByTarget(arr, target) {
                for (var k = 0; k < arr.length; k++) {
                  if (target === arr[k].target) return arr[k];
                }

                return null;
              };

              _proto._getElement = function _getElement(target, paused) {
                var element = this._elementPool.pop();

                if (!element) {
                  element = new HashElement();
                }

                element.target = target;
                element.paused = !!paused;
                return element;
              };

              _proto._putElement = function _putElement(element) {
                element.actions.length = 0;
                element.actionIndex = 0;
                element.currentAction = null;
                element.paused = false;
                element.target = null;
                element.lock = false;

                this._elementPool.push(element);
              };

              _proto.addAction = function addAction(action, target, paused) {
                if (!action || !target) {
                  errorID(1000);
                  return;
                }

                if (target.uuid == null) {
                  target.uuid = "_TWEEN_UUID_" + ID_COUNTER++;
                }

                var element = this._hashTargets.get(target);

                if (!element) {
                  element = this._getElement(target, paused);

                  this._hashTargets.set(target, element);

                  this._arrayTargets.push(element);
                } else if (!element.actions) {
                  element.actions = [];
                }

                element.target = target;
                element.actions.push(action);
                action.startWithTarget(target);
              };

              _proto.removeAllActions = function removeAllActions() {
                var locTargets = this._arrayTargets;

                for (var i = 0; i < locTargets.length; i++) {
                  var element = locTargets[i];
                  if (element) this._putElement(element);
                }

                this._arrayTargets.length = 0;
                this._hashTargets = new Map();
              };

              _proto.removeAllActionsFromTarget = function removeAllActionsFromTarget(target) {
                if (target == null) return;

                var element = this._hashTargets.get(target);

                if (element) {
                  element.actions.length = 0;

                  this._deleteHashElement(element);
                }
              };

              _proto.removeAction = function removeAction(action) {
                if (action == null) return;
                var target = action.getOriginalTarget();

                var element = this._hashTargets.get(target);

                if (element) {
                  for (var i = 0; i < element.actions.length; i++) {
                    if (element.actions[i] === action) {
                      element.actions.splice(i, 1);
                      if (element.actionIndex >= i) element.actionIndex--;
                      break;
                    }
                  }
                }
              };

              _proto._removeActionByTag = function _removeActionByTag(tag, element, target) {
                for (var i = 0, l = element.actions.length; i < l; ++i) {
                  var action = element.actions[i];

                  if (action && action.getTag() === tag) {
                    if (target && action.getOriginalTarget() !== target) {
                      continue;
                    }

                    this._removeActionAtIndex(i, element);

                    break;
                  }
                }
              };

              _proto._removeAllActionsByTag = function _removeAllActionsByTag(tag, element, target) {
                for (var i = element.actions.length - 1; i >= 0; --i) {
                  var action = element.actions[i];

                  if (action && action.getTag() === tag) {
                    if (target && action.getOriginalTarget() !== target) {
                      continue;
                    }

                    this._removeActionAtIndex(i, element);
                  }
                }
              };

              _proto.removeActionByTag = function removeActionByTag(tag, target) {
                var _this = this;

                if (tag === Action.TAG_INVALID) logID(1002);
                var hashTargets = this._hashTargets;

                if (target) {
                  var element = hashTargets.get(target);

                  if (element) {
                    this._removeActionByTag(tag, element, target);
                  }
                } else {
                  hashTargets.forEach(function (element) {
                    _this._removeActionByTag(tag, element);
                  });
                }
              };

              _proto.removeAllActionsByTag = function removeAllActionsByTag(tag, target) {
                var _this2 = this;

                if (tag === Action.TAG_INVALID) logID(1002);
                var hashTargets = this._hashTargets;

                if (target) {
                  var element = hashTargets.get(target);

                  if (element) {
                    this._removeAllActionsByTag(tag, element, target);
                  }
                } else {
                  hashTargets.forEach(function (element) {
                    _this2._removeAllActionsByTag(tag, element);
                  });
                }
              };

              _proto.getActionByTag = function getActionByTag(tag, target) {
                if (tag === Action.TAG_INVALID) logID(1004);

                var element = this._hashTargets.get(target);

                if (element) {
                  if (element.actions != null) {
                    for (var i = 0; i < element.actions.length; ++i) {
                      var action = element.actions[i];

                      if (action && action.getTag() === tag) {
                        return action;
                      }
                    }
                  }

                  logID(1005, tag);
                }

                return null;
              };

              _proto.getNumberOfRunningActionsInTarget = function getNumberOfRunningActionsInTarget(target) {
                var element = this._hashTargets.get(target);

                if (element) {
                  return element.actions ? element.actions.length : 0;
                }

                return 0;
              };

              _proto.pauseTarget = function pauseTarget(target) {
                var element = this._hashTargets.get(target);

                if (element) element.paused = true;
              };

              _proto.resumeTarget = function resumeTarget(target) {
                var element = this._hashTargets.get(target);

                if (element) element.paused = false;
              };

              _proto.pauseAllRunningActions = function pauseAllRunningActions() {
                var idsWithActions = [];
                var locTargets = this._arrayTargets;

                for (var i = 0; i < locTargets.length; i++) {
                  var element = locTargets[i];

                  if (element && !element.paused) {
                    element.paused = true;
                    idsWithActions.push(element.target);
                  }
                }

                return idsWithActions;
              };

              _proto.resumeTargets = function resumeTargets(targetsToResume) {
                if (!targetsToResume) return;

                for (var i = 0; i < targetsToResume.length; i++) {
                  if (targetsToResume[i]) this.resumeTarget(targetsToResume[i]);
                }
              };

              _proto.pauseTargets = function pauseTargets(targetsToPause) {
                if (!targetsToPause) return;

                for (var i = 0; i < targetsToPause.length; i++) {
                  if (targetsToPause[i]) this.pauseTarget(targetsToPause[i]);
                }
              };

              _proto.purgeSharedManager = function purgeSharedManager() {
                legacyCC.director.getScheduler().unscheduleUpdate(this);
              };

              _proto._removeActionAtIndex = function _removeActionAtIndex(index, element) {
                var action = element.actions[index];
                element.actions.splice(index, 1);
                if (element.actionIndex >= index) element.actionIndex--;

                if (element.actions.length === 0) {
                  this._deleteHashElement(element);
                }
              };

              _proto._deleteHashElement = function _deleteHashElement(element) {
                var ret = false;

                if (element && !element.lock) {
                  if (this._hashTargets.get(element.target)) {
                    this._hashTargets["delete"](element.target);

                    var targets = this._arrayTargets;

                    for (var i = 0, l = targets.length; i < l; i++) {
                      if (targets[i] === element) {
                        targets.splice(i, 1);
                        break;
                      }
                    }

                    this._putElement(element);

                    ret = true;
                  }
                }

                return ret;
              };

              _proto.update = function update(dt) {
                var locTargets = this._arrayTargets;
                var locCurrTarget;

                for (var elt = 0; elt < locTargets.length; elt++) {
                  this._currentTarget = locTargets[elt];
                  locCurrTarget = this._currentTarget;
                  var target = locCurrTarget.target;

                  if (isCCObject(target) && !target.isValid) {
                    this.removeAllActionsFromTarget(target);
                    elt--;
                    continue;
                  }

                  if (!locCurrTarget.paused && locCurrTarget.actions) {
                    locCurrTarget.lock = true;

                    for (locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < locCurrTarget.actions.length; locCurrTarget.actionIndex++) {
                      locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex];
                      if (!locCurrTarget.currentAction) continue;
                      locCurrTarget.currentAction.step(dt * (locCurrTarget.currentAction._speedMethod ? locCurrTarget.currentAction._speed : 1));

                      if (locCurrTarget.currentAction && locCurrTarget.currentAction.isDone()) {
                        locCurrTarget.currentAction.stop();
                        var action = locCurrTarget.currentAction;
                        locCurrTarget.currentAction = null;
                        this.removeAction(action);
                      }

                      locCurrTarget.currentAction = null;
                    }

                    locCurrTarget.lock = false;
                  }

                  if (locCurrTarget.actions.length === 0) {
                    if (this._deleteHashElement(locCurrTarget)) {
                      elt--;
                    }
                  }
                }
              };

              return ActionManager;
            }();

            var TweenSystem = exports('TweenSystem', function (_System) {
              _inheritsLoose(TweenSystem, _System);

              function TweenSystem() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _System.call.apply(_System, [this].concat(args)) || this;
                _this.actionMgr = new ActionManager();
                return _this;
              }

              var _proto = TweenSystem.prototype;

              _proto.update = function update(dt) {
                {
                  this.actionMgr.update(dt);
                }
              };

              _createClass(TweenSystem, [{
                key: "ActionManager",
                get: function get() {
                  return this.actionMgr;
                }
              }]);

              return TweenSystem;
            }(System));
            TweenSystem.ID = 'TWEEN';
            TweenSystem.instance = void 0;
            director.on(Director.EVENT_INIT, function () {
              var sys = new TweenSystem();
              TweenSystem.instance = sys;
              director.registerSystem(TweenSystem.ID, sys, System.Priority.MEDIUM);
            });

            var ActionInstant = function (_FiniteTimeAction) {
              _inheritsLoose(ActionInstant, _FiniteTimeAction);

              function ActionInstant() {
                return _FiniteTimeAction.apply(this, arguments) || this;
              }

              var _proto = ActionInstant.prototype;

              _proto.isDone = function isDone() {
                return true;
              };

              _proto.step = function step(dt) {
                this.update(1);
              };

              _proto.update = function update(dt) {};

              _proto.reverse = function reverse() {
                return this.clone();
              };

              _proto.clone = function clone() {
                return new ActionInstant();
              };

              return ActionInstant;
            }(FiniteTimeAction);
            var Show = function (_ActionInstant) {
              _inheritsLoose(Show, _ActionInstant);

              function Show() {
                return _ActionInstant.apply(this, arguments) || this;
              }

              var _proto2 = Show.prototype;

              _proto2.update = function update(dt) {
                var _renderComps = this.target.getComponentsInChildren(Renderer);

                for (var i = 0; i < _renderComps.length; ++i) {
                  var render = _renderComps[i];
                  render.enabled = true;
                }
              };

              _proto2.reverse = function reverse() {
                return new Hide();
              };

              _proto2.clone = function clone() {
                return new Show();
              };

              return Show;
            }(ActionInstant);
            function show() {
              return new Show();
            }
            var Hide = function (_ActionInstant2) {
              _inheritsLoose(Hide, _ActionInstant2);

              function Hide() {
                return _ActionInstant2.apply(this, arguments) || this;
              }

              var _proto3 = Hide.prototype;

              _proto3.update = function update(dt) {
                var _renderComps = this.target.getComponentsInChildren(Renderer);

                for (var i = 0; i < _renderComps.length; ++i) {
                  var render = _renderComps[i];
                  render.enabled = false;
                }
              };

              _proto3.reverse = function reverse() {
                return new Show();
              };

              _proto3.clone = function clone() {
                return new Hide();
              };

              return Hide;
            }(ActionInstant);
            function hide() {
              return new Hide();
            }
            var ToggleVisibility = function (_ActionInstant3) {
              _inheritsLoose(ToggleVisibility, _ActionInstant3);

              function ToggleVisibility() {
                return _ActionInstant3.apply(this, arguments) || this;
              }

              var _proto4 = ToggleVisibility.prototype;

              _proto4.update = function update(dt) {
                var _renderComps = this.target.getComponentsInChildren(Renderer);

                for (var i = 0; i < _renderComps.length; ++i) {
                  var render = _renderComps[i];
                  render.enabled = !render.enabled;
                }
              };

              _proto4.reverse = function reverse() {
                return new ToggleVisibility();
              };

              _proto4.clone = function clone() {
                return new ToggleVisibility();
              };

              return ToggleVisibility;
            }(ActionInstant);
            var RemoveSelf = function (_ActionInstant4) {
              _inheritsLoose(RemoveSelf, _ActionInstant4);

              function RemoveSelf(isNeedCleanUp) {
                var _this;

                _this = _ActionInstant4.call(this) || this;
                _this._isNeedCleanUp = true;
                isNeedCleanUp !== undefined && _this.init(isNeedCleanUp);
                return _this;
              }

              var _proto5 = RemoveSelf.prototype;

              _proto5.update = function update(dt) {
                this.target.removeFromParent();

                if (this._isNeedCleanUp) {
                  this.target.destroy();
                }
              };

              _proto5.init = function init(isNeedCleanUp) {
                this._isNeedCleanUp = isNeedCleanUp;
                return true;
              };

              _proto5.reverse = function reverse() {
                return new RemoveSelf(this._isNeedCleanUp);
              };

              _proto5.clone = function clone() {
                return new RemoveSelf(this._isNeedCleanUp);
              };

              return RemoveSelf;
            }(ActionInstant);
            function removeSelf(isNeedCleanUp) {
              return new RemoveSelf(isNeedCleanUp);
            }
            var CallFunc = function (_ActionInstant5) {
              _inheritsLoose(CallFunc, _ActionInstant5);

              function CallFunc(selector, selectorTarget, data) {
                var _this2;

                _this2 = _ActionInstant5.call(this) || this;
                _this2._selectorTarget = null;
                _this2._function = null;
                _this2._data = null;

                _this2.initWithFunction(selector, selectorTarget, data);

                return _this2;
              }

              var _proto6 = CallFunc.prototype;

              _proto6.initWithFunction = function initWithFunction(selector, selectorTarget, data) {
                if (selector) {
                  this._function = selector;
                }

                if (selectorTarget) {
                  this._selectorTarget = selectorTarget;
                }

                if (data !== undefined) {
                  this._data = data;
                }

                return true;
              };

              _proto6.execute = function execute() {
                if (this._function) {
                  this._function.call(this._selectorTarget, this.target, this._data);
                }
              };

              _proto6.update = function update(dt) {
                this.execute();
              };

              _proto6.getTargetCallback = function getTargetCallback() {
                return this._selectorTarget;
              };

              _proto6.setTargetCallback = function setTargetCallback(sel) {
                if (sel !== this._selectorTarget) {
                  if (this._selectorTarget) {
                    this._selectorTarget = null;
                  }

                  this._selectorTarget = sel;
                }
              };

              _proto6.clone = function clone() {
                var action = new CallFunc();
                action.initWithFunction(this._function, this._selectorTarget, this._data);
                return action;
              };

              return CallFunc;
            }(ActionInstant);
            function callFunc(selector, selectorTarget, data) {
              return new CallFunc(selector, selectorTarget, data);
            }

            var ActionInterval = function (_FiniteTimeAction) {
              _inheritsLoose(ActionInterval, _FiniteTimeAction);

              function ActionInterval(d) {
                var _this;

                _this = _FiniteTimeAction.call(this) || this;
                _this.MAX_VALUE = 2;
                _this._elapsed = 0;
                _this._firstTick = false;
                _this._easeList = [];
                _this._speed = 1;
                _this._repeatForever = false;
                _this._repeatMethod = false;
                _this._speedMethod = false;

                if (d !== undefined && !isNaN(d)) {
                  _this.initWithDuration(d);
                }

                return _this;
              }

              var _proto = ActionInterval.prototype;

              _proto.getElapsed = function getElapsed() {
                return this._elapsed;
              };

              _proto.initWithDuration = function initWithDuration(d) {
                this._duration = d === 0 ? macro.FLT_EPSILON : d;
                this._elapsed = 0;
                this._firstTick = true;
                return true;
              };

              _proto.isDone = function isDone() {
                return this._elapsed >= this._duration;
              };

              _proto._cloneDecoration = function _cloneDecoration(action) {
                action._repeatForever = this._repeatForever;
                action._speed = this._speed;
                action._timesForRepeat = this._timesForRepeat;
                action._easeList = this._easeList;
                action._speedMethod = this._speedMethod;
                action._repeatMethod = this._repeatMethod;
              };

              _proto._reverseEaseList = function _reverseEaseList(action) {
                if (this._easeList) {
                  action._easeList = [];

                  for (var i = 0; i < this._easeList.length; i++) {
                    action._easeList.push(this._easeList[i]);
                  }
                }
              };

              _proto.clone = function clone() {
                var action = new ActionInterval(this._duration);

                this._cloneDecoration(action);

                return action;
              };

              _proto.easing = function easing(easeObj) {
                if (this._easeList) this._easeList.length = 0;else this._easeList = [];

                for (var i = 0; i < arguments.length; i++) {
                  this._easeList.push(arguments[i]);
                }

                return this;
              };

              _proto._computeEaseTime = function _computeEaseTime(dt) {
                return dt;
              };

              _proto.step = function step(dt) {
                if (this._firstTick) {
                  this._firstTick = false;
                  this._elapsed = 0;
                } else this._elapsed += dt;

                var t = this._elapsed / (this._duration > 0.0000001192092896 ? this._duration : 0.0000001192092896);
                t = t < 1 ? t : 1;
                this.update(t > 0 ? t : 0);

                if (this._repeatMethod && this._timesForRepeat > 1 && this.isDone()) {
                  if (!this._repeatForever) {
                    this._timesForRepeat--;
                  }

                  this.startWithTarget(this.target);
                  this.step(this._elapsed - this._duration);
                }
              };

              _proto.startWithTarget = function startWithTarget(target) {
                Action.prototype.startWithTarget.call(this, target);
                this._elapsed = 0;
                this._firstTick = true;
              };

              _proto.reverse = function reverse() {
                logID(1010);
                return this;
              };

              _proto.setAmplitudeRate = function setAmplitudeRate(amp) {
                logID(1011);
              };

              _proto.getAmplitudeRate = function getAmplitudeRate() {
                logID(1012);
                return 0;
              };

              _proto.speed = function speed(_speed) {
                if (_speed <= 0) {
                  logID(1013);
                  return this;
                }

                this._speedMethod = true;
                this._speed *= _speed;
                return this;
              };

              _proto.getSpeed = function getSpeed() {
                return this._speed;
              };

              _proto.setSpeed = function setSpeed(speed) {
                this._speed = speed;
                return this;
              };

              _proto.repeat = function repeat(times) {
                times = Math.round(times);

                if (isNaN(times) || times < 1) {
                  logID(1014);
                  return this;
                }

                this._repeatMethod = true;
                this._timesForRepeat *= times;
                return this;
              };

              _proto.repeatForever = function repeatForever() {
                this._repeatMethod = true;
                this._timesForRepeat = this.MAX_VALUE;
                this._repeatForever = true;
                return this;
              };

              return ActionInterval;
            }(FiniteTimeAction);
            var Sequence = function (_ActionInterval) {
              _inheritsLoose(Sequence, _ActionInterval);

              function Sequence(tempArray) {
                var _this2;

                _this2 = _ActionInterval.call(this) || this;
                _this2._actions = [];
                _this2._split = 0;
                _this2._last = 0;
                _this2._reversed = false;
                var paramArray = tempArray instanceof Array ? tempArray : arguments;

                if (paramArray.length === 1) {
                  errorID(1019);
                  return _assertThisInitialized(_this2);
                }

                var last = paramArray.length - 1;
                if (last >= 0 && paramArray[last] == null) logID(1015);

                if (last >= 0) {
                  var prev = paramArray[0];
                  var action1;

                  for (var i = 1; i < last; i++) {
                    if (paramArray[i]) {
                      action1 = prev;
                      prev = Sequence._actionOneTwo(action1, paramArray[i]);
                    }
                  }

                  _this2.initWithTwoActions(prev, paramArray[last]);
                }

                return _this2;
              }

              var _proto2 = Sequence.prototype;

              _proto2.initWithTwoActions = function initWithTwoActions(actionOne, actionTwo) {
                if (!actionOne || !actionTwo) {
                  errorID(1025);
                  return false;
                }

                var durationOne = actionOne._duration;
                var durationTwo = actionTwo._duration;
                durationOne *= actionOne._repeatMethod ? actionOne._timesForRepeat : 1;
                durationTwo *= actionTwo._repeatMethod ? actionTwo._timesForRepeat : 1;
                var d = durationOne + durationTwo;
                this.initWithDuration(d);
                this._actions[0] = actionOne;
                this._actions[1] = actionTwo;
                return true;
              };

              _proto2.clone = function clone() {
                var action = new Sequence();

                this._cloneDecoration(action);

                action.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
                return action;
              };

              _proto2.startWithTarget = function startWithTarget(target) {
                ActionInterval.prototype.startWithTarget.call(this, target);
                this._split = this._actions[0]._duration / this._duration;
                this._split *= this._actions[0]._repeatMethod ? this._actions[0]._timesForRepeat : 1;
                this._last = -1;
              };

              _proto2.stop = function stop() {
                if (this._last !== -1) this._actions[this._last].stop();
                Action.prototype.stop.call(this);
              };

              _proto2.update = function update(dt) {
                var new_t;
                var found = 0;
                var locSplit = this._split;
                var locActions = this._actions;
                var locLast = this._last;
                var actionFound;
                dt = this._computeEaseTime(dt);

                if (dt < locSplit) {
                  new_t = locSplit !== 0 ? dt / locSplit : 1;

                  if (found === 0 && locLast === 1 && this._reversed) {
                    locActions[1].update(0);
                    locActions[1].stop();
                  }
                } else {
                  found = 1;
                  new_t = locSplit === 1 ? 1 : (dt - locSplit) / (1 - locSplit);

                  if (locLast === -1) {
                    locActions[0].startWithTarget(this.target);
                    locActions[0].update(1);
                    locActions[0].stop();
                  }

                  if (locLast === 0) {
                    locActions[0].update(1);
                    locActions[0].stop();
                  }
                }

                actionFound = locActions[found];
                if (locLast === found && actionFound.isDone()) return;
                if (locLast !== found) actionFound.startWithTarget(this.target);
                new_t *= actionFound._timesForRepeat;
                actionFound.update(new_t > 1 ? new_t % 1 : new_t);
                this._last = found;
              };

              _proto2.reverse = function reverse() {
                var action = Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());

                this._cloneDecoration(action);

                this._reverseEaseList(action);

                action._reversed = true;
                return action;
              };

              return Sequence;
            }(ActionInterval);

            Sequence._actionOneTwo = function (actionOne, actionTwo) {
              var sequence = new Sequence();
              sequence.initWithTwoActions(actionOne, actionTwo);
              return sequence;
            };

            function sequence(tempArray) {
              var paramArray = tempArray instanceof Array ? tempArray : arguments;

              if (paramArray.length === 1) {
                errorID(1019);
                return null;
              }

              var last = paramArray.length - 1;
              if (last >= 0 && paramArray[last] == null) logID(1015);
              var result = null;

              if (last >= 0) {
                result = paramArray[0];

                for (var i = 1; i <= last; i++) {
                  if (paramArray[i]) {
                    result = Sequence._actionOneTwo(result, paramArray[i]);
                  }
                }
              }

              return result;
            }
            var Repeat = function (_ActionInterval2) {
              _inheritsLoose(Repeat, _ActionInterval2);

              function Repeat(action, times) {
                var _this3;

                _this3 = _ActionInterval2.call(this) || this;
                _this3._times = 0;
                _this3._total = 0;
                _this3._nextDt = 0;
                _this3._actionInstant = false;
                _this3._innerAction = null;
                times !== undefined && _this3.initWithAction(action, times);
                return _this3;
              }

              var _proto3 = Repeat.prototype;

              _proto3.initWithAction = function initWithAction(action, times) {
                var duration = action._duration * times;

                if (this.initWithDuration(duration)) {
                  this._times = times;
                  this._innerAction = action;

                  if (action instanceof ActionInstant) {
                    this._actionInstant = true;
                    this._times -= 1;
                  }

                  this._total = 0;
                  return true;
                }

                return false;
              };

              _proto3.clone = function clone() {
                var action = new Repeat();

                this._cloneDecoration(action);

                action.initWithAction(this._innerAction.clone(), this._times);
                return action;
              };

              _proto3.startWithTarget = function startWithTarget(target) {
                this._total = 0;
                this._nextDt = this._innerAction._duration / this._duration;
                ActionInterval.prototype.startWithTarget.call(this, target);

                this._innerAction.startWithTarget(target);
              };

              _proto3.stop = function stop() {
                this._innerAction.stop();

                Action.prototype.stop.call(this);
              };

              _proto3.update = function update(dt) {
                dt = this._computeEaseTime(dt);
                var locInnerAction = this._innerAction;
                var locDuration = this._duration;
                var locTimes = this._times;
                var locNextDt = this._nextDt;

                if (dt >= locNextDt) {
                  while (dt > locNextDt && this._total < locTimes) {
                    locInnerAction.update(1);
                    this._total++;
                    locInnerAction.stop();
                    locInnerAction.startWithTarget(this.target);
                    locNextDt += locInnerAction._duration / locDuration;
                    this._nextDt = locNextDt > 1 ? 1 : locNextDt;
                  }

                  if (dt >= 1.0 && this._total < locTimes) {
                    locInnerAction.update(1);
                    this._total++;
                  }

                  if (!this._actionInstant) {
                    if (this._total === locTimes) {
                      locInnerAction.stop();
                    } else {
                      locInnerAction.update(dt - (locNextDt - locInnerAction._duration / locDuration));
                    }
                  }
                } else {
                  locInnerAction.update(dt * locTimes % 1.0);
                }
              };

              _proto3.isDone = function isDone() {
                return this._total === this._times;
              };

              _proto3.reverse = function reverse() {
                var action = new Repeat(this._innerAction.reverse(), this._times);

                this._cloneDecoration(action);

                this._reverseEaseList(action);

                return action;
              };

              _proto3.setInnerAction = function setInnerAction(action) {
                if (this._innerAction !== action) {
                  this._innerAction = action;
                }
              };

              _proto3.getInnerAction = function getInnerAction() {
                return this._innerAction;
              };

              return Repeat;
            }(ActionInterval);
            function repeat$1(action, times) {
              return new Repeat(action, times);
            }
            var RepeatForever = function (_ActionInterval3) {
              _inheritsLoose(RepeatForever, _ActionInterval3);

              function RepeatForever(action) {
                var _this4;

                _this4 = _ActionInterval3.call(this) || this;
                _this4._innerAction = null;
                action && _this4.initWithAction(action);
                return _this4;
              }

              var _proto4 = RepeatForever.prototype;

              _proto4.initWithAction = function initWithAction(action) {
                if (!action) {
                  errorID(1026);
                  return false;
                }

                this._innerAction = action;
                return true;
              };

              _proto4.clone = function clone() {
                var action = new RepeatForever();

                this._cloneDecoration(action);

                action.initWithAction(this._innerAction.clone());
                return action;
              };

              _proto4.startWithTarget = function startWithTarget(target) {
                ActionInterval.prototype.startWithTarget.call(this, target);

                this._innerAction.startWithTarget(target);
              };

              _proto4.step = function step(dt) {
                var locInnerAction = this._innerAction;
                locInnerAction.step(dt);

                if (locInnerAction.isDone()) {
                  locInnerAction.startWithTarget(this.target);
                  locInnerAction.step(locInnerAction.getElapsed() - locInnerAction._duration);
                }
              };

              _proto4.isDone = function isDone() {
                return false;
              };

              _proto4.reverse = function reverse() {
                var action = new RepeatForever(this._innerAction.reverse());

                this._cloneDecoration(action);

                this._reverseEaseList(action);

                return action;
              };

              _proto4.setInnerAction = function setInnerAction(action) {
                if (this._innerAction !== action) {
                  this._innerAction = action;
                }
              };

              _proto4.getInnerAction = function getInnerAction() {
                return this._innerAction;
              };

              return RepeatForever;
            }(ActionInterval);
            function repeatForever(action) {
              return new RepeatForever(action);
            }
            var Spawn = function (_ActionInterval4) {
              _inheritsLoose(Spawn, _ActionInterval4);

              function Spawn(tempArray) {
                var _this5;

                _this5 = _ActionInterval4.call(this) || this;
                _this5._one = null;
                _this5._two = null;
                var paramArray = tempArray instanceof Array ? tempArray : arguments;

                if (paramArray.length === 1) {
                  errorID(1020);
                  return _assertThisInitialized(_this5);
                }

                var last = paramArray.length - 1;
                if (last >= 0 && paramArray[last] == null) logID(1015);

                if (last >= 0) {
                  var prev = paramArray[0];
                  var action1;

                  for (var i = 1; i < last; i++) {
                    if (paramArray[i]) {
                      action1 = prev;
                      prev = Spawn._actionOneTwo(action1, paramArray[i]);
                    }
                  }

                  _this5.initWithTwoActions(prev, paramArray[last]);
                }

                return _this5;
              }

              var _proto5 = Spawn.prototype;

              _proto5.initWithTwoActions = function initWithTwoActions(action1, action2) {
                if (!action1 || !action2) {
                  errorID(1027);
                  return false;
                }

                var ret = false;
                var d1 = action1._duration;
                var d2 = action2._duration;

                if (this.initWithDuration(Math.max(d1, d2))) {
                  this._one = action1;
                  this._two = action2;

                  if (d1 > d2) {
                    this._two = Sequence._actionOneTwo(action2, delayTime(d1 - d2));
                  } else if (d1 < d2) {
                    this._one = Sequence._actionOneTwo(action1, delayTime(d2 - d1));
                  }

                  ret = true;
                }

                return ret;
              };

              _proto5.clone = function clone() {
                var action = new Spawn();

                this._cloneDecoration(action);

                action.initWithTwoActions(this._one.clone(), this._two.clone());
                return action;
              };

              _proto5.startWithTarget = function startWithTarget(target) {
                ActionInterval.prototype.startWithTarget.call(this, target);

                this._one.startWithTarget(target);

                this._two.startWithTarget(target);
              };

              _proto5.stop = function stop() {
                this._one.stop();

                this._two.stop();

                Action.prototype.stop.call(this);
              };

              _proto5.update = function update(dt) {
                dt = this._computeEaseTime(dt);
                if (this._one) this._one.update(dt);
                if (this._two) this._two.update(dt);
              };

              _proto5.reverse = function reverse() {
                var action = Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());

                this._cloneDecoration(action);

                this._reverseEaseList(action);

                return action;
              };

              return Spawn;
            }(ActionInterval);

            Spawn._actionOneTwo = function (action1, action2) {
              var pSpawn = new Spawn();
              pSpawn.initWithTwoActions(action1, action2);
              return pSpawn;
            };

            function spawn(tempArray) {
              var paramArray = tempArray instanceof Array ? tempArray : arguments;

              if (paramArray.length === 1) {
                errorID(1020);
                return null;
              }

              if (paramArray.length > 0 && paramArray[paramArray.length - 1] == null) logID(1015);
              var prev = paramArray[0];

              for (var i = 1; i < paramArray.length; i++) {
                if (paramArray[i] != null) prev = Spawn._actionOneTwo(prev, paramArray[i]);
              }

              return prev;
            }

            var DelayTime = function (_ActionInterval5) {
              _inheritsLoose(DelayTime, _ActionInterval5);

              function DelayTime() {
                return _ActionInterval5.apply(this, arguments) || this;
              }

              var _proto6 = DelayTime.prototype;

              _proto6.update = function update(dt) {};

              _proto6.reverse = function reverse() {
                var action = new DelayTime(this._duration);

                this._cloneDecoration(action);

                this._reverseEaseList(action);

                return action;
              };

              _proto6.clone = function clone() {
                var action = new DelayTime();

                this._cloneDecoration(action);

                action.initWithDuration(this._duration);
                return action;
              };

              return DelayTime;
            }(ActionInterval);

            function delayTime(d) {
              return new DelayTime(d);
            }
            var ReverseTime = function (_ActionInterval6) {
              _inheritsLoose(ReverseTime, _ActionInterval6);

              function ReverseTime(action) {
                var _this6;

                _this6 = _ActionInterval6.call(this) || this;
                _this6._other = null;
                action && _this6.initWithAction(action);
                return _this6;
              }

              var _proto7 = ReverseTime.prototype;

              _proto7.initWithAction = function initWithAction(action) {
                if (!action) {
                  errorID(1028);
                  return false;
                }

                if (action === this._other) {
                  errorID(1029);
                  return false;
                }

                if (ActionInterval.prototype.initWithDuration.call(this, action._duration)) {
                  this._other = action;
                  return true;
                }

                return false;
              };

              _proto7.clone = function clone() {
                var action = new ReverseTime();

                this._cloneDecoration(action);

                action.initWithAction(this._other.clone());
                return action;
              };

              _proto7.startWithTarget = function startWithTarget(target) {
                ActionInterval.prototype.startWithTarget.call(this, target);

                this._other.startWithTarget(target);
              };

              _proto7.update = function update(dt) {
                dt = this._computeEaseTime(dt);
                if (this._other) this._other.update(1 - dt);
              };

              _proto7.reverse = function reverse() {
                return this._other.clone();
              };

              _proto7.stop = function stop() {
                this._other.stop();

                Action.prototype.stop.call(this);
              };

              return ReverseTime;
            }(ActionInterval);
            function reverseTime(action) {
              return new ReverseTime(action);
            }

            function TweenEasingAdapter(easingName) {
              var initialChar = easingName.charAt(0);

              if (/[A-Z]/.test(initialChar)) {
                easingName = easingName.replace(initialChar, initialChar.toLowerCase());
                var arr = easingName.split('-');

                if (arr.length === 2) {
                  var str0 = arr[0];

                  if (str0 === 'linear') {
                    easingName = 'linear';
                  } else {
                    var str1 = arr[1];

                    switch (str0) {
                      case 'quadratic':
                        easingName = "quad" + str1;
                        break;

                      case 'quartic':
                        easingName = "quart" + str1;
                        break;

                      case 'quintic':
                        easingName = "quint" + str1;
                        break;

                      case 'sinusoidal':
                        easingName = "sine" + str1;
                        break;

                      case 'exponential':
                        easingName = "expo" + str1;
                        break;

                      case 'circular':
                        easingName = "circ" + str1;
                        break;

                      default:
                        easingName = str0 + str1;
                        break;
                    }
                  }
                }
              }

              return easingName;
            }

            function TweenOptionChecker(opts) {
              var header = ' [Tween:] ';
              var message = " option is not support in v + " + engineVersion;
              var _opts = opts;

              if (_opts.delay) {
                warn(header + "delay" + message);
              }

              if (_opts.repeat) {
                warn(header + "repeat" + message);
              }

              if (_opts.repeatDelay) {
                warn(header + "repeatDelay" + message);
              }

              if (_opts.interpolation) {
                warn(header + "interpolation" + message);
              }

              if (_opts.onStop) {
                warn(header + "onStop" + message);
              }
            }

            var TweenAction = exports('TweenAction', function (_ActionInterval) {
              _inheritsLoose(TweenAction, _ActionInterval);

              function TweenAction(duration, props, opts) {
                var _this;

                _this = _ActionInterval.call(this) || this;
                _this._opts = void 0;
                _this._props = void 0;
                _this._originProps = void 0;

                if (opts == null) {
                  opts = Object.create(null);
                } else {
                  TweenOptionChecker(opts);

                  if (opts.easing && typeof opts.easing === 'string') {
                    opts.easing = TweenEasingAdapter(opts.easing);
                  }

                  if (!opts.progress) {
                    opts.progress = _this.progress;
                  }

                  if (opts.easing && typeof opts.easing === 'string') {
                    var easingName = opts.easing;
                    opts.easing = easing[easingName];

                    if (!opts.easing) {
                      warnID(1031, easingName);
                    }
                  }
                }

                _this._opts = opts;
                _this._props = Object.create(null);

                for (var name in props) {
                  if (!props.hasOwnProperty(name)) continue;
                  var value = props[name];

                  if (typeof value === 'function') {
                    value = value();
                  }

                  if (value == null || typeof value === 'string') continue;
                  var customEasing = void 0;
                  var progress = void 0;

                  if (value.value !== undefined && (value.easing || value.progress)) {
                    if (typeof value.easing === 'string') {
                      customEasing = easing[value.easing];
                      if (!customEasing) warnID(1031, value.easing);
                    } else {
                      customEasing = value.easing;
                    }

                    progress = value.progress;
                    value = value.value;
                  }

                  var prop = Object.create(null);
                  prop.value = value;
                  prop.easing = customEasing;
                  prop.progress = progress;
                  _this._props[name] = prop;
                }

                _this._originProps = props;

                _this.initWithDuration(duration);

                return _this;
              }

              var _proto = TweenAction.prototype;

              _proto.clone = function clone() {
                var action = new TweenAction(this._duration, this._originProps, this._opts);

                this._cloneDecoration(action);

                return action;
              };

              _proto.startWithTarget = function startWithTarget(target) {
                ActionInterval.prototype.startWithTarget.call(this, target);
                var relative = !!this._opts.relative;
                var props = this._props;

                for (var property in props) {
                  var _t = target[property];

                  if (_t === undefined) {
                    continue;
                  }

                  var prop = props[property];
                  var value = prop.value;

                  if (typeof _t === 'number') {
                    prop.start = _t;
                    prop.current = _t;
                    prop.end = relative ? _t + value : value;
                  } else if (typeof _t === 'object') {
                    if (prop.start == null) {
                      prop.start = {};
                      prop.current = {};
                      prop.end = {};
                    }

                    for (var k in value) {
                      if (isNaN(_t[k])) continue;
                      prop.start[k] = _t[k];
                      prop.current[k] = _t[k];
                      prop.end[k] = relative ? _t[k] + value[k] : value[k];
                    }
                  }
                }

                if (this._opts.onStart) {
                  this._opts.onStart(this.target);
                }
              };

              _proto.update = function update(t) {
                var target = this.target;
                if (!target) return;
                var props = this._props;
                var opts = this._opts;
                var easingTime = t;
                if (opts.easing) easingTime = opts.easing(t);
                var progress = opts.progress;

                for (var name in props) {
                  var prop = props[name];
                  var time = prop.easing ? prop.easing(t) : easingTime;
                  var interpolation = prop.progress ? prop.progress : progress;
                  var start = prop.start;
                  var end = prop.end;

                  if (typeof start === 'number') {
                    prop.current = interpolation(start, end, prop.current, time);
                  } else if (typeof start === 'object') {
                    for (var k in start) {
                      prop.current[k] = interpolation(start[k], end[k], prop.current[k], time);
                    }
                  }

                  target[name] = prop.current;
                }

                if (opts.onUpdate) {
                  opts.onUpdate(this.target, t);
                }

                if (t === 1 && opts.onComplete) {
                  opts.onComplete(this.target);
                }
              };

              _proto.progress = function progress(start, end, current, t) {
                return current = start + (end - start) * t;
              };

              return TweenAction;
            }(ActionInterval));

            var SetAction = function (_ActionInstant) {
              _inheritsLoose(SetAction, _ActionInstant);

              function SetAction(props) {
                var _this;

                _this = _ActionInstant.call(this) || this;
                _this._props = void 0;
                _this._props = {};
                props !== undefined && _this.init(props);
                return _this;
              }

              var _proto = SetAction.prototype;

              _proto.init = function init(props) {
                for (var name in props) {
                  this._props[name] = props[name];
                }

                return true;
              };

              _proto.update = function update() {
                var props = this._props;
                var target = this.target;

                for (var name in props) {
                  target[name] = props[name];
                }
              };

              _proto.clone = function clone() {
                var action = new SetAction();
                action.init(this._props);
                return action;
              };

              return SetAction;
            }(ActionInstant);

            var Tween = exports('Tween', function () {
              function Tween(target) {
                this._actions = [];
                this._finalAction = null;
                this._target = null;
                this._tag = Action.TAG_INVALID;
                this._target = target === undefined ? null : target;
              }

              var _proto = Tween.prototype;

              _proto.tag = function tag(_tag) {
                this._tag = _tag;
                return this;
              };

              _proto.then = function then(other) {
                if (other instanceof Action) {
                  this._actions.push(other.clone());
                } else {
                  this._actions.push(other._union());
                }

                return this;
              };

              _proto.target = function target(_target) {
                this._target = _target;
                return this;
              };

              _proto.start = function start() {
                if (!this._target) {
                  warn('Please set target to tween first');
                  return this;
                }

                if (this._finalAction) {
                  TweenSystem.instance.ActionManager.removeAction(this._finalAction);
                }

                this._finalAction = this._union();

                this._finalAction.setTag(this._tag);

                TweenSystem.instance.ActionManager.addAction(this._finalAction, this._target, false);
                return this;
              };

              _proto.stop = function stop() {
                if (this._finalAction) {
                  TweenSystem.instance.ActionManager.removeAction(this._finalAction);
                }

                return this;
              };

              _proto.clone = function clone(target) {
                var action = this._union();

                return tween(target).then(action.clone());
              };

              _proto.union = function union() {
                var action = this._union();

                this._actions.length = 0;

                this._actions.push(action);

                return this;
              };

              _proto.to = function to(duration, props, opts) {
                opts = opts || Object.create(null);
                opts.relative = false;
                var action = new TweenAction(duration, props, opts);

                this._actions.push(action);

                return this;
              };

              _proto.by = function by(duration, props, opts) {
                opts = opts || Object.create(null);
                opts.relative = true;
                var action = new TweenAction(duration, props, opts);

                this._actions.push(action);

                return this;
              };

              _proto.set = function set(props) {
                var action = new SetAction(props);

                this._actions.push(action);

                return this;
              };

              _proto.delay = function delay(duration) {
                var action = delayTime(duration);

                this._actions.push(action);

                return this;
              };

              _proto.call = function call(callback) {
                var action = callFunc(callback);

                this._actions.push(action);

                return this;
              };

              _proto.sequence = function sequence() {
                var action = Tween._wrappedSequence.apply(Tween, arguments);

                this._actions.push(action);

                return this;
              };

              _proto.parallel = function parallel() {
                var action = Tween._wrappedParallel.apply(Tween, arguments);

                this._actions.push(action);

                return this;
              };

              _proto.repeat = function repeat(repeatTimes, embedTween) {
                if (repeatTimes === Infinity) {
                  return this.repeatForever(embedTween);
                }

                var actions = this._actions;
                var action;

                if (embedTween instanceof Tween) {
                  action = embedTween._union();
                } else {
                  action = actions.pop();
                }

                actions.push(repeat$1(action, repeatTimes));
                return this;
              };

              _proto.repeatForever = function repeatForever$1(embedTween) {
                var actions = this._actions;
                var action;

                if (embedTween instanceof Tween) {
                  action = embedTween._union();
                } else {
                  action = actions.pop();
                }

                actions.push(repeatForever(action));
                return this;
              };

              _proto.reverseTime = function reverseTime$1(embedTween) {
                var actions = this._actions;
                var action;

                if (embedTween instanceof Tween) {
                  action = embedTween._union();
                } else {
                  action = actions.pop();
                }

                actions.push(reverseTime(action));
                return this;
              };

              _proto.hide = function hide$1() {
                var action = hide();

                this._actions.push(action);

                return this;
              };

              _proto.show = function show$1() {
                var action = show();

                this._actions.push(action);

                return this;
              };

              _proto.removeSelf = function removeSelf$1() {
                var action = removeSelf(false);

                this._actions.push(action);

                return this;
              };

              _proto.destroySelf = function destroySelf() {
                var action = removeSelf(true);

                this._actions.push(action);

                return this;
              };

              Tween.stopAll = function stopAll() {
                TweenSystem.instance.ActionManager.removeAllActions();
              };

              Tween.stopAllByTag = function stopAllByTag(tag, target) {
                TweenSystem.instance.ActionManager.removeAllActionsByTag(tag, target);
              };

              Tween.stopAllByTarget = function stopAllByTarget(target) {
                TweenSystem.instance.ActionManager.removeAllActionsFromTarget(target);
              };

              _proto._union = function _union() {
                var actions = this._actions;
                var action;

                if (actions.length === 1) {
                  action = actions[0];
                } else {
                  action = sequence(actions);
                }

                return action;
              };

              _proto._destroy = function _destroy() {
                this.stop();
              };

              Tween._wrappedSequence = function _wrappedSequence() {
                var tmp_args = Tween._tmp_args;
                tmp_args.length = 0;

                for (var l = arguments.length, i = 0; i < l; i++) {
                  var arg = tmp_args[i] = i < 0 || arguments.length <= i ? undefined : arguments[i];

                  if (arg instanceof Tween) {
                    tmp_args[i] = arg._union();
                  }
                }

                return sequence.apply(sequence, tmp_args);
              };

              Tween._wrappedParallel = function _wrappedParallel() {
                var tmp_args = Tween._tmp_args;
                tmp_args.length = 0;

                for (var l = arguments.length, i = 0; i < l; i++) {
                  var arg = tmp_args[i] = i < 0 || arguments.length <= i ? undefined : arguments[i];

                  if (arg instanceof Tween) {
                    tmp_args[i] = arg._union();
                  }
                }

                return spawn.apply(spawn, tmp_args);
              };

              return Tween;
            }());
            Tween._tmp_args = [];
            legacyCC.Tween = Tween;
            function tween(target) {
              return new Tween(target);
            }
            legacyCC.tween = tween;
            function tweenUtil(target) {
              warn('tweenUtil\' is deprecated, please use \'tween\' instead ');
              return new Tween(target);
            }
            legacyCC.tweenUtil = tweenUtil;

            var DeviceType;

            (function (DeviceType) {
              DeviceType[DeviceType["Other"] = 0] = "Other";
              DeviceType[DeviceType["Left"] = 1] = "Left";
              DeviceType[DeviceType["Right"] = 2] = "Right";
            })(DeviceType || (DeviceType = {}));

            var XrUIPressEventType;

            (function (XrUIPressEventType) {
              XrUIPressEventType["XRUI_HOVER_ENTERED"] = "xrui-hover-entered";
              XrUIPressEventType["XRUI_HOVER_EXITED"] = "xrui-hover-exited";
              XrUIPressEventType["XRUI_HOVER_STAY"] = "xrui-hover-stay";
              XrUIPressEventType["XRUI_CLICK"] = "xrui-click";
              XrUIPressEventType["XRUI_UNCLICK"] = "xrui-unclick";
            })(XrUIPressEventType || (XrUIPressEventType = {}));

            var XrKeyboardEventType;

            (function (XrKeyboardEventType) {
              XrKeyboardEventType["XR_CAPS_LOCK"] = "xr-caps-lock";
              XrKeyboardEventType["XR_KEYBOARD_INIT"] = "xr-keyboard-init";
              XrKeyboardEventType["XR_KEYBOARD_INPUT"] = "xr-keyboard-input";
              XrKeyboardEventType["TO_LATIN"] = "to-latin";
              XrKeyboardEventType["TO_SYMBOL"] = "to-symbol";
              XrKeyboardEventType["TO_MATH_SYMBOL"] = "to-math-symbol";
            })(XrKeyboardEventType || (XrKeyboardEventType = {}));

            var XrUIPressEvent = function (_Event) {
              _inheritsLoose(XrUIPressEvent, _Event);

              function XrUIPressEvent() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Event.call.apply(_Event, [this].concat(args)) || this;
                _this.deviceType = DeviceType.Other;
                _this.hitPoint = new Vec3();
                return _this;
              }

              return XrUIPressEvent;
            }(Event);

            var _dec$1W, _dec2$1s, _dec3$Y, _dec4$G, _dec5$z, _dec6$s, _dec7$l, _dec8$f, _dec9$d, _dec10$7, _class$1Z, _class2$1I, _initializer$1D, _initializer2$1n, _initializer3$11, _initializer4$T, _initializer5$H, _initializer6$A, _initializer7$s, _initializer8$p, _initializer9$m, _initializer10$j, _initializer11$f, _initializer12$f, _initializer13$f, _initializer14$b, _class3$q, _temp$A;

            var _tempColor = new Color$1();

            var Transition$1;

            (function (Transition) {
              Transition[Transition["NONE"] = 0] = "NONE";
              Transition[Transition["COLOR"] = 1] = "COLOR";
              Transition[Transition["SPRITE"] = 2] = "SPRITE";
              Transition[Transition["SCALE"] = 3] = "SCALE";
            })(Transition$1 || (Transition$1 = {}));

            ccenum(Transition$1);
            var State$1;

            (function (State) {
              State["NORMAL"] = "normal";
              State["HOVER"] = "hover";
              State["PRESSED"] = "pressed";
              State["DISABLED"] = "disabled";
            })(State$1 || (State$1 = {}));

            var EventType$3;

            (function (EventType) {
              EventType["CLICK"] = "click";
            })(EventType$3 || (EventType$3 = {}));

            var Button = exports('Button', (_dec$1W = ccclass$p('cc.Button'), _dec2$1s = executionOrder(110), _dec3$Y = requireComponent(UITransform), _dec4$G = type$8(Node), _dec5$z = type$8(Transition$1), _dec6$s = type$8(SpriteFrame), _dec7$l = type$8(SpriteFrame), _dec8$f = type$8(SpriteFrame), _dec9$d = type$8(SpriteFrame), _dec10$7 = type$8([EventHandler]), _dec$1W(_class$1Z = _dec2$1s(_class$1Z = _dec3$Y(_class$1Z = (_class2$1I = (_temp$A = _class3$q = function (_Component) {
              _inheritsLoose(Button, _Component);

              function Button() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this.clickEvents = _initializer$1D && _initializer$1D();
                _this._interactable = _initializer2$1n && _initializer2$1n();
                _this._transition = _initializer3$11 && _initializer3$11();
                _this._normalColor = _initializer4$T && _initializer4$T();
                _this._hoverColor = _initializer5$H && _initializer5$H();
                _this._pressedColor = _initializer6$A && _initializer6$A();
                _this._disabledColor = _initializer7$s && _initializer7$s();
                _this._normalSprite = _initializer8$p && _initializer8$p();
                _this._hoverSprite = _initializer9$m && _initializer9$m();
                _this._pressedSprite = _initializer10$j && _initializer10$j();
                _this._disabledSprite = _initializer11$f && _initializer11$f();
                _this._duration = _initializer12$f && _initializer12$f();
                _this._zoomScale = _initializer13$f && _initializer13$f();
                _this._target = _initializer14$b && _initializer14$b();
                _this._pressed = false;
                _this._hovered = false;
                _this._fromColor = new Color$1();
                _this._toColor = new Color$1();
                _this._time = 0;
                _this._transitionFinished = true;
                _this._fromScale = new Vec3();
                _this._toScale = new Vec3();
                _this._originalScale = null;
                _this._sprite = null;
                _this._targetScale = new Vec3();
                return _this;
              }

              var _proto = Button.prototype;

              _proto.__preload = function __preload() {
                if (!this.target) {
                  this.target = this.node;
                }

                var sprite = this.node.getComponent(Sprite);

                if (sprite) {
                  this._normalSprite = sprite.spriteFrame;
                }

                this._applyTarget();

                this._resetState();
              };

              _proto.onEnable = function onEnable() {

                {
                  this._registerNodeEvent();
                }
              };

              _proto.onDisable = function onDisable() {
                this._resetState();

                {
                  this._unregisterNodeEvent();
                }
              };

              _proto.onDestroy = function onDestroy() {
                if (this.target.isValid) {
                  this._unregisterTargetEvent(this.target);
                }
              };

              _proto.update = function update(dt) {
                var target = this.target;

                if (this._transitionFinished || !target) {
                  return;
                }

                if (this._transition !== Transition$1.COLOR && this._transition !== Transition$1.SCALE) {
                  return;
                }

                this._time += dt;
                var ratio = 1.0;

                if (this._duration > 0) {
                  ratio = this._time / this._duration;
                }

                if (ratio >= 1) {
                  ratio = 1;
                }

                if (this._transition === Transition$1.COLOR) {
                  var renderComp = target._uiProps.uiComp;
                  Color$1.lerp(_tempColor, this._fromColor, this._toColor, ratio);

                  if (renderComp) {
                    renderComp.color = _tempColor;
                  }
                } else if (this.transition === Transition$1.SCALE) {
                  target.getScale(this._targetScale);
                  this._targetScale.x = lerp(this._fromScale.x, this._toScale.x, ratio);
                  this._targetScale.y = lerp(this._fromScale.y, this._toScale.y, ratio);
                  target.setScale(this._targetScale);
                }

                if (ratio === 1) {
                  this._transitionFinished = true;
                }
              };

              _proto._resizeNodeToTargetNode = function _resizeNodeToTargetNode() {
                if (!this.target) {
                  return;
                }

                var targetTrans = this.target._uiProps.uiTransformComp;
              };

              _proto._resetState = function _resetState() {
                this._pressed = false;
                this._hovered = false;
                var target = this.target;

                if (!target) {
                  return;
                }

                var transition = this._transition;

                if (transition === Transition$1.COLOR && this._interactable) {
                  var renderComp = target.getComponent(UIRenderer);

                  if (renderComp) {
                    renderComp.color = this._normalColor;
                  }
                } else if (transition === Transition$1.SCALE && this._originalScale) {
                  target.setScale(this._originalScale);
                }

                this._transitionFinished = true;
              };

              _proto._registerNodeEvent = function _registerNodeEvent() {
                this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMove, this);
                this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
                this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancel, this);
                this.node.on(NodeEventType.MOUSE_ENTER, this._onMouseMoveIn, this);
                this.node.on(NodeEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
                this.node.on(XrUIPressEventType.XRUI_HOVER_ENTERED, this._xrHoverEnter, this);
                this.node.on(XrUIPressEventType.XRUI_HOVER_EXITED, this._xrHoverExit, this);
                this.node.on(XrUIPressEventType.XRUI_CLICK, this._xrClick, this);
                this.node.on(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
              };

              _proto._registerTargetEvent = function _registerTargetEvent(target) {

                target.on(NodeEventType.TRANSFORM_CHANGED, this._onTargetTransformChanged, this);
              };

              _proto._unregisterNodeEvent = function _unregisterNodeEvent() {
                this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMove, this);
                this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
                this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancel, this);
                this.node.off(NodeEventType.MOUSE_ENTER, this._onMouseMoveIn, this);
                this.node.off(NodeEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
                this.node.off(XrUIPressEventType.XRUI_HOVER_ENTERED, this._xrHoverEnter, this);
                this.node.off(XrUIPressEventType.XRUI_HOVER_EXITED, this._xrHoverExit, this);
                this.node.off(XrUIPressEventType.XRUI_CLICK, this._xrClick, this);
                this.node.off(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
              };

              _proto._unregisterTargetEvent = function _unregisterTargetEvent(target) {

                target.off(NodeEventType.TRANSFORM_CHANGED);
              };

              _proto._getTargetSprite = function _getTargetSprite(target) {
                var sprite = null;

                if (target) {
                  sprite = target.getComponent(Sprite);
                }

                return sprite;
              };

              _proto._applyTarget = function _applyTarget() {
                if (this.target) {
                  this._sprite = this._getTargetSprite(this.target);

                  if (!this._originalScale) {
                    this._originalScale = new Vec3();
                  }

                  Vec3.copy(this._originalScale, this.target.getScale());

                  this._registerTargetEvent(this.target);
                }
              };

              _proto._onTargetSpriteFrameChanged = function _onTargetSpriteFrameChanged(comp) {
                if (this._transition === Transition$1.SPRITE) {
                  this._setCurrentStateSpriteFrame(comp.spriteFrame);
                }
              };

              _proto._setCurrentStateSpriteFrame = function _setCurrentStateSpriteFrame(spriteFrame) {
                if (!spriteFrame) {
                  return;
                }

                switch (this._getButtonState()) {
                  case State$1.NORMAL:
                    this._normalSprite = spriteFrame;
                    break;

                  case State$1.HOVER:
                    this._hoverSprite = spriteFrame;
                    break;

                  case State$1.PRESSED:
                    this._pressedSprite = spriteFrame;
                    break;

                  case State$1.DISABLED:
                    this._disabledSprite = spriteFrame;
                    break;
                }
              };

              _proto._onTargetColorChanged = function _onTargetColorChanged(color) {
                if (this._transition === Transition$1.COLOR) {
                  this._setCurrentStateColor(color);
                }
              };

              _proto._setCurrentStateColor = function _setCurrentStateColor(color) {
                switch (this._getButtonState()) {
                  case State$1.NORMAL:
                    this._normalColor = color;
                    break;

                  case State$1.HOVER:
                    this._hoverColor = color;
                    break;

                  case State$1.PRESSED:
                    this._pressedColor = color;
                    break;

                  case State$1.DISABLED:
                    this._disabledColor = color;
                    break;
                }
              };

              _proto._onTargetTransformChanged = function _onTargetTransformChanged(transformBit) {
                if (transformBit & TransformBit.SCALE && this._originalScale && this._transition === Transition$1.SCALE && this._transitionFinished) {
                  Vec3.copy(this._originalScale, this.target.getScale());
                }
              };

              _proto._onTouchBegan = function _onTouchBegan(event) {
                if (!this._interactable || !this.enabledInHierarchy) {
                  return;
                }

                this._pressed = true;

                this._updateState();

                if (event) {
                  event.propagationStopped = true;
                }
              };

              _proto._onTouchMove = function _onTouchMove(event) {
                if (!this._interactable || !this.enabledInHierarchy || !this._pressed) {
                  return;
                }

                if (!event) {
                  return;
                }

                var touch = event.touch;

                if (!touch) {
                  return;
                }

                var hit = this.node._uiProps.uiTransformComp.hitTest(touch.getLocation());

                if (this._transition === Transition$1.SCALE && this.target && this._originalScale) {
                  if (hit) {
                    Vec3.copy(this._fromScale, this._originalScale);
                    Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale);
                    this._transitionFinished = false;
                  } else {
                    this._time = 0;
                    this._transitionFinished = true;
                    this.target.setScale(this._originalScale);
                  }
                } else {
                  var state;

                  if (hit) {
                    state = State$1.PRESSED;
                  } else {
                    state = State$1.NORMAL;
                  }

                  this._applyTransition(state);
                }

                if (event) {
                  event.propagationStopped = true;
                }
              };

              _proto._onTouchEnded = function _onTouchEnded(event) {
                if (!this._interactable || !this.enabledInHierarchy) {
                  return;
                }

                if (this._pressed) {
                  EventHandler.emitEvents(this.clickEvents, event);
                  this.node.emit(EventType$3.CLICK, this);
                }

                this._pressed = false;

                this._updateState();

                if (event) {
                  event.propagationStopped = true;
                }
              };

              _proto._onTouchCancel = function _onTouchCancel(event) {
                if (!this._interactable || !this.enabledInHierarchy) {
                  return;
                }

                this._pressed = false;

                this._updateState();
              };

              _proto._onMouseMoveIn = function _onMouseMoveIn(event) {
                if (this._pressed || !this.interactable || !this.enabledInHierarchy) {
                  return;
                }

                if (this._transition === Transition$1.SPRITE && !this._hoverSprite) {
                  return;
                }

                if (!this._hovered) {
                  this._hovered = true;

                  this._updateState();
                }
              };

              _proto._onMouseMoveOut = function _onMouseMoveOut(event) {
                if (this._hovered) {
                  this._hovered = false;

                  this._updateState();
                }
              };

              _proto._updateState = function _updateState() {
                var state = this._getButtonState();

                this._applyTransition(state);
              };

              _proto._getButtonState = function _getButtonState() {
                var state = State$1.NORMAL;

                if (!this._interactable) {
                  state = State$1.DISABLED;
                } else if (this._pressed) {
                  state = State$1.PRESSED;
                } else if (this._hovered) {
                  state = State$1.HOVER;
                }

                return state.toString();
              };

              _proto._updateColorTransition = function _updateColorTransition(state) {
                var _this$target;

                var color = this[state + "Color"];
                var renderComp = (_this$target = this.target) === null || _this$target === void 0 ? void 0 : _this$target.getComponent(UIRenderer);

                if (!renderComp) {
                  return;
                }

                if ( state === State$1.DISABLED) {
                  renderComp.color = color;
                } else {
                  this._fromColor = renderComp.color.clone();
                  this._toColor = color;
                  this._time = 0;
                  this._transitionFinished = false;
                }
              };

              _proto._updateSpriteTransition = function _updateSpriteTransition(state) {
                var sprite = this[state + "Sprite"];

                if (this._sprite && sprite) {
                  this._sprite.spriteFrame = sprite;
                }
              };

              _proto._updateScaleTransition = function _updateScaleTransition(state) {
                if (!this._interactable) {
                  return;
                }

                if (state === State$1.PRESSED) {
                  this._zoomUp();
                } else {
                  this._zoomBack();
                }
              };

              _proto._zoomUp = function _zoomUp() {
                if (!this._originalScale) {
                  return;
                }

                Vec3.copy(this._fromScale, this._originalScale);
                Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale);
                this._time = 0;
                this._transitionFinished = false;
              };

              _proto._zoomBack = function _zoomBack() {
                if (!this.target || !this._originalScale) {
                  return;
                }

                Vec3.copy(this._fromScale, this.target.getScale());
                Vec3.copy(this._toScale, this._originalScale);
                this._time = 0;
                this._transitionFinished = false;
              };

              _proto._applyTransition = function _applyTransition(state) {
                var transition = this._transition;

                if (transition === Transition$1.COLOR) {
                  this._updateColorTransition(state);
                } else if (transition === Transition$1.SPRITE) {
                  this._updateSpriteTransition(state);
                } else if (transition === Transition$1.SCALE) {
                  this._updateScaleTransition(state);
                }
              };

              _proto._xrHoverEnter = function _xrHoverEnter() {
                this._onMouseMoveIn();

                this._updateState();
              };

              _proto._xrHoverExit = function _xrHoverExit() {
                this._onMouseMoveOut();

                if (this._pressed) {
                  this._pressed = false;

                  this._updateState();
                }
              };

              _proto._xrClick = function _xrClick() {
                if (!this._interactable || !this.enabledInHierarchy) {
                  return;
                }

                this._pressed = true;

                this._updateState();
              };

              _proto._xrUnClick = function _xrUnClick() {
                if (!this._interactable || !this.enabledInHierarchy) {
                  return;
                }

                if (this._pressed) {
                  EventHandler.emitEvents(this.clickEvents, this);
                  this.node.emit(EventType$3.CLICK, this);
                }

                this._pressed = false;

                this._updateState();
              };

              _createClass(Button, [{
                key: "target",
                get: function get() {
                  return this._target || this.node;
                },
                set: function set(value) {
                  if (this._target === value) {
                    return;
                  }

                  if (this._target) {
                    this._unregisterTargetEvent(this._target);
                  }

                  this._target = value;

                  this._applyTarget();
                }
              }, {
                key: "interactable",
                get: function get() {
                  return this._interactable;
                },
                set: function set(value) {
                  if (this._interactable === value) {
                    return;
                  }

                  this._interactable = value;

                  this._updateState();

                  if (!this._interactable) {
                    this._resetState();
                  }
                }
              }, {
                key: "_resizeToTarget",
                set: function set(value) {
                  if (value) {
                    this._resizeNodeToTargetNode();
                  }
                }
              }, {
                key: "transition",
                get: function get() {
                  return this._transition;
                },
                set: function set(value) {
                  if (this._transition === value) {
                    return;
                  }

                  if (this._transition === Transition$1.COLOR) {
                    this._updateColorTransition(State$1.NORMAL);
                  } else if (this._transition === Transition$1.SPRITE) {
                    this._updateSpriteTransition(State$1.NORMAL);
                  }

                  this._transition = value;

                  this._updateState();
                }
              }, {
                key: "normalColor",
                get: function get() {
                  return this._normalColor;
                },
                set: function set(value) {
                  if (this._normalColor === value) {
                    return;
                  }

                  this._normalColor.set(value);

                  this._updateState();
                }
              }, {
                key: "pressedColor",
                get: function get() {
                  return this._pressedColor;
                },
                set: function set(value) {
                  if (this._pressedColor === value) {
                    return;
                  }

                  this._pressedColor.set(value);
                }
              }, {
                key: "hoverColor",
                get: function get() {
                  return this._hoverColor;
                },
                set: function set(value) {
                  if (this._hoverColor === value) {
                    return;
                  }

                  this._hoverColor.set(value);
                }
              }, {
                key: "disabledColor",
                get: function get() {
                  return this._disabledColor;
                },
                set: function set(value) {
                  if (this._disabledColor === value) {
                    return;
                  }

                  this._disabledColor.set(value);

                  this._updateState();
                }
              }, {
                key: "duration",
                get: function get() {
                  return this._duration;
                },
                set: function set(value) {
                  if (this._duration === value) {
                    return;
                  }

                  this._duration = value;
                }
              }, {
                key: "zoomScale",
                get: function get() {
                  return this._zoomScale;
                },
                set: function set(value) {
                  if (this._zoomScale === value) {
                    return;
                  }

                  this._zoomScale = value;
                }
              }, {
                key: "normalSprite",
                get: function get() {
                  return this._normalSprite;
                },
                set: function set(value) {
                  if (this._normalSprite === value) {
                    return;
                  }

                  this._normalSprite = value;
                  var sprite = this.node.getComponent(Sprite);

                  if (sprite) {
                    sprite.spriteFrame = value;
                  }

                  this._updateState();
                }
              }, {
                key: "pressedSprite",
                get: function get() {
                  return this._pressedSprite;
                },
                set: function set(value) {
                  if (this._pressedSprite === value) {
                    return;
                  }

                  this._pressedSprite = value;

                  this._updateState();
                }
              }, {
                key: "hoverSprite",
                get: function get() {
                  return this._hoverSprite;
                },
                set: function set(value) {
                  if (this._hoverSprite === value) {
                    return;
                  }

                  this._hoverSprite = value;

                  this._updateState();
                }
              }, {
                key: "disabledSprite",
                get: function get() {
                  return this._disabledSprite;
                },
                set: function set(value) {
                  if (this._disabledSprite === value) {
                    return;
                  }

                  this._disabledSprite = value;

                  this._updateState();
                }
              }]);

              return Button;
            }(Component), _class3$q.Transition = Transition$1, _class3$q.EventType = EventType$3, _temp$A), (_applyDecoratedDescriptor(_class2$1I.prototype, "target", [_dec4$G], Object.getOwnPropertyDescriptor(_class2$1I.prototype, "target"), _class2$1I.prototype), _applyDecoratedDescriptor(_class2$1I.prototype, "transition", [_dec5$z], Object.getOwnPropertyDescriptor(_class2$1I.prototype, "transition"), _class2$1I.prototype), _applyDecoratedDescriptor(_class2$1I.prototype, "normalSprite", [_dec6$s], Object.getOwnPropertyDescriptor(_class2$1I.prototype, "normalSprite"), _class2$1I.prototype), _applyDecoratedDescriptor(_class2$1I.prototype, "pressedSprite", [_dec7$l], Object.getOwnPropertyDescriptor(_class2$1I.prototype, "pressedSprite"), _class2$1I.prototype), _applyDecoratedDescriptor(_class2$1I.prototype, "hoverSprite", [_dec8$f], Object.getOwnPropertyDescriptor(_class2$1I.prototype, "hoverSprite"), _class2$1I.prototype), _applyDecoratedDescriptor(_class2$1I.prototype, "disabledSprite", [_dec9$d], Object.getOwnPropertyDescriptor(_class2$1I.prototype, "disabledSprite"), _class2$1I.prototype), _initializer$1D = applyDecoratedInitializer(_class2$1I.prototype, "clickEvents", [_dec10$7, serializable$j], function () {
              return [];
            }), _initializer2$1n = applyDecoratedInitializer(_class2$1I.prototype, "_interactable", [serializable$j], function () {
              return true;
            }), _initializer3$11 = applyDecoratedInitializer(_class2$1I.prototype, "_transition", [serializable$j], function () {
              return Transition$1.NONE;
            }), _initializer4$T = applyDecoratedInitializer(_class2$1I.prototype, "_normalColor", [serializable$j], function () {
              return Color$1.WHITE.clone();
            }), _initializer5$H = applyDecoratedInitializer(_class2$1I.prototype, "_hoverColor", [serializable$j], function () {
              return new Color$1(211, 211, 211, 255);
            }), _initializer6$A = applyDecoratedInitializer(_class2$1I.prototype, "_pressedColor", [serializable$j], function () {
              return Color$1.WHITE.clone();
            }), _initializer7$s = applyDecoratedInitializer(_class2$1I.prototype, "_disabledColor", [serializable$j], function () {
              return new Color$1(124, 124, 124, 255);
            }), _initializer8$p = applyDecoratedInitializer(_class2$1I.prototype, "_normalSprite", [serializable$j], function () {
              return null;
            }), _initializer9$m = applyDecoratedInitializer(_class2$1I.prototype, "_hoverSprite", [serializable$j], function () {
              return null;
            }), _initializer10$j = applyDecoratedInitializer(_class2$1I.prototype, "_pressedSprite", [serializable$j], function () {
              return null;
            }), _initializer11$f = applyDecoratedInitializer(_class2$1I.prototype, "_disabledSprite", [serializable$j], function () {
              return null;
            }), _initializer12$f = applyDecoratedInitializer(_class2$1I.prototype, "_duration", [serializable$j], function () {
              return 0.1;
            }), _initializer13$f = applyDecoratedInitializer(_class2$1I.prototype, "_zoomScale", [serializable$j], function () {
              return 1.2;
            }), _initializer14$b = applyDecoratedInitializer(_class2$1I.prototype, "_target", [serializable$j], function () {
              return null;
            })), _class2$1I)) || _class$1Z) || _class$1Z) || _class$1Z));
            legacyCC.Button = Button;

            var tabIndexUtil = function () {
              function tabIndexUtil() {}

              tabIndexUtil.add = function add(editBoxImpl) {
                var list = this._tabIndexList;
                var index = list.indexOf(editBoxImpl);

                if (index === -1) {
                  list.push(editBoxImpl);
                }
              };

              tabIndexUtil.remove = function remove(editBoxImpl) {
                var list = this._tabIndexList;
                var index = list.indexOf(editBoxImpl);

                if (index !== -1) {
                  list.splice(index, 1);
                }
              };

              tabIndexUtil.resort = function resort() {
                this._tabIndexList.sort(function (a, b) {
                  return a._delegate.tabIndex - b._delegate.tabIndex;
                });
              };

              tabIndexUtil.next = function next(editBoxImpl) {
                var list = this._tabIndexList;
                var index = list.indexOf(editBoxImpl);
                editBoxImpl.setFocus(false);

                if (index !== -1) {
                  var nextImpl = list[index + 1];

                  if (nextImpl && nextImpl._delegate.tabIndex >= 0) {
                    nextImpl.setFocus(true);
                  }
                }
              };

              return tabIndexUtil;
            }();
            tabIndexUtil._tabIndexList = [];

            var KeyboardReturnType;

            (function (KeyboardReturnType) {
              KeyboardReturnType[KeyboardReturnType["DEFAULT"] = 0] = "DEFAULT";
              KeyboardReturnType[KeyboardReturnType["DONE"] = 1] = "DONE";
              KeyboardReturnType[KeyboardReturnType["SEND"] = 2] = "SEND";
              KeyboardReturnType[KeyboardReturnType["SEARCH"] = 3] = "SEARCH";
              KeyboardReturnType[KeyboardReturnType["GO"] = 4] = "GO";
              KeyboardReturnType[KeyboardReturnType["NEXT"] = 5] = "NEXT";
            })(KeyboardReturnType || (KeyboardReturnType = {}));

            Enum(KeyboardReturnType);
            var InputMode;

            (function (InputMode) {
              InputMode[InputMode["ANY"] = 0] = "ANY";
              InputMode[InputMode["EMAIL_ADDR"] = 1] = "EMAIL_ADDR";
              InputMode[InputMode["NUMERIC"] = 2] = "NUMERIC";
              InputMode[InputMode["PHONE_NUMBER"] = 3] = "PHONE_NUMBER";
              InputMode[InputMode["URL"] = 4] = "URL";
              InputMode[InputMode["DECIMAL"] = 5] = "DECIMAL";
              InputMode[InputMode["SINGLE_LINE"] = 6] = "SINGLE_LINE";
            })(InputMode || (InputMode = {}));

            Enum(InputMode);
            var InputFlag;

            (function (InputFlag) {
              InputFlag[InputFlag["PASSWORD"] = 0] = "PASSWORD";
              InputFlag[InputFlag["SENSITIVE"] = 1] = "SENSITIVE";
              InputFlag[InputFlag["INITIAL_CAPS_WORD"] = 2] = "INITIAL_CAPS_WORD";
              InputFlag[InputFlag["INITIAL_CAPS_SENTENCE"] = 3] = "INITIAL_CAPS_SENTENCE";
              InputFlag[InputFlag["INITIAL_CAPS_ALL_CHARACTERS"] = 4] = "INITIAL_CAPS_ALL_CHARACTERS";
              InputFlag[InputFlag["DEFAULT"] = 5] = "DEFAULT";
            })(InputFlag || (InputFlag = {}));

            Enum(InputFlag);

            var EditBoxImplBase = function () {
              function EditBoxImplBase() {
                this._editing = false;
                this._delegate = null;
              }

              var _proto = EditBoxImplBase.prototype;

              _proto.init = function init(delegate) {};

              _proto.onEnable = function onEnable() {};

              _proto.update = function update() {};

              _proto.onDisable = function onDisable() {
                if (this._editing) {
                  this.endEditing();
                }
              };

              _proto.clear = function clear() {
                this._delegate = null;
              };

              _proto.setTabIndex = function setTabIndex(index) {};

              _proto.setSize = function setSize(width, height) {};

              _proto.setFocus = function setFocus(value) {
                if (value) {
                  this.beginEditing();
                } else {
                  this.endEditing();
                }
              };

              _proto.isFocused = function isFocused() {
                return this._editing;
              };

              _proto.beginEditing = function beginEditing() {};

              _proto.endEditing = function endEditing() {};

              return EditBoxImplBase;
            }();

            var ccdocument$1 = ccwindow.document;
            var SCROLLY = 40;
            var LEFT_PADDING = 2;
            var DELAY_TIME = 400;

            var _matrix$1 = new Mat4();

            var _matrix_temp = new Mat4();

            var _vec3 = new Vec3();

            var _currentEditBoxImpl = null;
            var _domCount = 0;
            var EditBoxImpl = function (_EditBoxImplBase) {
              _inheritsLoose(EditBoxImpl, _EditBoxImplBase);

              function EditBoxImpl() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _EditBoxImplBase.call.apply(_EditBoxImplBase, [this].concat(args)) || this;
                _this._delegate = null;
                _this._inputMode = -1;
                _this._inputFlag = -1;
                _this._returnType = -1;
                _this.__eventListeners = {};
                _this.__autoResize = false;
                _this.__orientationChanged = void 0;
                _this._edTxt = null;
                _this._isTextArea = false;
                _this._textLabelFont = null;
                _this._textLabelFontSize = null;
                _this._textLabelFontColor = null;
                _this._textLabelAlign = null;
                _this._placeholderLabelFont = null;
                _this._placeholderLabelFontSize = null;
                _this._placeholderLabelFontColor = null;
                _this._placeholderLabelAlign = null;
                _this._placeholderLineHeight = null;
                _this._placeholderStyleSheet = null;
                _this._domId = "EditBoxId_" + ++_domCount;
                return _this;
              }

              var _proto = EditBoxImpl.prototype;

              _proto.init = function init(delegate) {
                if (!delegate) {
                  return;
                }

                this._delegate = delegate;

                if (delegate.inputMode === InputMode.ANY) {
                  this._createTextArea();
                } else {
                  this._createInput();
                }

                tabIndexUtil.add(this);
                this.setTabIndex(delegate.tabIndex);

                this._initStyleSheet();

                this._registerEventListeners();

                this._addDomToGameContainer();
              };

              _proto.clear = function clear() {
                this._removeEventListeners();

                this._removeDomFromGameContainer();

                tabIndexUtil.remove(this);

                if (_currentEditBoxImpl === this) {
                  _currentEditBoxImpl = null;
                }

                this._delegate = null;
              };

              _proto.update = function update() {
                this._updateMatrix();
              };

              _proto.setTabIndex = function setTabIndex(index) {
                this._edTxt.tabIndex = index;
                tabIndexUtil.resort();
              };

              _proto.setSize = function setSize(width, height) {
                var elem = this._edTxt;

                if (elem) {
                  elem.style.width = width + "px";
                  elem.style.height = height + "px";
                }
              };

              _proto.beginEditing = function beginEditing() {
                if (_currentEditBoxImpl && _currentEditBoxImpl !== this) {
                  _currentEditBoxImpl.setFocus(false);
                }

                this._editing = true;
                _currentEditBoxImpl = this;

                this._delegate._editBoxEditingDidBegan();

                this._showDom();

                this._edTxt.focus();
              };

              _proto.endEditing = function endEditing() {
                this._edTxt.blur();
              };

              _proto._createInput = function _createInput() {
                this._isTextArea = false;
                this._edTxt = ccdocument$1.createElement('input');
              };

              _proto._createTextArea = function _createTextArea() {
                this._isTextArea = true;
                this._edTxt = ccdocument$1.createElement('textarea');
              };

              _proto._addDomToGameContainer = function _addDomToGameContainer() {
                if (game.container && this._edTxt) {
                  game.container.appendChild(this._edTxt);
                  ccdocument$1.head.appendChild(this._placeholderStyleSheet);
                }
              };

              _proto._removeDomFromGameContainer = function _removeDomFromGameContainer() {
                var hasElem = contains$1(game.container, this._edTxt);

                if (hasElem && this._edTxt) {
                  game.container.removeChild(this._edTxt);
                }

                var hasStyleSheet = contains$1(ccdocument$1.head, this._placeholderStyleSheet);

                if (hasStyleSheet) {
                  ccdocument$1.head.removeChild(this._placeholderStyleSheet);
                }

                this._edTxt = null;
                this._placeholderStyleSheet = null;
              };

              _proto._showDom = function _showDom() {
                this._updateMaxLength();

                this._updateInputType();

                this._updateStyleSheet();

                if (this._edTxt && this._delegate) {
                  this._edTxt.style.display = '';

                  this._delegate._hideLabels();
                }

                if (sys.isMobile) {
                  this._showDomOnMobile();
                }
              };

              _proto._hideDom = function _hideDom() {
                var elem = this._edTxt;

                if (elem && this._delegate) {
                  elem.style.display = 'none';

                  this._delegate._showLabels();
                }

                if (sys.isMobile) {
                  this._hideDomOnMobile();
                }
              };

              _proto._showDomOnMobile = function _showDomOnMobile() {
                if (sys.os !== OS.ANDROID && sys.os !== OS.OHOS) {
                  return;
                }

                screenAdapter.handleResizeEvent = false;

                this._adjustWindowScroll();
              };

              _proto._hideDomOnMobile = function _hideDomOnMobile() {
                if (sys.os === OS.ANDROID || sys.os === OS.OHOS) {
                  screenAdapter.handleResizeEvent = true;
                }

                this._scrollBackWindow();
              };

              _proto._adjustWindowScroll = function _adjustWindowScroll() {
                var _this2 = this;

                setTimeout(function () {
                  if (ccwindow.scrollY < SCROLLY) {
                    _this2._edTxt.scrollIntoView({
                      block: 'start',
                      inline: 'nearest',
                      behavior: 'smooth'
                    });
                  }
                }, DELAY_TIME);
              };

              _proto._scrollBackWindow = function _scrollBackWindow() {
                setTimeout(function () {
                  if (sys.browserType === BrowserType.WECHAT && sys.os === OS.IOS) {
                    if (ccwindow.top) {
                      ccwindow.top.scrollTo(0, 0);
                    }

                    return;
                  }

                  ccwindow.scrollTo(0, 0);
                }, DELAY_TIME);
              };

              _proto._updateMatrix = function _updateMatrix() {
                if (!this._edTxt) {
                  return;
                }

                var node = this._delegate.node;
                var scaleX = view.getScaleX();
                var scaleY = view.getScaleY();
                var viewport = view.getViewportRect();
                var dpr = screenAdapter.devicePixelRatio;
                node.getWorldMatrix(_matrix$1);
                var transform = node._uiProps.uiTransformComp;

                if (transform) {
                  Vec3.set(_vec3, -transform.anchorX * transform.width, -transform.anchorY * transform.height, _vec3.z);
                }

                Mat4.transform(_matrix$1, _matrix$1, _vec3);

                if (!node._uiProps.uiTransformComp) {
                  return;
                }

                var camera = director.root.batcher2D.getFirstRenderCamera(node);
                if (!camera) return;
                camera.node.getWorldRT(_matrix_temp);
                var m12 = _matrix_temp.m12;
                var m13 = _matrix_temp.m13;
                var center = visibleRect.center;
                _matrix_temp.m12 = center.x - (_matrix_temp.m00 * m12 + _matrix_temp.m04 * m13);
                _matrix_temp.m13 = center.y - (_matrix_temp.m01 * m12 + _matrix_temp.m05 * m13);
                Mat4.multiply(_matrix_temp, _matrix_temp, _matrix$1);
                scaleX /= dpr;
                scaleY /= dpr;
                var container = game.container;
                var a = _matrix_temp.m00 * scaleX;
                var b = _matrix$1.m01;
                var c = _matrix$1.m04;
                var d = _matrix_temp.m05 * scaleY;
                var offsetX = parseInt(container && container.style.paddingLeft || '0');
                offsetX += viewport.x / dpr;
                var offsetY = parseInt(container && container.style.paddingBottom || '0');
                offsetY += viewport.y / dpr;
                var tx = _matrix_temp.m12 * scaleX + offsetX;
                var ty = _matrix_temp.m13 * scaleY + offsetY;
                var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
                this._edTxt.style.transform = matrix;
                this._edTxt.style['-webkit-transform'] = matrix;
                this._edTxt.style['transform-origin'] = '0px 100% 0px';
                this._edTxt.style['-webkit-transform-origin'] = '0px 100% 0px';
              };

              _proto._updateInputType = function _updateInputType() {
                var delegate = this._delegate;
                var inputMode = delegate.inputMode;
                var inputFlag = delegate.inputFlag;
                var returnType = delegate.returnType;
                var elem = this._edTxt;

                if (this._inputMode === inputMode && this._inputFlag === inputFlag && this._returnType === returnType) {
                  return;
                }

                this._inputMode = inputMode;
                this._inputFlag = inputFlag;
                this._returnType = returnType;

                if (this._isTextArea) {
                  var transform = 'none';

                  if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
                    transform = 'uppercase';
                  } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
                    transform = 'capitalize';
                  }

                  elem.style.textTransform = transform;
                  return;
                }

                elem = elem;

                if (inputFlag === InputFlag.PASSWORD) {
                  elem.type = 'password';
                  elem.style.textTransform = 'none';
                  return;
                }

                var type = elem.type;

                if (inputMode === InputMode.EMAIL_ADDR) {
                  type = 'email';
                } else if (inputMode === InputMode.NUMERIC || inputMode === InputMode.DECIMAL) {
                  type = 'number';
                } else if (inputMode === InputMode.PHONE_NUMBER) {
                  type = 'number';
                  elem.pattern = '[0-9]*';
                  elem.addEventListener('wheel', function () {
                    return false;
                  });
                } else if (inputMode === InputMode.URL) {
                  type = 'url';
                } else {
                  type = 'text';

                  if (returnType === KeyboardReturnType.SEARCH) {
                    type = 'search';
                  }
                }

                elem.type = type;
                var textTransform = 'none';

                if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
                  textTransform = 'uppercase';
                } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
                  textTransform = 'capitalize';
                }

                elem.style.textTransform = textTransform;
              };

              _proto._updateMaxLength = function _updateMaxLength() {
                var maxLength = this._delegate.maxLength;

                if (maxLength < 0) {
                  maxLength = 65535;
                }

                this._edTxt.maxLength = maxLength;
              };

              _proto._initStyleSheet = function _initStyleSheet() {
                if (!this._edTxt) {
                  return;
                }

                var elem = this._edTxt;
                elem.style.color = '#000000';
                elem.style.border = '0px';
                elem.style.background = 'transparent';
                elem.style.width = '100%';
                elem.style.height = '100%';
                elem.style.outline = 'medium';
                elem.style.padding = '0';
                elem.style.textTransform = 'none';
                elem.style.display = 'none';
                elem.style.position = 'absolute';
                elem.style.bottom = '0px';
                elem.style.left = LEFT_PADDING + "px";
                elem.className = 'cocosEditBox';
                elem.style.fontFamily = 'Arial';
                elem.id = this._domId;

                if (!this._isTextArea) {
                  elem = elem;
                  elem.type = 'text';
                  elem.style['-moz-appearance'] = 'textfield';
                } else {
                  elem.style.resize = 'none';
                  elem.style.overflowY = 'scroll';
                }

                this._placeholderStyleSheet = ccdocument$1.createElement('style');
              };

              _proto._updateStyleSheet = function _updateStyleSheet() {
                var delegate = this._delegate;
                var elem = this._edTxt;

                if (elem && delegate) {
                  elem.value = delegate.string;

                  this._updateTextLabel(delegate.textLabel);
                }
              };

              _proto._updateTextLabel = function _updateTextLabel(textLabel) {
                if (!textLabel) {
                  return;
                }

                var font = textLabel.font;

                if (font && !(font instanceof BitmapFont)) {
                  font = font._fontFamily;
                } else {
                  font = textLabel.fontFamily;
                }

                var fontSize = textLabel.fontSize * textLabel.node.scale.y;

                if (this._textLabelFont === font && this._textLabelFontSize === fontSize && this._textLabelFontColor === textLabel.fontColor && this._textLabelAlign === textLabel.horizontalAlign) {
                  return;
                }

                this._textLabelFont = font;
                this._textLabelFontSize = fontSize;
                this._textLabelFontColor = textLabel.fontColor;
                this._textLabelAlign = textLabel.horizontalAlign;

                if (!this._edTxt) {
                  return;
                }

                var elem = this._edTxt;
                elem.style.fontSize = fontSize + "px";
                elem.style.color = textLabel.color.toCSS();
                elem.style.fontFamily = font;

                switch (textLabel.horizontalAlign) {
                  case Label.HorizontalAlign.LEFT:
                    elem.style.textAlign = 'left';
                    break;

                  case Label.HorizontalAlign.CENTER:
                    elem.style.textAlign = 'center';
                    break;

                  case Label.HorizontalAlign.RIGHT:
                    elem.style.textAlign = 'right';
                    break;
                }
              };

              _proto._updatePlaceholderLabel = function _updatePlaceholderLabel(placeholderLabel) {
                if (!placeholderLabel) {
                  return;
                }

                var font = placeholderLabel.font;

                if (font && !(font instanceof BitmapFont)) {
                  font = placeholderLabel.font._fontFamily;
                } else {
                  font = placeholderLabel.fontFamily;
                }

                var fontSize = placeholderLabel.fontSize * placeholderLabel.node.scale.y;

                if (this._placeholderLabelFont === font && this._placeholderLabelFontSize === fontSize && this._placeholderLabelFontColor === placeholderLabel.fontColor && this._placeholderLabelAlign === placeholderLabel.horizontalAlign && this._placeholderLineHeight === placeholderLabel.fontSize) {
                  return;
                }

                this._placeholderLabelFont = font;
                this._placeholderLabelFontSize = fontSize;
                this._placeholderLabelFontColor = placeholderLabel.fontColor;
                this._placeholderLabelAlign = placeholderLabel.horizontalAlign;
                this._placeholderLineHeight = placeholderLabel.fontSize;
                var styleEl = this._placeholderStyleSheet;
                var fontColor = placeholderLabel.color.toCSS();
                var lineHeight = placeholderLabel.fontSize;
                var horizontalAlign = '';

                switch (placeholderLabel.horizontalAlign) {
                  case Label.HorizontalAlign.LEFT:
                    horizontalAlign = 'left';
                    break;

                  case Label.HorizontalAlign.CENTER:
                    horizontalAlign = 'center';
                    break;

                  case Label.HorizontalAlign.RIGHT:
                    horizontalAlign = 'right';
                    break;
                }

                styleEl.innerHTML = "#" + this._domId + "::-webkit-input-placeholder{text-transform: initial;-family: " + font + ";font-size: " + fontSize + "px;color: " + fontColor + ";line-height: " + lineHeight + "px;text-align: " + horizontalAlign + ";}" + ("#" + this._domId + "::-moz-placeholder{text-transform: initial;-family: " + font + ";font-size: " + fontSize + "px;color: " + fontColor + ";line-height: " + lineHeight + "px;text-align: " + horizontalAlign + ";}") + ("#" + this._domId + "::-ms-input-placeholder{text-transform: initial;-family: " + font + ";font-size: " + fontSize + "px;color: " + fontColor + ";line-height: " + lineHeight + "px;text-align: " + horizontalAlign + ";}");

                if (sys.browserType === BrowserType.EDGE) {
                  styleEl.innerHTML += "#" + this._domId + "::-ms-clear{display: none;}";
                }
              };

              _proto._registerEventListeners = function _registerEventListeners() {
                var _this3 = this;

                if (!this._edTxt) {
                  return;
                }

                var elem = this._edTxt;
                var inputLock = false;
                var cbs = this.__eventListeners;

                cbs.compositionStart = function () {
                  inputLock = true;
                };

                cbs.compositionEnd = function () {
                  inputLock = false;

                  _this3._delegate._editBoxTextChanged(elem.value);
                };

                cbs.onInput = function () {
                  if (inputLock) {
                    return;
                  }

                  var delegate = _this3._delegate;
                  var maxLength = delegate.maxLength;

                  if (maxLength >= 0) {
                    elem.value = elem.value.slice(0, maxLength);
                  }

                  delegate._editBoxTextChanged(elem.value);
                };

                cbs.onClick = function () {
                  if (_this3._editing) {
                    if (sys.isMobile) {
                      _this3._adjustWindowScroll();
                    }
                  }
                };

                cbs.onKeydown = function (e) {
                  if (e.keyCode === KeyCode.ENTER) {
                    e.propagationStopped = true;

                    _this3._delegate._editBoxEditingReturn();

                    if (!_this3._isTextArea) {
                      elem.blur();
                    }
                  } else if (e.keyCode === KeyCode.TAB) {
                    e.propagationStopped = true;
                    e.preventDefault();
                    tabIndexUtil.next(_this3);
                  }
                };

                cbs.onBlur = function () {
                  if (sys.isMobile && inputLock) {
                    cbs.compositionEnd();
                  }

                  _this3._editing = false;
                  _currentEditBoxImpl = null;

                  _this3._hideDom();

                  _this3._delegate._editBoxEditingDidEnded();
                };

                elem.addEventListener('compositionstart', cbs.compositionStart);
                elem.addEventListener('compositionend', cbs.compositionEnd);
                elem.addEventListener('input', cbs.onInput);
                elem.addEventListener('keydown', cbs.onKeydown);
                elem.addEventListener('blur', cbs.onBlur);
                elem.addEventListener('touchstart', cbs.onClick);
              };

              _proto._removeEventListeners = function _removeEventListeners() {
                if (!this._edTxt) {
                  return;
                }

                var elem = this._edTxt;
                var cbs = this.__eventListeners;
                elem.removeEventListener('compositionstart', cbs.compositionStart);
                elem.removeEventListener('compositionend', cbs.compositionEnd);
                elem.removeEventListener('input', cbs.onInput);
                elem.removeEventListener('keydown', cbs.onKeydown);
                elem.removeEventListener('blur', cbs.onBlur);
                elem.removeEventListener('touchstart', cbs.onClick);
                cbs.compositionStart = null;
                cbs.compositionEnd = null;
                cbs.onInput = null;
                cbs.onKeydown = null;
                cbs.onBlur = null;
                cbs.onClick = null;
              };

              return EditBoxImpl;
            }(EditBoxImplBase);

            var _dec$1X, _dec2$1t, _dec3$Z, _dec4$H, _dec5$A, _dec6$t, _dec7$m, _dec8$g, _dec9$e, _dec10$8, _dec11$5, _dec12$3, _dec13$3, _class$1_, _class2$1J, _initializer$1E, _initializer2$1o, _initializer3$12, _initializer4$U, _initializer5$I, _initializer6$B, _initializer7$t, _initializer8$q, _initializer9$n, _initializer10$k, _initializer11$g, _initializer12$g, _initializer13$g, _class3$r, _temp$B;
            var LEFT_PADDING$1 = 2;

            function capitalize(str) {
              return str.replace(/(?:^|\s)\S/g, function (a) {
                return a.toUpperCase();
              });
            }

            function capitalizeFirstLetter(str) {
              return str.charAt(0).toUpperCase() + str.slice(1);
            }

            var EventType$4;

            (function (EventType) {
              EventType["EDITING_DID_BEGAN"] = "editing-did-began";
              EventType["EDITING_DID_ENDED"] = "editing-did-ended";
              EventType["TEXT_CHANGED"] = "text-changed";
              EventType["EDITING_RETURN"] = "editing-return";
              EventType["XR_EDITING_DID_BEGAN"] = "xr-editing-did-began";
              EventType["XR_EDITING_DID_ENDED"] = "xr-editing-did-ended";
            })(EventType$4 || (EventType$4 = {}));

            var EditBox = exports('EditBox', (_dec$1X = ccclass$p('cc.EditBox'), _dec2$1t = executionOrder(110), _dec3$Z = requireComponent(UITransform), _dec4$H = type$8(Label), _dec5$A = type$8(Label), _dec6$t = type$8(SpriteFrame), _dec7$m = type$8(InputFlag), _dec8$g = type$8(InputMode), _dec9$e = type$8(KeyboardReturnType), _dec10$8 = type$8([EventHandler]), _dec11$5 = type$8([EventHandler]), _dec12$3 = type$8([EventHandler]), _dec13$3 = type$8([EventHandler]), _dec$1X(_class$1_ = _dec2$1t(_class$1_ = _dec3$Z(_class$1_ = (_class2$1J = (_temp$B = _class3$r = function (_Component) {
              _inheritsLoose(EditBox, _Component);

              function EditBox() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this.editingDidBegan = _initializer$1E && _initializer$1E();
                _this.textChanged = _initializer2$1o && _initializer2$1o();
                _this.editingDidEnded = _initializer3$12 && _initializer3$12();
                _this.editingReturn = _initializer4$U && _initializer4$U();
                _this._impl = null;
                _this._background = null;
                _this._textLabel = _initializer5$I && _initializer5$I();
                _this._placeholderLabel = _initializer6$B && _initializer6$B();
                _this._returnType = _initializer7$t && _initializer7$t();
                _this._string = _initializer8$q && _initializer8$q();
                _this._tabIndex = _initializer9$n && _initializer9$n();
                _this._backgroundImage = _initializer10$k && _initializer10$k();
                _this._inputFlag = _initializer11$g && _initializer11$g();
                _this._inputMode = _initializer12$g && _initializer12$g();
                _this._maxLength = _initializer13$g && _initializer13$g();
                _this._isLabelVisible = false;
                return _this;
              }

              var _proto = EditBox.prototype;

              _proto.__preload = function __preload() {
                this._init();
              };

              _proto.onEnable = function onEnable() {
                {
                  this._registerEvent();
                }

                this._ensureBackgroundSprite();

                if (this._impl) {
                  this._impl.onEnable();
                }
              };

              _proto.update = function update() {
                if (this._impl) {
                  this._impl.update();
                }
              };

              _proto.onDisable = function onDisable() {
                {
                  this._unregisterEvent();
                }

                this._unregisterBackgroundEvent();

                if (this._impl) {
                  this._impl.onDisable();
                }
              };

              _proto.onDestroy = function onDestroy() {
                if (this._impl) {
                  this._impl.clear();
                }
              };

              _proto.setFocus = function setFocus() {
                if (this._impl) {
                  this._impl.setFocus(true);
                }
              };

              _proto.focus = function focus() {
                if (this._impl) {
                  this._impl.setFocus(true);
                }
              };

              _proto.blur = function blur() {
                if (this._impl) {
                  this._impl.setFocus(false);
                }
              };

              _proto.isFocused = function isFocused() {
                if (this._impl) {
                  return this._impl.isFocused();
                }

                return false;
              };

              _proto._editBoxEditingDidBegan = function _editBoxEditingDidBegan() {
                EventHandler.emitEvents(this.editingDidBegan, this);
                this.node.emit(EventType$4.EDITING_DID_BEGAN, this);
              };

              _proto._editBoxEditingDidEnded = function _editBoxEditingDidEnded(text) {
                EventHandler.emitEvents(this.editingDidEnded, this);
                this.node.emit(EventType$4.EDITING_DID_ENDED, this, text);
              };

              _proto._editBoxTextChanged = function _editBoxTextChanged(text) {
                text = this._updateLabelStringStyle(text, true);
                this.string = text;
                EventHandler.emitEvents(this.textChanged, text, this);
                this.node.emit(EventType$4.TEXT_CHANGED, this);
              };

              _proto._editBoxEditingReturn = function _editBoxEditingReturn(text) {
                EventHandler.emitEvents(this.editingReturn, this);
                this.node.emit(EventType$4.EDITING_RETURN, this, text);
              };

              _proto._showLabels = function _showLabels() {
                this._isLabelVisible = true;

                this._updateLabels();
              };

              _proto._hideLabels = function _hideLabels() {
                this._isLabelVisible = false;

                if (this._textLabel) {
                  this._textLabel.node.active = false;
                }

                if (this._placeholderLabel) {
                  this._placeholderLabel.node.active = false;
                }
              };

              _proto._onTouchBegan = function _onTouchBegan(event) {
                event.propagationStopped = true;
              };

              _proto._onTouchCancel = function _onTouchCancel(event) {
                event.propagationStopped = true;
              };

              _proto._onTouchEnded = function _onTouchEnded(event) {
                if (this._impl) {
                  this._impl.beginEditing();
                }

                event.propagationStopped = true;
              };

              _proto._init = function _init() {
                this._updatePlaceholderLabel();

                this._updateTextLabel();

                this._isLabelVisible = true;
                this.node.on(NodeEventType.SIZE_CHANGED, this._resizeChildNodes, this);
                var impl = this._impl = new EditBox._EditBoxImpl();
                impl.init(this);

                this._updateString(this._string);

                this._syncSize();
              };

              _proto._ensureBackgroundSprite = function _ensureBackgroundSprite() {
                if (!this._background) {
                  var background = this.node.getComponent(Sprite);

                  if (!background) {
                    background = this.node.addComponent(Sprite);
                  }

                  if (background !== this._background) {
                    background.type = Sprite.Type.SLICED;
                    background.spriteFrame = this._backgroundImage;
                    this._background = background;

                    this._registerBackgroundEvent();
                  }
                }
              };

              _proto._updateTextLabel = function _updateTextLabel() {
                var textLabel = this._textLabel;

                if (!textLabel) {
                  var node = this.node.getChildByName('TEXT_LABEL');

                  if (!node) {
                    node = new Node('TEXT_LABEL');
                    node.layer = this.node.layer;
                  }

                  textLabel = node.getComponent(Label);

                  if (!textLabel) {
                    textLabel = node.addComponent(Label);
                  }

                  node.parent = this.node;
                  this._textLabel = textLabel;
                }

                if (this._inputMode === InputMode.ANY) {
                  textLabel.verticalAlign = VerticalTextAlignment.TOP;
                  textLabel.enableWrapText = true;
                } else {
                  textLabel.enableWrapText = false;
                }

                textLabel.string = this._updateLabelStringStyle(this._string);
              };

              _proto._updatePlaceholderLabel = function _updatePlaceholderLabel() {
                var placeholderLabel = this._placeholderLabel;

                if (!placeholderLabel) {
                  var node = this.node.getChildByName('PLACEHOLDER_LABEL');

                  if (!node) {
                    node = new Node('PLACEHOLDER_LABEL');
                    node.layer = this.node.layer;
                  }

                  placeholderLabel = node.getComponent(Label);

                  if (!placeholderLabel) {
                    placeholderLabel = node.addComponent(Label);
                  }

                  node.parent = this.node;
                  this._placeholderLabel = placeholderLabel;
                }

                if (this._inputMode === InputMode.ANY) {
                  placeholderLabel.enableWrapText = true;
                } else {
                  placeholderLabel.enableWrapText = false;
                }

                placeholderLabel.string = this.placeholder;
              };

              _proto._syncSize = function _syncSize() {
                var trans = this.node._uiProps.uiTransformComp;
                var size = trans.contentSize;

                if (this._background) {
                  var bgTrans = this._background.node._uiProps.uiTransformComp;
                  bgTrans.anchorPoint = trans.anchorPoint;
                  bgTrans.setContentSize(size);
                }

                this._updateLabelPosition(size);

                if (this._impl) {
                  this._impl.setSize(size.width, size.height);
                }
              };

              _proto._updateLabels = function _updateLabels() {
                if (this._isLabelVisible) {
                  var content = this._string;

                  if (this._textLabel) {
                    this._textLabel.node.active = content !== '';
                  }

                  if (this._placeholderLabel) {
                    this._placeholderLabel.node.active = content === '';
                  }
                }
              };

              _proto._updateString = function _updateString(text) {
                var textLabel = this._textLabel;

                if (!textLabel) {
                  return;
                }

                var displayText = text;

                if (displayText) {
                  displayText = this._updateLabelStringStyle(displayText);
                }

                textLabel.string = displayText;

                this._updateLabels();
              };

              _proto._updateLabelStringStyle = function _updateLabelStringStyle(text, ignorePassword) {
                if (ignorePassword === void 0) {
                  ignorePassword = false;
                }

                var inputFlag = this._inputFlag;

                if (!ignorePassword && inputFlag === InputFlag.PASSWORD) {
                  var passwordString = '';
                  var len = text.length;

                  for (var i = 0; i < len; ++i) {
                    passwordString += "\u25CF";
                  }

                  text = passwordString;
                } else if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
                  text = text.toUpperCase();
                } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
                  text = capitalize(text);
                } else if (inputFlag === InputFlag.INITIAL_CAPS_SENTENCE) {
                  text = capitalizeFirstLetter(text);
                }

                return text;
              };

              _proto._registerEvent = function _registerEvent() {
                this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
                this.node.on(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
                this.node.on(XrKeyboardEventType.XR_KEYBOARD_INPUT, this._xrKeyBoardInput, this);
              };

              _proto._unregisterEvent = function _unregisterEvent() {
                this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
                this.node.off(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
                this.node.off(XrKeyboardEventType.XR_KEYBOARD_INPUT, this._xrKeyBoardInput, this);
              };

              _proto._onBackgroundSpriteFrameChanged = function _onBackgroundSpriteFrameChanged() {
                if (!this._background) {
                  return;
                }

                this.backgroundImage = this._background.spriteFrame;
              };

              _proto._registerBackgroundEvent = function _registerBackgroundEvent() {
                var node = this._background && this._background.node;
                node === null || node === void 0 ? void 0 : node.on(Sprite.EventType.SPRITE_FRAME_CHANGED, this._onBackgroundSpriteFrameChanged, this);
              };

              _proto._unregisterBackgroundEvent = function _unregisterBackgroundEvent() {
                var node = this._background && this._background.node;
                node === null || node === void 0 ? void 0 : node.off(Sprite.EventType.SPRITE_FRAME_CHANGED, this._onBackgroundSpriteFrameChanged, this);
              };

              _proto._updateLabelPosition = function _updateLabelPosition(size) {
                var trans = this.node._uiProps.uiTransformComp;
                var offX = -trans.anchorX * trans.width;
                var offY = -trans.anchorY * trans.height;
                var placeholderLabel = this._placeholderLabel;
                var textLabel = this._textLabel;

                if (textLabel) {
                  textLabel.node._uiProps.uiTransformComp.setContentSize(size.width - LEFT_PADDING$1, size.height);

                  textLabel.node.setPosition(offX + LEFT_PADDING$1, offY + size.height, textLabel.node.position.z);

                  if (this._inputMode === InputMode.ANY) {
                    textLabel.verticalAlign = VerticalTextAlignment.TOP;
                  }

                  textLabel.enableWrapText = this._inputMode === InputMode.ANY;
                }

                if (placeholderLabel) {
                  placeholderLabel.node._uiProps.uiTransformComp.setContentSize(size.width - LEFT_PADDING$1, size.height);

                  placeholderLabel.lineHeight = size.height;
                  placeholderLabel.node.setPosition(offX + LEFT_PADDING$1, offY + size.height, placeholderLabel.node.position.z);
                  placeholderLabel.enableWrapText = this._inputMode === InputMode.ANY;
                }
              };

              _proto._resizeChildNodes = function _resizeChildNodes() {
                var trans = this.node._uiProps.uiTransformComp;
                var textLabelNode = this._textLabel && this._textLabel.node;

                if (textLabelNode) {
                  textLabelNode.setPosition(-trans.width / 2, trans.height / 2, textLabelNode.position.z);

                  textLabelNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
                }

                var placeholderLabelNode = this._placeholderLabel && this._placeholderLabel.node;

                if (placeholderLabelNode) {
                  placeholderLabelNode.setPosition(-trans.width / 2, trans.height / 2, placeholderLabelNode.position.z);

                  placeholderLabelNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
                }

                var backgroundNode = this._background && this._background.node;

                if (backgroundNode) {
                  backgroundNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
                }

                this._syncSize();
              };

              _proto._xrUnClick = function _xrUnClick() {
                this.node.emit(EventType$4.XR_EDITING_DID_BEGAN, this._maxLength, this.string);
              };

              _proto._xrKeyBoardInput = function _xrKeyBoardInput(str) {
                this.string = str;
              };

              _createClass(EditBox, [{
                key: "string",
                get: function get() {
                  return this._string;
                },
                set: function set(value) {
                  if (this._maxLength >= 0 && value.length >= this._maxLength) {
                    value = value.slice(0, this._maxLength);
                  }

                  if (this._string === value) {
                    return;
                  }

                  this._string = value;

                  this._updateString(value);
                }
              }, {
                key: "placeholder",
                get: function get() {
                  if (!this._placeholderLabel) {
                    return '';
                  }

                  return this._placeholderLabel.string;
                },
                set: function set(value) {
                  if (this._placeholderLabel) {
                    this._placeholderLabel.string = value;
                  }
                }
              }, {
                key: "textLabel",
                get: function get() {
                  return this._textLabel;
                },
                set: function set(oldValue) {
                  if (this._textLabel !== oldValue) {
                    this._textLabel = oldValue;

                    if (this._textLabel) {
                      this._updateTextLabel();

                      this._updateLabels();
                    }
                  }
                }
              }, {
                key: "placeholderLabel",
                get: function get() {
                  return this._placeholderLabel;
                },
                set: function set(oldValue) {
                  if (this._placeholderLabel !== oldValue) {
                    this._placeholderLabel = oldValue;

                    if (this._placeholderLabel) {
                      this._updatePlaceholderLabel();

                      this._updateLabels();
                    }
                  }
                }
              }, {
                key: "backgroundImage",
                get: function get() {
                  return this._backgroundImage;
                },
                set: function set(value) {
                  if (this._backgroundImage === value) {
                    return;
                  }

                  this._backgroundImage = value;

                  this._ensureBackgroundSprite();

                  this._background.spriteFrame = value;
                }
              }, {
                key: "inputFlag",
                get: function get() {
                  return this._inputFlag;
                },
                set: function set(value) {
                  if (this._inputFlag === value) {
                    return;
                  }

                  this._inputFlag = value;

                  this._updateString(this._string);
                }
              }, {
                key: "inputMode",
                get: function get() {
                  return this._inputMode;
                },
                set: function set(oldValue) {
                  if (this._inputMode !== oldValue) {
                    this._inputMode = oldValue;

                    this._updateTextLabel();

                    this._updatePlaceholderLabel();
                  }
                }
              }, {
                key: "returnType",
                get: function get() {
                  return this._returnType;
                },
                set: function set(value) {
                  this._returnType = value;
                }
              }, {
                key: "maxLength",
                get: function get() {
                  return this._maxLength;
                },
                set: function set(value) {
                  this._maxLength = value;
                }
              }, {
                key: "tabIndex",
                get: function get() {
                  return this._tabIndex;
                },
                set: function set(value) {
                  if (this._tabIndex !== value) {
                    this._tabIndex = value;

                    if (this._impl) {
                      this._impl.setTabIndex(value);
                    }
                  }
                }
              }]);

              return EditBox;
            }(Component), _class3$r._EditBoxImpl = EditBoxImplBase, _class3$r.KeyboardReturnType = KeyboardReturnType, _class3$r.InputFlag = InputFlag, _class3$r.InputMode = InputMode, _class3$r.EventType = EventType$4, _temp$B), (_applyDecoratedDescriptor(_class2$1J.prototype, "textLabel", [_dec4$H], Object.getOwnPropertyDescriptor(_class2$1J.prototype, "textLabel"), _class2$1J.prototype), _applyDecoratedDescriptor(_class2$1J.prototype, "placeholderLabel", [_dec5$A], Object.getOwnPropertyDescriptor(_class2$1J.prototype, "placeholderLabel"), _class2$1J.prototype), _applyDecoratedDescriptor(_class2$1J.prototype, "backgroundImage", [_dec6$t], Object.getOwnPropertyDescriptor(_class2$1J.prototype, "backgroundImage"), _class2$1J.prototype), _applyDecoratedDescriptor(_class2$1J.prototype, "inputFlag", [_dec7$m], Object.getOwnPropertyDescriptor(_class2$1J.prototype, "inputFlag"), _class2$1J.prototype), _applyDecoratedDescriptor(_class2$1J.prototype, "inputMode", [_dec8$g], Object.getOwnPropertyDescriptor(_class2$1J.prototype, "inputMode"), _class2$1J.prototype), _applyDecoratedDescriptor(_class2$1J.prototype, "returnType", [_dec9$e], Object.getOwnPropertyDescriptor(_class2$1J.prototype, "returnType"), _class2$1J.prototype), _initializer$1E = applyDecoratedInitializer(_class2$1J.prototype, "editingDidBegan", [_dec10$8, serializable$j], function () {
              return [];
            }), _initializer2$1o = applyDecoratedInitializer(_class2$1J.prototype, "textChanged", [_dec11$5, serializable$j], function () {
              return [];
            }), _initializer3$12 = applyDecoratedInitializer(_class2$1J.prototype, "editingDidEnded", [_dec12$3, serializable$j], function () {
              return [];
            }), _initializer4$U = applyDecoratedInitializer(_class2$1J.prototype, "editingReturn", [_dec13$3, serializable$j], function () {
              return [];
            }), _initializer5$I = applyDecoratedInitializer(_class2$1J.prototype, "_textLabel", [serializable$j], function () {
              return null;
            }), _initializer6$B = applyDecoratedInitializer(_class2$1J.prototype, "_placeholderLabel", [serializable$j], function () {
              return null;
            }), _initializer7$t = applyDecoratedInitializer(_class2$1J.prototype, "_returnType", [serializable$j], function () {
              return KeyboardReturnType.DEFAULT;
            }), _initializer8$q = applyDecoratedInitializer(_class2$1J.prototype, "_string", [serializable$j], function () {
              return '';
            }), _initializer9$n = applyDecoratedInitializer(_class2$1J.prototype, "_tabIndex", [serializable$j], function () {
              return 0;
            }), _initializer10$k = applyDecoratedInitializer(_class2$1J.prototype, "_backgroundImage", [serializable$j], function () {
              return null;
            }), _initializer11$g = applyDecoratedInitializer(_class2$1J.prototype, "_inputFlag", [serializable$j], function () {
              return InputFlag.DEFAULT;
            }), _initializer12$g = applyDecoratedInitializer(_class2$1J.prototype, "_inputMode", [serializable$j], function () {
              return InputMode.ANY;
            }), _initializer13$g = applyDecoratedInitializer(_class2$1J.prototype, "_maxLength", [serializable$j], function () {
              return 20;
            })), _class2$1J)) || _class$1_) || _class$1_) || _class$1_));

            if (typeof window === 'object' && typeof document === 'object' && !MINIGAME && !JSB && !RUNTIME_BASED) {
              EditBox._EditBoxImpl = EditBoxImpl;
            }

            legacyCC.internal.EditBox = EditBox;

            var _dec$1Y, _dec2$1u, _dec3$_, _dec4$I, _dec5$B, _dec6$u, _dec7$n, _dec8$h, _dec9$f, _class$1$, _class2$1K, _initializer$1F, _initializer2$1p, _initializer3$13, _initializer4$V, _initializer5$J, _initializer6$C, _initializer7$u, _initializer8$r, _initializer9$o, _initializer10$l, _initializer11$h, _initializer12$h, _initializer13$h, _initializer14$c, _initializer15$a, _initializer16$a, _class3$s, _temp$C;
            var Type;

            (function (Type) {
              Type[Type["NONE"] = 0] = "NONE";
              Type[Type["HORIZONTAL"] = 1] = "HORIZONTAL";
              Type[Type["VERTICAL"] = 2] = "VERTICAL";
              Type[Type["GRID"] = 3] = "GRID";
            })(Type || (Type = {}));

            ccenum(Type);
            var ResizeMode;

            (function (ResizeMode) {
              ResizeMode[ResizeMode["NONE"] = 0] = "NONE";
              ResizeMode[ResizeMode["CONTAINER"] = 1] = "CONTAINER";
              ResizeMode[ResizeMode["CHILDREN"] = 2] = "CHILDREN";
            })(ResizeMode || (ResizeMode = {}));

            ccenum(ResizeMode);
            var AxisDirection;

            (function (AxisDirection) {
              AxisDirection[AxisDirection["HORIZONTAL"] = 0] = "HORIZONTAL";
              AxisDirection[AxisDirection["VERTICAL"] = 1] = "VERTICAL";
            })(AxisDirection || (AxisDirection = {}));

            ccenum(AxisDirection);
            var VerticalDirection;

            (function (VerticalDirection) {
              VerticalDirection[VerticalDirection["BOTTOM_TO_TOP"] = 0] = "BOTTOM_TO_TOP";
              VerticalDirection[VerticalDirection["TOP_TO_BOTTOM"] = 1] = "TOP_TO_BOTTOM";
            })(VerticalDirection || (VerticalDirection = {}));

            ccenum(VerticalDirection);
            var HorizontalDirection;

            (function (HorizontalDirection) {
              HorizontalDirection[HorizontalDirection["LEFT_TO_RIGHT"] = 0] = "LEFT_TO_RIGHT";
              HorizontalDirection[HorizontalDirection["RIGHT_TO_LEFT"] = 1] = "RIGHT_TO_LEFT";
            })(HorizontalDirection || (HorizontalDirection = {}));

            ccenum(HorizontalDirection);
            var Constraint$2;

            (function (Constraint) {
              Constraint[Constraint["NONE"] = 0] = "NONE";
              Constraint[Constraint["FIXED_ROW"] = 1] = "FIXED_ROW";
              Constraint[Constraint["FIXED_COL"] = 2] = "FIXED_COL";
            })(Constraint$2 || (Constraint$2 = {}));

            ccenum(Constraint$2);

            var _tempVec3 = new Vec3();

            var Layout = exports('Layout', (_dec$1Y = ccclass$p('cc.Layout'), _dec2$1u = executionOrder(110), _dec3$_ = requireComponent(UITransform), _dec4$I = type$8(Type), _dec5$B = type$8(ResizeMode), _dec6$u = type$8(AxisDirection), _dec7$n = type$8(VerticalDirection), _dec8$h = type$8(HorizontalDirection), _dec9$f = type$8(Constraint$2), _dec$1Y(_class$1$ = _dec2$1u(_class$1$ = _dec3$_(_class$1$ = (_class2$1K = (_temp$C = _class3$s = function (_Component) {
              _inheritsLoose(Layout, _Component);

              function Layout() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._resizeMode = _initializer$1F && _initializer$1F();
                _this._layoutType = _initializer2$1p && _initializer2$1p();
                _this._cellSize = _initializer3$13 && _initializer3$13();
                _this._startAxis = _initializer4$V && _initializer4$V();
                _this._paddingLeft = _initializer5$J && _initializer5$J();
                _this._paddingRight = _initializer6$C && _initializer6$C();
                _this._paddingTop = _initializer7$u && _initializer7$u();
                _this._paddingBottom = _initializer8$r && _initializer8$r();
                _this._spacingX = _initializer9$o && _initializer9$o();
                _this._spacingY = _initializer10$l && _initializer10$l();
                _this._verticalDirection = _initializer11$h && _initializer11$h();
                _this._horizontalDirection = _initializer12$h && _initializer12$h();
                _this._constraint = _initializer13$h && _initializer13$h();
                _this._constraintNum = _initializer14$c && _initializer14$c();
                _this._affectedByScale = _initializer15$a && _initializer15$a();
                _this._isAlign = _initializer16$a && _initializer16$a();
                _this._layoutSize = new Size$1(300, 200);
                _this._layoutDirty = true;
                _this._childrenDirty = false;
                _this._usefulLayoutObj = [];
                _this._init = false;
                return _this;
              }

              var _proto = Layout.prototype;

              _proto.updateLayout = function updateLayout(force) {
                if (force === void 0) {
                  force = false;
                }

                if (this._layoutDirty || force) {
                  this._doLayout();

                  this._layoutDirty = false;
                }
              };

              _proto.onEnable = function onEnable() {
                this._addEventListeners();

                var trans = this.node._uiProps.uiTransformComp;

                if (trans.contentSize.equals(Size$1.ZERO)) {
                  trans.setContentSize(this._layoutSize);
                }

                this._childrenChanged();
              };

              _proto.onDisable = function onDisable() {
                this._usefulLayoutObj.length = 0;

                this._removeEventListeners();
              };

              _proto._checkUsefulObj = function _checkUsefulObj() {
                this._usefulLayoutObj.length = 0;
                var children = this.node.children;

                for (var i = 0; i < children.length; ++i) {
                  var child = children[i];
                  var uiTrans = child._uiProps.uiTransformComp;

                  if (child.activeInHierarchy && uiTrans) {
                    this._usefulLayoutObj.push(uiTrans);
                  }
                }
              };

              _proto._addEventListeners = function _addEventListeners() {
                director.on(Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
                this.node.on(NodeEventType.SIZE_CHANGED, this._resized, this);
                this.node.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
                this.node.on(NodeEventType.CHILD_ADDED, this._childAdded, this);
                this.node.on(NodeEventType.CHILD_REMOVED, this._childRemoved, this);
                this.node.on(NodeEventType.SIBLING_ORDER_CHANGED, this._childrenChanged, this);
                this.node.on('childrenSiblingOrderChanged', this.updateLayout, this);

                this._addChildrenEventListeners();
              };

              _proto._removeEventListeners = function _removeEventListeners() {
                director.off(Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
                this.node.off(NodeEventType.SIZE_CHANGED, this._resized, this);
                this.node.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
                this.node.off(NodeEventType.CHILD_ADDED, this._childAdded, this);
                this.node.off(NodeEventType.CHILD_REMOVED, this._childRemoved, this);
                this.node.off(NodeEventType.SIBLING_ORDER_CHANGED, this._childrenChanged, this);
                this.node.off('childrenSiblingOrderChanged', this.updateLayout, this);

                this._removeChildrenEventListeners();
              };

              _proto._addChildrenEventListeners = function _addChildrenEventListeners() {
                var children = this.node.children;

                for (var i = 0; i < children.length; ++i) {
                  var child = children[i];
                  child.on(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
                  child.on(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
                  child.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
                  child.on(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
                }
              };

              _proto._removeChildrenEventListeners = function _removeChildrenEventListeners() {
                var children = this.node.children;

                for (var i = 0; i < children.length; ++i) {
                  var child = children[i];
                  child.off(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
                  child.off(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
                  child.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
                  child.off(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
                }
              };

              _proto._childAdded = function _childAdded(child) {
                child.on(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
                child.on(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
                child.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
                child.on(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);

                this._childrenChanged();
              };

              _proto._childRemoved = function _childRemoved(child) {
                child.off(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
                child.off(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
                child.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
                child.off(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);

                this._childrenChanged();
              };

              _proto._resized = function _resized() {
                this._layoutSize.set(this.node._uiProps.uiTransformComp.contentSize);

                this._doLayoutDirty();
              };

              _proto._doLayoutHorizontally = function _doLayoutHorizontally(baseWidth, rowBreak, fnPositionY, applyChildren) {
                var trans = this.node._uiProps.uiTransformComp;
                var layoutAnchor = trans.anchorPoint;

                var limit = this._getFixedBreakingNum();

                var sign = 1;
                var paddingX = this._paddingLeft;

                if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                  sign = -1;
                  paddingX = this._paddingRight;
                }

                var startPos = (this._horizontalDirection - layoutAnchor.x) * baseWidth + sign * paddingX;
                var nextX = startPos - sign * this._spacingX;
                var totalHeight = 0;
                var rowMaxHeight = 0;
                var tempMaxHeight = 0;
                var maxHeight = 0;
                var isBreak = false;
                var activeChildCount = this._usefulLayoutObj.length;
                var newChildWidth = this._cellSize.width;

                var paddingH = this._getPaddingH();

                if (this._layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN) {
                  newChildWidth = (baseWidth - paddingH - (activeChildCount - 1) * this._spacingX) / activeChildCount;
                }

                var children = this._usefulLayoutObj;

                for (var i = 0; i < children.length; ++i) {
                  var childTrans = children[i];
                  var child = childTrans.node;
                  var scale = child.scale;

                  var childScaleX = this._getUsedScaleValue(scale.x);

                  var childScaleY = this._getUsedScaleValue(scale.y);

                  if (this._resizeMode === ResizeMode.CHILDREN) {
                    childTrans.width = newChildWidth / childScaleX;

                    if (this._layoutType === Type.GRID) {
                      childTrans.height = this._cellSize.height / childScaleY;
                    }
                  }

                  var anchorX = Math.abs(this._horizontalDirection - childTrans.anchorX);
                  var childBoundingBoxWidth = childTrans.width * childScaleX;
                  var childBoundingBoxHeight = childTrans.height * childScaleY;

                  if (childBoundingBoxHeight > tempMaxHeight) {
                    maxHeight = Math.max(tempMaxHeight, maxHeight);
                    rowMaxHeight = tempMaxHeight || childBoundingBoxHeight;
                    tempMaxHeight = childBoundingBoxHeight;
                  }

                  nextX += sign * (anchorX * childBoundingBoxWidth + this._spacingX);
                  var rightBoundaryOfChild = sign * (1 - anchorX) * childBoundingBoxWidth;

                  if (rowBreak) {
                    if (limit > 0) {
                      isBreak = i / limit > 0 && i % limit === 0;

                      if (isBreak) {
                        rowMaxHeight = tempMaxHeight > childBoundingBoxHeight ? tempMaxHeight : rowMaxHeight;
                      }
                    } else if (childBoundingBoxWidth > baseWidth - paddingH) {
                      if (nextX > startPos + sign * (anchorX * childBoundingBoxWidth)) {
                        isBreak = true;
                      }
                    } else {
                      var boundary = (1 - this._horizontalDirection - layoutAnchor.x) * baseWidth;
                      var rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (sign > 0 ? this._paddingRight : this._paddingLeft);
                      isBreak = Math.abs(rowBreakBoundary) > Math.abs(boundary);
                    }

                    if (isBreak) {
                      nextX = startPos + sign * (anchorX * childBoundingBoxWidth);

                      if (childBoundingBoxHeight !== tempMaxHeight) {
                        rowMaxHeight = tempMaxHeight;
                      }

                      totalHeight += rowMaxHeight + this._spacingY;
                      rowMaxHeight = tempMaxHeight = childBoundingBoxHeight;
                    }
                  }

                  var finalPositionY = fnPositionY(child, childTrans, totalHeight);

                  if (applyChildren) {
                    child.setPosition(nextX, finalPositionY);
                  }

                  nextX += rightBoundaryOfChild;
                }

                rowMaxHeight = Math.max(rowMaxHeight, tempMaxHeight);

                var containerResizeBoundary = Math.max(maxHeight, totalHeight + rowMaxHeight) + this._getPaddingV();

                return containerResizeBoundary;
              };

              _proto._doLayoutVertically = function _doLayoutVertically(baseHeight, columnBreak, fnPositionX, applyChildren) {
                var trans = this.node._uiProps.uiTransformComp;
                var layoutAnchor = trans.anchorPoint;

                var limit = this._getFixedBreakingNum();

                var sign = 1;
                var paddingY = this._paddingBottom;

                if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                  sign = -1;
                  paddingY = this._paddingTop;
                }

                var startPos = (this._verticalDirection - layoutAnchor.y) * baseHeight + sign * paddingY;
                var nextY = startPos - sign * this._spacingY;
                var tempMaxWidth = 0;
                var maxWidth = 0;
                var colMaxWidth = 0;
                var totalWidth = 0;
                var isBreak = false;
                var activeChildCount = this._usefulLayoutObj.length;
                var newChildHeight = this._cellSize.height;

                var paddingV = this._getPaddingV();

                if (this._layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN) {
                  newChildHeight = (baseHeight - paddingV - (activeChildCount - 1) * this._spacingY) / activeChildCount;
                }

                var children = this._usefulLayoutObj;

                for (var i = 0; i < children.length; ++i) {
                  var childTrans = children[i];
                  var child = childTrans.node;
                  var scale = child.scale;

                  var childScaleX = this._getUsedScaleValue(scale.x);

                  var childScaleY = this._getUsedScaleValue(scale.y);

                  if (this._resizeMode === ResizeMode.CHILDREN) {
                    childTrans.height = newChildHeight / childScaleY;

                    if (this._layoutType === Type.GRID) {
                      childTrans.width = this._cellSize.width / childScaleX;
                    }
                  }

                  var anchorY = Math.abs(this._verticalDirection - childTrans.anchorY);
                  var childBoundingBoxWidth = childTrans.width * childScaleX;
                  var childBoundingBoxHeight = childTrans.height * childScaleY;

                  if (childBoundingBoxWidth > tempMaxWidth) {
                    maxWidth = Math.max(tempMaxWidth, maxWidth);
                    colMaxWidth = tempMaxWidth || childBoundingBoxWidth;
                    tempMaxWidth = childBoundingBoxWidth;
                  }

                  nextY += sign * (anchorY * childBoundingBoxHeight + this._spacingY);
                  var topBoundaryOfChild = sign * (1 - anchorY) * childBoundingBoxHeight;

                  if (columnBreak) {
                    if (limit > 0) {
                      isBreak = i / limit > 0 && i % limit === 0;

                      if (isBreak) {
                        colMaxWidth = tempMaxWidth > childBoundingBoxHeight ? tempMaxWidth : colMaxWidth;
                      }
                    } else if (childBoundingBoxHeight > baseHeight - paddingV) {
                      if (nextY > startPos + sign * (anchorY * childBoundingBoxHeight)) {
                        isBreak = true;
                      }
                    } else {
                      var boundary = (1 - this._verticalDirection - layoutAnchor.y) * baseHeight;
                      var columnBreakBoundary = nextY + topBoundaryOfChild + sign * (sign > 0 ? this._paddingTop : this._paddingBottom);
                      isBreak = Math.abs(columnBreakBoundary) > Math.abs(boundary);
                    }

                    if (isBreak) {
                      nextY = startPos + sign * (anchorY * childBoundingBoxHeight);

                      if (childBoundingBoxWidth !== tempMaxWidth) {
                        colMaxWidth = tempMaxWidth;
                      }

                      totalWidth += colMaxWidth + this._spacingX;
                      colMaxWidth = tempMaxWidth = childBoundingBoxWidth;
                    }
                  }

                  var finalPositionX = fnPositionX(child, childTrans, totalWidth);

                  if (applyChildren) {
                    child.getPosition(_tempVec3);
                    child.setPosition(finalPositionX, nextY, _tempVec3.z);
                  }

                  nextY += topBoundaryOfChild;
                }

                colMaxWidth = Math.max(colMaxWidth, tempMaxWidth);

                var containerResizeBoundary = Math.max(maxWidth, totalWidth + colMaxWidth) + this._getPaddingH();

                return containerResizeBoundary;
              };

              _proto._doLayoutGridAxisHorizontal = function _doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) {
                var _this2 = this;

                var baseWidth = layoutSize.width;
                var sign = 1;
                var bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height;
                var paddingY = this._paddingBottom;

                if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                  sign = -1;
                  bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height;
                  paddingY = this._paddingTop;
                }

                var fnPositionY = function fnPositionY(child, childTrans, topOffset) {
                  return bottomBoundaryOfLayout + sign * (topOffset + (1 - childTrans.anchorY) * childTrans.height * _this2._getUsedScaleValue(child.scale.y) + paddingY);
                };

                var newHeight = 0;

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  newHeight = this._doLayoutHorizontally(baseWidth, true, fnPositionY, false);
                  bottomBoundaryOfLayout = -layoutAnchor.y * newHeight;

                  if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                    sign = -1;
                    bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight;
                  }
                }

                this._doLayoutHorizontally(baseWidth, true, fnPositionY, true);

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  this.node._uiProps.uiTransformComp.setContentSize(baseWidth, newHeight);
                }
              };

              _proto._doLayoutGridAxisVertical = function _doLayoutGridAxisVertical(layoutAnchor, layoutSize) {
                var _this3 = this;

                var baseHeight = layoutSize.height;
                var sign = 1;
                var leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width;
                var paddingX = this._paddingLeft;

                if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                  sign = -1;
                  leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width;
                  paddingX = this._paddingRight;
                }

                var fnPositionX = function fnPositionX(child, childTrans, leftOffset) {
                  return leftBoundaryOfLayout + sign * (leftOffset + (1 - childTrans.anchorX) * childTrans.width * _this3._getUsedScaleValue(child.scale.x) + paddingX);
                };

                var newWidth = 0;

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  newWidth = this._doLayoutVertically(baseHeight, true, fnPositionX, false);
                  leftBoundaryOfLayout = -layoutAnchor.x * newWidth;

                  if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                    sign = -1;
                    leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth;
                  }
                }

                this._doLayoutVertically(baseHeight, true, fnPositionX, true);

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  this.node._uiProps.uiTransformComp.setContentSize(newWidth, baseHeight);
                }
              };

              _proto._doLayoutGrid = function _doLayoutGrid() {
                var trans = this.node._uiProps.uiTransformComp;
                var layoutAnchor = trans.anchorPoint;
                var layoutSize = trans.contentSize;

                if (this.startAxis === AxisDirection.HORIZONTAL) {
                  this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize);
                } else if (this.startAxis === AxisDirection.VERTICAL) {
                  this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
                }
              };

              _proto._getHorizontalBaseWidth = function _getHorizontalBaseWidth(horizontal) {

                var children = this._usefulLayoutObj;
                var baseSize = 0;
                var activeChildCount = children.length;

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  for (var i = 0; i < children.length; ++i) {
                    var childTrans = children[i];
                    var child = childTrans.node;
                    var scale = child.scale;
                    baseSize += childTrans.width * this._getUsedScaleValue(scale.x);
                  }

                  baseSize += (activeChildCount - 1) * this._spacingX + this._getPaddingH();
                } else {
                  baseSize = this.node._uiProps.uiTransformComp.width;
                }

                return baseSize;
              };

              _proto._getVerticalBaseHeight = function _getVerticalBaseHeight() {
                var children = this._usefulLayoutObj;
                var baseSize = 0;
                var activeChildCount = children.length;

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  for (var i = 0; i < children.length; ++i) {
                    var childTrans = children[i];
                    var child = childTrans.node;
                    var scale = child.scale;
                    baseSize += childTrans.height * this._getUsedScaleValue(scale.y);
                  }

                  baseSize += (activeChildCount - 1) * this._spacingY + this._getPaddingV();
                } else {
                  baseSize = this.node._uiProps.uiTransformComp.height;
                }

                return baseSize;
              };

              _proto._doLayout = function _doLayout() {
                var _this4 = this;

                if (!this._init || this._childrenDirty) {
                  this._checkUsefulObj();

                  this._init = true;
                  this._childrenDirty = false;
                }

                if (this._layoutType === Type.HORIZONTAL) {
                  var newWidth = this._getHorizontalBaseWidth();

                  var fnPositionY = function fnPositionY(child) {
                    var pos = _this4._isAlign ? Vec3.ZERO : child.position;
                    return pos.y;
                  };

                  this._doLayoutHorizontally(newWidth, false, fnPositionY, true);

                  this.node._uiProps.uiTransformComp.width = newWidth;
                } else if (this._layoutType === Type.VERTICAL) {
                  var newHeight = this._getVerticalBaseHeight();

                  var fnPositionX = function fnPositionX(child) {
                    var pos = _this4._isAlign ? Vec3.ZERO : child.position;
                    return pos.x;
                  };

                  this._doLayoutVertically(newHeight, false, fnPositionX, true);

                  this.node._uiProps.uiTransformComp.height = newHeight;
                } else if (this._layoutType === Type.GRID) {
                  this._doLayoutGrid();
                }
              };

              _proto._getUsedScaleValue = function _getUsedScaleValue(value) {
                return this._affectedByScale ? Math.abs(value) : 1;
              };

              _proto._transformDirty = function _transformDirty(type) {
                if (!(type & TransformBit.SCALE) || !(type & TransformBit.POSITION) || !this._affectedByScale) {
                  return;
                }

                this._doLayoutDirty();
              };

              _proto._doLayoutDirty = function _doLayoutDirty() {
                this._layoutDirty = true;
              };

              _proto._childrenChanged = function _childrenChanged() {
                this._childrenDirty = true;

                this._doLayoutDirty();
              };

              _proto._getPaddingH = function _getPaddingH() {
                return this._paddingLeft + this._paddingRight;
              };

              _proto._getPaddingV = function _getPaddingV() {
                return this._paddingTop + this._paddingBottom;
              };

              _proto._getFixedBreakingNum = function _getFixedBreakingNum() {
                if (this._layoutType !== Type.GRID || this._constraint === Constraint$2.NONE || this._constraintNum <= 0) {
                  return 0;
                }

                var num = this._constraint === Constraint$2.FIXED_ROW ? Math.ceil(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum;

                if (this._startAxis === AxisDirection.VERTICAL) {
                  num = this._constraint === Constraint$2.FIXED_COL ? Math.ceil(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum;
                }

                return num;
              };

              _createClass(Layout, [{
                key: "alignHorizontal",
                get: function get() {
                  return this._isAlign;
                },
                set: function set(value) {
                  if (this._layoutType !== Type.HORIZONTAL) {
                    return;
                  }

                  this._isAlign = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "alignVertical",
                get: function get() {
                  return this._isAlign;
                },
                set: function set(value) {
                  if (this._layoutType !== Type.VERTICAL) {
                    return;
                  }

                  this._isAlign = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "type",
                get: function get() {
                  return this._layoutType;
                },
                set: function set(value) {
                  this._layoutType = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "resizeMode",
                get: function get() {
                  return this._resizeMode;
                },
                set: function set(value) {
                  if (this._layoutType === Type.NONE) {
                    return;
                  }

                  this._resizeMode = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "cellSize",
                get: function get() {
                  return this._cellSize;
                },
                set: function set(value) {
                  if (this._cellSize === value) {
                    return;
                  }

                  this._cellSize.set(value);

                  this._doLayoutDirty();
                }
              }, {
                key: "startAxis",
                get: function get() {
                  return this._startAxis;
                },
                set: function set(value) {
                  if (this._startAxis === value) {
                    return;
                  }

                  this._startAxis = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "paddingLeft",
                get: function get() {
                  return this._paddingLeft;
                },
                set: function set(value) {
                  if (this._paddingLeft === value) {
                    return;
                  }

                  this._paddingLeft = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "paddingRight",
                get: function get() {
                  return this._paddingRight;
                },
                set: function set(value) {
                  if (this._paddingRight === value) {
                    return;
                  }

                  this._paddingRight = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "paddingTop",
                get: function get() {
                  return this._paddingTop;
                },
                set: function set(value) {
                  if (this._paddingTop === value) {
                    return;
                  }

                  this._paddingTop = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "paddingBottom",
                get: function get() {
                  return this._paddingBottom;
                },
                set: function set(value) {
                  if (this._paddingBottom === value) {
                    return;
                  }

                  this._paddingBottom = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "spacingX",
                get: function get() {
                  return this._spacingX;
                },
                set: function set(value) {
                  if (this._spacingX === value) {
                    return;
                  }

                  this._spacingX = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "spacingY",
                get: function get() {
                  return this._spacingY;
                },
                set: function set(value) {
                  if (this._spacingY === value) {
                    return;
                  }

                  this._spacingY = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "verticalDirection",
                get: function get() {
                  return this._verticalDirection;
                },
                set: function set(value) {
                  if (this._verticalDirection === value) {
                    return;
                  }

                  this._verticalDirection = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "horizontalDirection",
                get: function get() {
                  return this._horizontalDirection;
                },
                set: function set(value) {
                  if (this._horizontalDirection === value) {
                    return;
                  }

                  this._horizontalDirection = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "padding",
                get: function get() {
                  return this._paddingLeft;
                },
                set: function set(value) {
                  if (this.paddingLeft !== value || this._paddingRight !== value || this._paddingTop !== value || this._paddingBottom !== value) {
                    this._paddingLeft = this._paddingRight = this._paddingTop = this._paddingBottom = value;

                    this._doLayoutDirty();
                  }
                }
              }, {
                key: "constraint",
                get: function get() {
                  return this._constraint;
                },
                set: function set(value) {
                  if (this._layoutType === Type.NONE || this._constraint === value) {
                    return;
                  }

                  this._constraint = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "constraintNum",
                get: function get() {
                  return this._constraintNum;
                },
                set: function set(value) {
                  if (this._constraint === Constraint$2.NONE || this._constraintNum === value) {
                    return;
                  }

                  if (value <= 0) {
                    warn('Limit values to be greater than 0');
                  }

                  this._constraintNum = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "affectedByScale",
                get: function get() {
                  return this._affectedByScale;
                },
                set: function set(value) {
                  this._affectedByScale = value;

                  this._doLayoutDirty();
                }
              }]);

              return Layout;
            }(Component), _class3$s.Type = Type, _class3$s.VerticalDirection = VerticalDirection, _class3$s.HorizontalDirection = HorizontalDirection, _class3$s.ResizeMode = ResizeMode, _class3$s.AxisDirection = AxisDirection, _class3$s.Constraint = Constraint$2, _temp$C), (_applyDecoratedDescriptor(_class2$1K.prototype, "type", [_dec4$I], Object.getOwnPropertyDescriptor(_class2$1K.prototype, "type"), _class2$1K.prototype), _applyDecoratedDescriptor(_class2$1K.prototype, "resizeMode", [_dec5$B], Object.getOwnPropertyDescriptor(_class2$1K.prototype, "resizeMode"), _class2$1K.prototype), _applyDecoratedDescriptor(_class2$1K.prototype, "startAxis", [_dec6$u], Object.getOwnPropertyDescriptor(_class2$1K.prototype, "startAxis"), _class2$1K.prototype), _applyDecoratedDescriptor(_class2$1K.prototype, "verticalDirection", [_dec7$n], Object.getOwnPropertyDescriptor(_class2$1K.prototype, "verticalDirection"), _class2$1K.prototype), _applyDecoratedDescriptor(_class2$1K.prototype, "horizontalDirection", [_dec8$h], Object.getOwnPropertyDescriptor(_class2$1K.prototype, "horizontalDirection"), _class2$1K.prototype), _applyDecoratedDescriptor(_class2$1K.prototype, "constraint", [_dec9$f], Object.getOwnPropertyDescriptor(_class2$1K.prototype, "constraint"), _class2$1K.prototype), _initializer$1F = applyDecoratedInitializer(_class2$1K.prototype, "_resizeMode", [serializable$j], function () {
              return ResizeMode.NONE;
            }), _initializer2$1p = applyDecoratedInitializer(_class2$1K.prototype, "_layoutType", [serializable$j], function () {
              return Type.NONE;
            }), _initializer3$13 = applyDecoratedInitializer(_class2$1K.prototype, "_cellSize", [serializable$j], function () {
              return new Size$1(40, 40);
            }), _initializer4$V = applyDecoratedInitializer(_class2$1K.prototype, "_startAxis", [serializable$j], function () {
              return AxisDirection.HORIZONTAL;
            }), _initializer5$J = applyDecoratedInitializer(_class2$1K.prototype, "_paddingLeft", [serializable$j], function () {
              return 0;
            }), _initializer6$C = applyDecoratedInitializer(_class2$1K.prototype, "_paddingRight", [serializable$j], function () {
              return 0;
            }), _initializer7$u = applyDecoratedInitializer(_class2$1K.prototype, "_paddingTop", [serializable$j], function () {
              return 0;
            }), _initializer8$r = applyDecoratedInitializer(_class2$1K.prototype, "_paddingBottom", [serializable$j], function () {
              return 0;
            }), _initializer9$o = applyDecoratedInitializer(_class2$1K.prototype, "_spacingX", [serializable$j], function () {
              return 0;
            }), _initializer10$l = applyDecoratedInitializer(_class2$1K.prototype, "_spacingY", [serializable$j], function () {
              return 0;
            }), _initializer11$h = applyDecoratedInitializer(_class2$1K.prototype, "_verticalDirection", [serializable$j], function () {
              return VerticalDirection.TOP_TO_BOTTOM;
            }), _initializer12$h = applyDecoratedInitializer(_class2$1K.prototype, "_horizontalDirection", [serializable$j], function () {
              return HorizontalDirection.LEFT_TO_RIGHT;
            }), _initializer13$h = applyDecoratedInitializer(_class2$1K.prototype, "_constraint", [serializable$j], function () {
              return Constraint$2.NONE;
            }), _initializer14$c = applyDecoratedInitializer(_class2$1K.prototype, "_constraintNum", [serializable$j], function () {
              return 2;
            }), _initializer15$a = applyDecoratedInitializer(_class2$1K.prototype, "_affectedByScale", [serializable$j], function () {
              return false;
            }), _initializer16$a = applyDecoratedInitializer(_class2$1K.prototype, "_isAlign", [serializable$j], function () {
              return false;
            })), _class2$1K)) || _class$1$) || _class$1$) || _class$1$));
            legacyCC.Layout = Layout;

            var _dec$1Z, _dec2$1v, _dec3$$, _dec4$J, _dec5$C, _class$20, _class2$1L, _initializer$1G, _initializer2$1q, _initializer3$14, _initializer4$W, _initializer5$K, _class3$t, _temp$D;
            var Mode$4;

            (function (Mode) {
              Mode[Mode["HORIZONTAL"] = 0] = "HORIZONTAL";
              Mode[Mode["VERTICAL"] = 1] = "VERTICAL";
              Mode[Mode["FILLED"] = 2] = "FILLED";
            })(Mode$4 || (Mode$4 = {}));

            Enum(Mode$4);
            var ProgressBar = exports('ProgressBar', (_dec$1Z = ccclass$p('cc.ProgressBar'), _dec2$1v = executionOrder(110), _dec3$$ = requireComponent(UITransform), _dec4$J = type$8(Sprite), _dec5$C = type$8(Mode$4), _dec$1Z(_class$20 = _dec2$1v(_class$20 = _dec3$$(_class$20 = (_class2$1L = (_temp$D = _class3$t = function (_Component) {
              _inheritsLoose(ProgressBar, _Component);

              function ProgressBar() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._barSprite = _initializer$1G && _initializer$1G();
                _this._mode = _initializer2$1q && _initializer2$1q();
                _this._totalLength = _initializer3$14 && _initializer3$14();
                _this._progress = _initializer4$W && _initializer4$W();
                _this._reverse = _initializer5$K && _initializer5$K();
                return _this;
              }

              var _proto = ProgressBar.prototype;

              _proto._initBarSprite = function _initBarSprite() {
                if (this._barSprite) {
                  var entity = this._barSprite.node;

                  if (!entity) {
                    return;
                  }

                  var trans = this.node._uiProps.uiTransformComp;
                  var nodeSize = trans.contentSize;
                  var nodeAnchor = trans.anchorPoint;
                  var barSpriteSize = entity._uiProps.uiTransformComp.contentSize;

                  if (this._barSprite.fillType === Sprite.FillType.RADIAL) {
                    this._mode = Mode$4.FILLED;
                  }

                  if (this._mode === Mode$4.HORIZONTAL) {
                    this.totalLength = barSpriteSize.width;
                  } else if (this._mode === Mode$4.VERTICAL) {
                    this.totalLength = barSpriteSize.height;
                  } else {
                    this.totalLength = this._barSprite.fillRange;
                  }

                  if (entity.parent === this.node) {
                    var x = -nodeSize.width * nodeAnchor.x;
                    entity.setPosition(x, 0, 0);
                  }
                }
              };

              _proto._updateBarStatus = function _updateBarStatus() {
                if (this._barSprite) {
                  var entity = this._barSprite.node;

                  if (!entity) {
                    return;
                  }

                  var entTrans = entity._uiProps.uiTransformComp;
                  var entityAnchorPoint = entTrans.anchorPoint;
                  var entitySize = entTrans.contentSize;
                  var entityPosition = entity.getPosition();
                  var anchorPoint = new Vec2(0, 0.5);
                  var progress = clamp01(this._progress);
                  var actualLenth = this._totalLength * progress;
                  var finalContentSize = entitySize;
                  var totalWidth = 0;
                  var totalHeight = 0;

                  switch (this._mode) {
                    case Mode$4.HORIZONTAL:
                      if (this._reverse) {
                        anchorPoint = new Vec2(1, 0.5);
                      }

                      finalContentSize = new Size$1(actualLenth, entitySize.height);
                      totalWidth = this._totalLength;
                      totalHeight = entitySize.height;
                      break;

                    case Mode$4.VERTICAL:
                      if (this._reverse) {
                        anchorPoint = new Vec2(0.5, 1);
                      } else {
                        anchorPoint = new Vec2(0.5, 0);
                      }

                      finalContentSize = new Size$1(entitySize.width, actualLenth);
                      totalWidth = entitySize.width;
                      totalHeight = this._totalLength;
                      break;
                  }

                  if (this._mode === Mode$4.FILLED) {
                    if (this._barSprite.type !== Sprite.Type.FILLED) {
                      warn('ProgressBar FILLED mode only works when barSprite\'s Type is FILLED!');
                    } else {
                      if (this._reverse) {
                        actualLenth *= -1;
                      }

                      this._barSprite.fillRange = actualLenth;
                    }
                  } else if (this._barSprite.type !== Sprite.Type.FILLED) {
                    var anchorOffsetX = anchorPoint.x - entityAnchorPoint.x;
                    var anchorOffsetY = anchorPoint.y - entityAnchorPoint.y;
                    var finalPosition = new Vec3(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY, 0);
                    entity.setPosition(entityPosition.x + finalPosition.x, entityPosition.y + finalPosition.y, entityPosition.z);
                    entTrans.setAnchorPoint(anchorPoint);
                    entTrans.setContentSize(finalContentSize);
                  } else {
                    warn('ProgressBar non-FILLED mode only works when barSprite\'s Type is non-FILLED!');
                  }
                }
              };

              _createClass(ProgressBar, [{
                key: "barSprite",
                get: function get() {
                  return this._barSprite;
                },
                set: function set(value) {
                  if (this._barSprite === value) {
                    return;
                  }

                  this._barSprite = value;

                  this._initBarSprite();
                }
              }, {
                key: "mode",
                get: function get() {
                  return this._mode;
                },
                set: function set(value) {
                  if (this._mode === value) {
                    return;
                  }

                  this._mode = value;

                  if (this._barSprite) {
                    var entity = this._barSprite.node;

                    if (!entity) {
                      return;
                    }

                    var entitySize = entity._uiProps.uiTransformComp.contentSize;

                    if (this._mode === Mode$4.HORIZONTAL) {
                      this.totalLength = entitySize.width;
                    } else if (this._mode === Mode$4.VERTICAL) {
                      this.totalLength = entitySize.height;
                    } else if (this._mode === Mode$4.FILLED) {
                      this.totalLength = this._barSprite.fillRange;
                    }
                  }
                }
              }, {
                key: "totalLength",
                get: function get() {
                  return this._totalLength;
                },
                set: function set(value) {
                  if (this._mode === Mode$4.FILLED) {
                    value = clamp01(value);
                  }

                  if (this._totalLength === value) {
                    return;
                  }

                  this._totalLength = value;

                  this._updateBarStatus();
                }
              }, {
                key: "progress",
                get: function get() {
                  return this._progress;
                },
                set: function set(value) {
                  if (this._progress === value) {
                    return;
                  }

                  this._progress = value;

                  this._updateBarStatus();
                }
              }, {
                key: "reverse",
                get: function get() {
                  return this._reverse;
                },
                set: function set(value) {
                  if (this._reverse === value) {
                    return;
                  }

                  this._reverse = value;

                  if (this._barSprite) {
                    this._barSprite.fillStart = 1 - this._barSprite.fillStart;
                  }

                  this._updateBarStatus();
                }
              }]);

              return ProgressBar;
            }(Component), _class3$t.Mode = Mode$4, _temp$D), (_applyDecoratedDescriptor(_class2$1L.prototype, "barSprite", [_dec4$J], Object.getOwnPropertyDescriptor(_class2$1L.prototype, "barSprite"), _class2$1L.prototype), _applyDecoratedDescriptor(_class2$1L.prototype, "mode", [_dec5$C], Object.getOwnPropertyDescriptor(_class2$1L.prototype, "mode"), _class2$1L.prototype), _initializer$1G = applyDecoratedInitializer(_class2$1L.prototype, "_barSprite", [serializable$j], function () {
              return null;
            }), _initializer2$1q = applyDecoratedInitializer(_class2$1L.prototype, "_mode", [serializable$j], function () {
              return Mode$4.HORIZONTAL;
            }), _initializer3$14 = applyDecoratedInitializer(_class2$1L.prototype, "_totalLength", [serializable$j], function () {
              return 1;
            }), _initializer4$W = applyDecoratedInitializer(_class2$1L.prototype, "_progress", [serializable$j], function () {
              return 0.1;
            }), _initializer5$K = applyDecoratedInitializer(_class2$1L.prototype, "_reverse", [serializable$j], function () {
              return false;
            })), _class2$1L)) || _class$20) || _class$20) || _class$20));
            legacyCC.ProgressBar = ProgressBar;

            var _dec$1_, _dec2$1w, _dec3$10, _dec4$K, _dec5$D, _class$21, _class2$1M, _initializer$1H, _initializer2$1r, _initializer3$15, _initializer4$X, _initializer5$L, _class3$u, _temp$E;
            var GETTING_SHORTER_FACTOR = 20;

            var _tempPos_1 = new Vec3();

            var _tempPos_2 = new Vec3();

            var _tempVec3$1 = new Vec3();

            var defaultAnchor = new Vec2();

            var _tempColor$1 = new Color$1();

            var _tempVec2 = new Vec2();

            var Direction;

            (function (Direction) {
              Direction[Direction["HORIZONTAL"] = 0] = "HORIZONTAL";
              Direction[Direction["VERTICAL"] = 1] = "VERTICAL";
            })(Direction || (Direction = {}));

            ccenum(Direction);
            var ScrollBar = exports('ScrollBar', (_dec$1_ = ccclass$p('cc.ScrollBar'), _dec2$1w = executionOrder(110), _dec3$10 = requireComponent(UITransform), _dec4$K = type$8(Sprite), _dec5$D = type$8(Direction), _dec$1_(_class$21 = _dec2$1w(_class$21 = _dec3$10(_class$21 = (_class2$1M = (_temp$E = _class3$u = function (_Component) {
              _inheritsLoose(ScrollBar, _Component);

              function ScrollBar() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._scrollView = _initializer$1H && _initializer$1H();
                _this._handle = _initializer2$1r && _initializer2$1r();
                _this._direction = _initializer3$15 && _initializer3$15();
                _this._enableAutoHide = _initializer4$X && _initializer4$X();
                _this._autoHideTime = _initializer5$L && _initializer5$L();
                _this._touching = false;
                _this._opacity = 255;
                _this._autoHideRemainingTime = 0;
                return _this;
              }

              var _proto = ScrollBar.prototype;

              _proto.hide = function hide() {
                this._autoHideRemainingTime = 0;

                this._setOpacity(0);
              };

              _proto.show = function show() {
                this._autoHideRemainingTime = this._autoHideTime;
                this._opacity = 255;

                this._setOpacity(this._opacity);
              };

              _proto.onScroll = function onScroll(outOfBoundary) {
                if (!this._scrollView) {
                  return;
                }

                var content = this._scrollView.content;

                if (!content) {
                  return;
                }

                var contentSize = content._uiProps.uiTransformComp.contentSize;
                var scrollViewSize = this._scrollView.node._uiProps.uiTransformComp.contentSize;
                var barSize = this.node._uiProps.uiTransformComp.contentSize;

                if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                  return;
                }

                if (this._enableAutoHide) {
                  this._autoHideRemainingTime = this._autoHideTime;

                  this._setOpacity(this._opacity);
                }

                var contentMeasure = 0;
                var scrollViewMeasure = 0;
                var outOfBoundaryValue = 0;
                var contentPosition = 0;
                var handleNodeMeasure = 0;
                var outOfContentPosition = _tempVec2;
                outOfContentPosition.set(0, 0);

                if (this._direction === Direction.HORIZONTAL) {
                  contentMeasure = contentSize.width;
                  scrollViewMeasure = scrollViewSize.width;
                  handleNodeMeasure = barSize.width;
                  outOfBoundaryValue = outOfBoundary.x;

                  this._convertToScrollViewSpace(outOfContentPosition, content);

                  contentPosition = -outOfContentPosition.x;
                } else if (this._direction === Direction.VERTICAL) {
                  contentMeasure = contentSize.height;
                  scrollViewMeasure = scrollViewSize.height;
                  handleNodeMeasure = barSize.height;
                  outOfBoundaryValue = outOfBoundary.y;

                  this._convertToScrollViewSpace(outOfContentPosition, content);

                  contentPosition = -outOfContentPosition.y;
                }

                var length = this._calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundaryValue);

                var position = _tempVec2;

                this._calculatePosition(position, contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundaryValue, length);

                this._updateLength(length);

                this._updateHandlerPosition(position);
              };

              _proto.setScrollView = function setScrollView(scrollView) {
                this._scrollView = scrollView;
              };

              _proto.onTouchBegan = function onTouchBegan() {
                if (!this._enableAutoHide) {
                  return;
                }

                this._touching = true;
              };

              _proto.onTouchEnded = function onTouchEnded() {
                if (!this._enableAutoHide) {
                  return;
                }

                this._touching = false;

                if (this._autoHideTime <= 0) {
                  return;
                }

                if (this._scrollView) {
                  var content = this._scrollView.content;

                  if (content) {
                    var contentSize = content._uiProps.uiTransformComp.contentSize;
                    var scrollViewSize = this._scrollView.node._uiProps.uiTransformComp.contentSize;

                    if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                      return;
                    }
                  }
                }

                this._autoHideRemainingTime = this._autoHideTime;
              };

              _proto.onEnable = function onEnable() {
                var renderComp = this.node.getComponent(Sprite);

                if (renderComp) {
                  this._opacity = renderComp.color.a;
                }
              };

              _proto.start = function start() {
                if (this._enableAutoHide) {
                  this._setOpacity(0);
                }
              };

              _proto.update = function update(dt) {
                this._processAutoHide(dt);
              };

              _proto._convertToScrollViewSpace = function _convertToScrollViewSpace(out, content) {
                var scrollTrans = this._scrollView && this._scrollView.node._uiProps.uiTransformComp;
                var contentTrans = content._uiProps.uiTransformComp;

                if (!scrollTrans || !contentTrans) {
                  out.set(Vec2.ZERO);
                } else {
                  _tempPos_1.set(-contentTrans.anchorX * contentTrans.width, -contentTrans.anchorY * contentTrans.height, 0);

                  contentTrans.convertToWorldSpaceAR(_tempPos_1, _tempPos_2);
                  var scrollViewSpacePos = scrollTrans.convertToNodeSpaceAR(_tempPos_2);
                  scrollViewSpacePos.x += scrollTrans.anchorX * scrollTrans.width;
                  scrollViewSpacePos.y += scrollTrans.anchorY * scrollTrans.height;
                  out.set(scrollViewSpacePos.x, scrollViewSpacePos.y);
                }
              };

              _proto._setOpacity = function _setOpacity(opacity) {
                if (this._handle) {
                  var renderComp = this.node.getComponent(Sprite);

                  if (renderComp) {
                    _tempColor$1.set(renderComp.color);

                    _tempColor$1.a = opacity;
                    renderComp.color = _tempColor$1;
                  }

                  renderComp = this._handle.getComponent(Sprite);

                  if (renderComp) {
                    _tempColor$1.set(renderComp.color);

                    _tempColor$1.a = opacity;
                    renderComp.color = _tempColor$1;
                  }
                }
              };

              _proto._updateHandlerPosition = function _updateHandlerPosition(position) {
                if (this._handle) {
                  var oldPosition = _tempVec3$1;

                  this._fixupHandlerPosition(oldPosition);

                  this._handle.node.setPosition(position.x + oldPosition.x, position.y + oldPosition.y, oldPosition.z);
                }
              };

              _proto._fixupHandlerPosition = function _fixupHandlerPosition(out) {
                var uiTrans = this.node._uiProps.uiTransformComp;
                var barSize = uiTrans.contentSize;
                var barAnchor = uiTrans.anchorPoint;
                var handleSize = this.handle.node._uiProps.uiTransformComp.contentSize;
                var handleParent = this.handle.node.parent;
                Vec3.set(_tempPos_1, -barSize.width * barAnchor.x, -barSize.height * barAnchor.y, 0);

                var leftBottomWorldPosition = this.node._uiProps.uiTransformComp.convertToWorldSpaceAR(_tempPos_1, _tempPos_2);

                var fixupPosition = out;
                fixupPosition.set(0, 0, 0);

                handleParent._uiProps.uiTransformComp.convertToNodeSpaceAR(leftBottomWorldPosition, fixupPosition);

                if (this.direction === Direction.HORIZONTAL) {
                  fixupPosition.set(fixupPosition.x, fixupPosition.y + (barSize.height - handleSize.height) / 2, fixupPosition.z);
                } else if (this.direction === Direction.VERTICAL) {
                  fixupPosition.set(fixupPosition.x + (barSize.width - handleSize.width) / 2, fixupPosition.y, fixupPosition.z);
                }

                this.handle.node.setPosition(fixupPosition);
              };

              _proto._conditionalDisableScrollBar = function _conditionalDisableScrollBar(contentSize, scrollViewSize) {
                if (contentSize.width <= scrollViewSize.width && this._direction === Direction.HORIZONTAL) {
                  return true;
                }

                if (contentSize.height <= scrollViewSize.height && this._direction === Direction.VERTICAL) {
                  return true;
                }

                return false;
              };

              _proto._calculateLength = function _calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundary) {
                var denominatorValue = contentMeasure;

                if (outOfBoundary) {
                  denominatorValue += (outOfBoundary > 0 ? outOfBoundary : -outOfBoundary) * GETTING_SHORTER_FACTOR;
                }

                var lengthRation = scrollViewMeasure / denominatorValue;
                return handleNodeMeasure * lengthRation;
              };

              _proto._calculatePosition = function _calculatePosition(out, contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundary, actualLenth) {
                var denominatorValue = contentMeasure - scrollViewMeasure;

                if (outOfBoundary) {
                  denominatorValue += Math.abs(outOfBoundary);
                }

                var positionRatio = 0;

                if (denominatorValue) {
                  positionRatio = contentPosition / denominatorValue;
                  positionRatio = clamp01(positionRatio);
                }

                var position = (handleNodeMeasure - actualLenth) * positionRatio;

                if (this._direction === Direction.VERTICAL) {
                  out.set(0, position);
                } else {
                  out.set(position, 0);
                }
              };

              _proto._updateLength = function _updateLength(length) {
                if (this._handle) {
                  var handleNode = this._handle.node;
                  var handleTrans = handleNode._uiProps.uiTransformComp;
                  var handleNodeSize = handleTrans.contentSize;
                  var anchor = handleTrans.anchorPoint;

                  if (anchor.x !== defaultAnchor.x || anchor.y !== defaultAnchor.y) {
                    handleTrans.setAnchorPoint(defaultAnchor);
                  }

                  if (this._direction === Direction.HORIZONTAL) {
                    handleTrans.setContentSize(length, handleNodeSize.height);
                  } else {
                    handleTrans.setContentSize(handleNodeSize.width, length);
                  }
                }
              };

              _proto._processAutoHide = function _processAutoHide(deltaTime) {
                if (!this._enableAutoHide || this._autoHideRemainingTime <= 0) {
                  return;
                } else if (this._touching) {
                  return;
                }

                this._autoHideRemainingTime -= deltaTime;

                if (this._autoHideRemainingTime <= this._autoHideTime) {
                  this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
                  var opacity = this._opacity * (this._autoHideRemainingTime / this._autoHideTime);

                  this._setOpacity(opacity);
                }
              };

              _createClass(ScrollBar, [{
                key: "handle",
                get: function get() {
                  return this._handle;
                },
                set: function set(value) {
                  if (this._handle === value) {
                    return;
                  }

                  this._handle = value;
                  this.onScroll(Vec2.ZERO);
                }
              }, {
                key: "direction",
                get: function get() {
                  return this._direction;
                },
                set: function set(value) {
                  if (this._direction === value) {
                    return;
                  }

                  this._direction = value;
                  this.onScroll(Vec2.ZERO);
                }
              }, {
                key: "enableAutoHide",
                get: function get() {
                  return this._enableAutoHide;
                },
                set: function set(value) {
                  if (this._enableAutoHide === value) {
                    return;
                  }

                  this._enableAutoHide = value;

                  if (this._enableAutoHide) {
                    this._setOpacity(0);
                  }
                }
              }, {
                key: "autoHideTime",
                get: function get() {
                  return this._autoHideTime;
                },
                set: function set(value) {
                  if (this._autoHideTime === value) {
                    return;
                  }

                  this._autoHideTime = value;
                }
              }]);

              return ScrollBar;
            }(Component), _class3$u.Direction = Direction, _temp$E), (_applyDecoratedDescriptor(_class2$1M.prototype, "handle", [_dec4$K], Object.getOwnPropertyDescriptor(_class2$1M.prototype, "handle"), _class2$1M.prototype), _applyDecoratedDescriptor(_class2$1M.prototype, "direction", [_dec5$D], Object.getOwnPropertyDescriptor(_class2$1M.prototype, "direction"), _class2$1M.prototype), _initializer$1H = applyDecoratedInitializer(_class2$1M.prototype, "_scrollView", [serializable$j], function () {
              return null;
            }), _initializer2$1r = applyDecoratedInitializer(_class2$1M.prototype, "_handle", [serializable$j], function () {
              return null;
            }), _initializer3$15 = applyDecoratedInitializer(_class2$1M.prototype, "_direction", [serializable$j], function () {
              return Direction.HORIZONTAL;
            }), _initializer4$X = applyDecoratedInitializer(_class2$1M.prototype, "_enableAutoHide", [serializable$j], function () {
              return false;
            }), _initializer5$L = applyDecoratedInitializer(_class2$1M.prototype, "_autoHideTime", [serializable$j], function () {
              return 1.0;
            })), _class2$1M)) || _class$21) || _class$21) || _class$21));
            legacyCC.ScrollBar = ScrollBar;

            var _dec$1$, _dec2$1x, _class$22;
            var ViewGroup = exports('ViewGroup', (_dec$1$ = ccclass$p('cc.ViewGroup'), _dec2$1x = executionOrder(110), _dec$1$(_class$22 = _dec2$1x(_class$22 = function (_Component) {
              _inheritsLoose(ViewGroup, _Component);

              function ViewGroup() {
                return _Component.apply(this, arguments) || this;
              }

              return ViewGroup;
            }(Component)) || _class$22) || _class$22));
            legacyCC.ViewGroup = ViewGroup;

            var _dec$20, _dec2$1y, _dec3$11, _dec4$L, _dec5$E, _dec6$v, _dec7$o, _class$23, _class2$1N, _initializer$1I, _initializer2$1s, _initializer3$16, _initializer4$Y, _initializer5$M, _initializer6$D, _initializer7$v, _initializer8$s, _initializer9$p, _initializer10$m, _initializer11$i, _class3$v, _temp$F;
            var NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED = 5;
            var OUT_OF_BOUNDARY_BREAKING_FACTOR = 0.05;
            var EPSILON$1 = 1e-4;
            var TOLERANCE = 1e4;
            var MOVEMENT_FACTOR = 0.7;

            var _tempVec3$2 = new Vec3();

            var _tempVec3_1 = new Vec3();

            var _tempVec2$1 = new Vec2();

            var _tempVec2_1 = new Vec2();

            var quintEaseOut = function quintEaseOut(time) {
              time -= 1;
              return time * time * time * time * time + 1;
            };

            var getTimeInMilliseconds = function getTimeInMilliseconds() {
              var currentTime = new Date();
              return currentTime.getMilliseconds();
            };

            var eventMap = {
              'scroll-to-top': 0,
              'scroll-to-bottom': 1,
              'scroll-to-left': 2,
              'scroll-to-right': 3,
              scrolling: 4,
              'bounce-bottom': 6,
              'bounce-left': 7,
              'bounce-right': 8,
              'bounce-top': 5,
              'scroll-ended': 9,
              'touch-up': 10,
              'scroll-ended-with-threshold': 11,
              'scroll-began': 12
            };
            var EventType$5;

            (function (EventType) {
              EventType["SCROLL_TO_TOP"] = "scroll-to-top";
              EventType["SCROLL_TO_BOTTOM"] = "scroll-to-bottom";
              EventType["SCROLL_TO_LEFT"] = "scroll-to-left";
              EventType["SCROLL_TO_RIGHT"] = "scroll-to-right";
              EventType["SCROLL_BEGAN"] = "scroll-began";
              EventType["SCROLL_ENDED"] = "scroll-ended";
              EventType["BOUNCE_TOP"] = "bounce-top";
              EventType["BOUNCE_BOTTOM"] = "bounce-bottom";
              EventType["BOUNCE_LEFT"] = "bounce-left";
              EventType["BOUNCE_RIGHT"] = "bounce-right";
              EventType["SCROLLING"] = "scrolling";
              EventType["SCROLL_ENG_WITH_THRESHOLD"] = "scroll-ended-with-threshold";
              EventType["TOUCH_UP"] = "touch-up";
            })(EventType$5 || (EventType$5 = {}));

            var XrhoverType;

            (function (XrhoverType) {
              XrhoverType[XrhoverType["NONE"] = 0] = "NONE";
              XrhoverType[XrhoverType["LEFT"] = 1] = "LEFT";
              XrhoverType[XrhoverType["RIGHT"] = 2] = "RIGHT";
            })(XrhoverType || (XrhoverType = {}));

            var ScrollView = exports('ScrollView', (_dec$20 = ccclass$p('cc.ScrollView'), _dec2$1y = executionOrder(110), _dec3$11 = requireComponent(UITransform), _dec4$L = type$8(Node), _dec5$E = type$8(ScrollBar), _dec6$v = type$8(ScrollBar), _dec7$o = type$8([EventHandler]), _dec$20(_class$23 = _dec2$1y(_class$23 = _dec3$11(_class$23 = (_class2$1N = (_temp$F = _class3$v = function (_ViewGroup) {
              _inheritsLoose(ScrollView, _ViewGroup);

              function ScrollView() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _ViewGroup.call.apply(_ViewGroup, [this].concat(args)) || this;
                _this.bounceDuration = _initializer$1I && _initializer$1I();
                _this.brake = _initializer2$1s && _initializer2$1s();
                _this.elastic = _initializer3$16 && _initializer3$16();
                _this.inertia = _initializer4$Y && _initializer4$Y();
                _this.horizontal = _initializer5$M && _initializer5$M();
                _this.vertical = _initializer6$D && _initializer6$D();
                _this.cancelInnerEvents = _initializer7$v && _initializer7$v();
                _this.scrollEvents = _initializer8$s && _initializer8$s();
                _this._autoScrolling = false;
                _this._scrolling = false;
                _this._content = _initializer9$p && _initializer9$p();
                _this._horizontalScrollBar = _initializer10$m && _initializer10$m();
                _this._verticalScrollBar = _initializer11$i && _initializer11$i();
                _this._topBoundary = 0;
                _this._bottomBoundary = 0;
                _this._leftBoundary = 0;
                _this._rightBoundary = 0;
                _this._touchMoveDisplacements = [];
                _this._touchMoveTimeDeltas = [];
                _this._touchMovePreviousTimestamp = 0;
                _this._touchMoved = false;
                _this._autoScrollAttenuate = false;
                _this._autoScrollStartPosition = new Vec3();
                _this._autoScrollTargetDelta = new Vec3();
                _this._autoScrollTotalTime = 0;
                _this._autoScrollAccumulatedTime = 0;
                _this._autoScrollCurrentlyOutOfBoundary = false;
                _this._autoScrollBraking = false;
                _this._autoScrollBrakingStartPosition = new Vec3();
                _this._outOfBoundaryAmount = new Vec3();
                _this._outOfBoundaryAmountDirty = true;
                _this._stopMouseWheel = false;
                _this._mouseWheelEventElapsedTime = 0.0;
                _this._isScrollEndedWithThresholdEventFired = false;
                _this._scrollEventEmitMask = 0;
                _this._isBouncing = false;
                _this._contentPos = new Vec3();
                _this._deltaPos = new Vec3();
                _this._hoverIn = XrhoverType.NONE;
                return _this;
              }

              var _proto = ScrollView.prototype;

              _proto.scrollToBottom = function scrollToBottom(timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, 0),
                  applyToHorizontal: false,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta, true);
                }
              };

              _proto.scrollToTop = function scrollToTop(timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, 1),
                  applyToHorizontal: false,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollToLeft = function scrollToLeft(timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, 0),
                  applyToHorizontal: true,
                  applyToVertical: false
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollToRight = function scrollToRight(timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(1, 0),
                  applyToHorizontal: true,
                  applyToVertical: false
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollToTopLeft = function scrollToTopLeft(timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, 1),
                  applyToHorizontal: true,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollToTopRight = function scrollToTopRight(timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(1, 1),
                  applyToHorizontal: true,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollToBottomLeft = function scrollToBottomLeft(timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, 0),
                  applyToHorizontal: true,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollToBottomRight = function scrollToBottomRight(timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(1, 0),
                  applyToHorizontal: true,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollToOffset = function scrollToOffset(offset, timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var maxScrollOffset = this.getMaxScrollOffset();
                var anchor = new Vec2(0, 0);

                if (maxScrollOffset.x === 0) {
                  anchor.x = 0;
                } else {
                  anchor.x = offset.x / maxScrollOffset.x;
                }

                if (maxScrollOffset.y === 0) {
                  anchor.y = 1;
                } else {
                  anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y;
                }

                this.scrollTo(anchor, timeInSecond, attenuated);
              };

              _proto.getScrollOffset = function getScrollOffset() {
                var topDelta = this._getContentTopBoundary() - this._topBoundary;

                var leftDelta = this._getContentLeftBoundary() - this._leftBoundary;

                return new Vec2(leftDelta, topDelta);
              };

              _proto.getMaxScrollOffset = function getMaxScrollOffset() {
                if (!this._content || !this.view) {
                  return Vec2.ZERO;
                }

                var contentSize = this._content._uiProps.uiTransformComp.contentSize;
                var horizontalMaximizeOffset = contentSize.width - this.view.width;
                var verticalMaximizeOffset = contentSize.height - this.view.height;
                horizontalMaximizeOffset = horizontalMaximizeOffset >= 0 ? horizontalMaximizeOffset : 0;
                verticalMaximizeOffset = verticalMaximizeOffset >= 0 ? verticalMaximizeOffset : 0;
                return new Vec2(horizontalMaximizeOffset, verticalMaximizeOffset);
              };

              _proto.scrollToPercentHorizontal = function scrollToPercentHorizontal(percent, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(percent, 0),
                  applyToHorizontal: true,
                  applyToVertical: false
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollTo = function scrollTo(anchor, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(anchor),
                  applyToHorizontal: true,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollToPercentVertical = function scrollToPercentVertical(percent, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, percent),
                  applyToHorizontal: false,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.stopAutoScroll = function stopAutoScroll() {
                this._autoScrolling = false;
                this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
              };

              _proto.setContentPosition = function setContentPosition(position) {
                this._setContentPosition(position);
              };

              _proto._setContentPosition = function _setContentPosition(position) {
                if (!this._content) {
                  return;
                }

                var contentPos = this._getContentPosition();

                if (Math.abs(position.x - contentPos.x) < EPSILON$1 && Math.abs(position.y - contentPos.y) < EPSILON$1) {
                  return;
                }

                this._content.setPosition(position);

                this._outOfBoundaryAmountDirty = true;
              };

              _proto.getContentPosition = function getContentPosition() {
                return this._getContentPosition();
              };

              _proto._getContentPosition = function _getContentPosition() {
                if (!this._content) {
                  return Vec3.ZERO.clone();
                }

                this._contentPos.set(this._content.position);

                return this._contentPos;
              };

              _proto.isScrolling = function isScrolling() {
                return this._scrolling;
              };

              _proto.isAutoScrolling = function isAutoScrolling() {
                return this._autoScrolling;
              };

              _proto.getScrollEndedEventTiming = function getScrollEndedEventTiming() {
                return EPSILON$1;
              };

              _proto.start = function start() {
                this._calculateBoundary();

                if (this._content) {
                  director.once(Director.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this);
                }
              };

              _proto.onEnable = function onEnable() {
                {
                  this._registerEvent();

                  if (this._content) {
                    this._content.on(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);

                    this._content.on(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);

                    if (this.view) {
                      this.view.node.on(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);
                      this.view.node.on(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);
                    }
                  }

                  this._calculateBoundary();
                }

                this._updateScrollBarState();
              };

              _proto.update = function update(dt) {
                if (this._autoScrolling) {
                  this._processAutoScrolling(dt);
                }
              };

              _proto.onDisable = function onDisable() {
                {
                  this._unregisterEvent();

                  if (this._content) {
                    this._content.off(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);

                    this._content.off(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);

                    if (this.view) {
                      this.view.node.off(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);
                      this.view.node.off(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);
                    }
                  }
                }

                this._hideScrollBar();

                this.stopAutoScroll();
              };

              _proto._registerEvent = function _registerEvent() {
                this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this, true);
                this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this, true);
                this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this, true);
                this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
                this.node.on(NodeEventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
                this.node.on(XrUIPressEventType.XRUI_HOVER_ENTERED, this._xrHoverEnter, this);
                this.node.on(XrUIPressEventType.XRUI_HOVER_EXITED, this._xrHoverExit, this);
                input.on(Input.EventType.HANDLE_INPUT, this._dispatchEventHandleInput, this);
                input.on(Input.EventType.GAMEPAD_INPUT, this._dispatchEventHandleInput, this);
              };

              _proto._unregisterEvent = function _unregisterEvent() {
                this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this, true);
                this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this, true);
                this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this, true);
                this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
                this.node.off(NodeEventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
                this.node.off(XrUIPressEventType.XRUI_HOVER_ENTERED, this._xrHoverEnter, this);
                this.node.off(XrUIPressEventType.XRUI_HOVER_EXITED, this._xrHoverExit, this);
                input.off(Input.EventType.HANDLE_INPUT, this._dispatchEventHandleInput, this);
                input.off(Input.EventType.GAMEPAD_INPUT, this._dispatchEventHandleInput, this);
              };

              _proto._onMouseWheel = function _onMouseWheel(event, captureListeners) {
                if (!this.enabledInHierarchy) {
                  return;
                }

                if (this._hasNestedViewGroup(event, captureListeners)) {
                  return;
                }

                var deltaMove = new Vec3();
                var wheelPrecision = -0.1;
                var scrollY = event.getScrollY();

                if (this.vertical) {
                  deltaMove.set(0, scrollY * wheelPrecision, 0);
                } else if (this.horizontal) {
                  deltaMove.set(scrollY * wheelPrecision, 0, 0);
                }

                this._mouseWheelEventElapsedTime = 0;

                this._processDeltaMove(deltaMove);

                if (!this._stopMouseWheel) {
                  this._handlePressLogic();

                  this.schedule(this._checkMouseWheel, 1.0 / 60, NaN, 0);
                  this._stopMouseWheel = true;
                }

                this._stopPropagationIfTargetIsMe(event);
              };

              _proto._onTouchBegan = function _onTouchBegan(event, captureListeners) {
                if (!this.enabledInHierarchy || !this._content) {
                  return;
                }

                if (this._hasNestedViewGroup(event, captureListeners)) {
                  return;
                }

                this._handlePressLogic();

                this._touchMoved = false;

                this._stopPropagationIfTargetIsMe(event);
              };

              _proto._onTouchMoved = function _onTouchMoved(event, captureListeners) {
                if (!this.enabledInHierarchy || !this._content) {
                  return;
                }

                if (this._hasNestedViewGroup(event, captureListeners)) {
                  return;
                }

                var touch = event.touch;

                this._handleMoveLogic(touch);

                if (!this.cancelInnerEvents) {
                  return;
                }

                var deltaMove = touch.getUILocation(_tempVec2$1);
                deltaMove.subtract(touch.getUIStartLocation(_tempVec2_1));

                if (deltaMove.length() > 7) {
                  if (!this._touchMoved && event.target !== this.node) {
                    var cancelEvent = new EventTouch(event.getTouches(), event.bubbles, SystemEventType.TOUCH_CANCEL);
                    cancelEvent.touch = event.touch;
                    cancelEvent.simulate = true;
                    event.target.dispatchEvent(cancelEvent);
                    this._touchMoved = true;
                  }
                }

                this._stopPropagationIfTargetIsMe(event);
              };

              _proto._onTouchEnded = function _onTouchEnded(event, captureListeners) {
                if (!this.enabledInHierarchy || !this._content || !event) {
                  return;
                }

                if (this._hasNestedViewGroup(event, captureListeners)) {
                  return;
                }

                this._dispatchEvent(EventType$5.TOUCH_UP);

                var touch = event.touch;

                this._handleReleaseLogic(touch);

                if (this._touchMoved) {
                  event.propagationStopped = true;
                } else {
                  this._stopPropagationIfTargetIsMe(event);
                }
              };

              _proto._onTouchCancelled = function _onTouchCancelled(event, captureListeners) {
                if (!this.enabledInHierarchy || !this._content) {
                  return;
                }

                if (this._hasNestedViewGroup(event, captureListeners)) {
                  return;
                }

                if (event && !event.simulate) {
                  var touch = event.touch;

                  this._handleReleaseLogic(touch);
                }

                this._stopPropagationIfTargetIsMe(event);
              };

              _proto._calculateBoundary = function _calculateBoundary() {
                if (this._content && this.view) {
                  var layout = this._content.getComponent(Layout);

                  if (layout && layout.enabledInHierarchy) {
                    layout.updateLayout();
                  }

                  var viewTrans = this.view;
                  var anchorX = viewTrans.width * viewTrans.anchorX;
                  var anchorY = viewTrans.height * viewTrans.anchorY;
                  this._leftBoundary = -anchorX;
                  this._bottomBoundary = -anchorY;
                  this._rightBoundary = this._leftBoundary + viewTrans.width;
                  this._topBoundary = this._bottomBoundary + viewTrans.height;

                  this._moveContentToTopLeft(viewTrans.contentSize);
                }
              };

              _proto._hasNestedViewGroup = function _hasNestedViewGroup(event, captureListeners) {
                if (!event || event.eventPhase !== Event.CAPTURING_PHASE) {
                  return false;
                }

                if (captureListeners) {
                  for (var _iterator = _createForOfIteratorHelperLoose(captureListeners), _step; !(_step = _iterator()).done;) {
                    var listener = _step.value;
                    var item = listener;

                    if (this.node === item) {
                      if (event.target && event.target.getComponent(ViewGroup)) {
                        return true;
                      }

                      return false;
                    }

                    if (item.getComponent(ViewGroup)) {
                      return true;
                    }
                  }
                }

                return false;
              };

              _proto._startInertiaScroll = function _startInertiaScroll(touchMoveVelocity) {
                var inertiaTotalMovement = new Vec3(touchMoveVelocity);
                inertiaTotalMovement.multiplyScalar(MOVEMENT_FACTOR);

                this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
              };

              _proto._calculateAttenuatedFactor = function _calculateAttenuatedFactor(distance) {
                if (this.brake <= 0) {
                  return 1 - this.brake;
                }

                return (1 - this.brake) * (1 / (1 + distance * 0.000014 + distance * distance * 0.000000008));
              };

              _proto._startAttenuatingAutoScroll = function _startAttenuatingAutoScroll(deltaMove, initialVelocity) {
                var targetDelta = deltaMove.clone();
                targetDelta.normalize();

                if (this._content && this.view) {
                  var contentSize = this._content._uiProps.uiTransformComp.contentSize;
                  var scrollViewSize = this.view.contentSize;
                  var totalMoveWidth = contentSize.width - scrollViewSize.width;
                  var totalMoveHeight = contentSize.height - scrollViewSize.height;

                  var attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth);

                  var attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);

                  targetDelta.x = targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX;
                  targetDelta.y = targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake);
                  targetDelta.z = 0;
                }

                var originalMoveLength = deltaMove.length();
                var factor = targetDelta.length() / originalMoveLength;
                targetDelta.add(deltaMove);

                if (this.brake > 0 && factor > 7) {
                  factor = Math.sqrt(factor);
                  var clonedDeltaMove = deltaMove.clone();
                  clonedDeltaMove.multiplyScalar(factor);
                  targetDelta.set(clonedDeltaMove);
                  targetDelta.add(deltaMove);
                }

                var time = this._calculateAutoScrollTimeByInitialSpeed(initialVelocity.length());

                if (this.brake > 0 && factor > 3) {
                  factor = 3;
                  time *= factor;
                }

                if (this.brake === 0 && factor > 1) {
                  time *= factor;
                }

                this._startAutoScroll(targetDelta, time, true);
              };

              _proto._calculateAutoScrollTimeByInitialSpeed = function _calculateAutoScrollTimeByInitialSpeed(initialSpeed) {
                return Math.sqrt(Math.sqrt(initialSpeed / 5));
              };

              _proto._startAutoScroll = function _startAutoScroll(deltaMove, timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = false;
                }

                var adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);

                this._autoScrolling = true;
                this._autoScrollTargetDelta = adjustedDeltaMove;
                this._autoScrollAttenuate = attenuated;
                Vec3.copy(this._autoScrollStartPosition, this._getContentPosition());
                this._autoScrollTotalTime = timeInSecond;
                this._autoScrollAccumulatedTime = 0;
                this._autoScrollBraking = false;
                this._isScrollEndedWithThresholdEventFired = false;

                this._autoScrollBrakingStartPosition.set(0, 0, 0);

                var currentOutOfBoundary = this._getHowMuchOutOfBoundary();

                if (!currentOutOfBoundary.equals(Vec3.ZERO, EPSILON$1)) {
                  this._autoScrollCurrentlyOutOfBoundary = true;
                }
              };

              _proto._calculateTouchMoveVelocity = function _calculateTouchMoveVelocity() {
                var out = new Vec3();
                var totalTime = 0;
                totalTime = this._touchMoveTimeDeltas.reduce(function (a, b) {
                  return a + b;
                }, totalTime);

                if (totalTime <= 0 || totalTime >= 0.5) {
                  out.set(Vec3.ZERO);
                } else {
                  var totalMovement = new Vec3();
                  totalMovement = this._touchMoveDisplacements.reduce(function (a, b) {
                    a.add(b);
                    return a;
                  }, totalMovement);
                  out.set(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime, totalMovement.z);
                }

                return out;
              };

              _proto._flattenVectorByDirection = function _flattenVectorByDirection(vector) {
                var result = vector;
                result.x = this.horizontal ? result.x : 0;
                result.y = this.vertical ? result.y : 0;
                return result;
              };

              _proto._moveContent = function _moveContent(deltaMove, canStartBounceBack) {
                var adjustedMove = this._flattenVectorByDirection(deltaMove);

                _tempVec3$2.set(this._getContentPosition());

                _tempVec3$2.add(adjustedMove);

                _tempVec3$2.set(Math.round(_tempVec3$2.x * TOLERANCE) * EPSILON$1, Math.round(_tempVec3$2.y * TOLERANCE) * EPSILON$1, _tempVec3$2.z);

                this._setContentPosition(_tempVec3$2);

                var outOfBoundary = this._getHowMuchOutOfBoundary();

                _tempVec2$1.set(outOfBoundary.x, outOfBoundary.y);

                this._updateScrollBar(_tempVec2$1);

                if (this.elastic && canStartBounceBack) {
                  this._startBounceBackIfNeeded();
                }
              };

              _proto._getContentLeftBoundary = function _getContentLeftBoundary() {
                if (!this._content) {
                  return -1;
                }

                var contentPos = this._getContentPosition();

                var uiTrans = this._content._uiProps.uiTransformComp;
                return contentPos.x - uiTrans.anchorX * uiTrans.width;
              };

              _proto._getContentRightBoundary = function _getContentRightBoundary() {
                if (!this._content) {
                  return -1;
                }

                var uiTrans = this._content._uiProps.uiTransformComp;
                return this._getContentLeftBoundary() + uiTrans.width;
              };

              _proto._getContentTopBoundary = function _getContentTopBoundary() {
                if (!this._content) {
                  return -1;
                }

                var uiTrans = this._content._uiProps.uiTransformComp;
                return this._getContentBottomBoundary() + uiTrans.height;
              };

              _proto._getContentBottomBoundary = function _getContentBottomBoundary() {
                if (!this._content) {
                  return -1;
                }

                var contentPos = this._getContentPosition();

                var uiTrans = this._content._uiProps.uiTransformComp;
                return contentPos.y - uiTrans.anchorY * uiTrans.height;
              };

              _proto._getHowMuchOutOfBoundary = function _getHowMuchOutOfBoundary(addition) {
                addition = addition || new Vec3();

                if (addition.equals(Vec3.ZERO, EPSILON$1) && !this._outOfBoundaryAmountDirty) {
                  return this._outOfBoundaryAmount;
                }

                var outOfBoundaryAmount = new Vec3();

                var tempLeftBoundary = this._getContentLeftBoundary();

                var tempRightBoundary = this._getContentRightBoundary();

                if (tempLeftBoundary + addition.x > this._leftBoundary) {
                  outOfBoundaryAmount.x = this._leftBoundary - (tempLeftBoundary + addition.x);
                } else if (tempRightBoundary + addition.x < this._rightBoundary) {
                  outOfBoundaryAmount.x = this._rightBoundary - (tempRightBoundary + addition.x);
                }

                var tempTopBoundary = this._getContentTopBoundary();

                var tempBottomBoundary = this._getContentBottomBoundary();

                if (tempTopBoundary + addition.y < this._topBoundary) {
                  outOfBoundaryAmount.y = this._topBoundary - (tempTopBoundary + addition.y);
                } else if (tempBottomBoundary + addition.y > this._bottomBoundary) {
                  outOfBoundaryAmount.y = this._bottomBoundary - (tempBottomBoundary + addition.y);
                }

                if (addition.equals(Vec3.ZERO, EPSILON$1)) {
                  this._outOfBoundaryAmount = outOfBoundaryAmount;
                  this._outOfBoundaryAmountDirty = false;
                }

                this._clampDelta(outOfBoundaryAmount);

                return outOfBoundaryAmount;
              };

              _proto._updateScrollBar = function _updateScrollBar(outOfBoundary) {
                if (this._horizontalScrollBar && this._horizontalScrollBar.isValid) {
                  this._horizontalScrollBar.onScroll(outOfBoundary);
                }

                if (this._verticalScrollBar && this._verticalScrollBar.isValid) {
                  this._verticalScrollBar.onScroll(outOfBoundary);
                }
              };

              _proto._onScrollBarTouchBegan = function _onScrollBarTouchBegan() {
                if (this._horizontalScrollBar && this._horizontalScrollBar.isValid) {
                  this._horizontalScrollBar.onTouchBegan();
                }

                if (this._verticalScrollBar && this._verticalScrollBar.isValid) {
                  this._verticalScrollBar.onTouchBegan();
                }
              };

              _proto._onScrollBarTouchEnded = function _onScrollBarTouchEnded() {
                if (this._horizontalScrollBar && this._horizontalScrollBar.isValid) {
                  this._horizontalScrollBar.onTouchEnded();
                }

                if (this._verticalScrollBar && this._verticalScrollBar.isValid) {
                  this._verticalScrollBar.onTouchEnded();
                }
              };

              _proto._dispatchEvent = function _dispatchEvent(event) {
                if (event === EventType$5.SCROLL_ENDED) {
                  this._scrollEventEmitMask = 0;
                } else if (event === EventType$5.SCROLL_TO_TOP || event === EventType$5.SCROLL_TO_BOTTOM || event === EventType$5.SCROLL_TO_LEFT || event === EventType$5.SCROLL_TO_RIGHT) {
                  var flag = 1 << eventMap[event];

                  if (this._scrollEventEmitMask & flag) {
                    return;
                  } else {
                    this._scrollEventEmitMask |= flag;
                  }
                }

                EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]);
                this.node.emit(event, this);
              };

              _proto._adjustContentOutOfBoundary = function _adjustContentOutOfBoundary() {
                if (!this._content) {
                  return;
                }

                this._outOfBoundaryAmountDirty = true;

                if (this._isOutOfBoundary()) {
                  var outOfBoundary = this._getHowMuchOutOfBoundary();

                  _tempVec3$2.set(this._getContentPosition());

                  _tempVec3$2.add(outOfBoundary);

                  this._setContentPosition(_tempVec3$2);

                  this._updateScrollBar(Vec2.ZERO);
                }
              };

              _proto._hideScrollBar = function _hideScrollBar() {
                if (this._horizontalScrollBar && this._horizontalScrollBar.isValid) {
                  this._horizontalScrollBar.hide();
                }

                if (this._verticalScrollBar && this._verticalScrollBar.isValid) {
                  this._verticalScrollBar.hide();
                }
              };

              _proto._updateScrollBarState = function _updateScrollBarState() {
                if (!this._content || !this.view) {
                  return;
                }

                var viewTrans = this.view;
                var uiTrans = this._content._uiProps.uiTransformComp;

                if (this._verticalScrollBar && this._verticalScrollBar.isValid) {
                  if (uiTrans.height < viewTrans.height) {
                    this._verticalScrollBar.hide();
                  } else {
                    this._verticalScrollBar.show();
                  }
                }

                if (this._horizontalScrollBar && this._horizontalScrollBar.isValid) {
                  if (uiTrans.width < viewTrans.width) {
                    this._horizontalScrollBar.hide();
                  } else {
                    this._horizontalScrollBar.show();
                  }
                }
              };

              _proto._stopPropagationIfTargetIsMe = function _stopPropagationIfTargetIsMe(event) {
                if (event.eventPhase === Event.AT_TARGET && event.target === this.node) {
                  event.propagationStopped = true;
                }
              };

              _proto._processDeltaMove = function _processDeltaMove(deltaMove) {
                this._scrollChildren(deltaMove);

                this._gatherTouchMove(deltaMove);
              };

              _proto._handleMoveLogic = function _handleMoveLogic(touch) {
                this._getLocalAxisAlignDelta(this._deltaPos, touch);

                this._processDeltaMove(this._deltaPos);
              };

              _proto._handleReleaseLogic = function _handleReleaseLogic(touch) {
                this._getLocalAxisAlignDelta(this._deltaPos, touch);

                this._gatherTouchMove(this._deltaPos);

                this._processInertiaScroll();

                if (this._scrolling) {
                  this._scrolling = false;

                  if (!this._autoScrolling) {
                    this._dispatchEvent(EventType$5.SCROLL_ENDED);
                  }
                }
              };

              _proto._getLocalAxisAlignDelta = function _getLocalAxisAlignDelta(out, touch) {
                var uiTransformComp = this.node._uiProps.uiTransformComp;
                var vec = new Vec3();

                if (uiTransformComp) {
                  touch.getUILocation(_tempVec2$1);
                  touch.getUIPreviousLocation(_tempVec2_1);

                  _tempVec3$2.set(_tempVec2$1.x, _tempVec2$1.y, 0);

                  _tempVec3_1.set(_tempVec2_1.x, _tempVec2_1.y, 0);

                  uiTransformComp.convertToNodeSpaceAR(_tempVec3$2, _tempVec3$2);
                  uiTransformComp.convertToNodeSpaceAR(_tempVec3_1, _tempVec3_1);
                  Vec3.subtract(vec, _tempVec3$2, _tempVec3_1);
                }

                out.set(vec);
              };

              _proto._scrollChildren = function _scrollChildren(deltaMove) {
                this._clampDelta(deltaMove);

                var realMove = deltaMove;
                var outOfBoundary;

                if (this.elastic) {
                  outOfBoundary = this._getHowMuchOutOfBoundary();
                  realMove.x *= outOfBoundary.x === 0 ? 1 : 0.5;
                  realMove.y *= outOfBoundary.y === 0 ? 1 : 0.5;
                }

                if (!this.elastic) {
                  outOfBoundary = this._getHowMuchOutOfBoundary(realMove);
                  realMove.add(outOfBoundary);
                }

                var verticalScrollEventType = '';
                var horizontalScrollEventType = '';

                if (this._content) {
                  var _ref = this._content._uiProps.uiTransformComp,
                      anchorX = _ref.anchorX,
                      anchorY = _ref.anchorY,
                      width = _ref.width,
                      height = _ref.height;
                  var pos = this._content.position || Vec3.ZERO;

                  if (this.vertical) {
                    if (realMove.y > 0) {
                      var icBottomPos = pos.y - anchorY * height;

                      if (icBottomPos + realMove.y >= this._bottomBoundary) {
                        verticalScrollEventType = EventType$5.SCROLL_TO_BOTTOM;
                      }
                    } else if (realMove.y < 0) {
                      var icTopPos = pos.y - anchorY * height + height;

                      if (icTopPos + realMove.y <= this._topBoundary) {
                        verticalScrollEventType = EventType$5.SCROLL_TO_TOP;
                      }
                    }
                  }

                  if (this.horizontal) {
                    if (realMove.x < 0) {
                      var icRightPos = pos.x - anchorX * width + width;

                      if (icRightPos + realMove.x <= this._rightBoundary) {
                        horizontalScrollEventType = EventType$5.SCROLL_TO_RIGHT;
                      }
                    } else if (realMove.x > 0) {
                      var icLeftPos = pos.x - anchorX * width;

                      if (icLeftPos + realMove.x >= this._leftBoundary) {
                        horizontalScrollEventType = EventType$5.SCROLL_TO_LEFT;
                      }
                    }
                  }
                }

                this._moveContent(realMove, false);

                if (this.horizontal && realMove.x !== 0 || this.vertical && realMove.y !== 0) {
                  if (!this._scrolling) {
                    this._scrolling = true;

                    this._dispatchEvent(EventType$5.SCROLL_BEGAN);
                  }

                  this._dispatchEvent(EventType$5.SCROLLING);
                }

                if (verticalScrollEventType !== '') {
                  this._dispatchEvent(verticalScrollEventType);
                }

                if (horizontalScrollEventType !== '') {
                  this._dispatchEvent(horizontalScrollEventType);
                }
              };

              _proto._handlePressLogic = function _handlePressLogic() {
                if (this._autoScrolling) {
                  this._dispatchEvent(EventType$5.SCROLL_ENDED);
                }

                this._autoScrolling = false;
                this._isBouncing = false;
                this._touchMovePreviousTimestamp = getTimeInMilliseconds();
                this._touchMoveDisplacements.length = 0;
                this._touchMoveTimeDeltas.length = 0;

                this._onScrollBarTouchBegan();
              };

              _proto._clampDelta = function _clampDelta(out) {
                if (this._content && this.view) {
                  var scrollViewSize = this.view.contentSize;
                  var uiTrans = this._content._uiProps.uiTransformComp;

                  if (uiTrans.width < scrollViewSize.width) {
                    out.x = 0;
                  }

                  if (uiTrans.height < scrollViewSize.height) {
                    out.y = 0;
                  }
                }
              };

              _proto._gatherTouchMove = function _gatherTouchMove(delta) {
                var clampDt = delta.clone();

                this._clampDelta(clampDt);

                while (this._touchMoveDisplacements.length >= NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED) {
                  this._touchMoveDisplacements.shift();

                  this._touchMoveTimeDeltas.shift();
                }

                this._touchMoveDisplacements.push(clampDt);

                var timeStamp = getTimeInMilliseconds();

                this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1000);

                this._touchMovePreviousTimestamp = timeStamp;
              };

              _proto._startBounceBackIfNeeded = function _startBounceBackIfNeeded() {
                if (!this.elastic) {
                  return false;
                }

                var bounceBackAmount = this._getHowMuchOutOfBoundary();

                this._clampDelta(bounceBackAmount);

                if (bounceBackAmount.equals(Vec3.ZERO, EPSILON$1)) {
                  return false;
                }

                var bounceBackTime = Math.max(this.bounceDuration, 0);

                this._startAutoScroll(bounceBackAmount, bounceBackTime, true);

                if (!this._isBouncing) {
                  if (bounceBackAmount.y > 0) {
                    this._dispatchEvent(EventType$5.BOUNCE_TOP);
                  }

                  if (bounceBackAmount.y < 0) {
                    this._dispatchEvent(EventType$5.BOUNCE_BOTTOM);
                  }

                  if (bounceBackAmount.x > 0) {
                    this._dispatchEvent(EventType$5.BOUNCE_RIGHT);
                  }

                  if (bounceBackAmount.x < 0) {
                    this._dispatchEvent(EventType$5.BOUNCE_LEFT);
                  }

                  this._isBouncing = true;
                }

                return true;
              };

              _proto._processInertiaScroll = function _processInertiaScroll() {
                var bounceBackStarted = this._startBounceBackIfNeeded();

                if (!bounceBackStarted && this.inertia) {
                  var touchMoveVelocity = this._calculateTouchMoveVelocity();

                  if (!touchMoveVelocity.equals(_tempVec3$2, EPSILON$1) && this.brake < 1) {
                    this._startInertiaScroll(touchMoveVelocity);
                  }
                }

                this._onScrollBarTouchEnded();
              };

              _proto._isOutOfBoundary = function _isOutOfBoundary() {
                var outOfBoundary = this._getHowMuchOutOfBoundary();

                return !outOfBoundary.equals(Vec3.ZERO, EPSILON$1);
              };

              _proto._isNecessaryAutoScrollBrake = function _isNecessaryAutoScrollBrake() {
                if (this._autoScrollBraking) {
                  return true;
                }

                if (this._isOutOfBoundary()) {
                  if (!this._autoScrollCurrentlyOutOfBoundary) {
                    this._autoScrollCurrentlyOutOfBoundary = true;
                    this._autoScrollBraking = true;
                    Vec3.copy(this._autoScrollBrakingStartPosition, this._getContentPosition());
                    return true;
                  }
                } else {
                  this._autoScrollCurrentlyOutOfBoundary = false;
                }

                return false;
              };

              _proto._processAutoScrolling = function _processAutoScrolling(dt) {
                var isAutoScrollBrake = this._isNecessaryAutoScrollBrake();

                var brakingFactor = isAutoScrollBrake ? OUT_OF_BOUNDARY_BREAKING_FACTOR : 1;
                this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
                var percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);

                if (this._autoScrollAttenuate) {
                  percentage = quintEaseOut(percentage);
                }

                var clonedAutoScrollTargetDelta = this._autoScrollTargetDelta.clone();

                clonedAutoScrollTargetDelta.multiplyScalar(percentage);

                var clonedAutoScrollStartPosition = this._autoScrollStartPosition.clone();

                clonedAutoScrollStartPosition.add(clonedAutoScrollTargetDelta);
                var reachedEnd = Math.abs(percentage - 1) <= EPSILON$1;
                var fireEvent = Math.abs(percentage - 1) <= this.getScrollEndedEventTiming();

                if (fireEvent && !this._isScrollEndedWithThresholdEventFired) {
                  this._dispatchEvent(EventType$5.SCROLL_ENG_WITH_THRESHOLD);

                  this._isScrollEndedWithThresholdEventFired = true;
                }

                if (this.elastic) {
                  var brakeOffsetPosition = clonedAutoScrollStartPosition.clone();
                  brakeOffsetPosition.subtract(this._autoScrollBrakingStartPosition);

                  if (isAutoScrollBrake) {
                    brakeOffsetPosition.multiplyScalar(brakingFactor);
                  }

                  clonedAutoScrollStartPosition.set(this._autoScrollBrakingStartPosition);
                  clonedAutoScrollStartPosition.add(brakeOffsetPosition);
                } else {
                  var moveDelta = clonedAutoScrollStartPosition.clone();
                  moveDelta.subtract(this.getContentPosition());

                  var outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);

                  if (!outOfBoundary.equals(Vec3.ZERO, EPSILON$1)) {
                    clonedAutoScrollStartPosition.add(outOfBoundary);
                    reachedEnd = true;
                  }
                }

                if (reachedEnd) {
                  this._autoScrolling = false;
                }

                var deltaMove = clonedAutoScrollStartPosition.clone();
                deltaMove.subtract(this._getContentPosition());

                this._clampDelta(deltaMove);

                this._moveContent(deltaMove, reachedEnd);

                this._dispatchEvent(EventType$5.SCROLLING);

                if (!this._autoScrolling) {
                  this._isBouncing = false;
                  this._scrolling = false;

                  this._dispatchEvent(EventType$5.SCROLL_ENDED);
                }
              };

              _proto._checkMouseWheel = function _checkMouseWheel(dt) {
                var currentOutOfBoundary = this._getHowMuchOutOfBoundary();

                var maxElapsedTime = 0.1;

                if (!currentOutOfBoundary.equals(Vec3.ZERO, EPSILON$1)) {
                  this._processInertiaScroll();

                  this.unschedule(this._checkMouseWheel);

                  this._dispatchEvent(EventType$5.SCROLL_ENDED);

                  this._stopMouseWheel = false;
                  return;
                }

                this._mouseWheelEventElapsedTime += dt;

                if (this._mouseWheelEventElapsedTime > maxElapsedTime) {
                  this._onScrollBarTouchEnded();

                  this.unschedule(this._checkMouseWheel);

                  this._dispatchEvent(EventType$5.SCROLL_ENDED);

                  this._stopMouseWheel = false;
                }
              };

              _proto._calculateMovePercentDelta = function _calculateMovePercentDelta(options) {
                var anchor = options.anchor;
                var applyToHorizontal = options.applyToHorizontal;
                var applyToVertical = options.applyToVertical;

                this._calculateBoundary();

                anchor.clampf(Vec2.ZERO, Vec2.ONE);

                var bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;

                bottomDelta = -bottomDelta;

                var leftDelta = this._getContentLeftBoundary() - this._leftBoundary;

                leftDelta = -leftDelta;
                var moveDelta = new Vec3();

                if (this._content && this.view) {
                  var totalScrollDelta = 0;
                  var uiTrans = this._content._uiProps.uiTransformComp;
                  var contentSize = uiTrans.contentSize;
                  var scrollSize = this.view.contentSize;

                  if (applyToHorizontal) {
                    totalScrollDelta = contentSize.width - scrollSize.width;
                    moveDelta.x = leftDelta - totalScrollDelta * anchor.x;
                  }

                  if (applyToVertical) {
                    totalScrollDelta = contentSize.height - scrollSize.height;
                    moveDelta.y = bottomDelta - totalScrollDelta * anchor.y;
                  }
                }

                return moveDelta;
              };

              _proto._moveContentToTopLeft = function _moveContentToTopLeft(scrollViewSize) {
                var bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;

                bottomDelta = -bottomDelta;
                var moveDelta = new Vec3();
                var totalScrollDelta = 0;

                var leftDelta = this._getContentLeftBoundary() - this._leftBoundary;

                leftDelta = -leftDelta;

                if (this._content) {
                  var uiTrans = this._content._uiProps.uiTransformComp;
                  var contentSize = uiTrans.contentSize;

                  if (contentSize.height < scrollViewSize.height) {
                    totalScrollDelta = contentSize.height - scrollViewSize.height;
                    moveDelta.y = bottomDelta - totalScrollDelta;
                  }

                  if (contentSize.width < scrollViewSize.width) {
                    totalScrollDelta = contentSize.width - scrollViewSize.width;
                    moveDelta.x = leftDelta;
                  }
                }

                this._updateScrollBarState();

                this._moveContent(moveDelta);

                this._adjustContentOutOfBoundary();
              };

              _proto._scaleChanged = function _scaleChanged(value) {
                if (value === TransformBit.SCALE) {
                  this._calculateBoundary();
                }
              };

              _proto._xrHoverEnter = function _xrHoverEnter(event) {
                if (event.deviceType === DeviceType.Left) {
                  this._hoverIn = XrhoverType.LEFT;
                } else if (event.deviceType === DeviceType.Right) {
                  this._hoverIn = XrhoverType.RIGHT;
                }
              };

              _proto._xrHoverExit = function _xrHoverExit(event) {
                this._hoverIn = XrhoverType.NONE;
              };

              _proto._dispatchEventHandleInput = function _dispatchEventHandleInput(event) {
                var handleInputDevice;

                if (event instanceof EventGamepad) {
                  handleInputDevice = event.gamepad;
                } else if (event instanceof EventHandle) {
                  handleInputDevice = event.handleInputDevice;
                }

                var value;

                if (!this.enabledInHierarchy || this._hoverIn === XrhoverType.NONE) {
                  return;
                }

                if (this._hoverIn === XrhoverType.LEFT) {
                  value = handleInputDevice.leftStick.getValue();

                  if (!value.equals(Vec2.ZERO)) {
                    this._xrThumbStickMove(value);
                  }
                } else if (this._hoverIn === XrhoverType.RIGHT) {
                  value = handleInputDevice.rightStick.getValue();

                  if (!value.equals(Vec2.ZERO)) {
                    this._xrThumbStickMove(value);
                  }
                }
              };

              _proto._xrThumbStickMove = function _xrThumbStickMove(event) {
                if (!this.enabledInHierarchy) {
                  return;
                }

                var deltaMove = new Vec3();
                var wheelPrecision = -62.5;
                var scrollY = event.y;

                if (this.vertical) {
                  deltaMove.set(0, scrollY * wheelPrecision, 0);
                } else if (this.horizontal) {
                  deltaMove.set(scrollY * wheelPrecision, 0, 0);
                }

                this._mouseWheelEventElapsedTime = 0;

                this._processDeltaMove(deltaMove);

                if (!this._stopMouseWheel) {
                  this._handlePressLogic();

                  this.schedule(this._checkMouseWheel, 1.0 / 60, NaN, 0);
                  this._stopMouseWheel = true;
                }
              };

              _createClass(ScrollView, [{
                key: "content",
                get: function get() {
                  return this._content;
                },
                set: function set(value) {
                  if (this._content === value) {
                    return;
                  }

                  var viewTrans = value && value.parent && value.parent._uiProps.uiTransformComp;

                  if (value && (!value || !viewTrans)) {
                    logID(4302);
                    return;
                  }

                  this._content = value;

                  this._calculateBoundary();
                }
              }, {
                key: "horizontalScrollBar",
                get: function get() {
                  if (this._horizontalScrollBar && !this._horizontalScrollBar.isValid) {
                    errorID(4303, 'horizontal', this.node.name);
                  }

                  return this._horizontalScrollBar;
                },
                set: function set(value) {
                  if (this._horizontalScrollBar === value) {
                    return;
                  }

                  this._horizontalScrollBar = value;

                  if (this._horizontalScrollBar) {
                    this._horizontalScrollBar.setScrollView(this);

                    this._updateScrollBar(Vec2.ZERO);
                  }
                }
              }, {
                key: "verticalScrollBar",
                get: function get() {
                  if (this._verticalScrollBar && !this._verticalScrollBar.isValid) {
                    errorID(4303, 'vertical', this.node.name);
                  }

                  return this._verticalScrollBar;
                },
                set: function set(value) {
                  if (this._verticalScrollBar === value) {
                    return;
                  }

                  this._verticalScrollBar = value;

                  if (this._verticalScrollBar) {
                    this._verticalScrollBar.setScrollView(this);

                    this._updateScrollBar(Vec2.ZERO);
                  }
                }
              }, {
                key: "view",
                get: function get() {
                  var parent = this._content && this._content.parent;

                  if (!parent) {
                    return null;
                  }

                  return parent._uiProps.uiTransformComp;
                }
              }]);

              return ScrollView;
            }(ViewGroup), _class3$v.EventType = EventType$5, _temp$F), (_initializer$1I = applyDecoratedInitializer(_class2$1N.prototype, "bounceDuration", [serializable$j], function () {
              return 1;
            }), _initializer2$1s = applyDecoratedInitializer(_class2$1N.prototype, "brake", [serializable$j], function () {
              return 0.5;
            }), _initializer3$16 = applyDecoratedInitializer(_class2$1N.prototype, "elastic", [serializable$j], function () {
              return true;
            }), _initializer4$Y = applyDecoratedInitializer(_class2$1N.prototype, "inertia", [serializable$j], function () {
              return true;
            }), _applyDecoratedDescriptor(_class2$1N.prototype, "content", [_dec4$L], Object.getOwnPropertyDescriptor(_class2$1N.prototype, "content"), _class2$1N.prototype), _initializer5$M = applyDecoratedInitializer(_class2$1N.prototype, "horizontal", [serializable$j], function () {
              return true;
            }), _applyDecoratedDescriptor(_class2$1N.prototype, "horizontalScrollBar", [_dec5$E], Object.getOwnPropertyDescriptor(_class2$1N.prototype, "horizontalScrollBar"), _class2$1N.prototype), _initializer6$D = applyDecoratedInitializer(_class2$1N.prototype, "vertical", [serializable$j], function () {
              return true;
            }), _applyDecoratedDescriptor(_class2$1N.prototype, "verticalScrollBar", [_dec6$v], Object.getOwnPropertyDescriptor(_class2$1N.prototype, "verticalScrollBar"), _class2$1N.prototype), _initializer7$v = applyDecoratedInitializer(_class2$1N.prototype, "cancelInnerEvents", [serializable$j], function () {
              return true;
            }), _initializer8$s = applyDecoratedInitializer(_class2$1N.prototype, "scrollEvents", [_dec7$o, serializable$j], function () {
              return [];
            }), _initializer9$p = applyDecoratedInitializer(_class2$1N.prototype, "_content", [serializable$j], function () {
              return null;
            }), _initializer10$m = applyDecoratedInitializer(_class2$1N.prototype, "_horizontalScrollBar", [serializable$j], function () {
              return null;
            }), _initializer11$i = applyDecoratedInitializer(_class2$1N.prototype, "_verticalScrollBar", [serializable$j], function () {
              return null;
            })), _class2$1N)) || _class$23) || _class$23) || _class$23));
            legacyCC.ScrollView = ScrollView;

            var _dec$21, _dec2$1z, _dec3$12, _dec4$M, _dec5$F, _dec6$w, _class$24, _class2$1O, _initializer$1J, _initializer2$1t, _initializer3$17, _initializer4$Z, _class3$w, _temp$G;

            var _tempPos = new Vec3();

            var Direction$1;

            (function (Direction) {
              Direction[Direction["Horizontal"] = 0] = "Horizontal";
              Direction[Direction["Vertical"] = 1] = "Vertical";
            })(Direction$1 || (Direction$1 = {}));

            ccenum(Direction$1);
            var Slider = exports('Slider', (_dec$21 = ccclass$p('cc.Slider'), _dec2$1z = executionOrder(110), _dec3$12 = requireComponent(UITransform), _dec4$M = type$8(Sprite), _dec5$F = type$8(Direction$1), _dec6$w = type$8([EventHandler]), _dec$21(_class$24 = _dec2$1z(_class$24 = _dec3$12(_class$24 = (_class2$1O = (_temp$G = _class3$w = function (_Component) {
              _inheritsLoose(Slider, _Component);

              function Slider() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this.slideEvents = _initializer$1J && _initializer$1J();
                _this._handle = _initializer2$1t && _initializer2$1t();
                _this._direction = _initializer3$17 && _initializer3$17();
                _this._progress = _initializer4$Z && _initializer4$Z();
                _this._offset = new Vec3();
                _this._dragging = false;
                _this._touchHandle = false;
                _this._handleLocalPos = new Vec3();
                _this._touchPos = new Vec3();
                return _this;
              }

              var _proto = Slider.prototype;

              _proto.__preload = function __preload() {
                this._updateHandlePosition();
              };

              _proto.onEnable = function onEnable() {
                this._updateHandlePosition();

                this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);
                this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
                this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this);
                this.node.on(XrUIPressEventType.XRUI_HOVER_STAY, this._xrHoverStay, this);
                this.node.on(XrUIPressEventType.XRUI_CLICK, this._xrClick, this);
                this.node.on(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);

                if (this._handle && this._handle.isValid) {
                  this._handle.node.on(NodeEventType.TOUCH_START, this._onHandleDragStart, this);

                  this._handle.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);

                  this._handle.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
                }
              };

              _proto.onDisable = function onDisable() {
                this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);
                this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
                this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this);
                this.node.off(XrUIPressEventType.XRUI_HOVER_STAY, this._xrHoverStay, this);
                this.node.off(XrUIPressEventType.XRUI_CLICK, this._xrClick, this);
                this.node.off(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);

                if (this._handle && this._handle.isValid) {
                  this._handle.node.off(NodeEventType.TOUCH_START, this._onHandleDragStart, this);

                  this._handle.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);

                  this._handle.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
                }
              };

              _proto._onHandleDragStart = function _onHandleDragStart(event) {
                if (!event || !this._handle || !this._handle.node._uiProps.uiTransformComp) {
                  return;
                }

                this._dragging = true;
                this._touchHandle = true;
                var touhPos = event.touch.getUILocation();
                Vec3.set(this._touchPos, touhPos.x, touhPos.y, 0);

                this._handle.node._uiProps.uiTransformComp.convertToNodeSpaceAR(this._touchPos, this._offset);

                event.propagationStopped = true;
              };

              _proto._onTouchBegan = function _onTouchBegan(event) {
                if (!this._handle || !event) {
                  return;
                }

                this._dragging = true;

                if (!this._touchHandle) {
                  this._handleSliderLogic(event.touch);
                }

                event.propagationStopped = true;
              };

              _proto._onTouchMoved = function _onTouchMoved(event) {
                if (!this._dragging || !event) {
                  return;
                }

                this._handleSliderLogic(event.touch);

                event.propagationStopped = true;
              };

              _proto._onTouchEnded = function _onTouchEnded(event) {
                this._dragging = false;
                this._touchHandle = false;
                this._offset = new Vec3();

                if (event) {
                  event.propagationStopped = true;
                }
              };

              _proto._onTouchCancelled = function _onTouchCancelled(event) {
                this._dragging = false;

                if (event) {
                  event.propagationStopped = true;
                }
              };

              _proto._handleSliderLogic = function _handleSliderLogic(touch) {
                this._updateProgress(touch);

                this._emitSlideEvent();
              };

              _proto._emitSlideEvent = function _emitSlideEvent() {
                EventHandler.emitEvents(this.slideEvents, this);
                this.node.emit('slide', this);
              };

              _proto._updateProgress = function _updateProgress(touch) {
                if (!this._handle || !touch) {
                  return;
                }

                var touchPos = touch.getUILocation();
                Vec3.set(this._touchPos, touchPos.x, touchPos.y, 0);
                var uiTrans = this.node._uiProps.uiTransformComp;
                var localTouchPos = uiTrans.convertToNodeSpaceAR(this._touchPos, _tempPos);

                if (this.direction === Direction$1.Horizontal) {
                  this.progress = clamp01(0.5 + (localTouchPos.x - this._offset.x) / uiTrans.width);
                } else {
                  this.progress = clamp01(0.5 + (localTouchPos.y - this._offset.y) / uiTrans.height);
                }
              };

              _proto._updateHandlePosition = function _updateHandlePosition() {
                if (!this._handle) {
                  return;
                }

                this._handleLocalPos.set(this._handle.node.getPosition());

                var uiTrans = this.node._uiProps.uiTransformComp;

                if (this._direction === Direction$1.Horizontal) {
                  this._handleLocalPos.x = -uiTrans.width * uiTrans.anchorX + this.progress * uiTrans.width;
                } else {
                  this._handleLocalPos.y = -uiTrans.height * uiTrans.anchorY + this.progress * uiTrans.height;
                }

                this._handle.node.setPosition(this._handleLocalPos);
              };

              _proto._changeLayout = function _changeLayout() {
                var uiTrans = this.node._uiProps.uiTransformComp;
                var contentSize = uiTrans.contentSize;
                uiTrans.setContentSize(contentSize.height, contentSize.width);

                if (this._handle) {
                  var pos = this._handle.node.position;

                  if (this._direction === Direction$1.Horizontal) {
                    this._handle.node.setPosition(pos.x, 0, pos.z);
                  } else {
                    this._handle.node.setPosition(0, pos.y, pos.z);
                  }

                  this._updateHandlePosition();
                }
              };

              _proto._xrHandleProgress = function _xrHandleProgress(point) {
                if (!this._touchHandle) {
                  var uiTrans = this.node._uiProps.uiTransformComp;
                  uiTrans.convertToNodeSpaceAR(point, _tempPos);

                  if (this.direction === Direction$1.Horizontal) {
                    this.progress = clamp01(0.5 + (_tempPos.x - this.node.position.x) / uiTrans.width);
                  } else {
                    this.progress = clamp01(0.5 + (_tempPos.y - this.node.position.y) / uiTrans.height);
                  }
                }
              };

              _proto._xrClick = function _xrClick(event) {
                if (!this._handle) {
                  return;
                }

                this._dragging = true;

                this._xrHandleProgress(event.hitPoint);

                this._emitSlideEvent();
              };

              _proto._xrUnClick = function _xrUnClick() {
                this._dragging = false;
                this._touchHandle = false;
              };

              _proto._xrHoverStay = function _xrHoverStay(event) {
                if (!this._dragging) {
                  return;
                }

                this._xrHandleProgress(event.hitPoint);

                this._emitSlideEvent();
              };

              _createClass(Slider, [{
                key: "handle",
                get: function get() {
                  return this._handle;
                },
                set: function set(value) {
                  if (this._handle === value) {
                    return;
                  }

                  this._handle = value;
                }
              }, {
                key: "direction",
                get: function get() {
                  return this._direction;
                },
                set: function set(value) {
                  if (this._direction === value) {
                    return;
                  }

                  this._direction = value;

                  this._changeLayout();
                }
              }, {
                key: "progress",
                get: function get() {
                  return this._progress;
                },
                set: function set(value) {
                  if (this._progress === value) {
                    return;
                  }

                  this._progress = value;

                  this._updateHandlePosition();
                }
              }]);

              return Slider;
            }(Component), _class3$w.Direction = Direction$1, _temp$G), (_applyDecoratedDescriptor(_class2$1O.prototype, "handle", [_dec4$M], Object.getOwnPropertyDescriptor(_class2$1O.prototype, "handle"), _class2$1O.prototype), _applyDecoratedDescriptor(_class2$1O.prototype, "direction", [_dec5$F], Object.getOwnPropertyDescriptor(_class2$1O.prototype, "direction"), _class2$1O.prototype), _initializer$1J = applyDecoratedInitializer(_class2$1O.prototype, "slideEvents", [_dec6$w, serializable$j], function () {
              return [];
            }), _initializer2$1t = applyDecoratedInitializer(_class2$1O.prototype, "_handle", [serializable$j], function () {
              return null;
            }), _initializer3$17 = applyDecoratedInitializer(_class2$1O.prototype, "_direction", [serializable$j], function () {
              return Direction$1.Horizontal;
            }), _initializer4$Z = applyDecoratedInitializer(_class2$1O.prototype, "_progress", [serializable$j], function () {
              return 0.1;
            })), _class2$1O)) || _class$24) || _class$24) || _class$24));
            legacyCC.Slider = Slider;

            function extendsEnum() {
              for (var _len = arguments.length, enums = new Array(_len), _key = 0; _key < _len; _key++) {
                enums[_key] = arguments[_key];
              }

              return Object.assign.apply(Object, [{}].concat(enums));
            }

            var _dec$22, _dec2$1A, _dec3$13, _dec4$N, _dec5$G, _class$25, _class2$1P, _initializer$1K, _initializer2$1u, _initializer3$18, _class3$x, _temp$H;
            var EventType$6;

            (function (EventType) {
              EventType["TOGGLE"] = "toggle";
            })(EventType$6 || (EventType$6 = {}));

            var Toggle = exports('Toggle', (_dec$22 = ccclass$p('cc.Toggle'), _dec2$1A = executionOrder(110), _dec3$13 = requireComponent(UITransform), _dec4$N = type$8(Sprite), _dec5$G = type$8([EventHandler]), _dec$22(_class$25 = _dec2$1A(_class$25 = _dec3$13(_class$25 = (_class2$1P = (_temp$H = _class3$x = function (_Button) {
              _inheritsLoose(Toggle, _Button);

              function Toggle() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Button.call.apply(_Button, [this].concat(args)) || this;
                _this.checkEvents = _initializer$1K && _initializer$1K();
                _this._isChecked = _initializer2$1u && _initializer2$1u();
                _this._checkMark = _initializer3$18 && _initializer3$18();
                return _this;
              }

              var _proto = Toggle.prototype;

              _proto._internalToggle = function _internalToggle() {
                this.isChecked = !this.isChecked;
              };

              _proto._set = function _set(value, emitEvent) {
                if (emitEvent === void 0) {
                  emitEvent = true;
                }

                if (this._isChecked == value) return;
                this._isChecked = value;
                var group = this._toggleContainer;

                if (group && group.enabled && this.enabled) {
                  if (value || !group.anyTogglesChecked() && !group.allowSwitchOff) {
                    this._isChecked = true;
                    group.notifyToggleCheck(this, emitEvent);
                  }
                }

                this.playEffect();

                if (emitEvent) {
                  this._emitToggleEvents();
                }
              };

              _proto.playEffect = function playEffect() {
                if (this._checkMark) {
                  this._checkMark.node.active = this._isChecked;
                }
              };

              _proto.setIsCheckedWithoutNotify = function setIsCheckedWithoutNotify(value) {
                this._set(value, false);
              };

              _proto.onEnable = function onEnable() {
                _Button.prototype.onEnable.call(this);

                this.playEffect();

                {
                  this.node.on(Toggle.EventType.CLICK, this._internalToggle, this);
                }
              };

              _proto.onDisable = function onDisable() {
                _Button.prototype.onDisable.call(this);

                {
                  this.node.off(Toggle.EventType.CLICK, this._internalToggle, this);
                }
              };

              _proto._emitToggleEvents = function _emitToggleEvents() {
                this.node.emit(Toggle.EventType.TOGGLE, this);

                if (this.checkEvents) {
                  EventHandler.emitEvents(this.checkEvents, this);
                }
              };

              _createClass(Toggle, [{
                key: "isChecked",
                get: function get() {
                  return this._isChecked;
                },
                set: function set(value) {
                  this._set(value);
                }
              }, {
                key: "checkMark",
                get: function get() {
                  return this._checkMark;
                },
                set: function set(value) {
                  if (this._checkMark === value) {
                    return;
                  }

                  this._checkMark = value;
                }
              }, {
                key: "_resizeToTarget",
                set: function set(value) {
                  if (value) {
                    this._resizeNodeToTargetNode();
                  }
                }
              }, {
                key: "_toggleContainer",
                get: function get() {
                  var parent = this.node.parent;

                  if (legacyCC.Node.isNode(parent)) {
                    return parent.getComponent('cc.ToggleContainer');
                  }

                  return null;
                }
              }]);

              return Toggle;
            }(Button), _class3$x.EventType = extendsEnum(EventType$6, EventType$3), _temp$H), (_applyDecoratedDescriptor(_class2$1P.prototype, "checkMark", [_dec4$N], Object.getOwnPropertyDescriptor(_class2$1P.prototype, "checkMark"), _class2$1P.prototype), _initializer$1K = applyDecoratedInitializer(_class2$1P.prototype, "checkEvents", [_dec5$G, serializable$j], function () {
              return [];
            }), _initializer2$1u = applyDecoratedInitializer(_class2$1P.prototype, "_isChecked", [serializable$j], function () {
              return true;
            }), _initializer3$18 = applyDecoratedInitializer(_class2$1P.prototype, "_checkMark", [serializable$j], function () {
              return null;
            })), _class2$1P)) || _class$25) || _class$25) || _class$25));
            legacyCC.Toggle = Toggle;

            var _dec$23, _dec2$1B, _dec3$14, _class$26, _class2$1Q, _initializer$1L, _initializer2$1v;
            var ToggleContainer = exports('ToggleContainer', (_dec$23 = ccclass$p('cc.ToggleContainer'), _dec2$1B = executionOrder(110), _dec3$14 = type$8([EventHandler]), _dec$23(_class$26 = _dec2$1B(_class$26 = (_class2$1Q = function (_Component) {
              _inheritsLoose(ToggleContainer, _Component);

              function ToggleContainer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._allowSwitchOff = _initializer$1L && _initializer$1L();
                _this.checkEvents = _initializer2$1v && _initializer2$1v();
                return _this;
              }

              var _proto = ToggleContainer.prototype;

              _proto.onEnable = function onEnable() {
                this.ensureValidState();
                this.node.on(NodeEventType.CHILD_ADDED, this.ensureValidState, this);
                this.node.on(NodeEventType.CHILD_REMOVED, this.ensureValidState, this);
              };

              _proto.onDisable = function onDisable() {
                this.node.off(NodeEventType.CHILD_ADDED, this.ensureValidState, this);
                this.node.off(NodeEventType.CHILD_REMOVED, this.ensureValidState, this);
              };

              _proto.activeToggles = function activeToggles() {
                return this.toggleItems.filter(function (x) {
                  return x.isChecked;
                });
              };

              _proto.anyTogglesChecked = function anyTogglesChecked() {
                return !!this.toggleItems.find(function (x) {
                  return x.isChecked;
                });
              };

              _proto.notifyToggleCheck = function notifyToggleCheck(toggle, emitEvent) {
                if (emitEvent === void 0) {
                  emitEvent = true;
                }

                if (!this.enabledInHierarchy) {
                  return;
                }

                for (var i = 0; i < this.toggleItems.length; i++) {
                  var item = this.toggleItems[i];

                  if (item === toggle) {
                    continue;
                  }

                  if (emitEvent) {
                    item.isChecked = false;
                  } else {
                    item.setIsCheckedWithoutNotify(false);
                  }
                }

                if (this.checkEvents) {
                  legacyCC.Component.EventHandler.emitEvents(this.checkEvents, toggle);
                }
              };

              _proto.ensureValidState = function ensureValidState() {
                var toggles = this.toggleItems;

                if (!this._allowSwitchOff && !this.anyTogglesChecked() && toggles.length !== 0) {
                  var toggle = toggles[0];
                  toggle.isChecked = true;
                  this.notifyToggleCheck(toggle);
                }

                var activeToggles = this.activeToggles();

                if (activeToggles.length > 1) {
                  var firstToggle = activeToggles[0];

                  for (var i = 0; i < activeToggles.length; ++i) {
                    var _toggle = activeToggles[i];

                    if (_toggle === firstToggle) {
                      continue;
                    }

                    _toggle.isChecked = false;
                  }
                }
              };

              _createClass(ToggleContainer, [{
                key: "allowSwitchOff",
                get: function get() {
                  return this._allowSwitchOff;
                },
                set: function set(value) {
                  this._allowSwitchOff = value;
                }
              }, {
                key: "toggleItems",
                get: function get() {
                  return this.node.children.map(function (item) {
                    var toggle = item.getComponent('cc.Toggle');

                    if (toggle && toggle.enabled) {
                      return toggle;
                    }

                    return null;
                  }).filter(Boolean);
                }
              }]);

              return ToggleContainer;
            }(Component), (_initializer$1L = applyDecoratedInitializer(_class2$1Q.prototype, "_allowSwitchOff", [serializable$j], function () {
              return false;
            }), _initializer2$1v = applyDecoratedInitializer(_class2$1Q.prototype, "checkEvents", [_dec3$14, serializable$j], function () {
              return [];
            })), _class2$1Q)) || _class$26) || _class$26));
            legacyCC.ToggleContainer = ToggleContainer;

            var _dec$24, _dec2$1C, _dec3$15, _dec4$O, _dec5$H, _class$27, _class2$1R, _initializer$1M, _initializer2$1w, _initializer3$19, _initializer4$_, _initializer5$N, _initializer6$E, _initializer7$w, _initializer8$t, _initializer9$q, _initializer10$n, _initializer11$j, _initializer12$i, _initializer13$i, _initializer14$d, _initializer15$b, _initializer16$b, _initializer17$9, _initializer18$8, _class3$y, _temp$I;

            var _tempScale = new Vec2();

            function getReadonlyNodeSize(parent) {
              if (parent instanceof Scene) {

                return visibleRect;
              } else if (parent._uiProps.uiTransformComp) {
                return parent._uiProps.uiTransformComp.contentSize;
              } else {
                return Size$1.ZERO;
              }
            }
            function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
              if (widgetNode.parent) {
                _tempScale.set(widgetNode.parent.getScale().x, widgetNode.parent.getScale().y);
              } else {
                _tempScale.set(0, 0);
              }

              var scaleX = _tempScale.x;
              var scaleY = _tempScale.y;
              var translateX = 0;
              var translateY = 0;

              for (var node = widgetNode.parent;;) {
                if (!node) {
                  out_inverseTranslate.x = out_inverseTranslate.y = 0;
                  out_inverseScale.x = out_inverseScale.y = 1;
                  return;
                }

                var pos = node.getPosition();
                translateX += pos.x;
                translateY += pos.y;
                node = node.parent;

                if (node !== target) {
                  if (node) {
                    _tempScale.set(node.getScale().x, node.getScale().y);
                  } else {
                    _tempScale.set(0, 0);
                  }

                  var sx = _tempScale.x;
                  var sy = _tempScale.y;
                  translateX *= sx;
                  translateY *= sy;
                  scaleX *= sx;
                  scaleY *= sy;
                } else {
                  break;
                }
              }

              out_inverseScale.x = scaleX !== 0 ? 1 / scaleX : 1;
              out_inverseScale.y = scaleY !== 0 ? 1 / scaleY : 1;
              out_inverseTranslate.x = -translateX;
              out_inverseTranslate.y = -translateY;
            }
            var AlignMode;

            (function (AlignMode) {
              AlignMode[AlignMode["ONCE"] = 0] = "ONCE";
              AlignMode[AlignMode["ALWAYS"] = 1] = "ALWAYS";
              AlignMode[AlignMode["ON_WINDOW_RESIZE"] = 2] = "ON_WINDOW_RESIZE";
            })(AlignMode || (AlignMode = {}));

            ccenum(AlignMode);
            var AlignFlags;

            (function (AlignFlags) {
              AlignFlags[AlignFlags["TOP"] = 1] = "TOP";
              AlignFlags[AlignFlags["MID"] = 2] = "MID";
              AlignFlags[AlignFlags["BOT"] = 4] = "BOT";
              AlignFlags[AlignFlags["LEFT"] = 8] = "LEFT";
              AlignFlags[AlignFlags["CENTER"] = 16] = "CENTER";
              AlignFlags[AlignFlags["RIGHT"] = 32] = "RIGHT";
              AlignFlags[AlignFlags["HORIZONTAL"] = 56] = "HORIZONTAL";
              AlignFlags[AlignFlags["VERTICAL"] = 7] = "VERTICAL";
            })(AlignFlags || (AlignFlags = {}));

            var TOP_BOT = AlignFlags.TOP | AlignFlags.BOT;
            var LEFT_RIGHT = AlignFlags.LEFT | AlignFlags.RIGHT;
            var Widget = exports('Widget', (_dec$24 = ccclass$p('cc.Widget'), _dec2$1C = executionOrder(110), _dec3$15 = requireComponent(UITransform), _dec4$O = type$8(Node), _dec5$H = type$8(AlignMode), _dec$24(_class$27 = _dec2$1C(_class$27 = _dec3$15(_class$27 = (_class2$1R = (_temp$I = _class3$y = function (_Component) {
              _inheritsLoose(Widget, _Component);

              function Widget() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._lastPos = new Vec3();
                _this._lastSize = new Size$1();
                _this._dirty = true;
                _this._hadAlignOnce = false;
                _this._alignFlags = _initializer$1M && _initializer$1M();
                _this._target = _initializer2$1w && _initializer2$1w();
                _this._left = _initializer3$19 && _initializer3$19();
                _this._right = _initializer4$_ && _initializer4$_();
                _this._top = _initializer5$N && _initializer5$N();
                _this._bottom = _initializer6$E && _initializer6$E();
                _this._horizontalCenter = _initializer7$w && _initializer7$w();
                _this._verticalCenter = _initializer8$t && _initializer8$t();
                _this._isAbsLeft = _initializer9$q && _initializer9$q();
                _this._isAbsRight = _initializer10$n && _initializer10$n();
                _this._isAbsTop = _initializer11$j && _initializer11$j();
                _this._isAbsBottom = _initializer12$i && _initializer12$i();
                _this._isAbsHorizontalCenter = _initializer13$i && _initializer13$i();
                _this._isAbsVerticalCenter = _initializer14$d && _initializer14$d();
                _this._originalWidth = _initializer15$b && _initializer15$b();
                _this._originalHeight = _initializer16$b && _initializer16$b();
                _this._alignMode = _initializer17$9 && _initializer17$9();
                _this._lockFlags = _initializer18$8 && _initializer18$8();
                return _this;
              }

              var _proto = Widget.prototype;

              _proto.updateAlignment = function updateAlignment() {
                legacyCC._widgetManager.updateAlignment(this.node);
              };

              _proto._validateTargetInDEV = function _validateTargetInDEV() {
                {
                  return;
                }
              };

              _proto.setDirty = function setDirty() {
                this._recursiveDirty();
              };

              _proto.onEnable = function onEnable() {
                this.node.getPosition(this._lastPos);

                this._lastSize.set(this.node._uiProps.uiTransformComp.contentSize);

                legacyCC._widgetManager.add(this);

                this._hadAlignOnce = false;

                this._registerEvent();

                this._registerTargetEvents();
              };

              _proto.onDisable = function onDisable() {
                legacyCC._widgetManager.remove(this);

                this._unregisterEvent();

                this._unregisterTargetEvents();
              };

              _proto.onDestroy = function onDestroy() {
                this._removeParentEvent();
              };

              _proto._adjustWidgetToAllowMovingInEditor = function _adjustWidgetToAllowMovingInEditor(eventType) {};

              _proto._adjustWidgetToAllowResizingInEditor = function _adjustWidgetToAllowResizingInEditor() {};

              _proto._adjustWidgetToAnchorChanged = function _adjustWidgetToAnchorChanged() {
                this.setDirty();
              };

              _proto._adjustTargetToParentChanged = function _adjustTargetToParentChanged(oldParent) {
                if (oldParent) {
                  this._unregisterOldParentEvents(oldParent);
                }

                if (this.node.getParent()) {
                  this._registerTargetEvents();
                }

                this._setDirtyByMode();
              };

              _proto._registerEvent = function _registerEvent() {
                {
                  this.node.on(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
                  this.node.on(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
                }

                this.node.on(NodeEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
                this.node.on(NodeEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
              };

              _proto._unregisterEvent = function _unregisterEvent() {
                {
                  this.node.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
                  this.node.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
                }

                this.node.off(NodeEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
              };

              _proto._removeParentEvent = function _removeParentEvent() {
                this.node.off(NodeEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
              };

              _proto._autoChangedValue = function _autoChangedValue(flag, isAbs) {
                var current = (this._alignFlags & flag) > 0;

                if (!current) {
                  return;
                }

                var parentUiProps = this.node.parent && this.node.parent._uiProps;
                var parentTrans = parentUiProps && parentUiProps.uiTransformComp;
                var size = parentTrans ? parentTrans.contentSize : visibleRect;

                if (this.isAlignLeft && flag === AlignFlags.LEFT) {
                  this._left = isAbs ? this._left * size.width : this._left / size.width;
                } else if (this.isAlignRight && flag === AlignFlags.RIGHT) {
                  this._right = isAbs ? this._right * size.width : this._right / size.width;
                } else if (this.isAlignHorizontalCenter && flag === AlignFlags.CENTER) {
                  this._horizontalCenter = isAbs ? this._horizontalCenter * size.width : this._horizontalCenter / size.width;
                } else if (this.isAlignTop && flag === AlignFlags.TOP) {
                  this._top = isAbs ? this._top * size.height : this._top / size.height;
                } else if (this.isAlignBottom && flag === AlignFlags.BOT) {
                  this._bottom = isAbs ? this._bottom * size.height : this._bottom / size.height;
                } else if (this.isAbsoluteVerticalCenter && flag === AlignFlags.MID) {
                  this._verticalCenter = isAbs ? this._verticalCenter / size.height : this._verticalCenter / size.height;
                }

                this._recursiveDirty();
              };

              _proto._registerTargetEvents = function _registerTargetEvents() {
                var target = this._target || this.node.parent;

                if (target) {
                  if (target.getComponent(UITransform)) {
                    target.on(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
                    target.on(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
                    target.on(NodeEventType.ANCHOR_CHANGED, this._setDirtyByMode, this);
                  }
                }
              };

              _proto._unregisterTargetEvents = function _unregisterTargetEvents() {
                var target = this._target || this.node.parent;

                if (target) {
                  target.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
                  target.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
                  target.off(NodeEventType.ANCHOR_CHANGED, this._setDirtyByMode, this);
                }
              };

              _proto._unregisterOldParentEvents = function _unregisterOldParentEvents(oldParent) {
                var target = this._target || oldParent;

                if (target) {
                  target.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
                  target.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
                }
              };

              _proto._setDirtyByMode = function _setDirtyByMode() {
                if (this.alignMode === AlignMode.ALWAYS || EDITOR ) {
                  this._recursiveDirty();
                }
              };

              _proto._setAlign = function _setAlign(flag, isAlign) {
                var current = (this._alignFlags & flag) > 0;

                if (isAlign === current) {
                  return;
                }

                var isHorizontal = (flag & LEFT_RIGHT) > 0;
                var trans = this.node._uiProps.uiTransformComp;

                if (isAlign) {
                  this._alignFlags |= flag;

                  if (isHorizontal) {
                    this.isAlignHorizontalCenter = false;

                    if (this.isStretchWidth) {
                      this._originalWidth = trans.width;
                    }
                  } else {
                    this.isAlignVerticalCenter = false;

                    if (this.isStretchHeight) {
                      this._originalHeight = trans.height;
                    }
                  }
                } else {
                  if (isHorizontal) {
                    if (this.isStretchWidth) {
                      trans.width = this._originalWidth;
                    }
                  } else if (this.isStretchHeight) {
                    trans.height = this._originalHeight;
                  }

                  this._alignFlags &= ~flag;
                }
              };

              _proto._recursiveDirty = function _recursiveDirty() {
                if (this._dirty) {
                  return;
                }

                this._dirty = true;
              };

              _createClass(Widget, [{
                key: "target",
                get: function get() {
                  return this._target;
                },
                set: function set(value) {
                  if (this._target === value) {
                    return;
                  }

                  this._unregisterTargetEvents();

                  this._target = value;

                  this._registerTargetEvents();

                  this._validateTargetInDEV();

                  this._recursiveDirty();
                }
              }, {
                key: "isAlignTop",
                get: function get() {
                  return (this._alignFlags & AlignFlags.TOP) > 0;
                },
                set: function set(value) {
                  this._setAlign(AlignFlags.TOP, value);

                  this._recursiveDirty();
                }
              }, {
                key: "isAlignBottom",
                get: function get() {
                  return (this._alignFlags & AlignFlags.BOT) > 0;
                },
                set: function set(value) {
                  this._setAlign(AlignFlags.BOT, value);

                  this._recursiveDirty();
                }
              }, {
                key: "isAlignLeft",
                get: function get() {
                  return (this._alignFlags & AlignFlags.LEFT) > 0;
                },
                set: function set(value) {
                  this._setAlign(AlignFlags.LEFT, value);

                  this._recursiveDirty();
                }
              }, {
                key: "isAlignRight",
                get: function get() {
                  return (this._alignFlags & AlignFlags.RIGHT) > 0;
                },
                set: function set(value) {
                  this._setAlign(AlignFlags.RIGHT, value);

                  this._recursiveDirty();
                }
              }, {
                key: "isAlignVerticalCenter",
                get: function get() {
                  return (this._alignFlags & AlignFlags.MID) > 0;
                },
                set: function set(value) {
                  if (value) {
                    this.isAlignTop = false;
                    this.isAlignBottom = false;
                    this._alignFlags |= AlignFlags.MID;
                  } else {
                    this._alignFlags &= ~AlignFlags.MID;
                  }

                  this._recursiveDirty();
                }
              }, {
                key: "isAlignHorizontalCenter",
                get: function get() {
                  return (this._alignFlags & AlignFlags.CENTER) > 0;
                },
                set: function set(value) {
                  if (value) {
                    this.isAlignLeft = false;
                    this.isAlignRight = false;
                    this._alignFlags |= AlignFlags.CENTER;
                  } else {
                    this._alignFlags &= ~AlignFlags.CENTER;
                  }

                  this._recursiveDirty();
                }
              }, {
                key: "isStretchWidth",
                get: function get() {
                  return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
                }
              }, {
                key: "isStretchHeight",
                get: function get() {
                  return (this._alignFlags & TOP_BOT) === TOP_BOT;
                }
              }, {
                key: "top",
                get: function get() {
                  return this._top;
                },
                set: function set(value) {
                  this._top = value;

                  this._recursiveDirty();
                }
              }, {
                key: "editorTop",
                get: function get() {
                  return this._isAbsTop ? this._top : this._top * 100;
                },
                set: function set(value) {
                  this._top = this._isAbsTop ? value : value / 100;

                  this._recursiveDirty();
                }
              }, {
                key: "bottom",
                get: function get() {
                  return this._bottom;
                },
                set: function set(value) {
                  this._bottom = value;

                  this._recursiveDirty();
                }
              }, {
                key: "editorBottom",
                get: function get() {
                  return this._isAbsBottom ? this._bottom : this._bottom * 100;
                },
                set: function set(value) {
                  this._bottom = this._isAbsBottom ? value : value / 100;

                  this._recursiveDirty();
                }
              }, {
                key: "left",
                get: function get() {
                  return this._left;
                },
                set: function set(value) {
                  this._left = value;

                  this._recursiveDirty();
                }
              }, {
                key: "editorLeft",
                get: function get() {
                  return this._isAbsLeft ? this._left : this._left * 100;
                },
                set: function set(value) {
                  this._left = this._isAbsLeft ? value : value / 100;

                  this._recursiveDirty();
                }
              }, {
                key: "right",
                get: function get() {
                  return this._right;
                },
                set: function set(value) {
                  this._right = value;

                  this._recursiveDirty();
                }
              }, {
                key: "editorRight",
                get: function get() {
                  return this._isAbsRight ? this._right : this._right * 100;
                },
                set: function set(value) {
                  this._right = this._isAbsRight ? value : value / 100;

                  this._recursiveDirty();
                }
              }, {
                key: "horizontalCenter",
                get: function get() {
                  return this._horizontalCenter;
                },
                set: function set(value) {
                  this._horizontalCenter = value;

                  this._recursiveDirty();
                }
              }, {
                key: "editorHorizontalCenter",
                get: function get() {
                  return this._isAbsHorizontalCenter ? this._horizontalCenter : this._horizontalCenter * 100;
                },
                set: function set(value) {
                  this._horizontalCenter = this._isAbsHorizontalCenter ? value : value / 100;

                  this._recursiveDirty();
                }
              }, {
                key: "verticalCenter",
                get: function get() {
                  return this._verticalCenter;
                },
                set: function set(value) {
                  this._verticalCenter = value;

                  this._recursiveDirty();
                }
              }, {
                key: "editorVerticalCenter",
                get: function get() {
                  return this._isAbsVerticalCenter ? this._verticalCenter : this._verticalCenter * 100;
                },
                set: function set(value) {
                  this._verticalCenter = this._isAbsVerticalCenter ? value : value / 100;

                  this._recursiveDirty();
                }
              }, {
                key: "isAbsoluteTop",
                get: function get() {
                  return this._isAbsTop;
                },
                set: function set(value) {
                  if (this._isAbsTop === value) {
                    return;
                  }

                  this._isAbsTop = value;

                  this._autoChangedValue(AlignFlags.TOP, this._isAbsTop);
                }
              }, {
                key: "isAbsoluteBottom",
                get: function get() {
                  return this._isAbsBottom;
                },
                set: function set(value) {
                  if (this._isAbsBottom === value) {
                    return;
                  }

                  this._isAbsBottom = value;

                  this._autoChangedValue(AlignFlags.BOT, this._isAbsBottom);
                }
              }, {
                key: "isAbsoluteLeft",
                get: function get() {
                  return this._isAbsLeft;
                },
                set: function set(value) {
                  if (this._isAbsLeft === value) {
                    return;
                  }

                  this._isAbsLeft = value;

                  this._autoChangedValue(AlignFlags.LEFT, this._isAbsLeft);
                }
              }, {
                key: "isAbsoluteRight",
                get: function get() {
                  return this._isAbsRight;
                },
                set: function set(value) {
                  if (this._isAbsRight === value) {
                    return;
                  }

                  this._isAbsRight = value;

                  this._autoChangedValue(AlignFlags.RIGHT, this._isAbsRight);
                }
              }, {
                key: "isAbsoluteHorizontalCenter",
                get: function get() {
                  return this._isAbsHorizontalCenter;
                },
                set: function set(value) {
                  if (this._isAbsHorizontalCenter === value) {
                    return;
                  }

                  this._isAbsHorizontalCenter = value;

                  this._autoChangedValue(AlignFlags.CENTER, this._isAbsHorizontalCenter);
                }
              }, {
                key: "isAbsoluteVerticalCenter",
                get: function get() {
                  return this._isAbsVerticalCenter;
                },
                set: function set(value) {
                  if (this._isAbsVerticalCenter === value) {
                    return;
                  }

                  this._isAbsVerticalCenter = value;

                  this._autoChangedValue(AlignFlags.MID, this._isAbsVerticalCenter);
                }
              }, {
                key: "alignMode",
                get: function get() {
                  return this._alignMode;
                },
                set: function set(value) {
                  this._alignMode = value;

                  this._recursiveDirty();
                }
              }, {
                key: "alignFlags",
                get: function get() {
                  return this._alignFlags;
                },
                set: function set(value) {
                  if (this._alignFlags === value) {
                    return;
                  }

                  this._alignFlags = value;

                  this._recursiveDirty();
                }
              }]);

              return Widget;
            }(Component), _class3$y.AlignMode = AlignMode, _temp$I), (_applyDecoratedDescriptor(_class2$1R.prototype, "target", [_dec4$O], Object.getOwnPropertyDescriptor(_class2$1R.prototype, "target"), _class2$1R.prototype), _applyDecoratedDescriptor(_class2$1R.prototype, "alignMode", [_dec5$H], Object.getOwnPropertyDescriptor(_class2$1R.prototype, "alignMode"), _class2$1R.prototype), _initializer$1M = applyDecoratedInitializer(_class2$1R.prototype, "_alignFlags", [serializable$j], function () {
              return 0;
            }), _initializer2$1w = applyDecoratedInitializer(_class2$1R.prototype, "_target", [serializable$j], function () {
              return null;
            }), _initializer3$19 = applyDecoratedInitializer(_class2$1R.prototype, "_left", [serializable$j], function () {
              return 0;
            }), _initializer4$_ = applyDecoratedInitializer(_class2$1R.prototype, "_right", [serializable$j], function () {
              return 0;
            }), _initializer5$N = applyDecoratedInitializer(_class2$1R.prototype, "_top", [serializable$j], function () {
              return 0;
            }), _initializer6$E = applyDecoratedInitializer(_class2$1R.prototype, "_bottom", [serializable$j], function () {
              return 0;
            }), _initializer7$w = applyDecoratedInitializer(_class2$1R.prototype, "_horizontalCenter", [serializable$j], function () {
              return 0;
            }), _initializer8$t = applyDecoratedInitializer(_class2$1R.prototype, "_verticalCenter", [serializable$j], function () {
              return 0;
            }), _initializer9$q = applyDecoratedInitializer(_class2$1R.prototype, "_isAbsLeft", [serializable$j], function () {
              return true;
            }), _initializer10$n = applyDecoratedInitializer(_class2$1R.prototype, "_isAbsRight", [serializable$j], function () {
              return true;
            }), _initializer11$j = applyDecoratedInitializer(_class2$1R.prototype, "_isAbsTop", [serializable$j], function () {
              return true;
            }), _initializer12$i = applyDecoratedInitializer(_class2$1R.prototype, "_isAbsBottom", [serializable$j], function () {
              return true;
            }), _initializer13$i = applyDecoratedInitializer(_class2$1R.prototype, "_isAbsHorizontalCenter", [serializable$j], function () {
              return true;
            }), _initializer14$d = applyDecoratedInitializer(_class2$1R.prototype, "_isAbsVerticalCenter", [serializable$j], function () {
              return true;
            }), _initializer15$b = applyDecoratedInitializer(_class2$1R.prototype, "_originalWidth", [serializable$j], function () {
              return 0;
            }), _initializer16$b = applyDecoratedInitializer(_class2$1R.prototype, "_originalHeight", [serializable$j], function () {
              return 0;
            }), _initializer17$9 = applyDecoratedInitializer(_class2$1R.prototype, "_alignMode", [serializable$j], function () {
              return AlignMode.ON_WINDOW_RESIZE;
            }), _initializer18$8 = applyDecoratedInitializer(_class2$1R.prototype, "_lockFlags", [serializable$j, editorOnly], function () {
              return 0;
            })), _class2$1R)) || _class$27) || _class$27) || _class$27));
            legacyCC.internal.computeInverseTransForTarget = computeInverseTransForTarget;
            legacyCC.internal.getReadonlyNodeSize = getReadonlyNodeSize;
            legacyCC.Widget = Widget;

            var _dec$25, _dec2$1D, _dec3$16, _dec4$P, _dec5$I, _class$28, _class2$1S, _initializer$1N, _initializer2$1x, _initializer3$1a, _initializer4$$, _class3$z, _temp$J;

            var _color$1 = new Color$1();

            var Direction$2;

            (function (Direction) {
              Direction[Direction["HORIZONTAL"] = 0] = "HORIZONTAL";
              Direction[Direction["VERTICAL"] = 1] = "VERTICAL";
            })(Direction$2 || (Direction$2 = {}));

            ccenum(Direction$2);
            var PageViewIndicator = exports('PageViewIndicator', (_dec$25 = ccclass$p('cc.PageViewIndicator'), _dec2$1D = executionOrder(110), _dec3$16 = type$8(SpriteFrame), _dec4$P = type$8(Direction$2), _dec5$I = type$8(Size$1), _dec$25(_class$28 = _dec2$1D(_class$28 = (_class2$1S = (_temp$J = _class3$z = function (_Component) {
              _inheritsLoose(PageViewIndicator, _Component);

              function PageViewIndicator() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this.spacing = _initializer$1N && _initializer$1N();
                _this._spriteFrame = _initializer2$1x && _initializer2$1x();
                _this._direction = _initializer3$1a && _initializer3$1a();
                _this._cellSize = _initializer4$$ && _initializer4$$();
                _this._layout = null;
                _this._pageView = null;
                _this._indicators = [];
                return _this;
              }

              var _proto = PageViewIndicator.prototype;

              _proto.onLoad = function onLoad() {
                this._updateLayout();
              };

              _proto.setPageView = function setPageView(target) {
                this._pageView = target;

                this._refresh();
              };

              _proto._updateLayout = function _updateLayout() {
                this._layout = this.getComponent(Layout);

                if (!this._layout) {
                  this._layout = this.addComponent(Layout);
                }

                var layout = this._layout;

                if (this.direction === Direction$2.HORIZONTAL) {
                  layout.type = Layout.Type.HORIZONTAL;
                  layout.spacingX = this.spacing;
                } else if (this.direction === Direction$2.VERTICAL) {
                  layout.type = Layout.Type.VERTICAL;
                  layout.spacingY = this.spacing;
                }

                layout.resizeMode = Layout.ResizeMode.CONTAINER;
              };

              _proto._createIndicator = function _createIndicator() {
                var node = new Node();
                node.layer = this.node.layer;
                var sprite = node.addComponent(Sprite);
                sprite.spriteFrame = this.spriteFrame;
                sprite.sizeMode = Sprite.SizeMode.CUSTOM;
                node.parent = this.node;

                node._uiProps.uiTransformComp.setContentSize(this._cellSize);

                return node;
              };

              _proto._changedState = function _changedState() {
                var indicators = this._indicators;

                if (indicators.length === 0 || !this._pageView) {
                  return;
                }

                var idx = this._pageView.curPageIdx;

                if (idx >= indicators.length) {
                  return;
                }

                for (var i = 0; i < indicators.length; ++i) {
                  var node = indicators[i];

                  if (!node._uiProps.uiComp) {
                    continue;
                  }

                  var uiComp = node._uiProps.uiComp;

                  _color$1.set(uiComp.color);

                  _color$1.a = 255 / 2;
                  uiComp.color = _color$1;
                }

                if (indicators[idx]._uiProps.uiComp) {
                  var comp = indicators[idx]._uiProps.uiComp;

                  _color$1.set(comp.color);

                  _color$1.a = 255;
                  comp.color = _color$1;
                }
              };

              _proto._refresh = function _refresh() {
                if (!this._pageView) {
                  return;
                }

                var indicators = this._indicators;

                var pages = this._pageView.getPages();

                if (pages.length === indicators.length) {
                  return;
                }

                var i = 0;

                if (pages.length > indicators.length) {
                  for (i = 0; i < pages.length; ++i) {
                    if (!indicators[i]) {
                      indicators[i] = this._createIndicator();
                    }
                  }
                } else {
                  var count = indicators.length - pages.length;

                  for (i = count; i > 0; --i) {
                    var node = indicators[i - 1];
                    this.node.removeChild(node);
                    indicators.splice(i - 1, 1);
                  }
                }

                if (this._layout && this._layout.enabledInHierarchy) {
                  this._layout.updateLayout();
                }

                this._changedState();
              };

              _createClass(PageViewIndicator, [{
                key: "spriteFrame",
                get: function get() {
                  return this._spriteFrame;
                },
                set: function set(value) {
                  if (this._spriteFrame === value) {
                    return;
                  }

                  this._spriteFrame = value;
                }
              }, {
                key: "direction",
                get: function get() {
                  return this._direction;
                },
                set: function set(value) {
                  if (this._direction === value) {
                    return;
                  }

                  this._direction = value;
                }
              }, {
                key: "cellSize",
                get: function get() {
                  return this._cellSize;
                },
                set: function set(value) {
                  if (this._cellSize === value) {
                    return;
                  }

                  this._cellSize = value;
                }
              }]);

              return PageViewIndicator;
            }(Component), _class3$z.Direction = Direction$2, _temp$J), (_applyDecoratedDescriptor(_class2$1S.prototype, "spriteFrame", [_dec3$16], Object.getOwnPropertyDescriptor(_class2$1S.prototype, "spriteFrame"), _class2$1S.prototype), _applyDecoratedDescriptor(_class2$1S.prototype, "direction", [_dec4$P], Object.getOwnPropertyDescriptor(_class2$1S.prototype, "direction"), _class2$1S.prototype), _applyDecoratedDescriptor(_class2$1S.prototype, "cellSize", [_dec5$I], Object.getOwnPropertyDescriptor(_class2$1S.prototype, "cellSize"), _class2$1S.prototype), _initializer$1N = applyDecoratedInitializer(_class2$1S.prototype, "spacing", [serializable$j], function () {
              return 0;
            }), _initializer2$1x = applyDecoratedInitializer(_class2$1S.prototype, "_spriteFrame", [serializable$j], function () {
              return null;
            }), _initializer3$1a = applyDecoratedInitializer(_class2$1S.prototype, "_direction", [serializable$j], function () {
              return Direction$2.HORIZONTAL;
            }), _initializer4$$ = applyDecoratedInitializer(_class2$1S.prototype, "_cellSize", [serializable$j], function () {
              return new Size$1(20, 20);
            })), _class2$1S)) || _class$28) || _class$28));
            legacyCC.PageViewIndicator = PageViewIndicator;

            var _dec$26, _dec2$1E, _dec3$17, _dec4$Q, _dec5$J, _dec6$x, _dec7$p, _dec8$i, _dec9$g, _class$29, _class2$1T, _initializer$1O, _initializer2$1y, _initializer3$1b, _initializer4$10, _initializer5$O, _initializer6$F, _initializer7$x, _initializer8$u, _initializer9$r, _initializer10$o, _initializer11$k, _initializer12$j, _class3$A, _temp$K;

            var _tempVec2$2 = new Vec2();

            var SizeMode$1;

            (function (SizeMode) {
              SizeMode[SizeMode["Unified"] = 0] = "Unified";
              SizeMode[SizeMode["Free"] = 1] = "Free";
            })(SizeMode$1 || (SizeMode$1 = {}));

            ccenum(SizeMode$1);
            var Direction$3;

            (function (Direction) {
              Direction[Direction["Horizontal"] = 0] = "Horizontal";
              Direction[Direction["Vertical"] = 1] = "Vertical";
            })(Direction$3 || (Direction$3 = {}));

            ccenum(Direction$3);
            var EventType$7;

            (function (EventType) {
              EventType["PAGE_TURNING"] = "page-turning";
            })(EventType$7 || (EventType$7 = {}));

            var PageView = exports('PageView', (_dec$26 = ccclass$p('cc.PageView'), _dec2$1E = executionOrder(110), _dec3$17 = type$8(SizeMode$1), _dec4$Q = type$8(Direction$3), _dec5$J = type$8(PageViewIndicator), _dec6$x = type$8(ScrollBar), _dec7$p = type$8(ScrollBar), _dec8$i = type$8([EventHandler]), _dec9$g = type$8([EventHandler]), _dec$26(_class$29 = _dec2$1E(_class$29 = (_class2$1T = (_temp$K = _class3$A = function (_ScrollView) {
              _inheritsLoose(PageView, _ScrollView);

              function PageView() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _ScrollView.call.apply(_ScrollView, [this].concat(args)) || this;
                _this.autoPageTurningThreshold = _initializer$1O && _initializer$1O();
                _this.horizontal = _initializer2$1y && _initializer2$1y();
                _this.vertical = _initializer3$1b && _initializer3$1b();
                _this.cancelInnerEvents = _initializer4$10 && _initializer4$10();
                _this.scrollEvents = _initializer5$O && _initializer5$O();
                _this.pageTurningSpeed = _initializer6$F && _initializer6$F();
                _this.pageEvents = _initializer7$x && _initializer7$x();
                _this._sizeMode = _initializer8$u && _initializer8$u();
                _this._direction = _initializer9$r && _initializer9$r();
                _this._scrollThreshold = _initializer10$o && _initializer10$o();
                _this._pageTurningEventTiming = _initializer11$k && _initializer11$k();
                _this._indicator = _initializer12$j && _initializer12$j();
                _this._curPageIdx = 0;
                _this._lastPageIdx = 0;
                _this._pages = [];
                _this._initContentPos = new Vec3();
                _this._scrollCenterOffsetX = [];
                _this._scrollCenterOffsetY = [];
                _this._touchBeganPosition = new Vec2();
                _this._touchEndPosition = new Vec2();
                return _this;
              }

              var _proto = PageView.prototype;

              _proto.onEnable = function onEnable() {
                _ScrollView.prototype.onEnable.call(this);

                this.node.on(NodeEventType.SIZE_CHANGED, this._updateAllPagesSize, this);

                {
                  this.node.on(PageView.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
                }
              };

              _proto.onDisable = function onDisable() {
                _ScrollView.prototype.onDisable.call(this);

                this.node.off(NodeEventType.SIZE_CHANGED, this._updateAllPagesSize, this);

                {
                  this.node.off(PageView.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
                }
              };

              _proto.onLoad = function onLoad() {
                this._initPages();

                if (this.indicator) {
                  this.indicator.setPageView(this);
                }
              };

              _proto.getCurrentPageIndex = function getCurrentPageIndex() {
                return this._curPageIdx;
              };

              _proto.setCurrentPageIndex = function setCurrentPageIndex(index) {
                this.scrollToPage(index, 1);
              };

              _proto.getPages = function getPages() {
                return this._pages;
              };

              _proto.addPage = function addPage(page) {
                if (!page || this._pages.indexOf(page) !== -1 || !this.content) {
                  return;
                }

                if (!page._uiProps.uiTransformComp) {
                  logID(4301);
                  return;
                }

                this.content.addChild(page);

                this._pages.push(page);

                this._updatePageView();
              };

              _proto.insertPage = function insertPage(page, index) {
                if (index < 0 || !page || this._pages.indexOf(page) !== -1 || !this.content) {
                  return;
                }

                var pageCount = this._pages.length;

                if (index >= pageCount) {
                  this.addPage(page);
                } else {
                  if (!page._uiProps.uiTransformComp) {
                    logID(4301);
                    return;
                  }

                  this._pages.splice(index, 0, page);

                  this.content.insertChild(page, index);

                  this._updatePageView();
                }
              };

              _proto.removePage = function removePage(page) {
                if (!page || !this.content) {
                  return;
                }

                var index = this._pages.indexOf(page);

                if (index === -1) {
                  warnID(4300, page.name);
                  return;
                }

                this.removePageAtIndex(index);
              };

              _proto.removePageAtIndex = function removePageAtIndex(index) {
                var pageList = this._pages;

                if (index < 0 || index >= pageList.length) {
                  return;
                }

                var page = pageList[index];

                if (!page || !this.content) {
                  return;
                }

                this.content.removeChild(page);
                pageList.splice(index, 1);

                this._updatePageView();
              };

              _proto.removeAllPages = function removeAllPages() {
                if (!this.content) {
                  return;
                }

                var locPages = this._pages;

                for (var i = 0, len = locPages.length; i < len; i++) {
                  this.content.removeChild(locPages[i]);
                }

                this._pages.length = 0;

                this._updatePageView();
              };

              _proto.scrollToPage = function scrollToPage(idx, timeInSecond) {
                if (timeInSecond === void 0) {
                  timeInSecond = 0.3;
                }

                if (idx < 0 || idx >= this._pages.length) {
                  return;
                }

                this._curPageIdx = idx;
                this.scrollToOffset(this._moveOffsetValue(idx), timeInSecond, true);

                if (this.indicator) {
                  this.indicator._changedState();
                }
              };

              _proto.getScrollEndedEventTiming = function getScrollEndedEventTiming() {
                return this.pageTurningEventTiming;
              };

              _proto._updatePageView = function _updatePageView() {
                if (!this.content) {
                  return;
                }

                var layout = this.content.getComponent(Layout);

                if (layout && layout.enabled) {
                  layout.updateLayout();
                }

                var pageCount = this._pages.length;

                if (this._curPageIdx >= pageCount) {
                  this._curPageIdx = pageCount === 0 ? 0 : pageCount - 1;
                  this._lastPageIdx = this._curPageIdx;
                }

                var contentPos = this._initContentPos;

                for (var i = 0; i < pageCount; ++i) {
                  var page = this._pages[i];
                  var pos = page.position;

                  if (this.direction === Direction$3.Horizontal) {
                    this._scrollCenterOffsetX[i] = Math.abs(contentPos.x + pos.x);
                  } else {
                    this._scrollCenterOffsetY[i] = Math.abs(contentPos.y + pos.y);
                  }
                }

                if (this.indicator) {
                  this.indicator._refresh();
                }
              };

              _proto._updateAllPagesSize = function _updateAllPagesSize() {
                var viewTrans = this.view;

                if (!this.content || !viewTrans) {
                  return;
                }

                if (this._sizeMode !== SizeMode$1.Unified) {
                  return;
                }

                var locPages =  this._pages;
                var selfSize = viewTrans.contentSize;

                for (var i = 0, len = locPages.length; i < len; i++) {
                  locPages[i]._uiProps.uiTransformComp.setContentSize(selfSize);
                }
              };

              _proto._handleReleaseLogic = function _handleReleaseLogic() {
                this._autoScrollToPage();

                if (this._scrolling) {
                  this._scrolling = false;

                  if (!this._autoScrolling) {
                    this._dispatchEvent(PageView.EventType.SCROLL_ENDED);
                  }
                }
              };

              _proto._onTouchBegan = function _onTouchBegan(event, captureListeners) {
                event.touch.getUILocation(_tempVec2$2);
                Vec2.set(this._touchBeganPosition, _tempVec2$2.x, _tempVec2$2.y);

                _ScrollView.prototype._onTouchBegan.call(this, event, captureListeners);
              };

              _proto._onTouchMoved = function _onTouchMoved(event, captureListeners) {
                _ScrollView.prototype._onTouchMoved.call(this, event, captureListeners);
              };

              _proto._onTouchEnded = function _onTouchEnded(event, captureListeners) {
                event.touch.getUILocation(_tempVec2$2);
                Vec2.set(this._touchEndPosition, _tempVec2$2.x, _tempVec2$2.y);

                _ScrollView.prototype._onTouchEnded.call(this, event, captureListeners);
              };

              _proto._onTouchCancelled = function _onTouchCancelled(event, captureListeners) {
                event.touch.getUILocation(_tempVec2$2);
                Vec2.set(this._touchEndPosition, _tempVec2$2.x, _tempVec2$2.y);

                _ScrollView.prototype._onTouchCancelled.call(this, event, captureListeners);
              };

              _proto._onMouseWheel = function _onMouseWheel() {};

              _proto._syncScrollDirection = function _syncScrollDirection() {
                this.horizontal = this.direction === Direction$3.Horizontal;
                this.vertical = this.direction === Direction$3.Vertical;
              };

              _proto._syncSizeMode = function _syncSizeMode() {
                var viewTrans = this.view;

                if (!this.content || !viewTrans) {
                  return;
                }

                var layout = this.content.getComponent(Layout);

                if (layout) {
                  if (this._sizeMode === SizeMode$1.Free && this._pages.length > 0) {
                    var firstPageTrans = this._pages[0]._uiProps.uiTransformComp;
                    var lastPageTrans = this._pages[this._pages.length - 1]._uiProps.uiTransformComp;

                    if (this.direction === Direction$3.Horizontal) {
                      layout.paddingLeft = (viewTrans.width - firstPageTrans.width) / 2;
                      layout.paddingRight = (viewTrans.width - lastPageTrans.width) / 2;
                    } else if (this.direction === Direction$3.Vertical) {
                      layout.paddingTop = (viewTrans.height - firstPageTrans.height) / 2;
                      layout.paddingBottom = (viewTrans.height - lastPageTrans.height) / 2;
                    }
                  }

                  layout.updateLayout();
                }
              };

              _proto._initPages = function _initPages() {
                if (!this.content) {
                  return;
                }

                this._initContentPos = this.content.position;
                var children = this.content.children;

                for (var i = 0; i < children.length; ++i) {
                  var page = children[i];

                  if (this._pages.indexOf(page) >= 0) {
                    continue;
                  }

                  this._pages.push(page);
                }

                this._syncScrollDirection();

                this._syncSizeMode();

                this._updatePageView();
              };

              _proto._dispatchPageTurningEvent = function _dispatchPageTurningEvent() {
                if (this._lastPageIdx === this._curPageIdx) {
                  return;
                }

                this._lastPageIdx = this._curPageIdx;
                EventHandler.emitEvents(this.pageEvents, this, EventType$7.PAGE_TURNING);
                this.node.emit(EventType$7.PAGE_TURNING, this);
              };

              _proto._isQuicklyScrollable = function _isQuicklyScrollable(touchMoveVelocity) {
                if (this.direction === Direction$3.Horizontal) {
                  if (Math.abs(touchMoveVelocity.x) > this.autoPageTurningThreshold) {
                    return true;
                  }
                } else if (this.direction === Direction$3.Vertical) {
                  if (Math.abs(touchMoveVelocity.y) > this.autoPageTurningThreshold) {
                    return true;
                  }
                }

                return false;
              };

              _proto._moveOffsetValue = function _moveOffsetValue(idx) {
                var offset = new Vec2();

                if (this._sizeMode === SizeMode$1.Free) {
                  if (this.direction === Direction$3.Horizontal) {
                    offset.x = this._scrollCenterOffsetX[idx];
                  } else if (this.direction === Direction$3.Vertical) {
                    offset.y = this._scrollCenterOffsetY[idx];
                  }
                } else {
                  var viewTrans = this.view;

                  if (!viewTrans) {
                    return offset;
                  }

                  if (this.direction === Direction$3.Horizontal) {
                    offset.x = idx * viewTrans.width;
                  } else if (this.direction === Direction$3.Vertical) {
                    offset.y = idx * viewTrans.height;
                  }
                }

                return offset;
              };

              _proto._getDragDirection = function _getDragDirection(moveOffset) {
                if (this._direction === Direction$3.Horizontal) {
                  if (moveOffset.x === 0) {
                    return 0;
                  }

                  return moveOffset.x > 0 ? 1 : -1;
                } else {
                  if (moveOffset.y === 0) {
                    return 0;
                  }

                  return moveOffset.y < 0 ? 1 : -1;
                }
              };

              _proto._isScrollable = function _isScrollable(offset, index, nextIndex) {
                if (this._sizeMode === SizeMode$1.Free) {
                  var curPageCenter = 0;
                  var nextPageCenter = 0;

                  if (this.direction === Direction$3.Horizontal) {
                    curPageCenter = this._scrollCenterOffsetX[index];
                    nextPageCenter = this._scrollCenterOffsetX[nextIndex];
                    return Math.abs(offset.x) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
                  } else if (this.direction === Direction$3.Vertical) {
                    curPageCenter = this._scrollCenterOffsetY[index];
                    nextPageCenter = this._scrollCenterOffsetY[nextIndex];
                    return Math.abs(offset.y) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
                  }
                } else {
                  var viewTrans = this.view;

                  if (!viewTrans) {
                    return false;
                  }

                  if (this.direction === Direction$3.Horizontal) {
                    return Math.abs(offset.x) >= viewTrans.width * this.scrollThreshold;
                  } else if (this.direction === Direction$3.Vertical) {
                    return Math.abs(offset.y) >= viewTrans.height * this.scrollThreshold;
                  }
                }

                return false;
              };

              _proto._autoScrollToPage = function _autoScrollToPage() {
                var bounceBackStarted = this._startBounceBackIfNeeded();

                if (bounceBackStarted) {
                  var bounceBackAmount = this._getHowMuchOutOfBoundary();

                  this._clampDelta(bounceBackAmount);

                  if (bounceBackAmount.x > 0 || bounceBackAmount.y < 0) {
                    this._curPageIdx = this._pages.length === 0 ? 0 : this._pages.length - 1;
                  }

                  if (bounceBackAmount.x < 0 || bounceBackAmount.y > 0) {
                    this._curPageIdx = 0;
                  }

                  if (this.indicator) {
                    this.indicator._changedState();
                  }
                } else {
                  var moveOffset = new Vec2();
                  Vec2.subtract(moveOffset, this._touchBeganPosition, this._touchEndPosition);
                  var index = this._curPageIdx;

                  var nextIndex = index + this._getDragDirection(moveOffset);

                  var timeInSecond = this.pageTurningSpeed * Math.abs(index - nextIndex);

                  if (nextIndex < this._pages.length) {
                    if (this._isScrollable(moveOffset, index, nextIndex)) {
                      this.scrollToPage(nextIndex, timeInSecond);
                      return;
                    } else {
                      var touchMoveVelocity = this._calculateTouchMoveVelocity();

                      if (this._isQuicklyScrollable(touchMoveVelocity)) {
                        this.scrollToPage(nextIndex, timeInSecond);
                        return;
                      }
                    }
                  }

                  this.scrollToPage(index, timeInSecond);
                }
              };

              _createClass(PageView, [{
                key: "sizeMode",
                get: function get() {
                  return this._sizeMode;
                },
                set: function set(value) {
                  if (this._sizeMode === value) {
                    return;
                  }

                  this._sizeMode = value;

                  this._syncSizeMode();
                }
              }, {
                key: "direction",
                get: function get() {
                  return this._direction;
                },
                set: function set(value) {
                  if (this._direction === value) {
                    return;
                  }

                  this._direction = value;

                  this._syncScrollDirection();
                }
              }, {
                key: "scrollThreshold",
                get: function get() {
                  return this._scrollThreshold;
                },
                set: function set(value) {
                  if (this._scrollThreshold === value) {
                    return;
                  }

                  this._scrollThreshold = value;
                }
              }, {
                key: "pageTurningEventTiming",
                get: function get() {
                  return this._pageTurningEventTiming;
                },
                set: function set(value) {
                  if (this._pageTurningEventTiming === value) {
                    return;
                  }

                  this._pageTurningEventTiming = value;
                }
              }, {
                key: "indicator",
                get: function get() {
                  return this._indicator;
                },
                set: function set(value) {
                  if (this._indicator === value) {
                    return;
                  }

                  this._indicator = value;

                  if (this.indicator) {
                    this.indicator.setPageView(this);
                  }
                }
              }, {
                key: "curPageIdx",
                get: function get() {
                  return this._curPageIdx;
                }
              }, {
                key: "verticalScrollBar",
                get: function get() {
                  return _ScrollView.prototype.verticalScrollBar;
                },
                set: function set(value) {
                  this.verticalScrollBar = value;
                }
              }, {
                key: "horizontalScrollBar",
                get: function get() {
                  return _ScrollView.prototype.horizontalScrollBar;
                },
                set: function set(value) {
                  this.horizontalScrollBar = value;
                }
              }]);

              return PageView;
            }(ScrollView), _class3$A.SizeMode = SizeMode$1, _class3$A.Direction = Direction$3, _class3$A.EventType = extendsEnum(EventType$7, EventType$5), _temp$K), (_applyDecoratedDescriptor(_class2$1T.prototype, "sizeMode", [_dec3$17], Object.getOwnPropertyDescriptor(_class2$1T.prototype, "sizeMode"), _class2$1T.prototype), _applyDecoratedDescriptor(_class2$1T.prototype, "direction", [_dec4$Q], Object.getOwnPropertyDescriptor(_class2$1T.prototype, "direction"), _class2$1T.prototype), _applyDecoratedDescriptor(_class2$1T.prototype, "indicator", [_dec5$J], Object.getOwnPropertyDescriptor(_class2$1T.prototype, "indicator"), _class2$1T.prototype), _initializer$1O = applyDecoratedInitializer(_class2$1T.prototype, "autoPageTurningThreshold", [serializable$j], function () {
              return 100;
            }), _applyDecoratedDescriptor(_class2$1T.prototype, "verticalScrollBar", [_dec6$x, override$1], Object.getOwnPropertyDescriptor(_class2$1T.prototype, "verticalScrollBar"), _class2$1T.prototype), _applyDecoratedDescriptor(_class2$1T.prototype, "horizontalScrollBar", [_dec7$p, override$1], Object.getOwnPropertyDescriptor(_class2$1T.prototype, "horizontalScrollBar"), _class2$1T.prototype), _initializer2$1y = applyDecoratedInitializer(_class2$1T.prototype, "horizontal", [override$1, serializable$j], function () {
              return true;
            }), _initializer3$1b = applyDecoratedInitializer(_class2$1T.prototype, "vertical", [override$1, serializable$j], function () {
              return true;
            }), _initializer4$10 = applyDecoratedInitializer(_class2$1T.prototype, "cancelInnerEvents", [override$1, serializable$j], function () {
              return true;
            }), _initializer5$O = applyDecoratedInitializer(_class2$1T.prototype, "scrollEvents", [_dec8$i, serializable$j, override$1], function () {
              return [];
            }), _initializer6$F = applyDecoratedInitializer(_class2$1T.prototype, "pageTurningSpeed", [serializable$j], function () {
              return 0.3;
            }), _initializer7$x = applyDecoratedInitializer(_class2$1T.prototype, "pageEvents", [_dec9$g, serializable$j], function () {
              return [];
            }), _initializer8$u = applyDecoratedInitializer(_class2$1T.prototype, "_sizeMode", [serializable$j], function () {
              return SizeMode$1.Unified;
            }), _initializer9$r = applyDecoratedInitializer(_class2$1T.prototype, "_direction", [serializable$j], function () {
              return Direction$3.Horizontal;
            }), _initializer10$o = applyDecoratedInitializer(_class2$1T.prototype, "_scrollThreshold", [serializable$j], function () {
              return 0.5;
            }), _initializer11$k = applyDecoratedInitializer(_class2$1T.prototype, "_pageTurningEventTiming", [serializable$j], function () {
              return 0.1;
            }), _initializer12$j = applyDecoratedInitializer(_class2$1T.prototype, "_indicator", [serializable$j], function () {
              return null;
            })), _class2$1T)) || _class$29) || _class$29));
            legacyCC.PageView = PageView;

            var _tempPos$1 = new Vec3();

            var _defaultAnchor = new Vec2();

            var tInverseTranslate = new Vec2();
            var tInverseScale = new Vec2(1, 1);

            var _tempVec2_1$1 = new Vec2();

            var _tempVec2_2 = new Vec2();

            function align(node, widget) {
              if (widget._hadAlignOnce) return;

              if ( widget.alignMode === AlignMode.ONCE) {
                widget._hadAlignOnce = true;
              }

              var hasTarget = widget.target;
              var target;
              var inverseTranslate = tInverseTranslate;
              var inverseScale = tInverseScale;

              if (hasTarget) {
                target = hasTarget;
                computeInverseTransForTarget(node, target, inverseTranslate, inverseScale);
              } else {
                target = node.parent;
              }

              var targetSize = getReadonlyNodeSize(target);
              var useGlobal = target instanceof Scene || !target.getComponent(UITransform);
              var targetAnchor = useGlobal ? _defaultAnchor : target.getComponent(UITransform).anchorPoint;
              var isRoot = useGlobal;
              node.getPosition(_tempPos$1);
              var uiTrans = node._uiProps.uiTransformComp;
              var x = _tempPos$1.x;
              var y = _tempPos$1.y;
              var anchor = uiTrans.anchorPoint;
              var scale = node.getScale();

              if (widget.alignFlags & AlignFlags.HORIZONTAL) {
                var localLeft = 0;
                var localRight = 0;
                var targetWidth = targetSize.width;

                if (isRoot) {
                  localLeft = visibleRect.left.x;
                  localRight = visibleRect.right.x;
                } else {
                  localLeft = -targetAnchor.x * targetWidth;
                  localRight = localLeft + targetWidth;
                }

                localLeft += widget.isAbsoluteLeft ? widget.left : widget.left * targetWidth;
                localRight -= widget.isAbsoluteRight ? widget.right : widget.right * targetWidth;

                if (hasTarget) {
                  localLeft += inverseTranslate.x;
                  localLeft *= inverseScale.x;
                  localRight += inverseTranslate.x;
                  localRight *= inverseScale.x;
                }

                var width = 0;
                var anchorX = anchor.x;
                var scaleX = scale.x;

                if (scaleX < 0) {
                  anchorX = 1.0 - anchorX;
                  scaleX = -scaleX;
                }

                if (widget.isStretchWidth) {
                  width = localRight - localLeft;

                  if (scaleX !== 0) {
                    uiTrans.width = width / scaleX;
                  }

                  x = localLeft + anchorX * width;
                } else {
                  width = uiTrans.width * scaleX;

                  if (widget.isAlignHorizontalCenter) {
                    var localHorizontalCenter = widget.isAbsoluteHorizontalCenter ? widget.horizontalCenter : widget.horizontalCenter * targetWidth;
                    var targetCenter = (0.5 - targetAnchor.x) * targetSize.width;

                    if (hasTarget) {
                      localHorizontalCenter *= inverseScale.x;
                      targetCenter += inverseTranslate.x;
                      targetCenter *= inverseScale.x;
                    }

                    x = targetCenter + (anchorX - 0.5) * width + localHorizontalCenter;
                  } else if (widget.isAlignLeft) {
                    x = localLeft + anchorX * width;
                  } else {
                    x = localRight + (anchorX - 1) * width;
                  }
                }

                widget._lastSize.width = width;
              }

              if (widget.alignFlags & AlignFlags.VERTICAL) {
                var localTop = 0;
                var localBottom = 0;
                var targetHeight = targetSize.height;

                if (isRoot) {
                  localBottom = visibleRect.bottom.y;
                  localTop = visibleRect.top.y;
                } else {
                  localBottom = -targetAnchor.y * targetHeight;
                  localTop = localBottom + targetHeight;
                }

                localBottom += widget.isAbsoluteBottom ? widget.bottom : widget.bottom * targetHeight;
                localTop -= widget.isAbsoluteTop ? widget.top : widget.top * targetHeight;

                if (hasTarget) {
                  localBottom += inverseTranslate.y;
                  localBottom *= inverseScale.y;
                  localTop += inverseTranslate.y;
                  localTop *= inverseScale.y;
                }

                var height = 0;
                var anchorY = anchor.y;
                var scaleY = scale.y;

                if (scaleY < 0) {
                  anchorY = 1.0 - anchorY;
                  scaleY = -scaleY;
                }

                if (widget.isStretchHeight) {
                  height = localTop - localBottom;

                  if (scaleY !== 0) {
                    uiTrans.height = height / scaleY;
                  }

                  y = localBottom + anchorY * height;
                } else {
                  height = uiTrans.height * scaleY;

                  if (widget.isAlignVerticalCenter) {
                    var localVerticalCenter = widget.isAbsoluteVerticalCenter ? widget.verticalCenter : widget.verticalCenter * targetHeight;
                    var targetMiddle = (0.5 - targetAnchor.y) * targetSize.height;

                    if (hasTarget) {
                      localVerticalCenter *= inverseScale.y;
                      targetMiddle += inverseTranslate.y;
                      targetMiddle *= inverseScale.y;
                    }

                    y = targetMiddle + (anchorY - 0.5) * height + localVerticalCenter;
                  } else if (widget.isAlignBottom) {
                    y = localBottom + anchorY * height;
                  } else {
                    y = localTop + (anchorY - 1) * height;
                  }
                }

                widget._lastSize.height = height;
              }

              node.setPosition(x, y, _tempPos$1.z);
              Vec3.set(widget._lastPos, x, y, _tempPos$1.z);
            }

            function visitNode(node) {
              var widget = node.getComponent(Widget);

              if (widget && widget.enabled) {

                if (!legacyCC.isValid(node, true)) {
                  return;
                }

                activeWidgets.push(widget);
              }

              var children = node.children;

              for (var _iterator = _createForOfIteratorHelperLoose(children), _step; !(_step = _iterator()).done;) {
                var child = _step.value;

                if (child.active) {
                  visitNode(child);
                }
              }
            }

            function refreshScene() {
              var scene = director.getScene();

              if (scene) {
                widgetManager.isAligning = true;

                if (widgetManager._nodesOrderDirty) {
                  activeWidgets.length = 0;
                  visitNode(scene);
                  widgetManager._nodesOrderDirty = false;
                }
                var widget = null;
                var iterator = widgetManager._activeWidgetsIterator;

                for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) {
                  widget = activeWidgets[iterator.i];

                  if (widget._dirty) {
                    align(widget.node, widget);
                    widget._dirty = false;
                  }
                }

                widgetManager.isAligning = false;
              }
            }

            var activeWidgets = [];

            function updateAlignment(node) {
              var parent = node.parent;

              if (parent && Node.isNode(parent)) {
                updateAlignment(parent);
              }

              var widget = node.getComponent(Widget);

              if (widget && parent) {
                align(node, widget);
              }
            }

            var widgetManager = exports('widgetManager', legacyCC._widgetManager = {
              isAligning: false,
              _nodesOrderDirty: false,
              _activeWidgetsIterator: new MutableForwardIterator(activeWidgets),
              animationState:  null,
              init: function init() {
                director.on(Director.EVENT_AFTER_SCENE_LAUNCH, refreshScene);
                director.on(Director.EVENT_AFTER_UPDATE, refreshScene);
                View.instance.on('design-resolution-changed', this.onResized, this);

                {
                  var thisOnResized = this.onResized.bind(this);
                  View.instance.on('canvas-resize', thisOnResized);
                  screenAdapter.on('window-resize', thisOnResized);
                }
              },
              add: function add(widget) {
                this._nodesOrderDirty = true;
              },
              remove: function remove(widget) {
                this._activeWidgetsIterator.remove(widget);
              },
              onResized: function onResized() {
                var scene = director.getScene();

                if (scene) {
                  this.refreshWidgetOnResized(scene);
                }
              },
              refreshWidgetOnResized: function refreshWidgetOnResized(node) {
                var widget = Node.isNode(node) && node.getComponent(Widget);

                if (widget && widget.enabled && (widget.alignMode === AlignMode.ON_WINDOW_RESIZE || widget.alignMode === AlignMode.ALWAYS)) {
                  widget.setDirty();
                }

                var children = node.children;

                for (var _iterator2 = _createForOfIteratorHelperLoose(children), _step2; !(_step2 = _iterator2()).done;) {
                  var child = _step2.value;
                  this.refreshWidgetOnResized(child);
                }
              },
              updateOffsetsToStayPut: function updateOffsetsToStayPut(widget, e) {
                function i(t, c) {
                  return Math.abs(t - c) > 1e-10 ? c : t;
                }

                var widgetNode = widget.node;
                var widgetParent = widgetNode.parent;

                if (widgetParent) {
                  var zero = _tempVec2_1$1;
                  zero.set(0, 0);
                  var one = _tempVec2_2;
                  one.set(1, 1);

                  if (widget.target) {
                    widgetParent = widget.target;
                    computeInverseTransForTarget(widgetNode, widgetParent, zero, one);
                  }

                  if (!e) {
                    return;
                  }

                  var parentTrans = widgetParent._uiProps && widgetParent._uiProps.uiTransformComp;
                  var parentAP = parentTrans ? parentTrans.anchorPoint : _defaultAnchor;
                  var trans = widgetNode._uiProps.uiTransformComp;
                  var matchSize = getReadonlyNodeSize(widgetParent);
                  var myAP = trans.anchorPoint;
                  var pos = widgetNode.getPosition();
                  var alignFlags = AlignFlags;
                  var widgetNodeScale = widgetNode.getScale();
                  var temp = 0;

                  if (e & alignFlags.LEFT) {
                    var l = -parentAP.x * matchSize.width;
                    l += zero.x;
                    l *= one.x;
                    temp = pos.x - myAP.x * trans.width * Math.abs(widgetNodeScale.x) - l;

                    if (!widget.isAbsoluteLeft) {
                      temp /= matchSize.width;
                    }

                    temp /= one.x;
                    widget.left = i(widget.left, temp);
                  }

                  if (e & alignFlags.RIGHT) {
                    var r = (1 - parentAP.x) * matchSize.width;
                    r += zero.x;
                    temp = (r *= one.x) - (pos.x + (1 - myAP.x) * trans.width * Math.abs(widgetNodeScale.x));

                    if (!widget.isAbsoluteRight) {
                      temp /= matchSize.width;
                    }

                    temp /= one.x;
                    widget.right = i(widget.right, temp);
                  }

                  if (e & alignFlags.TOP) {
                    var t = (1 - parentAP.y) * matchSize.height;
                    t += zero.y;
                    temp = (t *= one.y) - (pos.y + (1 - myAP.y) * trans.height * Math.abs(widgetNodeScale.y));

                    if (!widget.isAbsoluteTop) {
                      temp /= matchSize.height;
                    }

                    temp /= one.y;
                    widget.top = i(widget.top, temp);
                  }

                  if (e & alignFlags.BOT) {
                    var b = -parentAP.y * matchSize.height;
                    b += zero.y;
                    b *= one.y;
                    temp = pos.y - myAP.y * trans.height * Math.abs(widgetNodeScale.y) - b;

                    if (!widget.isAbsoluteBottom) {
                      temp /= matchSize.height;
                    }

                    temp /= one.y;
                    widget.bottom = i(widget.bottom, temp);
                  }
                }
              },
              updateAlignment: updateAlignment,
              AlignMode: AlignMode,
              AlignFlags: AlignFlags
            });
            director.on(Director.EVENT_INIT, function () {
              widgetManager.init();
            });

            var _dec$27, _dec2$1F, _dec3$18, _class$2a;
            var SafeArea = exports('SafeArea', (_dec$27 = ccclass$p('cc.SafeArea'), _dec2$1F = executionOrder(110), _dec3$18 = requireComponent(Widget), _dec$27(_class$2a = _dec2$1F(_class$2a = _dec3$18(_class$2a = function (_Component) {
              _inheritsLoose(SafeArea, _Component);

              function SafeArea() {
                return _Component.apply(this, arguments) || this;
              }

              var _proto = SafeArea.prototype;

              _proto.onEnable = function onEnable() {
                this.updateArea();
                screenAdapter.on('window-resize', this.updateArea, this);
                screenAdapter.on('orientation-change', this.updateArea, this);
              };

              _proto.onDisable = function onDisable() {
                screenAdapter.off('window-resize', this.updateArea, this);
                screenAdapter.off('orientation-change', this.updateArea, this);
              };

              _proto.updateArea = function updateArea() {
                var widget = this.node.getComponent(Widget);
                var uiTransComp = this.node.getComponent(UITransform);

                if (!widget || !uiTransComp) {
                  return;
                }

                widget.updateAlignment();
                var lastPos = this.node.position.clone();
                var lastAnchorPoint = uiTransComp.anchorPoint.clone();
                widget.isAlignTop = widget.isAlignBottom = widget.isAlignLeft = widget.isAlignRight = true;
                var visibleSize = view.getVisibleSize();
                var screenWidth = visibleSize.width;
                var screenHeight = visibleSize.height;
                var safeArea = sys.getSafeAreaRect();
                widget.top = screenHeight - safeArea.y - safeArea.height;
                widget.bottom = safeArea.y;
                widget.left = safeArea.x;
                widget.right = screenWidth - safeArea.x - safeArea.width;
                widget.updateAlignment();
                var curPos = this.node.position.clone();
                var anchorX = lastAnchorPoint.x - (curPos.x - lastPos.x) / uiTransComp.width;
                var anchorY = lastAnchorPoint.y - (curPos.y - lastPos.y) / uiTransComp.height;
                uiTransComp.setAnchorPoint(anchorX, anchorY);
                widgetManager.add(widget);
              };

              return SafeArea;
            }(Component)) || _class$2a) || _class$2a) || _class$2a));
            legacyCC.SafeArea = SafeArea;

            var _dec$28, _dec2$1G, _dec3$19, _dec4$R, _dec5$K, _class$2b, _class2$1U, _initializer$1P, _initializer2$1z, _initializer3$1c, _initializer4$11, _initializer5$P;
            var UICoordinateTracker = exports('UICoordinateTracker', (_dec$28 = ccclass$p('cc.UICoordinateTracker'), _dec2$1G = executionOrder(110), _dec3$19 = type$8(Node), _dec4$R = type$8(Camera), _dec5$K = type$8([EventHandler]), _dec$28(_class$2b = _dec2$1G(_class$2b = (_class2$1U = function (_Component) {
              _inheritsLoose(UICoordinateTracker, _Component);

              function UICoordinateTracker() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this.syncEvents = _initializer$1P && _initializer$1P();
                _this._target = _initializer2$1z && _initializer2$1z();
                _this._camera = _initializer3$1c && _initializer3$1c();
                _this._useScale = _initializer4$11 && _initializer4$11();
                _this._distance = _initializer5$P && _initializer5$P();
                _this._transformPos = new Vec3();
                _this._viewPos = new Vec3();
                _this._canMove = true;
                _this._lastWPos = new Vec3();
                _this._lastCameraPos = new Vec3();
                return _this;
              }

              var _proto = UICoordinateTracker.prototype;

              _proto.onEnable = function onEnable() {
                this._checkCanMove();
              };

              _proto.update = function update() {
                var wPos = this.node.worldPosition;
                var camera = this._camera;

                if (!this._canMove || !camera || !camera.camera || this._lastWPos.equals(wPos) && this._lastCameraPos.equals(camera.node.worldPosition)) {
                  return;
                }

                this._lastWPos.set(wPos);

                this._lastCameraPos.set(camera.node.worldPosition);

                camera.camera.update();
                camera.convertToUINode(wPos, this._target, this._transformPos);

                if (this._useScale) {
                  Vec3.transformMat4(this._viewPos, this.node.worldPosition, camera.camera.matView);
                }

                if (this.syncEvents.length > 0) {
                  var data = this._distance / Math.abs(this._viewPos.z);
                  EventHandler.emitEvents(this.syncEvents, this._transformPos, data);
                }
              };

              _proto._checkCanMove = function _checkCanMove() {
                this._canMove = !!(this._camera && this._target);
              };

              _createClass(UICoordinateTracker, [{
                key: "target",
                get: function get() {
                  return this._target;
                },
                set: function set(value) {
                  if (this._target === value) {
                    return;
                  }

                  this._target = value;

                  this._checkCanMove();
                }
              }, {
                key: "camera",
                get: function get() {
                  return this._camera;
                },
                set: function set(value) {
                  if (this._camera === value) {
                    return;
                  }

                  this._camera = value;

                  this._checkCanMove();
                }
              }, {
                key: "useScale",
                get: function get() {
                  return this._useScale;
                },
                set: function set(value) {
                  if (this._useScale === value) {
                    return;
                  }

                  this._useScale = value;
                }
              }, {
                key: "distance",
                get: function get() {
                  return this._distance;
                },
                set: function set(value) {
                  if (this._distance === value) {
                    return;
                  }

                  this._distance = value;
                }
              }]);

              return UICoordinateTracker;
            }(Component), (_applyDecoratedDescriptor(_class2$1U.prototype, "target", [_dec3$19], Object.getOwnPropertyDescriptor(_class2$1U.prototype, "target"), _class2$1U.prototype), _applyDecoratedDescriptor(_class2$1U.prototype, "camera", [_dec4$R], Object.getOwnPropertyDescriptor(_class2$1U.prototype, "camera"), _class2$1U.prototype), _initializer$1P = applyDecoratedInitializer(_class2$1U.prototype, "syncEvents", [_dec5$K, serializable$j], function () {
              return [];
            }), _initializer2$1z = applyDecoratedInitializer(_class2$1U.prototype, "_target", [serializable$j], function () {
              return null;
            }), _initializer3$1c = applyDecoratedInitializer(_class2$1U.prototype, "_camera", [serializable$j], function () {
              return null;
            }), _initializer4$11 = applyDecoratedInitializer(_class2$1U.prototype, "_useScale", [serializable$j], function () {
              return true;
            }), _initializer5$P = applyDecoratedInitializer(_class2$1U.prototype, "_distance", [serializable$j], function () {
              return 1;
            })), _class2$1U)) || _class$2b) || _class$2b));

            var _dec$29, _class$2c;
            var BlockEvents = [NodeEventType.TOUCH_START, NodeEventType.TOUCH_END, NodeEventType.TOUCH_MOVE, NodeEventType.MOUSE_DOWN, NodeEventType.MOUSE_MOVE, NodeEventType.MOUSE_UP, NodeEventType.MOUSE_ENTER, NodeEventType.MOUSE_LEAVE, NodeEventType.MOUSE_WHEEL];

            function stopPropagation(event) {
              event.propagationStopped = true;
            }

            var BlockInputEvents = exports('BlockInputEvents', (_dec$29 = ccclass$p('cc.BlockInputEvents'), _dec$29(_class$2c = function (_Component) {
              _inheritsLoose(BlockInputEvents, _Component);

              function BlockInputEvents() {
                return _Component.apply(this, arguments) || this;
              }

              var _proto = BlockInputEvents.prototype;

              _proto.onEnable = function onEnable() {
                for (var i = 0; i < BlockEvents.length; i++) {
                  this.node.on(BlockEvents[i], stopPropagation, this);
                }
              };

              _proto.onDisable = function onDisable() {
                for (var i = 0; i < BlockEvents.length; i++) {
                  this.node.off(BlockEvents[i], stopPropagation, this);
                }
              };

              return BlockInputEvents;
            }(Component)) || _class$2c));

            var _dec$2a, _dec2$1H, _dec3$1a, _class$2d, _class2$1V, _initializer$1Q, _initializer2$1A;
            var SubContextView = exports('SubContextView', (_dec$2a = ccclass$p('cc.SubContextView'), _dec2$1H = executionOrder(110), _dec3$1a = requireComponent(UITransform), _dec$2a(_class$2d = _dec2$1H(_class$2d = _dec3$1a(_class$2d = (_class2$1V = function (_Component) {
              _inheritsLoose(SubContextView, _Component);

              function SubContextView() {
                var _this;

                _this = _Component.call(this) || this;
                _this._fps = _initializer$1Q && _initializer$1Q();
                _this._sprite = void 0;
                _this._imageAsset = void 0;
                _this._texture = void 0;
                _this._updatedTime = 0;
                _this._updateInterval = 0;
                _this._openDataContext = void 0;
                _this._content = void 0;
                _this._designResolutionSize = _initializer2$1A && _initializer2$1A();
                _this._content = new Node('content');
                _this._content.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;
                _this._sprite = null;
                _this._imageAsset = new ImageAsset();
                _this._openDataContext = null;
                _this._updatedTime = performance.now();
                _this._texture = new Texture2D();
                return _this;
              }

              var _proto = SubContextView.prototype;

              _proto.onLoad = function onLoad() {
                if (minigame.getOpenDataContext) {
                  this._updateInterval = 1000 / this._fps;
                  this._openDataContext = minigame.getOpenDataContext();

                  this._initSharedCanvas();

                  this._initContentNode();

                  this._updateSubContextView();

                  this._updateContentLayer();
                } else {
                  this.enabled = false;
                }
              };

              _proto.onEnable = function onEnable() {
                this._registerNodeEvent();
              };

              _proto.onDisable = function onDisable() {
                this._unregisterNodeEvent();
              };

              _proto._initSharedCanvas = function _initSharedCanvas() {
                if (this._openDataContext) {
                  var sharedCanvas = this._openDataContext.canvas;
                  var designWidth = this._designResolutionSize.width;
                  var designHeight = this._designResolutionSize.height;

                  sharedCanvas.width = designWidth;
                  sharedCanvas.height = designHeight;
                }
              };

              _proto._initContentNode = function _initContentNode() {
                if (this._openDataContext) {
                  var sharedCanvas = this._openDataContext.canvas;
                  var image = this._imageAsset;
                  image.reset(sharedCanvas);
                  this._texture.image = image;

                  this._texture.create(sharedCanvas.width, sharedCanvas.height);

                  this._sprite = this._content.getComponent(Sprite);

                  if (!this._sprite) {
                    this._sprite = this._content.addComponent(Sprite);
                  }

                  if (this._sprite.spriteFrame) {
                    this._sprite.spriteFrame.texture = this._texture;
                  } else {
                    var sp = new SpriteFrame();
                    sp.texture = this._texture;
                    this._sprite.spriteFrame = sp;
                  }

                  this._content.parent = this.node;
                }
              };

              _proto._updateSubContextView = function _updateSubContextView() {
                if (!this._openDataContext) {
                  return;
                }

                var nodeTrans = this.node.getComponent(UITransform);

                var contentTrans = this._content.getComponent(UITransform);

                var scaleX = nodeTrans.width / contentTrans.width;
                var scaleY = nodeTrans.height / contentTrans.height;
                var scale = scaleX > scaleY ? scaleY : scaleX;
                contentTrans.width *= scale;
                contentTrans.height *= scale;
                var viewportRect = view.getViewportRect();
                var box = contentTrans.getBoundingBoxToWorld();
                var visibleSize = view.getVisibleSize();
                var dpr = screenAdapter.devicePixelRatio;
                var x = (viewportRect.width * (box.x / visibleSize.width) + viewportRect.x) / dpr;
                var y = (viewportRect.height * (box.y / visibleSize.height) + viewportRect.y) / dpr;
                var width = viewportRect.width * (box.width / visibleSize.width) / dpr;
                var height = viewportRect.height * (box.height / visibleSize.height) / dpr;

                this._openDataContext.postMessage({
                  fromEngine: true,
                  type: 'engine',
                  event: 'viewport',
                  x: x,
                  y: y,
                  width: width,
                  height: height
                });
              };

              _proto._updateSubContextTexture = function _updateSubContextTexture() {
                var img = this._imageAsset;

                if (!img || !this._openDataContext) {
                  return;
                }

                if (img.width <= 0 || img.height <= 0) {
                  return;
                }

                var sharedCanvas = this._openDataContext.canvas;
                img.reset(sharedCanvas);

                if (sharedCanvas.width > img.width || sharedCanvas.height > img.height) {
                  this._texture.create(sharedCanvas.width, sharedCanvas.height);
                }

                this._texture.uploadData(sharedCanvas);
              };

              _proto._registerNodeEvent = function _registerNodeEvent() {
                this.node.on(NodeEventType.TRANSFORM_CHANGED, this._updateSubContextView, this);
                this.node.on(NodeEventType.SIZE_CHANGED, this._updateSubContextView, this);
                this.node.on(NodeEventType.LAYER_CHANGED, this._updateContentLayer, this);
              };

              _proto._unregisterNodeEvent = function _unregisterNodeEvent() {
                this.node.off(NodeEventType.TRANSFORM_CHANGED, this._updateSubContextView, this);
                this.node.off(NodeEventType.SIZE_CHANGED, this._updateSubContextView, this);
                this.node.off(NodeEventType.LAYER_CHANGED, this._updateContentLayer, this);
              };

              _proto._updateContentLayer = function _updateContentLayer() {
                this._content.layer = this.node.layer;
              };

              _proto.update = function update(dt) {
                var calledUpdateManually = dt === undefined;

                if (calledUpdateManually) {
                  this._updateSubContextTexture();

                  return;
                }

                var now = performance.now();
                var deltaTime = now - this._updatedTime;

                if (deltaTime >= this._updateInterval) {
                  this._updatedTime += this._updateInterval;

                  this._updateSubContextTexture();
                }
              };

              _proto.onDestroy = function onDestroy() {
                this._content.destroy();

                this._texture.destroy();

                if (this._sprite) {
                  this._sprite.destroy();
                }

                this._imageAsset.destroy();

                this._openDataContext = null;
              };

              _createClass(SubContextView, [{
                key: "designResolutionSize",
                get: function get() {
                  return this._designResolutionSize;
                },
                set: function set(value) {
                  {
                    return;
                  }
                }
              }, {
                key: "fps",
                get: function get() {
                  return this._fps;
                },
                set: function set(value) {
                  if (this._fps === value) {
                    return;
                  }

                  this._fps = value;
                  this._updateInterval = 1000 / value;
                }
              }]);

              return SubContextView;
            }(Component), (_initializer$1Q = applyDecoratedInitializer(_class2$1V.prototype, "_fps", [serializable$j], function () {
              return 60;
            }), _initializer2$1A = applyDecoratedInitializer(_class2$1V.prototype, "_designResolutionSize", [serializable$j], function () {
              return new Size$1(640, 960);
            })), _class2$1V)) || _class$2d) || _class$2d) || _class$2d));
            legacyCC.SubContextView = SubContextView;

        }
    };
});
//# sourceMappingURL=cc.js.map
